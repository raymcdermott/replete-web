if(typeof Math.imul == "undefined" || (Math.imul(0xffffffff,5) == 0)) {
    Math.imul = function (a, b) {
        var ah  = (a >>> 16) & 0xffff;
        var al = a & 0xffff;
        var bh  = (b >>> 16) & 0xffff;
        var bl = b & 0xffff;
        // the shift by 0 fixes the sign on the high part
        // the final |0 converts the unsigned value into a signed value
        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0)|0);
    }
}

/** @license React v16.3.2
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
            ;(function(p,h){"object"===typeof exports&&"undefined"!==typeof module?module.exports=h():"function"===typeof define&&define.amd?define(h):p.React=h()})(this,function(){function p(a){for(var b=arguments.length-1,e="http://reactjs.org/docs/error-decoder.html?invariant\x3d"+a,c=0;c<b;c++)e+="\x26args[]\x3d"+encodeURIComponent(arguments[c+1]);O(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",
e)}function h(a){return function(){return a}}function q(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||E}function F(){}function v(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||E}function G(a,b,e){var c=void 0,f={},k=null,d=null;if(null!=b)for(c in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(k=""+b.key),b)H.call(b,c)&&!I.hasOwnProperty(c)&&(f[c]=b[c]);var g=arguments.length-2;if(1===g)f.children=e;else if(1<g){for(var m=Array(g),l=0;l<g;l++)m[l]=arguments[l+2];f.children=
m}if(a&&a.defaultProps)for(c in g=a.defaultProps,g)void 0===f[c]&&(f[c]=g[c]);return{$$typeof:r,type:a,key:k,ref:d,props:f,_owner:w.current}}function x(a){return"object"===typeof a&&null!==a&&a.$$typeof===r}function P(a){var b={"\x3d":"\x3d0",":":"\x3d2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function J(a,b,e,c){if(u.length){var f=u.pop();f.result=a;f.keyPrefix=b;f.func=e;f.context=c;f.count=0;return f}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function K(a){a.result=
null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>u.length&&u.push(a)}function t(a,b,e,c){var f=typeof a;if("undefined"===f||"boolean"===f)a=null;var k=!1;if(null===a)k=!0;else switch(f){case "string":case "number":k=!0;break;case "object":switch(a.$$typeof){case r:case Q:k=!0}}if(k)return e(c,a,""===b?"."+y(a,0):b),1;k=0;b=""===b?".":b+":";if(Array.isArray(a))for(var d=0;d<a.length;d++){f=a[d];var g=b+y(f,d);k+=t(f,g,e,c)}else if(null===a||"undefined"===typeof a?g=null:(g=L&&a[L]||a["@@iterator"],
g="function"===typeof g?g:null),"function"===typeof g)for(a=g.call(a),d=0;!(f=a.next()).done;)f=f.value,g=b+y(f,d++),k+=t(f,g,e,c);else"object"===f&&(e=""+a,p("31","[object Object]"===e?"object with keys {"+Object.keys(a).join(", ")+"}":e,""));return k}function y(a,b){return"object"===typeof a&&null!==a&&null!=a.key?P(a.key):b.toString(36)}function R(a,b,e){a.func.call(a.context,b,a.count++)}function S(a,b,e){var c=a.result,f=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?z(a,c,
e,A.thatReturnsArgument):null!=a&&(x(a)&&(b=f+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(M,"$\x26/")+"/")+e,a={$$typeof:r,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a))}function z(a,b,e,c,f){var d="";null!=e&&(d=(""+e).replace(M,"$\x26/")+"/");b=J(b,d,c,f);null==a||t(a,"",S,b);K(b)}var N=Object.getOwnPropertySymbols,T=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable,B=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===
Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var e={};"abcdefghijklmnopqrst".split("").forEach(function(a){e[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},e)).join("")?!1:!0}catch(c){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var e=
Object(a);for(var c,f=1;f<arguments.length;f++){var d=Object(arguments[f]);for(var h in d)T.call(d,h)&&(e[h]=d[h]);if(N){c=N(d);for(var g=0;g<c.length;g++)U.call(d,c[g])&&(e[c[g]]=d[c[g]])}}return e},d="function"===typeof Symbol&&Symbol["for"],r=d?Symbol["for"]("react.element"):60103,Q=d?Symbol["for"]("react.portal"):60106,n=d?Symbol["for"]("react.fragment"):60107,C=d?Symbol["for"]("react.strict_mode"):60108,V=d?Symbol["for"]("react.provider"):60109,W=d?Symbol["for"]("react.context"):60110,X=d?Symbol["for"]("react.async_mode"):
60111,Y=d?Symbol["for"]("react.forward_ref"):60112,L="function"===typeof Symbol&&Symbol.iterator,O=function(a,b,e,c,f,d,h,g){if(!a){if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var k=[e,c,f,d,h,g],l=0;a=Error(b.replace(/%s/g,function(){return k[l++]}));a.name="Invariant Violation"}a.framesToPop=1;throw a;}},D={};d=function(){};d.thatReturns=h;d.thatReturnsFalse=h(!1);d.thatReturnsTrue=h(!0);
d.thatReturnsNull=h(null);d.thatReturnsThis=function(){return this};d.thatReturnsArgument=function(a){return a};var A=d,E={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,e){},enqueueReplaceState:function(a,b,e,c){},enqueueSetState:function(a,b,e,c){}};q.prototype.isReactComponent={};q.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?p("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};q.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,
a,"forceUpdate")};F.prototype=q.prototype;d=v.prototype=new F;d.constructor=v;B(d,q.prototype);d.isPureReactComponent=!0;var w={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0},M=/\/+/g,u=[];n={Children:{map:function(a,b,e){if(null==a)return a;var c=[];z(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=J(null,null,b,e);null==a||t(a,"",R,b);K(b)},count:function(a,b){return null==a?0:t(a,"",A.thatReturnsNull,null)},toArray:function(a){var b=
[];z(a,b,null,A.thatReturnsArgument);return b},only:function(a){x(a)?void 0:p("143");return a}},createRef:function(){return{current:null}},Component:q,PureComponent:v,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:W,_calculateChangedBits:b,_defaultValue:a,_currentValue:a,_changedBits:0,Provider:null,Consumer:null};a.Provider={$$typeof:V,_context:a};return a.Consumer=a},forwardRef:function(a){return{$$typeof:Y,render:a}},Fragment:n,StrictMode:C,unstable_AsyncMode:X,createElement:G,cloneElement:function(a,
b,e){null===a||void 0===a?p("267",a):void 0;var c=void 0,d=B({},a.props),k=a.key,h=a.ref,g=a._owner;if(null!=b){void 0!==b.ref&&(h=b.ref,g=w.current);void 0!==b.key&&(k=""+b.key);var m=void 0;a.type&&a.type.defaultProps&&(m=a.type.defaultProps);for(c in b)H.call(b,c)&&!I.hasOwnProperty(c)&&(d[c]=void 0===b[c]&&void 0!==m?m[c]:b[c])}c=arguments.length-2;if(1===c)d.children=e;else if(1<c){m=Array(c);for(var l=0;l<c;l++)m[l]=arguments[l+2];d.children=m}return{$$typeof:r,type:a.type,key:k,ref:h,props:d,
_owner:g}},createFactory:function(a){var b=G.bind(null,a);b.type=a;return b},isValidElement:x,version:"16.3.2",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:w,assign:B}};n=(C=Object.freeze({default:n}))&&n||C;return n["default"]?n["default"]:n});

!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("react")):"function"==typeof define&&define.amd?define(["react"],e):"object"==typeof exports?exports.createReactClass=e(require("react")):t.createReactClass=e(t.React)}(this,function(t){return function(t){function e(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return t[o].call(r.exports,r,r.exports,e),r.l=!0,r.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,o){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:o})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=2)}([function(t,e,n){"use strict";function o(t){return t}function r(t,e,n){function r(t,e){var n=N.hasOwnProperty(e)?N[e]:null;b.hasOwnProperty(e)&&s("OVERRIDE_BASE"===n,"ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.",e),t&&s("DEFINE_MANY"===n||"DEFINE_MANY_MERGED"===n,"ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.",e)}function u(t,n){if(n){s("function"!=typeof n,"ReactClass: You're attempting to use a component class or function as a mixin. Instead, just use a regular object."),s(!e(n),"ReactClass: You're attempting to use a component as a mixin. Instead, just use a regular object.");var o=t.prototype,i=o.__reactAutoBindPairs;n.hasOwnProperty(c)&&g.mixins(t,n.mixins);for(var a in n)if(n.hasOwnProperty(a)&&a!==c){var u=n[a],p=o.hasOwnProperty(a);if(r(p,a),g.hasOwnProperty(a))g[a](t,u);else{var l=N.hasOwnProperty(a),E="function"==typeof u,m=E&&!l&&!p&&!1!==n.autobind;if(m)i.push(a,u),o[a]=u;else if(p){var h=N[a];s(l&&("DEFINE_MANY_MERGED"===h||"DEFINE_MANY"===h),"ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.",h,a),"DEFINE_MANY_MERGED"===h?o[a]=f(o[a],u):"DEFINE_MANY"===h&&(o[a]=d(o[a],u))}else o[a]=u}}}else;}function p(t,e){if(e)for(var n in e){var o=e[n];if(e.hasOwnProperty(n)){var r=n in g;s(!r,'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.',n);var i=n in t;if(i){var a=_.hasOwnProperty(n)?_[n]:null;return s("DEFINE_MANY_MERGED"===a,"ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.",n),void(t[n]=f(t[n],o))}t[n]=o}}}function l(t,e){s(t&&e&&"object"==typeof t&&"object"==typeof e,"mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.");for(var n in e)e.hasOwnProperty(n)&&(s(void 0===t[n],"mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.",n),t[n]=e[n]);return t}function f(t,e){return function(){var n=t.apply(this,arguments),o=e.apply(this,arguments);if(null==n)return o;if(null==o)return n;var r={};return l(r,n),l(r,o),r}}function d(t,e){return function(){t.apply(this,arguments),e.apply(this,arguments)}}function E(t,e){var n=e.bind(t);return n}function m(t){for(var e=t.__reactAutoBindPairs,n=0;n<e.length;n+=2){var o=e[n],r=e[n+1];t[o]=E(t,r)}}function h(t){var e=o(function(t,o,r){this.__reactAutoBindPairs.length&&m(this),this.props=t,this.context=o,this.refs=a,this.updater=r||n,this.state=null;var i=this.getInitialState?this.getInitialState():null;s("object"==typeof i&&!Array.isArray(i),"%s.getInitialState(): must return an object or null",e.displayName||"ReactCompositeComponent"),this.state=i});e.prototype=new I,e.prototype.constructor=e,e.prototype.__reactAutoBindPairs=[],y.forEach(u.bind(null,e)),u(e,v),u(e,t),u(e,D),e.getDefaultProps&&(e.defaultProps=e.getDefaultProps()),s(e.prototype.render,"createClass(...): Class specification must implement a `render` method.");for(var r in N)e.prototype[r]||(e.prototype[r]=null);return e}var y=[],N={mixins:"DEFINE_MANY",statics:"DEFINE_MANY",propTypes:"DEFINE_MANY",contextTypes:"DEFINE_MANY",childContextTypes:"DEFINE_MANY",getDefaultProps:"DEFINE_MANY_MERGED",getInitialState:"DEFINE_MANY_MERGED",getChildContext:"DEFINE_MANY_MERGED",render:"DEFINE_ONCE",componentWillMount:"DEFINE_MANY",componentDidMount:"DEFINE_MANY",componentWillReceiveProps:"DEFINE_MANY",shouldComponentUpdate:"DEFINE_ONCE",componentWillUpdate:"DEFINE_MANY",componentDidUpdate:"DEFINE_MANY",componentWillUnmount:"DEFINE_MANY",UNSAFE_componentWillMount:"DEFINE_MANY",UNSAFE_componentWillReceiveProps:"DEFINE_MANY",UNSAFE_componentWillUpdate:"DEFINE_MANY",updateComponent:"OVERRIDE_BASE"},_={getDerivedStateFromProps:"DEFINE_MANY_MERGED"},g={displayName:function(t,e){t.displayName=e},mixins:function(t,e){if(e)for(var n=0;n<e.length;n++)u(t,e[n])},childContextTypes:function(t,e){t.childContextTypes=i({},t.childContextTypes,e)},contextTypes:function(t,e){t.contextTypes=i({},t.contextTypes,e)},getDefaultProps:function(t,e){t.getDefaultProps?t.getDefaultProps=f(t.getDefaultProps,e):t.getDefaultProps=e},propTypes:function(t,e){t.propTypes=i({},t.propTypes,e)},statics:function(t,e){p(t,e)},autobind:function(){}},v={componentDidMount:function(){this.__isMounted=!0}},D={componentWillUnmount:function(){this.__isMounted=!1}},b={replaceState:function(t,e){this.updater.enqueueReplaceState(this,t,e)},isMounted:function(){return!!this.__isMounted}},I=function(){};return i(I.prototype,t.prototype,b),h}var i=n(5),a=n(3),s=n(4),c="mixins";t.exports=r},function(e,n){e.exports=t},function(t,e,n){"use strict";var o=n(1),r=n(0);if(void 0===o)throw Error("create-react-class could not find the React object. If you are using script tags, make sure that React is being loaded before create-react-class.");var i=(new o.Component).updater;t.exports=r(o.Component,o.isValidElement,i)},function(t,e,n){"use strict";var o={};t.exports=o},function(t,e,n){"use strict";function o(t,e,n,o,i,a,s,c){if(r(e),!t){var u;if(void 0===e)u=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var p=[n,o,i,a,s,c],l=0;u=new Error(e.replace(/%s/g,function(){return p[l++]})),u.name="Invariant Violation"}throw u.framesToPop=1,u}}var r=function(t){};t.exports=o},function(t,e,n){"use strict";function o(t){if(null===t||void 0===t)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(t)}var r=Object.getOwnPropertySymbols,i=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;t.exports=function(){try{if(!Object.assign)return!1;var t=new String("abc");if(t[5]="de","5"===Object.getOwnPropertyNames(t)[0])return!1;for(var e={},n=0;n<10;n++)e["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(e).map(function(t){return e[t]}).join(""))return!1;var o={};return"abcdefghijklmnopqrst".split("").forEach(function(t){o[t]=t}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},o)).join("")}catch(t){return!1}}()?Object.assign:function(t,e){for(var n,s,c=o(t),u=1;u<arguments.length;u++){n=Object(arguments[u]);for(var p in n)i.call(n,p)&&(c[p]=n[p]);if(r){s=r(n);for(var l=0;l<s.length;l++)a.call(n,s[l])&&(c[s[l]]=n[s[l]])}}return c}}])});
/** @license React v16.3.2
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
            ;(function(pa,l){"object"===typeof exports&&"undefined"!==typeof module?module.exports=l(require("react")):"function"===typeof define&&define.amd?define(["react"],l):pa.ReactDOM=l(pa.React)})(this,function(pa){function l(a){for(var b=arguments.length-1,c="http://reactjs.org/docs/error-decoder.html?invariant\x3d"+a,d=0;d<b;d++)c+="\x26args[]\x3d"+encodeURIComponent(arguments[d+1]);ze(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",
c)}function Ec(){if(bb)for(var a in va){var b=va[a],c=bb.indexOf(a);-1<c?void 0:l("96",a);if(!ea[c]){b.extractEvents?void 0:l("97",a);ea[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;Gb.hasOwnProperty(h)?l("99",h):void 0;Gb[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&Fc(k[e],g,h);e=!0}else f.registrationName?(Fc(f.registrationName,g,h),e=!0):e=!1;e?void 0:l("98",d,a)}}}}function Fc(a,b,c){qa[a]?l("100",a):void 0;qa[a]=b;cb[a]=b.eventTypes[c].dependencies}
function Gc(a){bb?l("101"):void 0;bb=Array.prototype.slice.call(a);Ec()}function Hc(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];va.hasOwnProperty(c)&&va[c]===d||(va[c]?l("102",c):void 0,va[c]=d,b=!0)}b&&Ec()}function db(a){return function(){return a}}function Ic(a,b,c,d){b=a.type||"unknown-event";a.currentTarget=Jc(d);z.invokeGuardedCallbackAndCatchFirstError(b,c,void 0,a);a.currentTarget=null}function wa(a,b){null==b?l("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,
b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function X(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function Hb(a,b){var c=a.stateNode;if(!c)return null;var d=Ib(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===
a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;c&&"function"!==typeof c?l("231",b,typeof c):void 0;return c}function Jb(a,b){null!==a&&(fa=wa(fa,a));a=fa;fa=null;a&&(b?X(a,Ae):X(a,Be),fa?l("95"):void 0,z.rethrowCaughtError())}function Kc(a,b,c,d){for(var e=null,f=0;f<ea.length;f++){var g=ea[f];g&&(g=g.extractEvents(a,b,c,d))&&(e=wa(e,g))}Jb(e,!1)}function Ca(a){if(a[P])return a[P];for(;!a[P];)if(a.parentNode)a=a.parentNode;else return null;a=a[P];return 5===a.tag||6===
a.tag?a:null}function xa(a){if(5===a.tag||6===a.tag)return a.stateNode;l("33")}function Lc(a){return a[ha]||null}function Q(a){do a=a["return"];while(a&&5!==a.tag);return a?a:null}function Mc(a,b,c){for(var d=[];a;)d.push(a),a=Q(a);for(a=d.length;0<a--;)b(d[a],"captured",c);for(a=0;a<d.length;a++)b(d[a],"bubbled",c)}function Nc(a,b,c){if(b=Hb(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=wa(c._dispatchListeners,b),c._dispatchInstances=wa(c._dispatchInstances,a)}function Ce(a){a&&
a.dispatchConfig.phasedRegistrationNames&&Mc(a._targetInst,Nc,a)}function De(a){if(a&&a.dispatchConfig.phasedRegistrationNames){var b=a._targetInst;b=b?Q(b):null;Mc(b,Nc,a)}}function Kb(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Hb(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=wa(c._dispatchListeners,b),c._dispatchInstances=wa(c._dispatchInstances,a))}function Ee(a){a&&a.dispatchConfig.registrationName&&Kb(a._targetInst,null,a)}function ya(a){X(a,Ce)}function Oc(a,b,c,d){if(c&&
d)a:{var e=c;for(var f=d,g=0,h=e;h;h=Q(h))g++;h=0;for(var k=f;k;k=Q(k))h++;for(;0<g-h;)e=Q(e),g--;for(;0<h-g;)f=Q(f),h--;for(;g--;){if(e===f||e===f.alternate)break a;e=Q(e);f=Q(f)}e=null}else e=null;f=e;for(e=[];c&&c!==f;){g=c.alternate;if(null!==g&&g===f)break;e.push(c);c=Q(c)}for(c=[];d&&d!==f;){g=d.alternate;if(null!==g&&g===f)break;c.push(d);d=Q(d)}for(d=0;d<e.length;d++)Kb(e[d],"bubbled",a);for(a=c.length;0<a--;)Kb(c[a],"captured",b)}function Pc(){!Lb&&R.canUseDOM&&(Lb="textContent"in document.documentElement?
"textContent":"innerText");return Lb}function Qc(){if(H._fallbackText)return H._fallbackText;var a,b=H._startText,c=b.length,d,e=Rc(),f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);H._fallbackText=e.slice(a,1<d?1-d:void 0);return H._fallbackText}function Rc(){return"value"in H._root?H._root.value:H._root[Pc()]}function I(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?
this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?M.thatReturnsTrue:M.thatReturnsFalse;this.isPropagationStopped=M.thatReturnsFalse;return this}function Fe(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Ge(a){a instanceof this?void 0:l("223");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function Sc(a){a.eventPool=
[];a.getPooled=Fe;a.release=Ge}function Tc(a,b){switch(a){case "topKeyUp":return-1!==He.indexOf(b.keyCode);case "topKeyDown":return 229!==b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":return!0;default:return!1}}function Uc(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}function Ie(a,b){switch(a){case "topCompositionEnd":return Uc(b);case "topKeyPress":if(32!==b.which)return null;Vc=!0;return Wc;case "topTextInput":return a=b.data,a===Wc&&Vc?null:a;default:return null}}
function Je(a,b){if(ia)return"topCompositionEnd"===a||!Mb&&Tc(a,b)?(a=Qc(),H._root=null,H._startText=null,H._fallbackText=null,ia=!1,a):null;switch(a){case "topPaste":return null;case "topKeyPress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "topCompositionEnd":return Xc?null:b.data;default:return null}}function Yc(a){if(a=Zc(a)){eb&&"function"===typeof eb.restoreControlledState?
void 0:l("194");var b=Ib(a.stateNode);eb.restoreControlledState(a.stateNode,a.type,b)}}function $c(a){za?ra?ra.push(a):ra=[a]:za=a}function ad(){return null!==za||null!==ra}function bd(){if(za){var a=za,b=ra;ra=za=null;Yc(a);if(b)for(a=0;a<b.length;a++)Yc(b[a])}}function cd(a,b){if(Nb)return a(b);Nb=!0;try{return dd(a,b)}finally{Nb=!1,ad()&&(ed(),bd())}}function fd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Ke[a.type]:"textarea"===b?!0:!1}function Ob(a){a=a.target||window;
a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function Pb(a,b){if(!R.canUseDOM||b&&!("addEventListener"in document))return!1;a="on"+a;b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function gd(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function Le(a){var b=gd(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,
b),d=""+a[b];if(!a.hasOwnProperty(b)&&"function"===typeof c.get&&"function"===typeof c.set)return Object.defineProperty(a,b,{configurable:!0,get:function(){return c.get.call(this)},set:function(a){d=""+a;c.set.call(this,a)}}),Object.defineProperty(a,b,{enumerable:c.enumerable}),{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}function fb(a){a._valueTracker||(a._valueTracker=Le(a))}function hd(a){if(!a)return!1;var b=a._valueTracker;
if(!b)return!0;var c=b.getValue();var d="";a&&(d=gd(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Da(a){if(null===a||"undefined"===typeof a)return null;a=id&&a[id]||a["@@iterator"];return"function"===typeof a?a:null}function Ia(a){a=a.type;if("function"===typeof a)return a.displayName||a.name;if("string"===typeof a)return a;switch(a){case Y:return"ReactFragment";case ja:return"ReactPortal";case jd:return"ReactCall";case kd:return"ReactReturn"}if("object"===typeof a&&
null!==a)switch(a.$$typeof){case ld:return a=a.render.displayName||a.render.name||"",""!==a?"ForwardRef("+a+")":"ForwardRef"}return null}function Qb(a){var b="";do{a:switch(a.tag){case 0:case 1:case 2:case 5:var c=a._debugOwner,d=a._debugSource;var e=Ia(a);var f=null;c&&(f=Ia(c));c=d;e="\n    in "+(e||"Unknown")+(c?" (at "+c.fileName.replace(/^.*[\\\/]/,"")+":"+c.lineNumber+")":f?" (created by "+f+")":"");break a;default:e=""}b+=e;a=a["return"]}while(a);return b}function Me(a){if(md.hasOwnProperty(a))return!0;
if(nd.hasOwnProperty(a))return!1;if(Ne.test(a))return md[a]=!0;nd[a]=!0;return!1}function Oe(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function Pe(a,b,c,d){if(null===b||"undefined"===typeof b||Oe(a,b,c,d))return!0;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||
1>b}return!1}function J(a,b,c,d,e){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b}function Rb(a,b,c,d){var e=F.hasOwnProperty(b)?F[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(Pe(b,c,e,d)&&(c=null),d||null===e?Me(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=
e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function Sb(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function od(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Tb(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===
b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function pd(a,b){b=b.checked;null!=b&&Rb(a,"checked",b,!1)}function Ub(a,b){pd(a,b);var c=Tb(b.value);if(null!=c)if("number"===b.type){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);b.hasOwnProperty("value")?Vb(a,b.type,c):b.hasOwnProperty("defaultValue")&&Vb(a,b.type,Tb(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function qd(a,b){if(b.hasOwnProperty("value")||
b.hasOwnProperty("defaultValue"))""===a.value&&(a.value=""+a._wrapperState.initialValue),a.defaultValue=""+a._wrapperState.initialValue;b=a.name;""!==b&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!a.defaultChecked;""!==b&&(a.name=b)}function Vb(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function Tb(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function rd(a,b,c){a=I.getPooled(sd.change,a,b,c);a.type="change";$c(c);ya(a);return a}function Qe(a){Jb(a,!1)}function gb(a){var b=xa(a);if(hd(b))return a}function Re(a,b){if("topChange"===a)return b}function td(){Ja&&(Ja.detachEvent("onpropertychange",ud),Ka=Ja=null)}function ud(a){"value"===a.propertyName&&gb(Ka)&&(a=rd(Ka,a,Ob(a)),cd(Qe,a))}function Se(a,b,c){"topFocus"===a?(td(),Ja=b,Ka=c,Ja.attachEvent("onpropertychange",ud)):"topBlur"===a&&td()}function Te(a,b){if("topSelectionChange"===
a||"topKeyUp"===a||"topKeyDown"===a)return gb(Ka)}function Ue(a,b){if("topClick"===a)return gb(b)}function Ve(a,b){if("topInput"===a||"topChange"===a)return gb(b)}function We(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Xe[a])?!!b[a]:!1}function Wb(a){return We}function vd(a,b){return a===b?0!==a||0!==b||1/a===1/b:a!==a&&b!==b}function La(a){var b=a;if(a.alternate)for(;b["return"];)b=b["return"];else{if(0!==(b.effectTag&2))return 1;for(;b["return"];)if(b=b["return"],
0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function Ye(a){return(a=a._reactInternalFiber)?2===La(a):!1}function wd(a){2!==La(a)?l("188"):void 0}function xd(a){var b=a.alternate;if(!b)return b=La(a),3===b?l("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c["return"],f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return wd(e),a;if(g===d)return wd(e),b;g=g.sibling}l("188")}if(c["return"]!==d["return"])c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===
c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?void 0:l("189")}}c.alternate!==d?l("190"):void 0}3!==c.tag?l("188"):void 0;return c.stateNode.current===c?a:b}function yd(a){a=xd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=
b["return"];b=b.sibling}}return null}function Ze(a){a=xd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}function hb(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function zd(a,b){var c=a[0].toUpperCase()+
a.slice(1),d="on"+c;c="top"+c;b={phasedRegistrationNames:{bubbled:d,captured:d+"Capture"},dependencies:[c],isInteractive:b};Ad[a]=b;Xb[c]=b}function $e(a){var b=a.targetInst;do{if(!b){a.ancestors.push(b);break}var c;for(c=b;c["return"];)c=c["return"];c=3!==c.tag?null:c.stateNode.containerInfo;if(!c)break;a.ancestors.push(b);b=Ca(c)}while(b);for(c=0;c<a.ancestors.length;c++)b=a.ancestors[c],Kc(a.topLevelType,b,a.nativeEvent,Ob(a.nativeEvent))}function Yb(a){Ma=!!a}function y(a,b,c){if(!c)return null;
a=(Bd(a)?Cd:ib).bind(null,a);c.addEventListener(b,a,!1)}function S(a,b,c){if(!c)return null;a=(Bd(a)?Cd:ib).bind(null,a);c.addEventListener(b,a,!0)}function Cd(a,b){Dd(ib,a,b)}function ib(a,b){if(Ma){var c=Ob(b);c=Ca(c);null!==c&&"number"===typeof c.tag&&2!==La(c)&&(c=null);if(jb.length){var d=jb.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{cd($e,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=
0,10>jb.length&&jb.push(a)}}}function kb(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;c["ms"+a]="MS"+b;c["O"+a]="o"+b.toLowerCase();return c}function lb(a){if(Zb[a])return Zb[a];if(!T[a])return a;var b=T[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ed)return Zb[a]=b[c];return a}function Fd(a){Object.prototype.hasOwnProperty.call(a,mb)||(a[mb]=af++,Gd[a[mb]]={});return Gd[a[mb]]}function Hd(a,b){return a&&b?a===b?!0:Id(a)?!1:Id(b)?Hd(a,b.parentNode):
"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function Jd(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function Kd(a,b){var c=Jd(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Jd(c)}}function $b(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&"text"===a.type||"textarea"===b||"true"===
a.contentEditable)}function Ld(a,b){if(ac||null==ka||ka!==bc())return null;var c=ka;"selectionStart"in c&&$b(c)?c={start:c.selectionStart,end:c.selectionEnd}:window.getSelection?(c=window.getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}):c=void 0;return Na&&cc(Na,c)?null:(Na=c,a=I.getPooled(Md.select,dc,a,b),a.type="select",a.target=ka,ya(a),a)}function sa(a,b,c,d){this.tag=a;this.key=c;this.stateNode=this.type=null;this.sibling=
this.child=this["return"]=null;this.index=0;this.ref=null;this.pendingProps=b;this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.expirationTime=0;this.alternate=null}function nb(a,b,c){var d=a.alternate;null===d?(d=new sa(a.tag,b,a.key,a.mode),d.type=a.type,d.stateNode=a.stateNode,d.alternate=a,a.alternate=d):(d.pendingProps=b,d.effectTag=0,d.nextEffect=null,d.firstEffect=null,d.lastEffect=null);d.expirationTime=
c;d.child=a.child;d.memoizedProps=a.memoizedProps;d.memoizedState=a.memoizedState;d.updateQueue=a.updateQueue;d.sibling=a.sibling;d.index=a.index;d.ref=a.ref;return d}function ec(a,b,c){var d=a.type,e=a.key;a=a.props;var f=void 0;if("function"===typeof d)f=d.prototype&&d.prototype.isReactComponent?2:0;else if("string"===typeof d)f=5;else switch(d){case Y:return ob(a.children,b,c,e);case bf:f=11;b|=3;break;case cf:f=11;b|=2;break;case jd:f=7;break;case kd:f=9;break;default:if("object"===typeof d&&
null!==d)switch(d.$$typeof){case df:f=13;break;case ef:f=12;break;case ld:f=14;break;default:if("number"===typeof d.tag)return b=d,b.pendingProps=a,b.expirationTime=c,b;l("130",null==d?d:typeof d,"")}else l("130",null==d?d:typeof d,"")}b=new sa(f,a,e,b);b.type=d;b.expirationTime=c;return b}function ob(a,b,c,d){a=new sa(10,a,d,b);a.expirationTime=c;return a}function fc(a,b,c){a=new sa(6,a,null,b);a.expirationTime=c;return a}function gc(a,b,c){b=new sa(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=
c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Nd(a){return function(b){try{return a(b)}catch(c){}}}function ff(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);hc=Nd(function(a){return b.onCommitFiberRoot(c,a)});ic=Nd(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0}function Od(a){"function"===
typeof hc&&hc(a)}function Pd(a){"function"===typeof ic&&ic(a)}function Qd(a){return{baseState:a,expirationTime:0,first:null,last:null,callbackList:null,hasForceUpdate:!1,isInitialized:!1,capturedValues:null}}function pb(a,b){null===a.last?a.first=a.last=b:(a.last.next=b,a.last=b);if(0===a.expirationTime||a.expirationTime>b.expirationTime)a.expirationTime=b.expirationTime}function jc(a){kc=lc=null;var b=a.alternate,c=a.updateQueue;null===c&&(c=a.updateQueue=Qd(null));null!==b?(a=b.updateQueue,null===
a&&(a=b.updateQueue=Qd(null))):a=null;kc=c;lc=a!==c?a:null}function Oa(a,b){jc(a);a=kc;var c=lc;null===c?pb(a,b):null===a.last||null===c.last?(pb(a,b),pb(c,b)):(pb(a,b),c.last=b)}function Rd(a,b,c,d){a=a.partialState;return"function"===typeof a?a.call(b,c,d):a}function qb(a,b,c,d,e,f){null!==a&&a.updateQueue===c&&(c=b.updateQueue={baseState:c.baseState,expirationTime:c.expirationTime,first:c.first,last:c.last,isInitialized:c.isInitialized,capturedValues:c.capturedValues,callbackList:null,hasForceUpdate:!1});
c.expirationTime=0;c.isInitialized?a=c.baseState:(a=c.baseState=b.memoizedState,c.isInitialized=!0);for(var g=!0,h=c.first,k=!1;null!==h;){var l=h.expirationTime;if(l>f){var m=c.expirationTime;if(0===m||m>l)c.expirationTime=l;k||(k=!0,c.baseState=a)}else{k||(c.first=h.next,null===c.first&&(c.last=null));if(h.isReplace)a=Rd(h,d,a,e),g=!0;else if(l=Rd(h,d,a,e))a=g?A({},a,l):A(a,l),g=!1;h.isForced&&(c.hasForceUpdate=!0);null!==h.callback&&(l=c.callbackList,null===l&&(l=c.callbackList=[]),l.push(h));
null!==h.capturedValue&&(l=c.capturedValues,null===l?c.capturedValues=[h.capturedValue]:l.push(h.capturedValue))}h=h.next}null!==c.callbackList?b.effectTag|=32:null!==c.first||c.hasForceUpdate||null!==c.capturedValues||(b.updateQueue=null);k||(c.baseState=a);return a}function Sd(a,b){var c=a.callbackList;if(null!==c)for(a.callbackList=null,a=0;a<c.length;a++){var d=c[a],e=d.callback;d.callback=null;"function"!==typeof e?l("191",e):void 0;e.call(b)}}function Pa(a,b,c){a=c.ref;if(null!==a&&"function"!==
typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;var d=void 0;c&&(2!==c.tag?l("110"):void 0,d=c.stateNode);d?void 0:l("147",a);var e=""+a;if(null!==b&&null!==b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs===la?d.refs={}:d.refs;null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}"string"!==typeof a?l("148"):void 0;c._owner?void 0:l("254",a)}return a}function rb(a,b){"textarea"!==a.type&&l("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+
"}":b,"")}function Td(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=nb(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,
d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=fc(c,a.mode,d),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function k(a,b,c,d){if(null!==b&&b.type===c.type)return d=e(b,c.props,d),d.ref=Pa(a,b,c),d["return"]=a,d;d=ec(c,a.mode,d);d.ref=Pa(a,b,c);d["return"]=a;return d}function D(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
c.implementation)return b=gc(c,a.mode,d),b["return"]=a,b;b=e(b,c.children||[],d);b["return"]=a;return b}function m(a,b,c,d,f){if(null===b||10!==b.tag)return b=ob(c,a.mode,d,f),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function w(a,b,c){if("string"===typeof b||"number"===typeof b)return b=fc(""+b,a.mode,c),b["return"]=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case sb:return c=ec(b,a.mode,c),c.ref=Pa(a,null,b),c["return"]=a,c;case ja:return b=gc(b,a.mode,c),b["return"]=a,b}if(tb(b)||
Da(b))return b=ob(b,a.mode,c,null),b["return"]=a,b;rb(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case sb:return c.key===e?c.type===Y?m(a,b,c.props.children,d,e):k(a,b,c,d):null;case ja:return c.key===e?D(a,b,c,d):null}if(tb(c)||Da(c))return null!==e?null:m(a,b,c,d,null);rb(a,c)}return null}function G(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=
a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case sb:return a=a.get(null===d.key?c:d.key)||null,d.type===Y?m(b,a,d.props.children,e,d.key):k(b,a,d,e);case ja:return a=a.get(null===d.key?c:d.key)||null,D(b,a,d,e)}if(tb(d)||Da(d))return a=a.get(c)||null,m(b,a,d,e,null);rb(b,d)}return null}function v(e,m,h,C){for(var x=null,g=null,t=m,r=m=0,q=null;null!==t&&r<h.length;r++){t.index>r?(q=t,t=null):q=t.sibling;var n=p(e,t,h[r],C);if(null===n){null===t&&(t=q);break}a&&
t&&null===n.alternate&&b(e,t);m=f(n,m,r);null===g?x=n:g.sibling=n;g=n;t=q}if(r===h.length)return c(e,t),x;if(null===t){for(;r<h.length;r++)if(t=w(e,h[r],C))m=f(t,m,r),null===g?x=t:g.sibling=t,g=t;return x}for(t=d(e,t);r<h.length;r++)if(q=G(t,e,r,h[r],C)){if(a&&null!==q.alternate)t["delete"](null===q.key?r:q.key);m=f(q,m,r);null===g?x=q:g.sibling=q;g=q}a&&t.forEach(function(a){return b(e,a)});return x}function C(e,m,h,C){var g=Da(h);"function"!==typeof g?l("150"):void 0;h=g.call(h);null==h?l("151"):
void 0;for(var x=g=null,t=m,r=m=0,q=null,n=h.next();null!==t&&!n.done;r++,n=h.next()){t.index>r?(q=t,t=null):q=t.sibling;var k=p(e,t,n.value,C);if(null===k){t||(t=q);break}a&&t&&null===k.alternate&&b(e,t);m=f(k,m,r);null===x?g=k:x.sibling=k;x=k;t=q}if(n.done)return c(e,t),g;if(null===t){for(;!n.done;r++,n=h.next())n=w(e,n.value,C),null!==n&&(m=f(n,m,r),null===x?g=n:x.sibling=n,x=n);return g}for(t=d(e,t);!n.done;r++,n=h.next())if(n=G(t,e,r,n.value,C),null!==n){if(a&&null!==n.alternate)t["delete"](null===
n.key?r:n.key);m=f(n,m,r);null===x?g=n:x.sibling=n;x=n}a&&t.forEach(function(a){return b(e,a)});return g}return function(a,d,f,m){"object"===typeof f&&null!==f&&f.type===Y&&null===f.key&&(f=f.props.children);var h="object"===typeof f&&null!==f;if(h)switch(f.$$typeof){case sb:a:{var x=f.key;for(h=d;null!==h;){if(h.key===x)if(10===h.tag?f.type===Y:h.type===f.type){c(a,h.sibling);d=e(h,f.type===Y?f.props.children:f.props,m);d.ref=Pa(a,h,f);d["return"]=a;a=d;break a}else{c(a,h);break}else b(a,h);h=h.sibling}f.type===
Y?(d=ob(f.props.children,a.mode,m,f.key),d["return"]=a,a=d):(m=ec(f,a.mode,m),m.ref=Pa(a,d,f),m["return"]=a,a=m)}return g(a);case ja:a:{for(h=f.key;null!==d;){if(d.key===h)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[],m);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=gc(f,a.mode,m);d["return"]=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===
d.tag?(c(a,d.sibling),d=e(d,f,m),d["return"]=a,a=d):(c(a,d),d=fc(f,a.mode,m),d["return"]=a,a=d),g(a);if(tb(f))return v(a,d,f,m);if(Da(f))return C(a,d,f,m);h&&rb(a,f);if("undefined"===typeof f)switch(a.tag){case 2:case 1:m=a.type,l("152",m.displayName||m.name||"Component")}return c(a,d)}}function Ud(a,b){var c=b.source;null===b.stack&&Qb(c);null!==c&&Ia(c);b=b.value;null!==a&&2===a.tag&&Ia(a);try{b&&b.suppressReactErrorLogging||console.error(b)}catch(d){d&&d.suppressReactErrorLogging||console.error(d)}}
function hf(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:ja,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function jf(a){var b="";pa.Children.forEach(a,function(a){null==a||"string"!==typeof a&&"number"!==typeof a||(b+=a)});return b}function mc(a,b){a=A({children:void 0},b);if(b=jf(b.children))a.children=b;return a}function O(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+
a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+c;b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Vd(a,b){var c=b.value;a._wrapperState={initialValue:null!=c?c:b.defaultValue,wasMultiple:!!b.multiple}}function nc(a,b){null!=b.dangerouslySetInnerHTML?l("91"):void 0;return A({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Wd(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?l("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:l("93"),b=b[0]),c=""+b),null==c&&(c=""));a._wrapperState={initialValue:""+c}}function Xd(a,b){var c=b.value;null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&(a.defaultValue=c));null!=b.defaultValue&&(a.defaultValue=b.defaultValue)}function Yd(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";
default:return"http://www.w3.org/1999/xhtml"}}function oc(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Yd(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function Zd(a,b,c){a=a.style;for(var d in b)if(b.hasOwnProperty(d)){c=0===d.indexOf("--");var e=d;var f=b[d];e=null==f||"boolean"===typeof f||""===f?"":c||"number"!==typeof f||0===f||Qa.hasOwnProperty(e)&&Qa[e]?(""+f).trim():f+"px";"float"===d&&(d="cssFloat");c?a.setProperty(d,e):a[d]=e}}function pc(a,
b,c){b&&(kf[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?l("137",a,c()):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?l("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:l("61")),null!=b.style&&"object"!==typeof b.style?l("62",c()):void 0)}function qc(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function U(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Fd(a);b=cb[b];for(var d=0;d<b.length;d++){var e=b[d];c.hasOwnProperty(e)&&c[e]||("topScroll"===e?S("topScroll","scroll",a):"topFocus"===e||"topBlur"===e?(S("topFocus","focus",a),S("topBlur","blur",a),c.topBlur=!0,c.topFocus=!0):"topCancel"===e?(Pb("cancel",!0)&&S("topCancel","cancel",a),c.topCancel=!0):"topClose"===e?(Pb("close",!0)&&S("topClose","close",a),c.topClose=!0):$d.hasOwnProperty(e)&&y(e,$d[e],a),
c[e]=!0)}}function ae(a,b,c,d){c=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===d&&(d=Yd(a));"http://www.w3.org/1999/xhtml"===d?"script"===a?(a=c.createElement("div"),a.innerHTML="\x3cscript\x3e\x3c/script\x3e",a=a.removeChild(a.firstChild)):a="string"===typeof b.is?c.createElement(a,{is:b.is}):c.createElement(a):a=c.createElementNS(d,a);return a}function be(a,b){return(9===b.nodeType?b:b.ownerDocument).createTextNode(a)}function ce(a,b,c,d){var e=qc(b,c);switch(b){case "iframe":case "object":y("topLoad",
"load",a);var f=c;break;case "video":case "audio":for(f in Z)Z.hasOwnProperty(f)&&y(f,Z[f],a);f=c;break;case "source":y("topError","error",a);f=c;break;case "img":case "image":case "link":y("topError","error",a);y("topLoad","load",a);f=c;break;case "form":y("topReset","reset",a);y("topSubmit","submit",a);f=c;break;case "details":y("topToggle","toggle",a);f=c;break;case "input":od(a,c);f=Sb(a,c);y("topInvalid","invalid",a);U(d,"onChange");break;case "option":f=mc(a,c);break;case "select":Vd(a,c);f=
A({},c,{value:void 0});y("topInvalid","invalid",a);U(d,"onChange");break;case "textarea":Wd(a,c);f=nc(a,c);y("topInvalid","invalid",a);U(d,"onChange");break;default:f=c}pc(b,f,Ra);var g=f,h;for(h in g)if(g.hasOwnProperty(h)){var k=g[h];"style"===h?Zd(a,k,Ra):"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,null!=k&&de(a,k)):"children"===h?"string"===typeof k?("textarea"!==b||""!==k)&&ub(a,k):"number"===typeof k&&ub(a,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==
h&&(qa.hasOwnProperty(h)?null!=k&&U(d,h):null!=k&&Rb(a,h,k,e))}switch(b){case "input":fb(a);qd(a,c);break;case "textarea":fb(a);c=a.textContent;c===a._wrapperState.initialValue&&(a.value=c);break;case "option":null!=c.value&&a.setAttribute("value",c.value);break;case "select":a.multiple=!!c.multiple;b=c.value;null!=b?O(a,!!c.multiple,b,!1):null!=c.defaultValue&&O(a,!!c.multiple,c.defaultValue,!0);break;default:"function"===typeof f.onClick&&(a.onclick=M)}}function ee(a,b,c,d,e){var f=null;switch(b){case "input":c=
Sb(a,c);d=Sb(a,d);f=[];break;case "option":c=mc(a,c);d=mc(a,d);f=[];break;case "select":c=A({},c,{value:void 0});d=A({},d,{value:void 0});f=[];break;case "textarea":c=nc(a,c);d=nc(a,d);f=[];break;default:"function"!==typeof c.onClick&&"function"===typeof d.onClick&&(a.onclick=M)}pc(b,d,Ra);b=a=void 0;var g=null;for(a in c)if(!d.hasOwnProperty(a)&&c.hasOwnProperty(a)&&null!=c[a])if("style"===a){var h=c[a];for(b in h)h.hasOwnProperty(b)&&(g||(g={}),g[b]="")}else"dangerouslySetInnerHTML"!==a&&"children"!==
a&&"suppressContentEditableWarning"!==a&&"suppressHydrationWarning"!==a&&"autoFocus"!==a&&(qa.hasOwnProperty(a)?f||(f=[]):(f=f||[]).push(a,null));for(a in d){var k=d[a];h=null!=c?c[a]:void 0;if(d.hasOwnProperty(a)&&k!==h&&(null!=k||null!=h))if("style"===a)if(h){for(b in h)!h.hasOwnProperty(b)||k&&k.hasOwnProperty(b)||(g||(g={}),g[b]="");for(b in k)k.hasOwnProperty(b)&&h[b]!==k[b]&&(g||(g={}),g[b]=k[b])}else g||(f||(f=[]),f.push(a,g)),g=k;else"dangerouslySetInnerHTML"===a?(k=k?k.__html:void 0,h=h?
h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(a,""+k)):"children"===a?h===k||"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(a,""+k):"suppressContentEditableWarning"!==a&&"suppressHydrationWarning"!==a&&(qa.hasOwnProperty(a)?(null!=k&&U(e,a),f||h===k||(f=[])):(f=f||[]).push(a,k))}g&&(f=f||[]).push("style",g);return f}function fe(a,b,c,d,e){"input"===c&&"radio"===e.type&&null!=e.name&&pd(a,e);qc(c,d);d=qc(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];"style"===g?Zd(a,h,Ra):"dangerouslySetInnerHTML"===
g?de(a,h):"children"===g?ub(a,h):Rb(a,g,h,d)}switch(c){case "input":Ub(a,e);break;case "textarea":Xd(a,e);break;case "select":a._wrapperState.initialValue=void 0,b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?O(a,!!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?O(a,!!e.multiple,e.defaultValue,!0):O(a,!!e.multiple,e.multiple?[]:"",!1))}}function ge(a,b,c,d,e){switch(b){case "iframe":case "object":y("topLoad","load",a);break;case "video":case "audio":for(var f in Z)Z.hasOwnProperty(f)&&
y(f,Z[f],a);break;case "source":y("topError","error",a);break;case "img":case "image":case "link":y("topError","error",a);y("topLoad","load",a);break;case "form":y("topReset","reset",a);y("topSubmit","submit",a);break;case "details":y("topToggle","toggle",a);break;case "input":od(a,c);y("topInvalid","invalid",a);U(e,"onChange");break;case "select":Vd(a,c);y("topInvalid","invalid",a);U(e,"onChange");break;case "textarea":Wd(a,c),y("topInvalid","invalid",a),U(e,"onChange")}pc(b,c,Ra);d=null;for(var g in c)c.hasOwnProperty(g)&&
(f=c[g],"children"===g?"string"===typeof f?a.textContent!==f&&(d=["children",f]):"number"===typeof f&&a.textContent!==""+f&&(d=["children",""+f]):qa.hasOwnProperty(g)&&null!=f&&U(e,g));switch(b){case "input":fb(a);qd(a,c);break;case "textarea":fb(a);b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b);break;case "select":case "option":break;default:"function"===typeof c.onClick&&(a.onclick=M)}return d}function he(a,b){return a.nodeValue!==b}function Sa(a){this._expirationTime=B.computeUniqueAsyncExpiration();
this._root=a;this._callbacks=this._next=null;this._hasChildren=this._didComplete=!1;this._children=null;this._defer=!0}function ma(){this._callbacks=null;this._didCommit=!1;this._onCommit=this._onCommit.bind(this)}function aa(a,b,c){this._internalRoot=B.createContainer(a,b,c)}function rc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function ie(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}
function lf(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new aa(a,!1,b)}function vb(a,b,c,d,e){rc(c)?void 0:l("200");var f=c._reactRootContainer;if(f){if("function"===typeof e){var g=e;e=function(){var a=B.getPublicRootInstance(f._internalRoot);g.call(a)}}null!=a?f.legacy_renderSubtreeIntoContainer(a,b,e):f.render(b,e)}else{f=c._reactRootContainer=lf(c,d);if("function"===
typeof e){var h=e;e=function(){var a=B.getPublicRootInstance(f._internalRoot);h.call(a)}}B.unbatchedUpdates(function(){null!=a?f.legacy_renderSubtreeIntoContainer(a,b,e):f.render(b,e)})}return B.getPublicRootInstance(f._internalRoot)}function je(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;rc(b)?void 0:l("200");return hf(a,b,null,c)}var ze=function(a,b,c,d,e,f,g,h){if(!a){if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
else{var k=[c,d,e,f,g,h],l=0;a=Error(b.replace(/%s/g,function(){return k[l++]}));a.name="Invariant Violation"}a.framesToPop=1;throw a;}};pa?void 0:l("227");var mf=function(a,b,c,d,e,f,g,h,k){this._hasCaughtError=!1;this._caughtError=null;var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this._caughtError=m,this._hasCaughtError=!0}},z={_caughtError:null,_hasCaughtError:!1,_rethrowError:null,_hasRethrowError:!1,invokeGuardedCallback:function(a,b,c,d,e,f,g,h,l){mf.apply(z,arguments)},
invokeGuardedCallbackAndCatchFirstError:function(a,b,c,d,e,f,g,h,l){z.invokeGuardedCallback.apply(this,arguments);if(z.hasCaughtError()){var k=z.clearCaughtError();z._hasRethrowError||(z._hasRethrowError=!0,z._rethrowError=k)}},rethrowCaughtError:function(){return nf.apply(z,arguments)},hasCaughtError:function(){return z._hasCaughtError},clearCaughtError:function(){if(z._hasCaughtError){var a=z._caughtError;z._caughtError=null;z._hasCaughtError=!1;return a}l("198")}},nf=function(){if(z._hasRethrowError){var a=
z._rethrowError;z._rethrowError=null;z._hasRethrowError=!1;throw a;}},bb=null,va={},ea=[],Gb={},qa={},cb={},of=Object.freeze({plugins:ea,eventNameDispatchConfigs:Gb,registrationNameModules:qa,registrationNameDependencies:cb,possibleRegistrationNames:null,injectEventPluginOrder:Gc,injectEventPluginsByName:Hc}),ba=function(){};ba.thatReturns=db;ba.thatReturnsFalse=db(!1);ba.thatReturnsTrue=db(!0);ba.thatReturnsNull=db(null);ba.thatReturnsThis=function(){return this};ba.thatReturnsArgument=function(a){return a};
var M=ba,Ib=null,Zc=null,Jc=null,fa=null,ke=function(a,b){if(a){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)Ic(a,b,c[e],d[e]);else c&&Ic(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},Ae=function(a){return ke(a,!0)},Be=function(a){return ke(a,!1)},sc={injectEventPluginOrder:Gc,injectEventPluginsByName:Hc},pf=Object.freeze({injection:sc,getListener:Hb,runEventsInBatch:Jb,
runExtractedEventsInBatch:Kc}),le=Math.random().toString(36).slice(2),P="__reactInternalInstance$"+le,ha="__reactEventHandlers$"+le,me=Object.freeze({precacheFiberNode:function(a,b){b[P]=a},getClosestInstanceFromNode:Ca,getInstanceFromNode:function(a){a=a[P];return!a||5!==a.tag&&6!==a.tag?null:a},getNodeFromInstance:xa,getFiberCurrentPropsFromNode:Lc,updateFiberProps:function(a,b){a[ha]=b}}),qf=Object.freeze({accumulateTwoPhaseDispatches:ya,accumulateTwoPhaseDispatchesSkipTarget:function(a){X(a,De)},
accumulateEnterLeaveDispatches:Oc,accumulateDirectDispatches:function(a){X(a,Ee)}}),wb=!("undefined"===typeof window||!window.document||!window.document.createElement),R={canUseDOM:wb,canUseWorkers:"undefined"!==typeof Worker,canUseEventListeners:wb&&!(!window.addEventListener&&!window.attachEvent),canUseViewport:wb&&!!window.screen,isInWorker:!wb},Lb=null,H={_root:null,_startText:null,_fallbackText:null},A=pa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,ne="dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
rf={type:null,target:null,currentTarget:M.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};A(I.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=M.thatReturnsTrue)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():
"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=M.thatReturnsTrue)},persist:function(){this.isPersistent=M.thatReturnsTrue},isPersistent:M.thatReturnsFalse,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;for(a=0;a<ne.length;a++)this[ne[a]]=null}});I.Interface=rf;I.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;A(d,b.prototype);b.prototype=d;b.prototype.constructor=
b;b.Interface=A({},c.Interface,a);b.extend=c.extend;Sc(b);return b};Sc(I);var sf=I.extend({data:null}),tf=I.extend({data:null}),He=[9,13,27,32],Mb=R.canUseDOM&&"CompositionEvent"in window,Ta=null;R.canUseDOM&&"documentMode"in document&&(Ta=document.documentMode);var uf=R.canUseDOM&&"TextEvent"in window&&!Ta,Xc=R.canUseDOM&&(!Mb||Ta&&8<Ta&&11>=Ta),Wc=String.fromCharCode(32),ca={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["topCompositionEnd",
"topKeyPress","topTextInput","topPaste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},dependencies:"topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",
captured:"onCompositionUpdateCapture"},dependencies:"topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")}},Vc=!1,ia=!1,vf={eventTypes:ca,extractEvents:function(a,b,c,d){var e=void 0;var f=void 0;if(Mb)b:{switch(a){case "topCompositionStart":e=ca.compositionStart;break b;case "topCompositionEnd":e=ca.compositionEnd;break b;case "topCompositionUpdate":e=ca.compositionUpdate;break b}e=void 0}else ia?Tc(a,c)&&(e=ca.compositionEnd):"topKeyDown"===a&&229===c.keyCode&&(e=
ca.compositionStart);e?(Xc&&(ia||e!==ca.compositionStart?e===ca.compositionEnd&&ia&&(f=Qc()):(H._root=d,H._startText=Rc(),ia=!0)),e=sf.getPooled(e,b,c,d),f?e.data=f:(f=Uc(c),null!==f&&(e.data=f)),ya(e),f=e):f=null;(a=uf?Ie(a,c):Je(a,c))?(b=tf.getPooled(ca.beforeInput,b,c,d),b.data=a,ya(b)):b=null;return null===f?b:null===b?f:[f,b]}},eb=null,za=null,ra=null,oe={injectFiberControlledHostComponent:function(a){eb=a}},wf=Object.freeze({injection:oe,enqueueStateRestore:$c,needsStateRestore:ad,restoreStateIfNeeded:bd}),
dd=function(a,b){return a(b)},Dd=function(a,b,c){return a(b,c)},ed=function(){},Nb=!1,Ke={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},tc=pa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,V="function"===typeof Symbol&&Symbol["for"],sb=V?Symbol["for"]("react.element"):60103,jd=V?Symbol["for"]("react.call"):60104,kd=V?Symbol["for"]("react.return"):60105,ja=V?Symbol["for"]("react.portal"):
60106,Y=V?Symbol["for"]("react.fragment"):60107,cf=V?Symbol["for"]("react.strict_mode"):60108,df=V?Symbol["for"]("react.provider"):60109,ef=V?Symbol["for"]("react.context"):60110,bf=V?Symbol["for"]("react.async_mode"):60111,ld=V?Symbol["for"]("react.forward_ref"):60112,id="function"===typeof Symbol&&Symbol.iterator,Ne=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
nd={},md={},F={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){F[a]=new J(a,0,!1,a,null)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];F[b]=new J(b,1,!1,a[1],null)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){F[a]=new J(a,2,!1,a.toLowerCase(),null)});["autoReverse",
"externalResourcesRequired","preserveAlpha"].forEach(function(a){F[a]=new J(a,2,!1,a,null)});"allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){F[a]=new J(a,3,!1,a.toLowerCase(),null)});["checked","multiple","muted","selected"].forEach(function(a){F[a]=new J(a,3,!0,a.toLowerCase(),null)});["capture","download"].forEach(function(a){F[a]=
new J(a,4,!1,a.toLowerCase(),null)});["cols","rows","size","span"].forEach(function(a){F[a]=new J(a,6,!1,a.toLowerCase(),null)});["rowSpan","start"].forEach(function(a){F[a]=new J(a,5,!1,a.toLowerCase(),null)});var uc=/[\-:]([a-z])/g,vc=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(uc,vc);F[b]=new J(b,1,!1,a,null)});"xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(uc,vc);F[b]=new J(b,1,!1,a,"http://www.w3.org/1999/xlink")});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(uc,vc);F[b]=new J(b,1,!1,a,"http://www.w3.org/XML/1998/namespace")});F.tabIndex=new J("tabIndex",1,!1,"tabindex",null);var sd={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},
dependencies:"topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")}},Ja=null,Ka=null,wc=!1;R.canUseDOM&&(wc=Pb("input")&&(!document.documentMode||9<document.documentMode));var xf={eventTypes:sd,_isInputEventSupported:wc,extractEvents:function(a,b,c,d){var e=b?xa(b):window,f=void 0,g=void 0,h=e.nodeName&&e.nodeName.toLowerCase();"select"===h||"input"===h&&"file"===e.type?f=Re:fd(e)?wc?f=Ve:(f=Te,g=Se):(h=e.nodeName)&&"input"===h.toLowerCase()&&("checkbox"===
e.type||"radio"===e.type)&&(f=Ue);if(f&&(f=f(a,b)))return rd(f,c,d);g&&g(a,e,b);"topBlur"===a&&null!=b&&(a=b._wrapperState||e._wrapperState)&&a.controlled&&"number"===e.type&&Vb(e,"number",e.value)}},Ua=I.extend({view:null,detail:null}),Xe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},Va=Ua.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Wb,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||
(a.fromElement===a.srcElement?a.toElement:a.fromElement)}}),xc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["topMouseOut","topMouseOver"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["topMouseOut","topMouseOver"]}},yf={eventTypes:xc,extractEvents:function(a,b,c,d){if("topMouseOver"===a&&(c.relatedTarget||c.fromElement)||"topMouseOut"!==a&&"topMouseOver"!==a)return null;var e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;"topMouseOut"===a?(a=b,
b=(b=c.relatedTarget||c.toElement)?Ca(b):null):a=null;if(a===b)return null;var f=null==a?e:xa(a);e=null==b?e:xa(b);var g=Va.getPooled(xc.mouseLeave,a,c,d);g.type="mouseleave";g.target=f;g.relatedTarget=e;c=Va.getPooled(xc.mouseEnter,b,c,d);c.type="mouseenter";c.target=e;c.relatedTarget=f;Oc(g,c,a,b);return[g,c]}},bc=function(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}},zf=Object.prototype.hasOwnProperty,
cc=function(a,b){if(vd(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!zf.call(b,c[d])||!vd(a[c[d]],b[c[d]]))return!1;return!0},Af=I.extend({animationName:null,elapsedTime:null,pseudoElement:null}),Bf=I.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Cf=Ua.extend({relatedTarget:null}),Df={Esc:"Escape",Spacebar:" ",
Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Ef={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",
120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Ff=Ua.extend({key:function(a){if(a.key){var b=Df[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=hb(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Ef[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Wb,charCode:function(a){return"keypress"===a.type?hb(a):0},keyCode:function(a){return"keydown"===
a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===a.type?hb(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Gf=Va.extend({dataTransfer:null}),Hf=Ua.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Wb}),If=I.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),Jf=Va.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in
a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),Ad={},Xb={};"blur cancel click close contextMenu copy cut doubleClick dragEnd dragStart drop focus input invalid keyDown keyPress keyUp mouseDown mouseUp paste pause play rateChange reset seeked submit touchCancel touchEnd touchStart volumeChange".split(" ").forEach(function(a){zd(a,!0)});"abort animationEnd animationIteration animationStart canPlay canPlayThrough drag dragEnter dragExit dragLeave dragOver durationChange emptied encrypted ended error load loadedData loadedMetadata loadStart mouseMove mouseOut mouseOver playing progress scroll seeking stalled suspend timeUpdate toggle touchMove transitionEnd waiting wheel".split(" ").forEach(function(a){zd(a,
!1)});var pe={eventTypes:Ad,isInteractiveTopLevelEventType:function(a){a=Xb[a];return void 0!==a&&!0===a.isInteractive},extractEvents:function(a,b,c,d){var e=Xb[a];if(!e)return null;switch(a){case "topKeyPress":if(0===hb(c))return null;case "topKeyDown":case "topKeyUp":a=Ff;break;case "topBlur":case "topFocus":a=Cf;break;case "topClick":if(2===c.button)return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":a=
Va;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":a=Gf;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":a=Hf;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":a=Af;break;case "topTransitionEnd":a=If;break;case "topScroll":a=Ua;break;case "topWheel":a=Jf;break;case "topCopy":case "topCut":case "topPaste":a=Bf;break;default:a=
I}b=a.getPooled(e,b,c,d);ya(b);return b}},Bd=pe.isInteractiveTopLevelEventType,jb=[],Ma=!0,Kf=Object.freeze({get _enabled(){return Ma},setEnabled:Yb,isEnabled:function(){return Ma},trapBubbledEvent:y,trapCapturedEvent:S,dispatchEvent:ib}),T={animationend:kb("Animation","AnimationEnd"),animationiteration:kb("Animation","AnimationIteration"),animationstart:kb("Animation","AnimationStart"),transitionend:kb("Transition","TransitionEnd")},Zb={},Ed={};R.canUseDOM&&(Ed=document.createElement("div").style,
"AnimationEvent"in window||(delete T.animationend.animation,delete T.animationiteration.animation,delete T.animationstart.animation),"TransitionEvent"in window||delete T.transitionend.transition);var $d={topAnimationEnd:lb("animationend"),topAnimationIteration:lb("animationiteration"),topAnimationStart:lb("animationstart"),topBlur:"blur",topCancel:"cancel",topChange:"change",topClick:"click",topClose:"close",topCompositionEnd:"compositionend",topCompositionStart:"compositionstart",topCompositionUpdate:"compositionupdate",
topContextMenu:"contextmenu",topCopy:"copy",topCut:"cut",topDoubleClick:"dblclick",topDrag:"drag",topDragEnd:"dragend",topDragEnter:"dragenter",topDragExit:"dragexit",topDragLeave:"dragleave",topDragOver:"dragover",topDragStart:"dragstart",topDrop:"drop",topFocus:"focus",topInput:"input",topKeyDown:"keydown",topKeyPress:"keypress",topKeyUp:"keyup",topLoad:"load",topLoadStart:"loadstart",topMouseDown:"mousedown",topMouseMove:"mousemove",topMouseOut:"mouseout",topMouseOver:"mouseover",topMouseUp:"mouseup",
topPaste:"paste",topScroll:"scroll",topSelectionChange:"selectionchange",topTextInput:"textInput",topToggle:"toggle",topTouchCancel:"touchcancel",topTouchEnd:"touchend",topTouchMove:"touchmove",topTouchStart:"touchstart",topTransitionEnd:lb("transitionend"),topWheel:"wheel"},Z={topAbort:"abort",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topLoadedData:"loadeddata",topLoadedMetadata:"loadedmetadata",
topLoadStart:"loadstart",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topSeeked:"seeked",topSeeking:"seeking",topStalled:"stalled",topSuspend:"suspend",topTimeUpdate:"timeupdate",topVolumeChange:"volumechange",topWaiting:"waiting"},Gd={},af=0,mb="_reactListenersID"+(""+Math.random()).slice(2),Id=function(a){var b=(a?a.ownerDocument||a:document).defaultView||window;return!!(a&&("function"===typeof b.Node?a instanceof b.Node:"object"===typeof a&&
"number"===typeof a.nodeType&&"string"===typeof a.nodeName))&&3==a.nodeType},Lf=R.canUseDOM&&"documentMode"in document&&11>=document.documentMode,Md={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")}},ka=null,dc=null,Na=null,ac=!1,Mf={eventTypes:Md,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=
!e)){a:{e=Fd(e);f=cb.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0}f=!e}if(f)return null;e=b?xa(b):window;switch(a){case "topFocus":if(fd(e)||"true"===e.contentEditable)ka=e,dc=b,Na=null;break;case "topBlur":Na=dc=ka=null;break;case "topMouseDown":ac=!0;break;case "topContextMenu":case "topMouseUp":return ac=!1,Ld(c,d);case "topSelectionChange":if(Lf)break;case "topKeyDown":case "topKeyUp":return Ld(c,d)}return null}};sc.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
(function(a){Ib=a.getFiberCurrentPropsFromNode;Zc=a.getInstanceFromNode;Jc=a.getNodeFromInstance})(me);sc.injectEventPluginsByName({SimpleEventPlugin:pe,EnterLeaveEventPlugin:yf,ChangeEventPlugin:xf,SelectEventPlugin:Mf,BeforeInputEventPlugin:vf});var la={},hc=null,ic=null;new Set;var kc=void 0,lc=void 0,Nf=function(a,b,c,d,e){function f(a,b,c,d,e,f){if(null===b||null!==a.updateQueue&&a.updateQueue.hasForceUpdate)return!0;var m=a.stateNode;a=a.type;return"function"===typeof m.shouldComponentUpdate?
m.shouldComponentUpdate(c,e,f):a.prototype&&a.prototype.isPureReactComponent?!cc(b,c)||!cc(d,e):!0}function g(a,b){b.updater=v;a.stateNode=b;b._reactInternalFiber=a}function h(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&v.enqueueReplaceState(b,b.state,null)}function l(a,b,c,d){a=a.type;if("function"===typeof a.getDerivedStateFromProps)return a.getDerivedStateFromProps.call(null,
c,d)}var D=a.cacheContext,m=a.getMaskedContext,w=a.getUnmaskedContext,p=a.isContextConsumer,G=a.hasContextChanged,v={isMounted:Ye,enqueueSetState:function(a,d,e){a=a._reactInternalFiber;e=void 0===e?null:e;var f=c(a);Oa(a,{expirationTime:f,partialState:d,callback:e,isReplace:!1,isForced:!1,capturedValue:null,next:null});b(a,f)},enqueueReplaceState:function(a,d,e){a=a._reactInternalFiber;e=void 0===e?null:e;var f=c(a);Oa(a,{expirationTime:f,partialState:d,callback:e,isReplace:!0,isForced:!1,capturedValue:null,
next:null});b(a,f)},enqueueForceUpdate:function(a,d){a=a._reactInternalFiber;d=void 0===d?null:d;var e=c(a);Oa(a,{expirationTime:e,partialState:null,callback:d,isReplace:!1,isForced:!0,capturedValue:null,next:null});b(a,e)}};return{adoptClassInstance:g,callGetDerivedStateFromProps:l,constructClassInstance:function(a,b){var c=a.type,d=w(a),e=p(a),f=e?m(a,d):la;c=new c(b,f);var h=null!==c.state&&void 0!==c.state?c.state:null;g(a,c);a.memoizedState=h;b=l(a,c,b,h);null!==b&&void 0!==b&&(a.memoizedState=
A({},a.memoizedState,b));e&&D(a,d,f);return c},mountClassInstance:function(a,b){var c=a.type,d=a.alternate,e=a.stateNode,f=a.pendingProps,h=w(a);e.props=f;e.state=a.memoizedState;e.refs=la;e.context=m(a,h);"function"===typeof c.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(c=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&
e.UNSAFE_componentWillMount(),c!==e.state&&v.enqueueReplaceState(e,e.state,null),c=a.updateQueue,null!==c&&(e.state=qb(d,a,c,e,f,b)));"function"===typeof e.componentDidMount&&(a.effectTag|=4)},resumeMountClassInstance:function(a,b){var c=a.type,g=a.stateNode;g.props=a.memoizedProps;g.state=a.memoizedState;var k=a.memoizedProps,v=a.pendingProps,p=g.context,x=w(a);x=m(a,x);(c="function"===typeof c.getDerivedStateFromProps||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
"function"!==typeof g.componentWillReceiveProps||(k!==v||p!==x)&&h(a,g,v,x);p=a.memoizedState;b=null!==a.updateQueue?qb(null,a,a.updateQueue,g,v,b):p;var r=void 0;k!==v&&(r=l(a,g,v,b));if(null!==r&&void 0!==r){b=null===b||void 0===b?r:A({},b,r);var q=a.updateQueue;null!==q&&(q.baseState=A({},q.baseState,r))}if(!(k!==v||p!==b||G()||null!==a.updateQueue&&a.updateQueue.hasForceUpdate))return"function"===typeof g.componentDidMount&&(a.effectTag|=4),!1;(k=f(a,k,v,p,b,x))?(c||"function"!==typeof g.UNSAFE_componentWillMount&&
"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(a.effectTag|=4)):("function"===typeof g.componentDidMount&&(a.effectTag|=4),d(a,v),e(a,b));g.props=v;g.state=b;g.context=x;return k},updateClassInstance:function(a,b,c){var g=b.type,k=b.stateNode;k.props=b.memoizedProps;k.state=b.memoizedState;var v=b.memoizedProps,p=b.pendingProps,
C=k.context,r=w(b);r=m(b,r);(g="function"===typeof g.getDerivedStateFromProps||"function"===typeof k.getSnapshotBeforeUpdate)||"function"!==typeof k.UNSAFE_componentWillReceiveProps&&"function"!==typeof k.componentWillReceiveProps||(v!==p||C!==r)&&h(b,k,p,r);C=b.memoizedState;c=null!==b.updateQueue?qb(a,b,b.updateQueue,k,p,c):C;var q=void 0;v!==p&&(q=l(b,k,p,c));if(null!==q&&void 0!==q){c=null===c||void 0===c?q:A({},c,q);var n=b.updateQueue;null!==n&&(n.baseState=A({},n.baseState,q))}if(!(v!==p||
C!==c||G()||null!==b.updateQueue&&b.updateQueue.hasForceUpdate))return"function"!==typeof k.componentDidUpdate||v===a.memoizedProps&&C===a.memoizedState||(b.effectTag|=4),"function"!==typeof k.getSnapshotBeforeUpdate||v===a.memoizedProps&&C===a.memoizedState||(b.effectTag|=2048),!1;(q=f(b,v,p,C,c,r))?(g||"function"!==typeof k.UNSAFE_componentWillUpdate&&"function"!==typeof k.componentWillUpdate||("function"===typeof k.componentWillUpdate&&k.componentWillUpdate(p,c,r),"function"===typeof k.UNSAFE_componentWillUpdate&&
k.UNSAFE_componentWillUpdate(p,c,r)),"function"===typeof k.componentDidUpdate&&(b.effectTag|=4),"function"===typeof k.getSnapshotBeforeUpdate&&(b.effectTag|=2048)):("function"!==typeof k.componentDidUpdate||v===a.memoizedProps&&C===a.memoizedState||(b.effectTag|=4),"function"!==typeof k.getSnapshotBeforeUpdate||v===a.memoizedProps&&C===a.memoizedState||(b.effectTag|=2048),d(b,p),e(b,c));k.props=p;k.state=c;k.context=r;return q}}},tb=Array.isArray,xb=Td(!0),yc=Td(!1),Qf=function(a,b,c,d,e,f,g){function h(a,
b,c){k(a,b,c,b.expirationTime)}function k(a,b,c,d){b.child=null===a?yc(b,null,c,d):xb(b,a.child,c,d)}function D(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function m(a,b,c,d,e,f){D(a,b);if(!c&&!e)return d&&n(b,!1),v(a,b);c=b.stateNode;tc.current=b;var m=e?null:c.render();b.effectTag|=1;e&&(k(a,b,null,f),b.child=null);k(a,b,m,f);b.memoizedState=c.state;b.memoizedProps=c.props;d&&n(b,!0);return b.child}function w(a){var b=a.stateNode;b.pendingContext?q(a,b.pendingContext,
b.pendingContext!==b.context):b.context&&q(a,b.context,!1);y(a,b.containerInfo)}function p(a,b,c,d){var e=a.child;for(null!==e&&(e["return"]=a);null!==e;){switch(e.tag){case 12:var f=e.stateNode|0;if(e.type===b&&0!==(f&c)){for(f=e;null!==f;){var m=f.alternate;if(0===f.expirationTime||f.expirationTime>d)f.expirationTime=d,null!==m&&(0===m.expirationTime||m.expirationTime>d)&&(m.expirationTime=d);else if(null!==m&&(0===m.expirationTime||m.expirationTime>d))m.expirationTime=d;else break;f=f["return"]}f=
null}else f=e.child;break;case 13:f=e.type===a.type?null:e.child;break;default:f=e.child}if(null!==f)f["return"]=e;else for(f=e;null!==f;){if(f===a){f=null;break}e=f.sibling;if(null!==e){f=e;break}f=f["return"]}e=f}}function G(a,b,c){var d=b.type._context,e=b.pendingProps,f=b.memoizedProps;if(!Aa()&&f===e)return b.stateNode=0,z(b),v(a,b);var m=e.value;b.memoizedProps=e;if(null===f)m=1073741823;else if(f.value===e.value){if(f.children===e.children)return b.stateNode=0,z(b),v(a,b);m=0}else{var g=f.value;
if(g===m&&(0!==g||1/g===1/m)||g!==g&&m!==m){if(f.children===e.children)return b.stateNode=0,z(b),v(a,b);m=0}else if(m="function"===typeof d._calculateChangedBits?d._calculateChangedBits(g,m):1073741823,m|=0,0===m){if(f.children===e.children)return b.stateNode=0,z(b),v(a,b)}else p(b,d,m,c)}b.stateNode=m;z(b);h(a,b,e.children);return b.child}function v(a,b){null!==a&&b.child!==a.child?l("153"):void 0;if(null!==b.child){a=b.child;var c=nb(a,a.pendingProps,a.expirationTime);b.child=c;for(c["return"]=
b;null!==a.sibling;)a=a.sibling,c=c.sibling=nb(a,a.pendingProps,a.expirationTime),c["return"]=b;c.sibling=null}return b.child}var C=a.shouldSetTextContent,x=a.shouldDeprioritizeSubtree,t=b.pushHostContext,y=b.pushHostContainer,z=d.pushProvider,B=c.getMaskedContext,F=c.getUnmaskedContext,Aa=c.hasContextChanged,r=c.pushContextProvider,q=c.pushTopLevelContextObject,n=c.invalidateContextProvider,gf=e.enterHydrationState,E=e.resetHydrationState,qe=e.tryToClaimNextHydratableInstance;a=Nf(c,f,g,function(a,
b){a.memoizedProps=b},function(a,b){a.memoizedState=b});var Of=a.adoptClassInstance,Pf=a.callGetDerivedStateFromProps,H=a.constructClassInstance,re=a.mountClassInstance,I=a.resumeMountClassInstance,J=a.updateClassInstance;return{beginWork:function(a,b,c){if(0===b.expirationTime||b.expirationTime>c){switch(b.tag){case 3:w(b);break;case 2:r(b);break;case 4:y(b,b.stateNode.containerInfo);break;case 13:z(b)}return null}switch(b.tag){case 0:null!==a?l("155"):void 0;var d=b.type,e=b.pendingProps,f=F(b);
f=B(b,f);d=d(e,f);b.effectTag|=1;"object"===typeof d&&null!==d&&"function"===typeof d.render&&void 0===d.$$typeof?(f=b.type,b.tag=2,b.memoizedState=null!==d.state&&void 0!==d.state?d.state:null,"function"===typeof f.getDerivedStateFromProps&&(e=Pf(b,d,e,b.memoizedState),null!==e&&void 0!==e&&(b.memoizedState=A({},b.memoizedState,e))),e=r(b),Of(b,d),re(b,c),a=m(a,b,!0,e,!1,c)):(b.tag=1,h(a,b,d),b.memoizedProps=e,a=b.child);return a;case 1:return e=b.type,c=b.pendingProps,Aa()||b.memoizedProps!==c?
(d=F(b),d=B(b,d),e=e(c,d),b.effectTag|=1,h(a,b,e),b.memoizedProps=c,a=b.child):a=v(a,b),a;case 2:e=r(b);null===a?null===b.stateNode?(H(b,b.pendingProps),re(b,c),d=!0):d=I(b,c):d=J(a,b,c);f=!1;var g=b.updateQueue;null!==g&&null!==g.capturedValues&&(f=d=!0);return m(a,b,d,e,f,c);case 3:a:if(w(b),d=b.updateQueue,null!==d){f=b.memoizedState;e=qb(a,b,d,null,null,c);b.memoizedState=e;d=b.updateQueue;if(null!==d&&null!==d.capturedValues)d=null;else if(f===e){E();a=v(a,b);break a}else d=e.element;f=b.stateNode;
(null===a||null===a.child)&&f.hydrate&&gf(b)?(b.effectTag|=2,b.child=yc(b,null,d,c)):(E(),h(a,b,d));b.memoizedState=e;a=b.child}else E(),a=v(a,b);return a;case 5:a:{t(b);null===a&&qe(b);e=b.type;g=b.memoizedProps;d=b.pendingProps;f=null!==a?a.memoizedProps:null;if(!Aa()&&g===d){if(g=b.mode&1&&x(e,d))b.expirationTime=1073741823;if(!g||1073741823!==c){a=v(a,b);break a}}g=d.children;C(e,d)?g=null:f&&C(e,f)&&(b.effectTag|=16);D(a,b);1073741823!==c&&b.mode&1&&x(e,d)?(b.expirationTime=1073741823,b.memoizedProps=
d,a=null):(h(a,b,g),b.memoizedProps=d,a=b.child)}return a;case 6:return null===a&&qe(b),b.memoizedProps=b.pendingProps,null;case 8:b.tag=7;case 7:return e=b.pendingProps,Aa()||b.memoizedProps!==e||(e=b.memoizedProps),d=e.children,b.stateNode=null===a?yc(b,b.stateNode,d,c):xb(b,a.stateNode,d,c),b.memoizedProps=e,b.stateNode;case 9:return null;case 4:return y(b,b.stateNode.containerInfo),e=b.pendingProps,Aa()||b.memoizedProps!==e?(null===a?b.child=xb(b,null,e,c):h(a,b,e),b.memoizedProps=e,a=b.child):
a=v(a,b),a;case 14:return c=b.type.render,c=c(b.pendingProps,b.ref),h(a,b,c),b.memoizedProps=c,b.child;case 10:return c=b.pendingProps,Aa()||b.memoizedProps!==c?(h(a,b,c),b.memoizedProps=c,a=b.child):a=v(a,b),a;case 11:return c=b.pendingProps.children,Aa()||null!==c&&b.memoizedProps!==c?(h(a,b,c),b.memoizedProps=c,a=b.child):a=v(a,b),a;case 13:return G(a,b,c);case 12:a:{d=b.type;f=b.pendingProps;g=b.memoizedProps;e=d._currentValue;var n=d._changedBits;if(Aa()||0!==n||g!==f){b.memoizedProps=f;var q=
f.unstable_observedBits;if(void 0===q||null===q)q=1073741823;b.stateNode=q;if(0!==(n&q))p(b,d,n,c);else if(g===f){a=v(a,b);break a}c=f.children;c=c(e);h(a,b,c);a=b.child}else a=v(a,b)}return a;default:l("156")}}}},Rf=function(a,b,c,d,e){function f(a){a.effectTag|=4}var g=a.createInstance,h=a.createTextInstance,k=a.appendInitialChild,D=a.finalizeInitialChildren,m=a.prepareUpdate,w=a.persistence,p=b.getRootHostContainer,G=b.popHostContext,v=b.getHostContext,C=b.popHostContainer,x=c.popContextProvider,
t=c.popTopLevelContextObject,y=d.popProvider,z=e.prepareToHydrateHostInstance,B=e.prepareToHydrateHostTextInstance,A=e.popHydrationState,F=void 0,r=void 0,q=void 0;a.mutation?(F=function(a){},r=function(a,b,c,d,e,m,g,h){(b.updateQueue=c)&&f(b)},q=function(a,b,c,d){c!==d&&f(b)}):w?l("235"):l("236");return{completeWork:function(a,b,c){var d=b.pendingProps;switch(b.tag){case 1:return null;case 2:return x(b),a=b.stateNode,d=b.updateQueue,null!==d&&null!==d.capturedValues&&(b.effectTag&=-65,"function"===
typeof a.componentDidCatch?b.effectTag|=256:d.capturedValues=null),null;case 3:C(b);t(b);d=b.stateNode;d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)A(b),b.effectTag&=-3;F(b);a=b.updateQueue;null!==a&&null!==a.capturedValues&&(b.effectTag|=256);return null;case 5:G(b);c=p();var e=b.type;if(null!==a&&null!=b.stateNode){var n=a.memoizedProps,w=b.stateNode,E=v();w=m(w,e,n,d,c,E);r(a,b,w,e,n,d,c,E);a.ref!==b.ref&&(b.effectTag|=128)}else{if(!d)return null===
b.stateNode?l("166"):void 0,null;a=v();if(A(b))z(b,c,a)&&f(b);else{n=g(e,d,c,a,b);a:for(E=b.child;null!==E;){if(5===E.tag||6===E.tag)k(n,E.stateNode);else if(4!==E.tag&&null!==E.child){E.child["return"]=E;E=E.child;continue}if(E===b)break;for(;null===E.sibling;){if(null===E["return"]||E["return"]===b)break a;E=E["return"]}E.sibling["return"]=E["return"];E=E.sibling}D(n,e,d,c,a)&&f(b);b.stateNode=n}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)q(a,b,a.memoizedProps,d);
else{if("string"!==typeof d)return null===b.stateNode?l("166"):void 0,null;a=p();c=v();A(b)?B(b)&&f(b):b.stateNode=h(d,a,c,b)}return null;case 7:(d=b.memoizedProps)?void 0:l("165");b.tag=8;e=[];a:for((n=b.stateNode)&&(n["return"]=b);null!==n;){if(5===n.tag||6===n.tag||4===n.tag)l("247");else if(9===n.tag)e.push(n.pendingProps.value);else if(null!==n.child){n.child["return"]=n;n=n.child;continue}for(;null===n.sibling;){if(null===n["return"]||n["return"]===b)break a;n=n["return"]}n.sibling["return"]=
n["return"];n=n.sibling}n=d.handler;d=n(d.props,e);b.child=xb(b,null!==a?a.child:null,d,c);return b.child;case 8:return b.tag=7,null;case 9:return null;case 14:return null;case 10:return null;case 11:return null;case 4:return C(b),F(b),null;case 13:return y(b),null;case 12:return null;case 0:l("167");default:l("156")}}}},Sf=function(a,b,c,d,e){var f=a.popHostContainer,g=a.popHostContext,h=b.popContextProvider,k=b.popTopLevelContextObject,l=c.popProvider;return{throwException:function(a,b,c){b.effectTag|=
512;b.firstEffect=b.lastEffect=null;b={value:c,source:b,stack:Qb(b)};do{switch(a.tag){case 3:jc(a);a.updateQueue.capturedValues=[b];a.effectTag|=1024;return;case 2:if(c=a.stateNode,0===(a.effectTag&64)&&null!==c&&"function"===typeof c.componentDidCatch&&!e(c)){jc(a);c=a.updateQueue;var d=c.capturedValues;null===d?c.capturedValues=[b]:d.push(b);a.effectTag|=1024;return}}a=a["return"]}while(null!==a)},unwindWork:function(a){switch(a.tag){case 2:h(a);var b=a.effectTag;return b&1024?(a.effectTag=b&-1025|
64,a):null;case 3:return f(a),k(a),b=a.effectTag,b&1024?(a.effectTag=b&-1025|64,a):null;case 5:return g(a),null;case 4:return f(a),null;case 13:return l(a),null;default:return null}},unwindInterruptedWork:function(a){switch(a.tag){case 2:h(a);break;case 3:f(a);k(a);break;case 5:g(a);break;case 4:f(a);break;case 13:l(a)}}}},Tf=function(a,b,c,d,e,f){function g(a){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null)}catch(n){b(a,n)}else c.current=null}function h(a){"function"===typeof Pd&&Pd(a);
switch(a.tag){case 2:g(a);var c=a.stateNode;if("function"===typeof c.componentWillUnmount)try{c.props=a.memoizedProps,c.state=a.memoizedState,c.componentWillUnmount()}catch(n){b(a,n)}break;case 5:g(a);break;case 7:k(a.stateNode);break;case 4:p&&m(a)}}function k(a){for(var b=a;;)if(h(b),null===b.child||p&&4===b.tag){if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||b["return"]===a)return;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}else b.child["return"]=b,b=b.child}function D(a){return 5===
a.tag||3===a.tag||4===a.tag}function m(a){for(var b=a,c=!1,d=void 0,e=void 0;;){if(!c){c=b["return"];a:for(;;){null===c?l("160"):void 0;switch(c.tag){case 5:d=c.stateNode;e=!1;break a;case 3:d=c.stateNode.containerInfo;e=!0;break a;case 4:d=c.stateNode.containerInfo;e=!0;break a}c=c["return"]}c=!0}if(5===b.tag||6===b.tag)k(b),e?F(d,b.stateNode):B(d,b.stateNode);else if(4===b.tag?d=b.stateNode.containerInfo:h(b),null!==b.child){b.child["return"]=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===
b["return"]||b["return"]===a)return;b=b["return"];4===b.tag&&(c=!1)}b.sibling["return"]=b["return"];b=b.sibling}}var w=a.getPublicInstance,p=a.mutation;a=a.persistence;p||(a?l("235"):l("236"));var G=p.commitMount,v=p.commitUpdate,C=p.resetTextContent,x=p.commitTextUpdate,t=p.appendChild,y=p.appendChildToContainer,z=p.insertBefore,A=p.insertInContainerBefore,B=p.removeChild,F=p.removeChildFromContainer;return{commitBeforeMutationLifeCycles:function(a,b){switch(b.tag){case 2:if(b.effectTag&2048&&null!==
a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;a.props=b.memoizedProps;a.state=b.memoizedState;b=a.getSnapshotBeforeUpdate(c,d);a.__reactInternalSnapshotBeforeUpdate=b}break;case 3:case 5:case 6:case 4:break;default:l("163")}},commitResetTextContent:function(a){C(a.stateNode)},commitPlacement:function(a){a:{for(var b=a["return"];null!==b;){if(D(b)){var c=b;break a}b=b["return"]}l("160");c=void 0}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;
d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:l("161")}c.effectTag&16&&(C(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c["return"]||D(c["return"])){c=null;break a}c=c["return"]}c.sibling["return"]=c["return"];for(c=c.sibling;5!==c.tag&&6!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;else c.child["return"]=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)c?d?A(b,e.stateNode,c):
z(b,e.stateNode,c):d?y(b,e.stateNode):t(b,e.stateNode);else if(4!==e.tag&&null!==e.child){e.child["return"]=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e["return"]||e["return"]===a)return;e=e["return"]}e.sibling["return"]=e["return"];e=e.sibling}},commitDeletion:function(a){m(a);a["return"]=null;a.child=null;a.alternate&&(a.alternate.child=null,a.alternate["return"]=null)},commitWork:function(a,b){switch(b.tag){case 2:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;
a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&v(c,f,e,a,d,b)}break;case 6:null===b.stateNode?l("162"):void 0;c=b.memoizedProps;x(b.stateNode,null!==a?a.memoizedProps:c,c);break;case 3:break;default:l("163")}},commitLifeCycles:function(a,b,c,d,e){switch(c.tag){case 2:a=c.stateNode;c.effectTag&4&&(null===b?(a.props=c.memoizedProps,a.state=c.memoizedState,a.componentDidMount()):(d=b.memoizedProps,b=b.memoizedState,a.props=c.memoizedProps,a.state=c.memoizedState,
a.componentDidUpdate(d,b,a.__reactInternalSnapshotBeforeUpdate)));c=c.updateQueue;null!==c&&Sd(c,a);break;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=w(c.child.stateNode);break;case 2:a=c.child.stateNode}Sd(b,a)}break;case 5:a=c.stateNode;null===b&&c.effectTag&4&&G(a,c.type,c.memoizedProps,c);break;case 6:break;case 4:break;default:l("163")}},commitErrorLogging:function(a,b){switch(a.tag){case 2:var c=a.type;b=a.stateNode;var d=a.updateQueue;null===d||
null===d.capturedValues?l("264"):void 0;var f=d.capturedValues;d.capturedValues=null;"function"!==typeof c.getDerivedStateFromCatch&&e(b);b.props=a.memoizedProps;b.state=a.memoizedState;for(c=0;c<f.length;c++){d=f[c];var m=d.value,g=d.stack;Ud(a,d);b.componentDidCatch(m,{componentStack:null!==g?g:""})}break;case 3:c=a.updateQueue;null===c||null===c.capturedValues?l("264"):void 0;f=c.capturedValues;c.capturedValues=null;for(c=0;c<f.length;c++)d=f[c],Ud(a,d),b(d.value);break;default:l("265")}},commitAttachRef:function(a){var b=
a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=w(c);break;default:a=c}"function"===typeof b?b(a):b.current=a}},commitDetachRef:function(a){a=a.ref;null!==a&&("function"===typeof a?a(null):a.current=null)}}},Wa={},Uf=function(a,b){function c(a){a===Wa?l("174"):void 0;return a}var d=a.getChildHostContext,e=a.getRootHostContext;a=b.createCursor;var f=b.push,g=b.pop,h=a(Wa),k=a(Wa),D=a(Wa);return{getHostContext:function(){return c(h.current)},getRootHostContainer:function(){return c(D.current)},
popHostContainer:function(a){g(h,a);g(k,a);g(D,a)},popHostContext:function(a){k.current===a&&(g(h,a),g(k,a))},pushHostContainer:function(a,b){f(D,b,a);f(k,a,a);f(h,Wa,a);b=e(b);g(h,a);f(h,b,a)},pushHostContext:function(a){var b=c(D.current),e=c(h.current);b=d(e,a.type,b);e!==b&&(f(k,a,a),f(h,b,a))}}},Vf=function(a){function b(a,b){var c=new sa(5,null,null,0);c.type="DELETED";c.stateNode=b;c["return"]=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=
c}function c(a,b){switch(a.tag){case 5:return b=f(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=g(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;default:return!1}}function d(a){for(a=a["return"];null!==a&&5!==a.tag&&3!==a.tag;)a=a["return"];w=a}var e=a.shouldSetTextContent;a=a.hydration;if(!a)return{enterHydrationState:function(){return!1},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){l("175")},prepareToHydrateHostTextInstance:function(){l("176")},
popHydrationState:function(a){return!1}};var f=a.canHydrateInstance,g=a.canHydrateTextInstance,h=a.getNextHydratableSibling,k=a.getFirstHydratableChild,D=a.hydrateInstance,m=a.hydrateTextInstance,w=null,p=null,G=!1;return{enterHydrationState:function(a){p=k(a.stateNode.containerInfo);w=a;return G=!0},resetHydrationState:function(){p=w=null;G=!1},tryToClaimNextHydratableInstance:function(a){if(G){var d=p;if(d){if(!c(a,d)){d=h(d);if(!d||!c(a,d)){a.effectTag|=2;G=!1;w=a;return}b(w,p)}w=a;p=k(d)}else a.effectTag|=
2,G=!1,w=a}},prepareToHydrateHostInstance:function(a,b,c){b=D(a.stateNode,a.type,a.memoizedProps,b,c,a);a.updateQueue=b;return null!==b?!0:!1},prepareToHydrateHostTextInstance:function(a){return m(a.stateNode,a.memoizedProps,a)},popHydrationState:function(a){if(a!==w)return!1;if(!G)return d(a),G=!0,!1;var c=a.type;if(5!==a.tag||"head"!==c&&"body"!==c&&!e(c,a.memoizedProps))for(c=p;c;)b(a,c),c=h(c);d(a);p=w?h(a.stateNode):null;return!0}}},Wf=function(a){function b(a,b,c){a=a.stateNode;a.__reactInternalMemoizedUnmaskedChildContext=
b;a.__reactInternalMemoizedMaskedChildContext=c}function c(a){return 2===a.tag&&null!=a.type.childContextTypes}function d(a,b){var c=a.stateNode,d=a.type.childContextTypes;if("function"!==typeof c.getChildContext)return b;c=c.getChildContext();for(var e in c)e in d?void 0:l("108",Ia(a)||"Unknown",e);return A({},b,c)}var e=a.createCursor,f=a.push,g=a.pop,h=e(la),k=e(!1),D=la;return{getUnmaskedContext:function(a){return c(a)?D:h.current},cacheContext:b,getMaskedContext:function(a,c){var d=a.type.contextTypes;
if(!d)return la;var e=a.stateNode;if(e&&e.__reactInternalMemoizedUnmaskedChildContext===c)return e.__reactInternalMemoizedMaskedChildContext;var f={},g;for(g in d)f[g]=c[g];e&&b(a,c,f);return f},hasContextChanged:function(){return k.current},isContextConsumer:function(a){return 2===a.tag&&null!=a.type.contextTypes},isContextProvider:c,popContextProvider:function(a){c(a)&&(g(k,a),g(h,a))},popTopLevelContextObject:function(a){g(k,a);g(h,a)},pushTopLevelContextObject:function(a,b,c){null!=h.cursor?l("168"):
void 0;f(h,b,a);f(k,c,a)},processChildContext:d,pushContextProvider:function(a){if(!c(a))return!1;var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||la;D=h.current;f(h,b,a);f(k,k.current,a);return!0},invalidateContextProvider:function(a,b){var c=a.stateNode;c?void 0:l("169");if(b){var e=d(a,D);c.__reactInternalMemoizedMergedChildContext=e;g(k,a);g(h,a);f(h,e,a)}else g(k,a);f(k,b,a)},findCurrentUnmaskedContext:function(a){for(2!==La(a)||2!==a.tag?l("170"):void 0;3!==a.tag;){if(c(a))return a.stateNode.__reactInternalMemoizedMergedChildContext;
(a=a["return"])?void 0:l("171")}return a.stateNode.context}}},Xf=function(a){var b=a.createCursor,c=a.push,d=a.pop,e=b(null),f=b(null),g=b(0);return{pushProvider:function(a){var b=a.type._context;c(g,b._changedBits,a);c(f,b._currentValue,a);c(e,a,a);b._currentValue=a.pendingProps.value;b._changedBits=a.stateNode},popProvider:function(a){var b=g.current,c=f.current;d(e,a);d(f,a);d(g,a);a=a.type._context;a._currentValue=c;a._changedBits=b}}},Yf=function(){var a=[],b=-1;return{createCursor:function(a){return{current:a}},
isEmpty:function(){return-1===b},pop:function(c,d){0>b||(c.current=a[b],a[b]=null,b--)},push:function(c,d,e){b++;a[b]=c.current;c.current=d},checkThatStackIsEmpty:function(){},resetStackAfterFatalErrorInDev:function(){}}},$f=function(a){function b(){if(null!==K)for(var a=K["return"];null!==a;)Q(a),a=a["return"];S=null;na=0;K=null;ka=!1}function c(a){return null!==O&&O.has(a)}function d(a){for(;;){var b=a.alternate,c=a["return"],d=a.sibling;if(0===(a.effectTag&512)){b=J(b,a,na);var e=a;if(1073741823===
na||1073741823!==e.expirationTime){b:switch(e.tag){case 3:case 2:var f=e.updateQueue;f=null===f?0:f.expirationTime;break b;default:f=0}for(var g=e.child;null!==g;)0!==g.expirationTime&&(0===f||f>g.expirationTime)&&(f=g.expirationTime),g=g.sibling;e.expirationTime=f}if(null!==b)return b;null!==c&&0===(c.effectTag&512)&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==
c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));if(null!==d)return d;if(null!==c)a=c;else{ka=!0;break}}else{a=P(a);if(null!==a)return a.effectTag&=2559,a;null!==c&&(c.firstEffect=c.lastEffect=null,c.effectTag|=512);if(null!==d)return d;if(null!==c)a=c;else break}}return null}function e(a){var b=E(a.alternate,a,na);null===b&&(b=d(a));tc.current=null;return b}function f(a,c,f){ta?l("243"):void 0;ta=!0;if(c!==na||a!==S||null===K)b(),S=a,na=c,K=nb(S.current,null,na),a.pendingCommitExpirationTime=
0;var g=!1;do{try{if(f)for(;null!==K&&!F();)K=e(K);else for(;null!==K;)K=e(K)}catch(zc){if(null===K){g=!0;H(zc);break}f=K;var h=f["return"];if(null===h){g=!0;H(zc);break}M(h,f,zc);K=d(f)}break}while(1);ta=!1;if(g||null!==K)return null;if(ka)return a.pendingCommitExpirationTime=c,a.current.alternate;l("262")}function g(a,b,c,d){a={value:c,source:a,stack:Qb(a)};Oa(b,{expirationTime:d,partialState:null,callback:null,isReplace:!1,isForced:!1,capturedValue:a,next:null});D(b,d)}function h(a,b){a:{ta&&!T?
l("263"):void 0;for(var d=a["return"];null!==d;){switch(d.tag){case 2:var e=d.stateNode;if("function"===typeof d.type.getDerivedStateFromCatch||"function"===typeof e.componentDidCatch&&!c(e)){g(a,d,b,1);a=void 0;break a}break;case 3:g(a,d,b,1);a=void 0;break a}d=d["return"]}3===a.tag&&g(a,a,b,1);a=void 0}return a}function k(a){a=0!==Ba?Ba:ta?T?1:na:a.mode&1?Fa?10*(((m()+15)/10|0)+1):25*(((m()+500)/25|0)+1):1;Fa&&(0===ua||a>ua)&&(ua=a);return a}function D(a,c){a:{for(;null!==a;){if(0===a.expirationTime||
a.expirationTime>c)a.expirationTime=c;null!==a.alternate&&(0===a.alternate.expirationTime||a.alternate.expirationTime>c)&&(a.alternate.expirationTime=c);if(null===a["return"])if(3===a.tag){var d=a.stateNode;!ta&&0!==na&&c<na&&b();ta&&!T&&S===d||y(d,c);ha>Ca&&l("185")}else{c=void 0;break a}a=a["return"]}c=void 0}return c}function m(){ra=ba()-ia;return za=(ra/10|0)+2}function w(a,b,c,d,e){var f=Ba;Ba=1;try{return a(b,c,d,e)}finally{Ba=f}}function p(a){if(0!==Z){if(a>Z)return;wa(ma)}var b=ba()-ia;Z=
a;ma=va(C,{timeout:10*(a-2)-b})}function y(a,b){if(null===a.nextScheduledRoot)a.remainingExpirationTime=b,null===N?(Ea=N=a,a.nextScheduledRoot=a):(N=N.nextScheduledRoot=a,N.nextScheduledRoot=Ea);else{var c=a.remainingExpirationTime;if(0===c||b<c)a.remainingExpirationTime=b}da||(L?fa&&(oa=a,W=1,A(a,1,!1)):1===b?x():p(b))}function v(){var a=0,b=null;if(null!==N)for(var c=N,d=Ea;null!==d;){var e=d.remainingExpirationTime;if(0===e){null===c||null===N?l("244"):void 0;if(d===d.nextScheduledRoot){Ea=N=d.nextScheduledRoot=
null;break}else if(d===Ea)Ea=e=d.nextScheduledRoot,N.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===N){N=c;N.nextScheduledRoot=Ea;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot}else{if(0===a||e<a)a=e,b=d;if(d===N)break;c=d;d=d.nextScheduledRoot}}c=oa;null!==c&&c===b&&1===a?ha++:ha=0;oa=b;W=a}function C(a){t(0,!0,a)}function x(){t(1,!1,null)}function t(a,b,c){X=c;v();if(b)for(;null!==oa&&0!==W&&(0===a||a>=W)&&(!aa||
m()>=W);)A(oa,W,!aa),v();else for(;null!==oa&&0!==W&&(0===a||a>=W);)A(oa,W,!1),v();null!==X&&(Z=0,ma=-1);0!==W&&p(W);X=null;aa=!1;z()}function z(){ha=0;if(null!==Ga){var a=Ga;Ga=null;for(var b=0;b<a.length;b++){var c=a[b];try{c._onComplete()}catch(Zf){Ha||(Ha=!0,ea=Zf)}}}if(Ha)throw a=ea,ea=null,Ha=!1,a;}function A(a,b,c){da?l("245"):void 0;da=!0;c?(c=a.finishedWork,null!==c?B(a,c,b):(a.finishedWork=null,c=f(a,b,!0),null!==c&&(F()?a.finishedWork=c:B(a,c,b)))):(c=a.finishedWork,null!==c?B(a,c,b):(a.finishedWork=
null,c=f(a,b,!1),null!==c&&B(a,c,b)));da=!1}function B(a,b,c){var d=a.firstBatch;if(null!==d&&d._expirationTime<=c&&(null===Ga?Ga=[d]:Ga.push(d),d._defer)){a.finishedWork=b;a.remainingExpirationTime=0;return}a.finishedWork=null;T=ta=!0;c=b.stateNode;c.current===b?l("177"):void 0;d=c.pendingCommitExpirationTime;0===d?l("261"):void 0;c.pendingCommitExpirationTime=0;var e=m();tc.current=null;if(1<b.effectTag)if(null!==b.lastEffect){b.lastEffect.nextEffect=b;var f=b.firstEffect}else f=b;else f=b.firstEffect;
xa(c.containerInfo);for(u=f;null!==u;){var g=!1,k=void 0;try{for(;null!==u;)u.effectTag&2048&&R(u.alternate,u),u=u.nextEffect}catch(Xa){g=!0,k=Xa}g&&(null===u?l("178"):void 0,h(u,k),null!==u&&(u=u.nextEffect))}for(u=f;null!==u;){g=!1;k=void 0;try{for(;null!==u;){var n=u.effectTag;n&16&&V(u);if(n&128){var p=u.alternate;null!==p&&sa(p)}switch(n&14){case 2:U(u);u.effectTag&=-3;break;case 6:U(u);u.effectTag&=-3;Y(u.alternate,u);break;case 4:Y(u.alternate,u);break;case 8:ca(u)}u=u.nextEffect}}catch(Xa){g=
!0,k=Xa}g&&(null===u?l("178"):void 0,h(u,k),null!==u&&(u=u.nextEffect))}ya(c.containerInfo);c.current=b;for(u=f;null!==u;){n=!1;p=void 0;try{for(f=c,g=e,k=d;null!==u;){var w=u.effectTag;w&36&&la(f,u.alternate,u,g,k);w&256&&pa(u,H);w&128&&qa(u);var q=u.nextEffect;u.nextEffect=null;u=q}}catch(Xa){n=!0,p=Xa}n&&(null===u?l("178"):void 0,h(u,p),null!==u&&(u=u.nextEffect))}ta=T=!1;"function"===typeof Od&&Od(b.stateNode);b=c.current.expirationTime;0===b&&(O=null);a.remainingExpirationTime=b}function F(){return null===
X||X.timeRemaining()>Da?!1:aa=!0}function H(a){null===oa?l("246"):void 0;oa.remainingExpirationTime=0;Ha||(Ha=!0,ea=a)}var r=Yf(),q=Uf(a,r),n=Wf(r);r=Xf(r);var I=Vf(a),E=Qf(a,q,n,r,I,D,k).beginWork,J=Rf(a,q,n,r,I).completeWork;q=Sf(q,n,r,D,c);var M=q.throwException,P=q.unwindWork,Q=q.unwindInterruptedWork;q=Tf(a,h,D,k,function(a){null===O?O=new Set([a]):O.add(a)},m);var R=q.commitBeforeMutationLifeCycles,V=q.commitResetTextContent,U=q.commitPlacement,ca=q.commitDeletion,Y=q.commitWork,la=q.commitLifeCycles,
pa=q.commitErrorLogging,qa=q.commitAttachRef,sa=q.commitDetachRef,ba=a.now,va=a.scheduleDeferredCallback,wa=a.cancelDeferredCallback,xa=a.prepareForCommit,ya=a.resetAfterCommit,ia=ba(),za=2,ra=ia,ja=0,Ba=0,ta=!1,K=null,S=null,na=0,u=null,T=!1,ka=!1,O=null,Ea=null,N=null,Z=0,ma=-1,da=!1,oa=null,W=0,ua=0,aa=!1,Ha=!1,ea=null,X=null,L=!1,fa=!1,Fa=!1,Ga=null,Ca=1E3,ha=0,Da=1;return{recalculateCurrentTime:m,computeExpirationForFiber:k,scheduleWork:D,requestWork:y,flushRoot:function(a,b){da?l("253"):void 0;
oa=a;W=b;A(a,b,!1);x();z()},batchedUpdates:function(a,b){var c=L;L=!0;try{return a(b)}finally{(L=c)||da||x()}},unbatchedUpdates:function(a,b){if(L&&!fa){fa=!0;try{return a(b)}finally{fa=!1}}return a(b)},flushSync:function(a,b){da?l("187"):void 0;var c=L;L=!0;try{return w(a,b)}finally{L=c,x()}},flushControlled:function(a){var b=L;L=!0;try{w(a)}finally{(L=b)||da||t(1,!1,null)}},deferredUpdates:function(a){var b=Ba;Ba=25*(((m()+500)/25|0)+1);try{return a()}finally{Ba=b}},syncUpdates:w,interactiveUpdates:function(a,
b,c){if(Fa)return a(b,c);L||da||0===ua||(t(ua,!1,null),ua=0);var d=Fa,e=L;L=Fa=!0;try{return a(b,c)}finally{Fa=d,(L=e)||da||x()}},flushInteractiveUpdates:function(){da||0===ua||(t(ua,!1,null),ua=0)},computeUniqueAsyncExpiration:function(){var a=25*(((m()+500)/25|0)+1);a<=ja&&(a=ja+1);return ja=a},legacyContext:n}},se=function(a){function b(a,b,c,d,e,g){d=b.current;if(c){c=c._reactInternalFiber;var m=h(c);c=k(c)?y(c,m):m}else c=la;null===b.context?b.context=c:b.pendingContext=c;b=g;Oa(d,{expirationTime:e,
partialState:{element:a},callback:void 0===b?null:b,isReplace:!1,isForced:!1,capturedValue:null,next:null});f(d,e);return e}var c=a.getPublicInstance;a=$f(a);var d=a.recalculateCurrentTime,e=a.computeExpirationForFiber,f=a.scheduleWork,g=a.legacyContext,h=g.findCurrentUnmaskedContext,k=g.isContextProvider,y=g.processChildContext;return{createContainer:function(a,b,c){b=new sa(3,null,null,b?3:0);a={current:b,containerInfo:a,pendingChildren:null,pendingCommitExpirationTime:0,finishedWork:null,context:null,
pendingContext:null,hydrate:c,remainingExpirationTime:0,firstBatch:null,nextScheduledRoot:null};return b.stateNode=a},updateContainer:function(a,c,f,g){var h=c.current,k=d();h=e(h);return b(a,c,f,k,h,g)},updateContainerAtExpirationTime:function(a,c,e,f,g){var h=d();return b(a,c,e,h,f,g)},flushRoot:a.flushRoot,requestWork:a.requestWork,computeUniqueAsyncExpiration:a.computeUniqueAsyncExpiration,batchedUpdates:a.batchedUpdates,unbatchedUpdates:a.unbatchedUpdates,deferredUpdates:a.deferredUpdates,syncUpdates:a.syncUpdates,
interactiveUpdates:a.interactiveUpdates,flushInteractiveUpdates:a.flushInteractiveUpdates,flushControlled:a.flushControlled,flushSync:a.flushSync,getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return c(a.child.stateNode);default:return a.child.stateNode}},findHostInstance:function(a){var b=a._reactInternalFiber;void 0===b&&("function"===typeof a.render?l("188"):l("268",Object.keys(a)));a=yd(b);return null===a?null:a.stateNode},findHostInstanceWithNoPortals:function(a){a=
Ze(a);return null===a?null:a.stateNode},injectIntoDevTools:function(a){var b=a.findFiberByHostInstance;return ff(A({},a,{findHostInstanceByFiber:function(a){a=yd(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null}}))}}},te=Object.freeze({default:se}),Ac=te&&se||te,ag=Ac["default"]?Ac["default"]:Ac,ue="object"===typeof performance&&"function"===typeof performance.now,yb=void 0;yb=ue?function(){return performance.now()}:function(){return Date.now()};var zb=void 0,
Ab=void 0;if(R.canUseDOM)if("function"!==typeof requestIdleCallback||"function"!==typeof cancelIdleCallback){var Bb=null,Cb=!1,Ya=-1,Za=!1,$a=0,Db=33,ab=33,Eb=void 0;Eb=ue?{didTimeout:!1,timeRemaining:function(){var a=$a-performance.now();return 0<a?a:0}}:{didTimeout:!1,timeRemaining:function(){var a=$a-Date.now();return 0<a?a:0}};var ve="__reactIdleCallback$"+Math.random().toString(36).slice(2);window.addEventListener("message",function(a){if(a.source===window&&a.data===ve){Cb=!1;a=yb();if(0>=$a-
a)if(-1!==Ya&&Ya<=a)Eb.didTimeout=!0;else{Za||(Za=!0,requestAnimationFrame(we));return}else Eb.didTimeout=!1;Ya=-1;a=Bb;Bb=null;null!==a&&a(Eb)}},!1);var we=function(a){Za=!1;var b=a-$a+ab;b<ab&&Db<ab?(8>b&&(b=8),ab=b<Db?Db:b):Db=b;$a=a+ab;Cb||(Cb=!0,window.postMessage(ve,"*"))};zb=function(a,b){Bb=a;null!=b&&"number"===typeof b.timeout&&(Ya=yb()+b.timeout);Za||(Za=!0,requestAnimationFrame(we));return 0};Ab=function(){Bb=null;Cb=!1;Ya=-1}}else zb=window.requestIdleCallback,Ab=window.cancelIdleCallback;
else zb=function(a){return setTimeout(function(){a({timeRemaining:function(){return Infinity},didTimeout:!1})})},Ab=function(a){clearTimeout(a)};var Fb=void 0,de=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{Fb=Fb||document.createElement("div");Fb.innerHTML="\x3csvg\x3e"+b+"\x3c/svg\x3e";
for(b=Fb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),ub=function(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},Qa={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,
gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},bg=["Webkit","ms","Moz","O"];Object.keys(Qa).forEach(function(a){bg.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Qa[b]=Qa[a]})});var kf=A({menuitem:!0},
{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),Ra=M.thatReturns(""),cg=Object.freeze({createElement:ae,createTextNode:be,setInitialProperties:ce,diffProperties:ee,updateProperties:fe,diffHydratedProperties:ge,diffHydratedText:he,warnForUnmatchedText:function(a,b){},warnForDeletedHydratableElement:function(a,b){},warnForDeletedHydratableText:function(a,b){},warnForInsertedHydratedElement:function(a,b,c){},warnForInsertedHydratedText:function(a,
b){},restoreControlledState:function(a,b,c){switch(b){case "input":Ub(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name\x3d"+JSON.stringify(""+b)+'][type\x3d"radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Lc(d);e?void 0:l("90");hd(d);Ub(d,e)}}}break;case "textarea":Xd(a,c);break;case "select":b=c.value,null!=b&&O(a,!!c.multiple,b,!1)}}});oe.injectFiberControlledHostComponent(cg);var Bc=null,Cc=null;Sa.prototype.render=
function(a){this._defer?void 0:l("250");this._hasChildren=!0;this._children=a;var b=this._root._internalRoot,c=this._expirationTime,d=new ma;B.updateContainerAtExpirationTime(a,b,null,c,d._onCommit);return d};Sa.prototype.then=function(a){if(this._didComplete)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a)}};Sa.prototype.commit=function(){var a=this._root._internalRoot,b=a.firstBatch;this._defer&&null!==b?void 0:l("251");if(this._hasChildren){var c=this._expirationTime;if(b!==
this){this._hasChildren&&(c=this._expirationTime=b._expirationTime,this.render(this._children));for(var d=null,e=b;e!==this;)d=e,e=e._next;null===d?l("251"):void 0;d._next=e._next;this._next=b;a.firstBatch=this}this._defer=!1;B.flushRoot(a,c);b=this._next;this._next=null;b=a.firstBatch=b;null!==b&&b._hasChildren&&b.render(b._children)}else this._next=null,this._defer=!1};Sa.prototype._onComplete=function(){if(!this._didComplete){this._didComplete=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<
a.length;b++)(0,a[b])()}};ma.prototype.then=function(a){if(this._didCommit)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a)}};ma.prototype._onCommit=function(){if(!this._didCommit){this._didCommit=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<a.length;b++){var c=a[b];"function"!==typeof c?l("191",c):void 0;c()}}};aa.prototype.render=function(a,b){var c=this._internalRoot,d=new ma;b=void 0===b?null:b;null!==b&&d.then(b);B.updateContainer(a,c,null,d._onCommit);return d};
aa.prototype.unmount=function(a){var b=this._internalRoot,c=new ma;a=void 0===a?null:a;null!==a&&c.then(a);B.updateContainer(null,b,null,c._onCommit);return c};aa.prototype.legacy_renderSubtreeIntoContainer=function(a,b,c){var d=this._internalRoot,e=new ma;c=void 0===c?null:c;null!==c&&e.then(c);B.updateContainer(b,d,a,e._onCommit);return e};aa.prototype.createBatch=function(){var a=new Sa(this),b=a._expirationTime,c=this._internalRoot,d=c.firstBatch;if(null===d)c.firstBatch=a,a._next=null;else{for(c=
null;null!==d&&d._expirationTime<=b;)c=d,d=d._next;a._next=d;null!==c&&(c._next=a)}return a};var B=ag({getRootHostContext:function(a){var b=a.nodeType;switch(b){case 9:case 11:a=(a=a.documentElement)?a.namespaceURI:oc(null,"");break;default:b=8===b?a.parentNode:a,a=b.namespaceURI||null,b=b.tagName,a=oc(a,b)}return a},getChildHostContext:function(a,b){return oc(a,b)},getPublicInstance:function(a){return a},prepareForCommit:function(){Bc=Ma;var a=bc();if($b(a)){if("selectionStart"in a)var b={start:a.selectionStart,
end:a.selectionEnd};else a:{var c=window.getSelection&&window.getSelection();if(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType}catch(G){b=null;break a}var f=0,g=-1,h=-1,k=0,l=0,m=a,w=null;b:for(;;){for(var p;;){m!==b||0!==d&&3!==m.nodeType||(g=f+d);m!==e||0!==c&&3!==m.nodeType||(h=f+c);3===m.nodeType&&(f+=m.nodeValue.length);if(null===(p=m.firstChild))break;w=m;m=p}for(;;){if(m===a)break b;w===b&&++k===d&&(g=f);w===e&&++l===c&&(h=f);
if(null!==(p=m.nextSibling))break;m=w;w=m.parentNode}m=p}b=-1===g||-1===h?null:{start:g,end:h}}else b=null}b=b||{start:0,end:0}}else b=null;Cc={focusedElem:a,selectionRange:b};Yb(!1)},resetAfterCommit:function(){var a=Cc,b=bc(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&Hd(document.documentElement,c)){if($b(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(window.getSelection){b=window.getSelection();var e=c[Pc()].length;
a=Math.min(d.start,e);d=void 0===d.end?a:Math.min(d.end,e);!b.extend&&a>d&&(e=d,d=a,a=e);e=Kd(c,a);var f=Kd(c,d);if(e&&f&&(1!==b.rangeCount||b.anchorNode!==e.node||b.anchorOffset!==e.offset||b.focusNode!==f.node||b.focusOffset!==f.offset)){var g=document.createRange();g.setStart(e.node,e.offset);b.removeAllRanges();a>d?(b.addRange(g),b.extend(f.node,f.offset)):(g.setEnd(f.node,f.offset),b.addRange(g))}}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});
c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}Cc=null;Yb(Bc);Bc=null},createInstance:function(a,b,c,d,e){a=ae(a,b,c,d);a[P]=e;a[ha]=b;return a},appendInitialChild:function(a,b){a.appendChild(b)},finalizeInitialChildren:function(a,b,c,d){ce(a,b,c,d);return ie(b,c)},prepareUpdate:function(a,b,c,d,e,f){return ee(a,b,c,d,e)},shouldSetTextContent:function(a,b){return"textarea"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&"string"===typeof b.dangerouslySetInnerHTML.__html},shouldDeprioritizeSubtree:function(a,b){return!!b.hidden},createTextInstance:function(a,b,c,d){a=be(a,b);a[P]=d;return a},now:yb,mutation:{commitMount:function(a,b,c,d){ie(b,c)&&a.focus()},commitUpdate:function(a,b,c,d,e,f){a[ha]=e;fe(a,b,c,d,e)},resetTextContent:function(a){ub(a,"")},commitTextUpdate:function(a,b,c){a.nodeValue=c},appendChild:function(a,b){a.appendChild(b)},appendChildToContainer:function(a,b){8===
a.nodeType?a.parentNode.insertBefore(b,a):a.appendChild(b)},insertBefore:function(a,b,c){a.insertBefore(b,c)},insertInContainerBefore:function(a,b,c){8===a.nodeType?a.parentNode.insertBefore(b,c):a.insertBefore(b,c)},removeChild:function(a,b){a.removeChild(b)},removeChildFromContainer:function(a,b){8===a.nodeType?a.parentNode.removeChild(b):a.removeChild(b)}},hydration:{canHydrateInstance:function(a,b,c){return 1!==a.nodeType||b.toLowerCase()!==a.nodeName.toLowerCase()?null:a},canHydrateTextInstance:function(a,
b){return""===b||3!==a.nodeType?null:a},getNextHydratableSibling:function(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},getFirstHydratableChild:function(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},hydrateInstance:function(a,b,c,d,e,f){a[P]=f;a[ha]=c;return ge(a,b,c,e,d)},hydrateTextInstance:function(a,b,c){a[P]=c;return he(a,b)},didNotMatchHydratedContainerTextInstance:function(a,b,c){},didNotMatchHydratedTextInstance:function(a,
b,c,d,e){},didNotHydrateContainerInstance:function(a,b){},didNotHydrateInstance:function(a,b,c,d){},didNotFindHydratableContainerInstance:function(a,b,c){},didNotFindHydratableContainerTextInstance:function(a,b){},didNotFindHydratableInstance:function(a,b,c,d,e){},didNotFindHydratableTextInstance:function(a,b,c,d){}},scheduleDeferredCallback:zb,cancelDeferredCallback:Ab});(function(a){dd=a.batchedUpdates;Dd=a.interactiveUpdates;ed=a.flushInteractiveUpdates})(B);var xe={createPortal:je,findDOMNode:function(a){return null==
a?null:1===a.nodeType?a:B.findHostInstance(a)},hydrate:function(a,b,c){return vb(null,a,b,!0,c)},render:function(a,b,c){return vb(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null==a||void 0===a._reactInternalFiber?l("38"):void 0;return vb(a,b,c,!1,d)},unmountComponentAtNode:function(a){rc(a)?void 0:l("40");return a._reactRootContainer?(B.unbatchedUpdates(function(){vb(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:function(){return je.apply(void 0,
arguments)},unstable_batchedUpdates:B.batchedUpdates,unstable_deferredUpdates:B.deferredUpdates,flushSync:B.flushSync,unstable_flushControlled:B.flushControlled,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{EventPluginHub:pf,EventPluginRegistry:of,EventPropagators:qf,ReactControlledComponent:wf,ReactDOMComponentTree:me,ReactDOMEventListener:Kf},unstable_createRoot:function(a,b){return new aa(a,!0,null!=b&&!0===b.hydrate)}};B.injectIntoDevTools({findFiberByHostInstance:Ca,bundleType:0,version:"16.3.2",
rendererPackageName:"react-dom"});var ye=Object.freeze({default:xe}),Dc=ye&&xe||ye;return Dc["default"]?Dc["default"]:Dc});

(function(q,m){"function"===typeof define&&define.amd?define([],m):"object"===typeof module&&module.exports?module.exports=m():q.parinfer=m()})(this,function(){function q(a){return"number"===typeof a&&isFinite(a)&&Math.floor(a)===a}function m(a){a=a||{};return{cursorX:a.cursorX,cursorLine:a.cursorLine,prevCursorX:a.prevCursorX,prevCursorLine:a.prevCursorLine,selectionStartLine:a.selectionStartLine,changes:a.changes,partialResult:a.partialResult,forceBalance:a.forceBalance,returnParens:a.returnParens}}
function M(){return{lineNo:-999,startX:-999,endX:-999,openers:[],clamped:{startX:-999,endX:-999,openers:[]}}}function p(a,c){var b={lineNo:a.lineNo,x:a.x,inputLineNo:a.inputLineNo,inputX:a.inputX};return a.errorPosCache[c]=b}function n(a,c){var b=a.errorPosCache[c],e=a.partialResult?"lineNo":"inputLineNo",d=a.partialResult?"x":"inputX",f={parinferError:!0,name:c,message:F[c],lineNo:b?b[e]:a[e],x:b?b[d]:a[d]},h=k(a.parenStack,0);if("unmatched-close-paren"===c){if((b=a.errorPosCache["unmatched-open-paren"])||
h)f.extra={name:"unmatched-open-paren",lineNo:b?b[e]:h[e],x:b?b[d]:h[d]}}else"unclosed-paren"===c&&(f.lineNo=h[e],f.x=h[d]);return f}function w(a,c,b,e,d){var f;f=a.lines[c];f=f.substring(0,b)+d+f.substring(e);a.lines[c]=f;d=d.length-(e-b);0!==d&&a.cursorLine===c&&-999!==a.cursorX&&(a.cursorX===b&&a.cursorX===e?0===a.cursorX:a.cursorX>=e)&&(a.cursorX+=d)}function k(a,c){var b=a.length-1;return c>b?null:a[b-c]}function x(a){return"}"===a||")"===a||"]"===a}function y(a,c){return 0===a.length?!1:k(a,
0).ch===z[c]}function A(a){var c=a.ch;return!a.isEscaped&&(" "===c||"  "===c)}function u(a,c,b){a.parenTrail.lineNo=c;a.parenTrail.startX=b;a.parenTrail.endX=b;a.parenTrail.openers=[];a.parenTrail.clamped.startX=-999;a.parenTrail.clamped.endX=-999;a.parenTrail.clamped.openers=[]}function B(a,c){var b;for(b=0;b<a.parenStack.length;b++){var e=k(a.parenStack,b);if(e.x-e.indentDelta<c)break;if(e.x<c){var d=k(a.parenStack,b+1);if(!d||d.indentDelta!==e.indentDelta){e.indentDelta=0;break}}}return b}function N(a,
c){if(c){var b=k(a.parenStack,0);b?b.maxChildIndent=c.x:a.maxIndent=c.x}}function G(a){var c=a.parenTrail,b=c.clamped.openers.concat(c.openers);if(0<b.length&&(c={lineNo:c.lineNo,startX:-999!==c.clamped.startX?c.clamped.startX:c.startX,endX:0===c.openers.length?c.clamped.endX:c.endX},a.parenTrails.push(c),a.returnParens))for(a=0;a<b.length;a++)b[a].closer.trail=c}function v(a,c){var b=a.x,e=b+c,d,f="";for(d=0;d<e;d++)f+=" ";w(a,a.lineNo,0,b,f);a.x=e;a.indentX=e;a.indentDelta+=c}function H(a){a.indentX=
a.x;a.trackingIndent=!1;if(a.quoteDanger)throw n(a,"quote-danger");if("INDENT_MODE"===a.mode){var c="",b=B(a,a.x),e;for(e=0;e<b;e++){var d=a.parenStack.pop();a.parenTrail.openers.push(d);var f=z[d.ch],c=c+f;if(a.returnParens){var h=a.parenTrail.startX+e;d.closer.lineNo=a.parenTrail.lineNo;d.closer.x=h;d.closer.ch=f}}-999!==a.parenTrail.lineNo&&(w(a,a.parenTrail.lineNo,a.parenTrail.startX,a.parenTrail.endX,c),a.parenTrail.endX=a.parenTrail.startX+c.length,G(a));(c=k(a.parenStack,0))&&c.indentDelta!==
a.indentDelta&&v(a,c.indentDelta)}else if("PAREN_MODE"===a.mode){f=c=a.x;b=0;e=a.maxIndent;if(d=k(a.parenStack,0))b=d.x+1,e=d.maxChildIndent,d.indentDelta!==a.indentDelta&&(f+=d.indentDelta);-999!==b&&(f=Math.max(b,f));-999!==e&&(f=Math.min(e,f));f!==c&&v(a,f-c)}}function O(a,c){var b={ch:c.ch,x:c.x,lineNo:c.lineNo};null!=c.argX&&(b.argX=c.argX);return b}function P(a,c){a.ch=c;a.skipChar=!1;if(a.changes&&(a.smart||"PAREN_MODE"===a.mode)){var b=a.changes[a.inputLineNo];b&&(b=b[a.inputX])&&(a.indentDelta+=
b.newEndX-b.oldEndX)}if(a.trackingIndent)if(x(a.ch)){if("INDENT_MODE"===a.mode){if(!a.forceBalance){if(a.smart)throw{leadingCloseParen:!0};a.errorPosCache["leading-close-paren"]||p(a,"leading-close-paren")}a.skipChar=!0}if("PAREN_MODE"===a.mode)if(y(a.parenStack,a.ch)){var b=a.cursorX,e=a.x;if(a.cursorLine===a.lineNo&&-999!==e&&-999!==b&&b<=e)u(a,a.lineNo,a.x),H(a);else{b=a.parenStack.pop();e=z[b.ch];if(a.returnParens){var d=a.parenTrail.endX;b.closer.lineNo=a.parenTrail.lineNo;b.closer.x=d;b.closer.ch=
e}N(a,b);d=a.parenTrail.endX;w(a,a.parenTrail.lineNo,d,d,e);a.parenTrail.endX++;a.parenTrail.openers.push(b);(b=a.parenTrails[a.parenTrails.length-1])&&b.lineNo===a.parenTrail.lineNo?(b.endX=a.parenTrail.endX,a.returnParens&&(a.parenTrail.openers[a.parenTrail.openers.length-1].closer.trail=b)):G(a);a.skipChar=!0}}else if(a.smart)a.skipChar=!0;else throw n(a,"unmatched-close-paren");}else if(";"===a.ch){b=a.parenTrail.openers.length;if("PAREN_MODE"===a.mode)for(e=0;e<b;e++)a.parenStack.push(k(a.parenTrail.openers,
e));e=B(a,a.x);(e=k(a.parenStack,e))&&e.indentDelta!==a.indentDelta&&v(a,e.indentDelta);if("PAREN_MODE"===a.mode)for(e=0;e<b;e++)a.parenStack.pop();a.trackingIndent=!1}else"\n"!==a.ch&&" "!==a.ch&&"\t"!==a.ch&&H(a);if(a.skipChar)a.ch="";else{b=a.ch;a.isEscaped=!1;if(a.isEscaping){if(a.isEscaping=!1,a.isEscaped=!0,"\n"===a.ch){if(a.isInCode)throw n(a,"eol-backslash");a.isInComment=!1;a.ch=""}}else if("{"===b||"("===b||"["===b)a.isInCode&&(b={inputLineNo:a.inputLineNo,inputX:a.inputX,lineNo:a.lineNo,
x:a.x,ch:a.ch,indentDelta:a.indentDelta,maxChildIndent:-999},a.returnParens&&(b.children=[],b.closer={lineNo:-999,x:-999,ch:""},e=(e=k(a.parenStack,0))?e.children:a.parens,e.push(b)),a.parenStack.push(b),a.trackingArgTabStop="space");else if(x(b)){if(a.isInCode)if(y(a.parenStack,a.ch)){b=k(a.parenStack,0);a.returnParens&&(e=a.x,d=a.ch,b.closer.lineNo=a.lineNo,b.closer.x=e,b.closer.ch=d);a.parenTrail.endX=a.x+1;a.parenTrail.openers.push(b);if(b="INDENT_MODE"===a.mode&&a.smart){var b=k(a.parenStack,
0),e=(e=k(a.parenStack,1))?e.x+1:0,d=b.x,f=a.cursorLine===b.lineNo&&e<=a.cursorX&&a.cursorX<=d;if(!a.changes&&-999!==a.prevCursorLine&&a.prevCursorLine===b.lineNo&&e<=a.prevCursorX&&a.prevCursorX<=d&&!f)throw{releaseCursorHold:!0};b=f}b&&(b=a.parenTrail.startX,e=a.parenTrail.endX,d=a.parenTrail.openers,u(a,a.lineNo,a.x+1),a.parenTrail.clamped.startX=b,a.parenTrail.clamped.endX=e,a.parenTrail.clamped.openers=d);a.parenStack.pop();a.trackingArgTabStop=null}else{if("PAREN_MODE"===a.mode){if(b=a.parenTrail,
b=b.lineNo===a.lineNo&&b.startX===a.indentX,!a.smart||!b)throw n(a,"unmatched-close-paren");}else"INDENT_MODE"===a.mode&&!a.errorPosCache["unmatched-close-paren"]&&(p(a,"unmatched-close-paren"),b=k(a.parenStack,0))&&(e=p(a,"unmatched-open-paren"),e.inputLineNo=b.inputLineNo,e.inputX=b.inputX);a.ch=""}}else'"'===b?a.isInStr?a.isInStr=!1:a.isInComment?(a.quoteDanger=!a.quoteDanger,a.quoteDanger&&p(a,"quote-danger")):(a.isInStr=!0,p(a,"unclosed-quote")):";"===b?a.isInCode&&(a.isInComment=!0,a.commentX=
a.x,a.trackingArgTabStop=null):"\\"===b?a.isEscaping=!0:"\t"===b?a.isInCode&&(a.ch="  "):"\n"===b&&(a.isInComment=!1,a.ch="");b=a.ch;a.isInCode=!a.isInComment&&!a.isInStr;e=a.ch;d=x(e)&&!a.isEscaped;a.isInCode&&!A(a)&&""!==e&&!d&&u(a,a.lineNo,a.x+b.length);if(b=a.trackingArgTabStop)"space"===b?a.isInCode&&A(a)&&(a.trackingArgTabStop="arg"):"arg"!==b||A(a)||(k(a.parenStack,0).argX=a.x,a.trackingArgTabStop=null)}b=a.ch;c!==b&&(w(a,a.lineNo,a.x,a.x+c.length,b),a.indentDelta-=c.length-b.length);a.x+=
b.length}function D(a,c,b,e){b={mode:b,smart:e,origText:a,origCursorX:-999,origCursorLine:-999,inputLines:a.split(I),inputLineNo:-1,inputX:-1,lines:[],lineNo:-1,ch:"",x:0,indentX:-999,parenStack:[],tabStops:[],parenTrail:M(),parenTrails:[],returnParens:!1,parens:[],cursorX:-999,cursorLine:-999,prevCursorX:-999,prevCursorLine:-999,selectionStartLine:-999,changes:null,isInCode:!0,isEscaping:!1,isEscaped:!1,isInStr:!1,isInComment:!1,commentX:-999,quoteDanger:!1,trackingIndent:!1,skipChar:!1,success:!1,
partialResult:!1,forceBalance:!1,maxIndent:-999,indentDelta:0,trackingArgTabStop:null,error:{name:null,message:null,lineNo:null,x:null,extra:{name:null,lineNo:null,x:null}},errorPosCache:{}};if(c){q(c.cursorX)&&(b.cursorX=c.cursorX,b.origCursorX=c.cursorX);q(c.cursorLine)&&(b.cursorLine=c.cursorLine,b.origCursorLine=c.cursorLine);q(c.prevCursorX)&&(b.prevCursorX=c.prevCursorX);q(c.prevCursorLine)&&(b.prevCursorLine=c.prevCursorLine);q(c.selectionStartLine)&&(b.selectionStartLine=c.selectionStartLine);
if(Array.isArray(c.changes)){var d;d=c.changes;if(0===d.length)d=null;else{var f={},h,g,l;for(g=0;g<d.length;g++){if(h=d[g]){var m=h.newText.split(I);l=h.oldText.split(I);var p=(1===m.length?h.x:0)+m[m.length-1].length,m=h.lineNo+(m.length-1);l={x:h.x,lineNo:h.lineNo,oldText:h.oldText,newText:h.newText,oldEndX:(1===l.length?h.x:0)+l[l.length-1].length,newEndX:p,newEndLineNo:m,lookupLineNo:m,lookupX:p}}else l=void 0;(h=f[l.lookupLineNo])||(h=f[l.lookupLineNo]={});h[l.lookupX]=l}d=f}b.changes=d}"boolean"===
typeof c.partialResult&&(b.partialResult=c.partialResult);"boolean"===typeof c.forceBalance&&(b.forceBalance=c.forceBalance);"boolean"===typeof c.returnParens&&(b.returnParens=c.returnParens)}try{var C;for(C=0;C<b.inputLines.length;C++){b.inputLineNo=C;d=b;f=C;g=d;var z=d.inputLines[f];g.x=0;g.lineNo++;g.lines.push(z);g.indentX=-999;g.commentX=-999;g.indentDelta=0;delete g.errorPosCache["unmatched-close-paren"];delete g.errorPosCache["unmatched-open-paren"];delete g.errorPosCache["leading-close-paren"];
g.trackingArgTabStop=null;g.trackingIndent=!g.isInStr;g=d;if((-999!==g.selectionStartLine?g.selectionStartLine:g.cursorLine)===g.lineNo){h=void 0;for(h=0;h<g.parenStack.length;h++)g.tabStops.push(O(g,g.parenStack[h]));if("PAREN_MODE"===g.mode)for(h=g.parenTrail.openers.length-1;0<=h;h--)g.tabStops.push(O(g,g.parenTrail.openers[h]));for(h=1;h<g.tabStops.length;h++){var A=g.tabStops[h].x,u=g.tabStops[h-1].argX;null!=u&&u>=A&&delete g.tabStops[h-1].argX}}g=void 0;for(g=0;g<d.inputLines[f].length;g++)d.inputX=
g,P(d,d.inputLines[f][g]);P(d,"\n");if(!d.forceBalance){var v=d.errorPosCache["unmatched-close-paren"];if(v&&v.x<d.parenTrail.startX)throw n(d,"unmatched-close-paren");if(d.errorPosCache["leading-close-paren"]&&d.parenTrail.lineNo===d.lineNo)throw n(d,"leading-close-paren");}if(d.lineNo===d.parenTrail.lineNo)if(d.isInStr)d.parenTrail=M();else if("INDENT_MODE"===d.mode){var f=d,t=f.parenTrail.startX,y=f.parenTrail.endX;g=f;var E=f.cursorX,B=f.cursorLine,Q=g.parenTrail.startX,J;if(J=B===g.lineNo&&-999!==
Q&&-999!==E&&E>Q){var R=g.commentX;J=!(B===g.lineNo&&-999!==R&&-999!==E&&E>R)}if(J){var S=Math.max(t,f.cursorX),F=Math.max(y,f.cursorX),W=f.lines[f.lineNo];g=0;h=void 0;for(h=t;h<S;h++)x(W[h])&&g++;var T=f.parenTrail.openers;f.parenTrail.openers=T.slice(g);f.parenTrail.startX=S;f.parenTrail.endX=F;f.parenTrail.clamped.openers=T.slice(0,g);f.parenTrail.clamped.startX=t;f.parenTrail.clamped.endX=y}if(d.parenTrail.startX!==d.parenTrail.endX)for(var U=d.parenTrail.openers;0!==U.length;)d.parenStack.push(U.pop())}else if("PAREN_MODE"===
d.mode){N(d,k(d.parenTrail.openers,0));if(d.lineNo!==d.cursorLine){var f=d,K=f.parenTrail.startX,L=f.parenTrail.endX;if(K!==L&&f.lineNo===f.parenTrail.lineNo){var V=f.lines[f.lineNo];g="";h=0;l=void 0;for(l=K;l<L;l++)x(V[l])?g+=V[l]:h++;0<h&&(w(f,f.lineNo,K,L,g),f.parenTrail.endX-=h)}}G(d)}}if(b.quoteDanger)throw n(b,"quote-danger");if(b.isInStr)throw n(b,"unclosed-quote");if(0!==b.parenStack.length&&"PAREN_MODE"===b.mode)throw n(b,"unclosed-paren");"INDENT_MODE"===b.mode&&(b.x=0,H(b));b.success=
!0}catch(r){if(r.leadingCloseParen||r.releaseCursorHold)return D(a,c,"PAREN_MODE",e);b.success=!1;if(r.parinferError)delete r.parinferError,b.error=r;else throw b.error.name="unhandled",b.error.message=r.stack,r;}return b}function t(a){var c;c=-1!==a.origText.search("\r")?"\r\n":"\n";a.success?(c={text:a.lines.join(c),cursorX:a.cursorX,cursorLine:a.cursorLine,success:!0,tabStops:a.tabStops,parenTrails:a.parenTrails},a.returnParens&&(c.parens=a.parens)):(c={text:a.partialResult?a.lines.join(c):a.origText,
cursorX:a.partialResult?a.cursorX:a.origCursorX,cursorLine:a.partialResult?a.cursorLine:a.origCursorLine,parenTrails:a.partialResult?a.parenTrails:null,success:!1,error:a.error},a.partialResult&&a.returnParens&&(c.parens=a.parens));-999===c.cursorX&&delete c.cursorX;-999===c.cursorLine&&delete c.cursorLine;c.tabStops&&0===c.tabStops.length&&delete c.tabStops;return c}var I=/\r?\n/,z={"{":"}","}":"{","[":"]","]":"[","(":")",")":"("},F={"quote-danger":"Quotes must balanced inside comment blocks.","eol-backslash":"Line cannot end in a hanging backslash.",
"unclosed-quote":"String is missing a closing quote.","unclosed-paren":"Unclosed open-paren.","unmatched-close-paren":"Unmatched close-paren.","unmatched-open-paren":"Unmatched open-paren.","leading-close-paren":"Line cannot lead with a close-paren.",unhandled:"Unhandled error."};return{version:"3.11.0",indentMode:function(a,c){c=m(c);return t(D(a,c,"INDENT_MODE"))},parenMode:function(a,c){c=m(c);return t(D(a,c,"PAREN_MODE"))},smartMode:function(a,c){c=m(c);return t(D(a,c,"INDENT_MODE",null==c.selectionStartLine))}}});
(function(Fa,ea){"object"===typeof exports&&"undefined"!==typeof module?module.exports=ea():"function"===typeof define&&define.amd?define(ea):Fa.CodeMirror=ea()})(this,function(){function Fa(a){return new RegExp("(^|\\s)"+a+"(?:$|\\s)\\s*")}function ea(a){for(var b=a.childNodes.length;0<b;--b)a.removeChild(a.firstChild);return a}function Z(a,b){return ea(a).appendChild(b)}function u(a,b,c,d){a=document.createElement(a);c&&(a.className=c);d&&(a.style.cssText=d);if("string"==typeof b)a.appendChild(document.createTextNode(b));
else if(b)for(c=0;c<b.length;++c)a.appendChild(b[c]);return a}function Za(a,b,c,d){a=u(a,b,c,d);a.setAttribute("role","presentation");return a}function xa(a,b){3==b.nodeType&&(b=b.parentNode);if(a.contains)return a.contains(b);do if(11==b.nodeType&&(b=b.host),b==a)return!0;while(b=b.parentNode)}function sa(){var a;try{a=document.activeElement}catch(b){a=document.body||null}for(;a&&a.shadowRoot&&a.shadowRoot.activeElement;)a=a.shadowRoot.activeElement;return a}function Ga(a,b){var c=a.className;Fa(b).test(c)||
(a.className+=(c?" ":"")+b)}function Nc(a,b){for(var c=a.split(" "),d=0;d<c.length;d++)c[d]&&!Fa(c[d]).test(b)&&(b+=" "+c[d]);return b}function Oc(a){var b=Array.prototype.slice.call(arguments,1);return function(){return a.apply(null,b)}}function Ha(a,b,c){b||(b={});for(var d in a)!a.hasOwnProperty(d)||!1===c&&b.hasOwnProperty(d)||(b[d]=a[d]);return b}function fa(a,b,c,d,e){null==b&&(b=a.search(/[^\s\u00a0]/),-1==b&&(b=a.length));d=d||0;for(e=e||0;;){var f=a.indexOf("\t",d);if(0>f||f>=b)return e+
(b-d);e+=f-d;e+=c-e%c;d=f+1}}function L(a,b){for(var c=0;c<a.length;++c)if(a[c]==b)return c;return-1}function Pc(a,b,c){for(var d=0,e=0;;){var f=a.indexOf("\t",d);-1==f&&(f=a.length);var g=f-d;if(f==a.length||e+g>=b)return d+Math.min(g,b-e);e+=f-d;e+=c-e%c;d=f+1;if(e>=b)return d}}function Qc(a){for(;fc.length<=a;)fc.push(w(fc)+" ");return fc[a]}function w(a){return a[a.length-1]}function gc(a,b){for(var c=[],d=0;d<a.length;d++)c[d]=b(a[d],d);return c}function ig(a,b,c){for(var d=0,e=c(b);d<a.length&&
c(a[d])<=e;)d++;a.splice(d,0,b)}function Wd(){}function Xd(a,b){var c;Object.create?c=Object.create(a):(Wd.prototype=a,c=new Wd);b&&Ha(b,c);return c}function Rc(a){return/\w/.test(a)||""<a&&(a.toUpperCase()!=a.toLowerCase()||jg.test(a))}function hc(a,b){return b?-1<b.source.indexOf("\\w")&&Rc(a)?!0:b.test(a):Rc(a)}function Yd(a){for(var b in a)if(a.hasOwnProperty(b)&&a[b])return!1;return!0}function Sc(a){return 768<=a.charCodeAt(0)&&kg.test(a)}function Zd(a,b,c){for(;(0>c?0<b:b<a.length)&&Sc(a.charAt(b));)b+=
c;return b}function rb(a,b,c){for(var d=b>c?-1:1;;){if(b==c)return b;var e=(b+c)/2,e=0>d?Math.ceil(e):Math.floor(e);if(e==b)return a(e)?b:c;a(e)?c=e:b=e+d}}function lg(a,b,c){this.input=c;this.scrollbarFiller=u("div",null,"CodeMirror-scrollbar-filler");this.scrollbarFiller.setAttribute("cm-not-content","true");this.gutterFiller=u("div",null,"CodeMirror-gutter-filler");this.gutterFiller.setAttribute("cm-not-content","true");this.lineDiv=Za("div",null,"CodeMirror-code");this.selectionDiv=u("div",null,
null,"position: relative; z-index: 1");this.cursorDiv=u("div",null,"CodeMirror-cursors");this.measure=u("div",null,"CodeMirror-measure");this.lineMeasure=u("div",null,"CodeMirror-measure");this.lineSpace=Za("div",[this.measure,this.lineMeasure,this.selectionDiv,this.cursorDiv,this.lineDiv],null,"position: relative; outline: none");var d=Za("div",[this.lineSpace],"CodeMirror-lines");this.mover=u("div",[d],null,"position: relative");this.sizer=u("div",[this.mover],"CodeMirror-sizer");this.sizerWidth=
null;this.heightForcer=u("div",null,null,"position: absolute; height: 30px; width: 1px;");this.gutters=u("div",null,"CodeMirror-gutters");this.lineGutter=null;this.scroller=u("div",[this.sizer,this.heightForcer,this.gutters],"CodeMirror-scroll");this.scroller.setAttribute("tabIndex","-1");this.wrapper=u("div",[this.scrollbarFiller,this.gutterFiller,this.scroller],"CodeMirror");A&&8>D&&(this.gutters.style.zIndex=-1,this.scroller.style.paddingRight=0);P||ya&&sb||(this.scroller.draggable=!0);a&&(a.appendChild?
a.appendChild(this.wrapper):a(this.wrapper));this.reportedViewFrom=this.reportedViewTo=this.viewFrom=this.viewTo=b.first;this.view=[];this.externalMeasured=this.renderedView=null;this.lastWrapHeight=this.lastWrapWidth=this.viewOffset=0;this.updateLineNumbers=null;this.nativeBarWidth=this.barHeight=this.barWidth=0;this.scrollbarsClipped=!1;this.lineNumWidth=this.lineNumInnerWidth=this.lineNumChars=null;this.alignWidgets=!1;this.maxLine=this.cachedCharWidth=this.cachedTextHeight=this.cachedPaddingH=
null;this.maxLineLength=0;this.maxLineChanged=!1;this.wheelDX=this.wheelDY=this.wheelStartX=this.wheelStartY=null;this.shift=!1;this.activeTouch=this.selForContextMenu=null;c.init(this)}function t(a,b){b-=a.first;if(0>b||b>=a.size)throw Error("There is no line "+(b+a.first)+" in the document.");for(var c=a;!c.lines;)for(var d=0;;++d){var e=c.children[d],f=e.chunkSize();if(b<f){c=e;break}b-=f}return c.lines[b]}function Ia(a,b,c){var d=[],e=b.line;a.iter(b.line,c.line+1,function(a){a=a.text;e==c.line&&
(a=a.slice(0,c.ch));e==b.line&&(a=a.slice(b.ch));d.push(a);++e});return d}function Tc(a,b,c){var d=[];a.iter(b,c,function(a){d.push(a.text)});return d}function ma(a,b){var c=b-a.height;if(c)for(var d=a;d;d=d.parent)d.height+=c}function B(a){if(null==a.parent)return null;var b=a.parent;a=L(b.lines,a);for(var c=b.parent;c;b=c,c=c.parent)for(var d=0;c.children[d]!=b;++d)a+=c.children[d].chunkSize();return a+b.first}function Ja(a,b){var c=a.first;a:do{for(var d=0;d<a.children.length;++d){var e=a.children[d],
f=e.height;if(b<f){a=e;continue a}b-=f;c+=e.chunkSize()}return c}while(!a.lines);for(d=0;d<a.lines.length;++d){e=a.lines[d].height;if(b<e)break;b-=e}return c+d}function tb(a,b){return b>=a.first&&b<a.first+a.size}function Uc(a,b){return String(a.lineNumberFormatter(b+a.firstLineNumber))}function q(a,b,c){void 0===c&&(c=null);if(!(this instanceof q))return new q(a,b,c);this.line=a;this.ch=b;this.sticky=c}function y(a,b){return a.line-b.line||a.ch-b.ch}function Vc(a,b){return a.sticky==b.sticky&&0==
y(a,b)}function Wc(a){return q(a.line,a.ch)}function ic(a,b){return 0>y(a,b)?b:a}function jc(a,b){return 0>y(a,b)?a:b}function x(a,b){if(b.line<a.first)return q(a.first,0);var c=a.first+a.size-1;if(b.line>c)return q(c,t(a,c).text.length);var c=t(a,b.line).text.length,d=b.ch,c=null==d||d>c?q(b.line,c):0>d?q(b.line,0):b;return c}function $d(a,b){for(var c=[],d=0;d<b.length;d++)c[d]=x(a,b[d]);return c}function kc(a,b,c){this.marker=a;this.from=b;this.to=c}function ub(a,b){if(a)for(var c=0;c<a.length;++c){var d=
a[c];if(d.marker==b)return d}}function Xc(a,b){if(b.full)return null;var c=tb(a,b.from.line)&&t(a,b.from.line).markedSpans,d=tb(a,b.to.line)&&t(a,b.to.line).markedSpans;if(!c&&!d)return null;var e=b.from.ch,f=b.to.ch,g=0==y(b.from,b.to),h;if(c)for(var k=0;k<c.length;++k){var l=c[k],m=l.marker;if(null==l.from||(m.inclusiveLeft?l.from<=e:l.from<e)||!(l.from!=e||"bookmark"!=m.type||g&&l.marker.insertLeft)){var p=null==l.to||(m.inclusiveRight?l.to>=e:l.to>e);(h||(h=[])).push(new kc(m,l.from,p?null:l.to))}}var c=
h,n;if(d)for(h=0;h<d.length;++h)if(k=d[h],l=k.marker,null==k.to||(l.inclusiveRight?k.to>=f:k.to>f)||k.from==f&&"bookmark"==l.type&&(!g||k.marker.insertLeft))m=null==k.from||(l.inclusiveLeft?k.from<=f:k.from<f),(n||(n=[])).push(new kc(l,m?null:k.from-f,null==k.to?null:k.to-f));d=n;f=1==b.text.length;g=w(b.text).length+(f?e:0);if(c)for(n=0;n<c.length;++n)if(h=c[n],null==h.to)(k=ub(d,h.marker),k)?f&&(h.to=null==k.to?null:k.to+g):h.to=e;if(d)for(e=0;e<d.length;++e)n=d[e],null!=n.to&&(n.to+=g),null==n.from?
ub(c,n.marker)||(n.from=g,f&&(c||(c=[])).push(n)):(n.from+=g,f&&(c||(c=[])).push(n));c&&(c=ae(c));d&&d!=c&&(d=ae(d));e=[c];if(!f){var f=b.text.length-2,r;if(0<f&&c)for(g=0;g<c.length;++g)null==c[g].to&&(r||(r=[])).push(new kc(c[g].marker,null,null));for(c=0;c<f;++c)e.push(r);e.push(d)}return e}function ae(a){for(var b=0;b<a.length;++b){var c=a[b];null!=c.from&&c.from==c.to&&!1!==c.marker.clearWhenEmpty&&a.splice(b--,1)}return a.length?a:null}function mg(a,b,c){var d=null;a.iter(b.line,c.line+1,function(a){if(a.markedSpans)for(var b=
0;b<a.markedSpans.length;++b){var c=a.markedSpans[b].marker;!c.readOnly||d&&-1!=L(d,c)||(d||(d=[])).push(c)}});if(!d)return null;a=[{from:b,to:c}];for(b=0;b<d.length;++b){c=d[b];for(var e=c.find(0),f=0;f<a.length;++f){var g=a[f];if(!(0>y(g.to,e.from)||0<y(g.from,e.to))){var h=[f,1],k=y(g.from,e.from),l=y(g.to,e.to);(0>k||!c.inclusiveLeft&&!k)&&h.push({from:g.from,to:e.from});(0<l||!c.inclusiveRight&&!l)&&h.push({from:e.to,to:g.to});a.splice.apply(a,h);f+=h.length-3}}}return a}function be(a){var b=
a.markedSpans;if(b){for(var c=0;c<b.length;++c)b[c].marker.detachLine(a);a.markedSpans=null}}function ce(a,b){if(b){for(var c=0;c<b.length;++c)b[c].marker.attachLine(a);a.markedSpans=b}}function Yc(a,b){var c=a.lines.length-b.lines.length;if(0!=c)return c;var c=a.find(),d=b.find(),e=y(c.from,d.from)||(a.inclusiveLeft?-1:0)-(b.inclusiveLeft?-1:0);return e?-e:(c=y(c.to,d.to)||(a.inclusiveRight?1:0)-(b.inclusiveRight?1:0))?c:b.id-a.id}function $a(a,b){var c=ta&&a.markedSpans,d;if(c)for(var e=void 0,
f=0;f<c.length;++f)e=c[f],e.marker.collapsed&&null==(b?e.from:e.to)&&(!d||0>Yc(d,e.marker))&&(d=e.marker);return d}function de(a,b,c,d,e){a=t(a,b);if(a=ta&&a.markedSpans)for(b=0;b<a.length;++b){var f=a[b];if(f.marker.collapsed){var g=f.marker.find(0),h=y(g.from,c)||(f.marker.inclusiveLeft?-1:0)-(e.inclusiveLeft?-1:0),k=y(g.to,d)||(f.marker.inclusiveRight?1:0)-(e.inclusiveRight?1:0);if(!(0<=h&&0>=k||0>=h&&0<=k)&&(0>=h&&(f.marker.inclusiveRight&&e.inclusiveLeft?0<=y(g.to,c):0<y(g.to,c))||0<=h&&(f.marker.inclusiveRight&&
e.inclusiveLeft?0>=y(g.from,d):0>y(g.from,d))))return!0}}}function na(a){for(var b;b=$a(a,!0);)a=b.find(-1,!0).line;return a}function Zc(a,b){var c=t(a,b),d=na(c);return c==d?b:B(d)}function ee(a,b){if(b>a.lastLine())return b;var c=t(a,b),d;if(!za(a,c))return b;for(;d=$a(c,!1);)c=d.find(1,!0).line;return B(c)+1}function za(a,b){var c=ta&&b.markedSpans;if(c)for(var d=void 0,e=0;e<c.length;++e)if(d=c[e],d.marker.collapsed&&(null==d.from||!d.marker.widgetNode&&0==d.from&&d.marker.inclusiveLeft&&$c(a,
b,d)))return!0}function $c(a,b,c){if(null==c.to)return b=c.marker.find(1,!0),$c(a,b.line,ub(b.line.markedSpans,c.marker));if(c.marker.inclusiveRight&&c.to==b.text.length)return!0;for(var d=void 0,e=0;e<b.markedSpans.length;++e)if(d=b.markedSpans[e],d.marker.collapsed&&!d.marker.widgetNode&&d.from==c.to&&(null==d.to||d.to!=c.from)&&(d.marker.inclusiveLeft||c.marker.inclusiveRight)&&$c(a,b,d))return!0}function oa(a){a=na(a);for(var b=0,c=a.parent,d=0;d<c.lines.length;++d){var e=c.lines[d];if(e==a)break;
else b+=e.height}for(a=c.parent;a;c=a,a=c.parent)for(d=0;d<a.children.length&&(e=a.children[d],e!=c);++d)b+=e.height;return b}function lc(a){if(0==a.height)return 0;for(var b=a.text.length,c,d=a;c=$a(d,!0);)c=c.find(0,!0),d=c.from.line,b+=c.from.ch-c.to.ch;for(d=a;c=$a(d,!1);)a=c.find(0,!0),b-=d.text.length-a.from.ch,d=a.to.line,b+=d.text.length-a.to.ch;return b}function ad(a){var b=a.display;a=a.doc;b.maxLine=t(a,a.first);b.maxLineLength=lc(b.maxLine);b.maxLineChanged=!0;a.iter(function(a){var d=
lc(a);d>b.maxLineLength&&(b.maxLineLength=d,b.maxLine=a)})}function ng(a,b,c,d){if(!a)return d(b,c,"ltr",0);for(var e=!1,f=0;f<a.length;++f){var g=a[f];if(g.from<c&&g.to>b||b==c&&g.to==b)d(Math.max(g.from,b),Math.min(g.to,c),1==g.level?"rtl":"ltr",f),e=!0}e||d(b,c,"ltr")}function vb(a,b,c){var d;wb=null;for(var e=0;e<a.length;++e){var f=a[e];if(f.from<b&&f.to>b)return e;f.to==b&&(f.from!=f.to&&"before"==c?d=e:wb=e);f.from==b&&(f.from!=f.to&&"before"!=c?d=e:wb=e)}return null!=d?d:wb}function ua(a,
b){var c=a.order;null==c&&(c=a.order=og(a.text,b));return c}function aa(a,b,c){if(a.removeEventListener)a.removeEventListener(b,c,!1);else if(a.detachEvent)a.detachEvent("on"+b,c);else{var d=(a=a._handlers)&&a[b];d&&(c=L(d,c),-1<c&&(a[b]=d.slice(0,c).concat(d.slice(c+1))))}}function F(a,b){var c=a._handlers&&a._handlers[b]||mc;if(c.length)for(var d=Array.prototype.slice.call(arguments,2),e=0;e<c.length;++e)c[e].apply(null,d)}function I(a,b,c){"string"==typeof b&&(b={type:b,preventDefault:function(){this.defaultPrevented=
!0}});F(a,c||b.type,a,b);return bd(b)||b.codemirrorIgnore}function fe(a){var b=a._handlers&&a._handlers.cursorActivity;if(b){a=a.curOp.cursorActivityHandlers||(a.curOp.cursorActivityHandlers=[]);for(var c=0;c<b.length;++c)-1==L(a,b[c])&&a.push(b[c])}}function ga(a,b){return 0<(a._handlers&&a._handlers[b]||mc).length}function ab(a){a.prototype.on=function(a,c){v(this,a,c)};a.prototype.off=function(a,c){aa(this,a,c)}}function T(a){a.preventDefault?a.preventDefault():a.returnValue=!1}function ge(a){a.stopPropagation?
a.stopPropagation():a.cancelBubble=!0}function bd(a){return null!=a.defaultPrevented?a.defaultPrevented:0==a.returnValue}function xb(a){T(a);ge(a)}function he(a){var b=a.which;null==b&&(a.button&1?b=1:a.button&2?b=3:a.button&4&&(b=2));ha&&a.ctrlKey&&1==b&&(b=3);return b}function pg(a){if(null==cd){var b=u("span","​");Z(a,u("span",[b,document.createTextNode("x")]));0!=a.firstChild.offsetHeight&&(cd=1>=b.offsetWidth&&2<b.offsetHeight&&!(A&&8>D))}a=cd?u("span","​"):u("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");
a.setAttribute("cm-text","");return a}function qg(a,b){2<arguments.length&&(b.dependencies=Array.prototype.slice.call(arguments,2));dd[a]=b}function nc(a){if("string"==typeof a&&bb.hasOwnProperty(a))a=bb[a];else if(a&&"string"==typeof a.name&&bb.hasOwnProperty(a.name)){var b=bb[a.name];"string"==typeof b&&(b={name:b});a=Xd(b,a);a.name=b.name}else{if("string"==typeof a&&/^[\w\-]+\/[\w\-]+\+xml$/.test(a))return nc("application/xml");if("string"==typeof a&&/^[\w\-]+\/[\w\-]+\+json$/.test(a))return nc("application/json")}return"string"==
typeof a?{name:a}:a||{name:"null"}}function ed(a,b){b=nc(b);var c=dd[b.name];if(!c)return ed(a,"text/plain");c=c(a,b);if(cb.hasOwnProperty(b.name)){var d=cb[b.name],e;for(e in d)d.hasOwnProperty(e)&&(c.hasOwnProperty(e)&&(c["_"+e]=c[e]),c[e]=d[e])}c.name=b.name;b.helperType&&(c.helperType=b.helperType);if(b.modeProps)for(var f in b.modeProps)c[f]=b.modeProps[f];return c}function rg(a,b){var c=cb.hasOwnProperty(a)?cb[a]:cb[a]={};Ha(b,c)}function Ka(a,b){if(!0===b)return b;if(a.copyState)return a.copyState(b);
var c={},d;for(d in b){var e=b[d];e instanceof Array&&(e=e.concat([]));c[d]=e}return c}function fd(a,b){for(var c;a.innerMode;){c=a.innerMode(b);if(!c||c.mode==a)break;b=c.state;a=c.mode}return c||{mode:a,state:b}}function ie(a,b,c){return a.startState?a.startState(b,c):!0}function je(a,b,c,d){var e=[a.state.modeGen],f={};ke(a,b.text,a.doc.mode,c,function(a,b){return e.push(a,b)},f,d);var g=c.state;d=function(d){c.baseTokens=e;var h=a.state.overlays[d],m=1,p=0;c.state=!0;ke(a,b.text,h.mode,c,function(a,
b){for(var d=m;p<a;){var c=e[m];c>a&&e.splice(m,1,a,e[m+1],c);m+=2;p=Math.min(a,c)}if(b)if(h.opaque)e.splice(d,m-d,a,"overlay "+b),m=d+2;else for(;d<m;d+=2)c=e[d+1],e[d+1]=(c?c+" ":"")+"overlay "+b},f);c.state=g;c.baseTokens=null;c.baseTokenPos=1};for(var h=0;h<a.state.overlays.length;++h)d(h);return{styles:e,classes:f.bgClass||f.textClass?f:null}}function le(a,b,c){if(!b.styles||b.styles[0]!=a.state.modeGen){var d=yb(a,B(b)),e=b.text.length>a.options.maxHighlightLength&&Ka(a.doc.mode,d.state),f=
je(a,b,d);e&&(d.state=e);b.stateAfter=d.save(!e);b.styles=f.styles;f.classes?b.styleClasses=f.classes:b.styleClasses&&(b.styleClasses=null);c===a.doc.highlightFrontier&&(a.doc.modeFrontier=Math.max(a.doc.modeFrontier,++a.doc.highlightFrontier))}return b.styles}function yb(a,b,c){var d=a.doc,e=a.display;if(!d.mode.startState)return new pa(d,!0,b);var f=sg(a,b,c),g=f>d.first&&t(d,f-1).stateAfter,h=g?pa.fromSaved(d,g,f):new pa(d,ie(d.mode),f);d.iter(f,b,function(d){gd(a,d.text,h);var c=h.line;d.stateAfter=
c==b-1||0==c%5||c>=e.viewFrom&&c<e.viewTo?h.save():null;h.nextLine()});c&&(d.modeFrontier=h.line);return h}function gd(a,b,c,d){var e=a.doc.mode;a=new G(b,a.options.tabSize,c);a.start=a.pos=d||0;for(""==b&&me(e,c.state);!a.eol();)hd(e,a,c.state),a.start=a.pos}function me(a,b){if(a.blankLine)return a.blankLine(b);if(a.innerMode){var c=fd(a,b);if(c.mode.blankLine)return c.mode.blankLine(c.state)}}function hd(a,b,c,d){for(var e=0;10>e;e++){d&&(d[0]=fd(a,c).mode);var f=a.token(b,c);if(b.pos>b.start)return f}throw Error("Mode "+
a.name+" failed to advance stream.");}function ne(a,b,c,d){var e=a.doc,f=e.mode,g;b=x(e,b);var h=t(e,b.line);c=yb(a,b.line,c);a=new G(h.text,a.options.tabSize,c);var k;for(d&&(k=[]);(d||a.pos<b.ch)&&!a.eol();)a.start=a.pos,g=hd(f,a,c.state),d&&k.push(new oe(a,g,Ka(e.mode,c.state)));return d?k:new oe(a,g,c.state)}function pe(a,b){if(a)for(;;){var c=a.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!c)break;a=a.slice(0,c.index)+a.slice(c.index+c[0].length);var d=c[1]?"bgClass":"textClass";null==b[d]?
b[d]=c[2]:(new RegExp("(?:^|s)"+c[2]+"(?:$|s)")).test(b[d])||(b[d]+=" "+c[2])}return a}function ke(a,b,c,d,e,f,g){var h=c.flattenSpans;null==h&&(h=a.options.flattenSpans);var k=0,l=null,m=new G(b,a.options.tabSize,d),p,n=a.options.addModeClass&&[null];for(""==b&&pe(me(c,d.state),f);!m.eol();){m.pos>a.options.maxHighlightLength?(h=!1,g&&gd(a,b,d,m.pos),m.pos=b.length,p=null):p=pe(hd(c,m,d.state,n),f);if(n){var r=n[0].name;r&&(p="m-"+(p?r+" "+p:r))}if(!h||l!=p){for(;k<m.start;)k=Math.min(m.start,k+
5E3),e(k,l);l=p}m.start=m.pos}for(;k<m.pos;)a=Math.min(m.pos,k+5E3),e(a,l),k=a}function sg(a,b,c){for(var d,e,f=a.doc,g=c?-1:b-(a.doc.mode.innerMode?1E3:100);b>g;--b){if(b<=f.first)return f.first;var h=t(f,b-1),k=h.stateAfter;if(k&&(!c||b+(k instanceof oc?k.lookAhead:0)<=f.modeFrontier))return b;h=fa(h.text,null,a.options.tabSize);if(null==e||d>h)e=b-1,d=h}return e}function tg(a,b){a.modeFrontier=Math.min(a.modeFrontier,b);if(!(a.highlightFrontier<b-10)){for(var c=a.first,d=b-1;d>c;d--){var e=t(a,
d).stateAfter;if(e&&(!(e instanceof oc)||d+e.lookAhead<b)){c=d+1;break}}a.highlightFrontier=Math.min(a.highlightFrontier,c)}}function qe(a,b){if(!a||/^\s*$/.test(a))return null;var c=b.addModeClass?ug:vg;return c[a]||(c[a]=a.replace(/\S+/g,"cm-$\x26"))}function re(a,b){var c=Za("span",null,null,P?"padding-right: .1px":null),c={pre:Za("pre",[c],"CodeMirror-line"),content:c,col:0,pos:0,cm:a,trailingSpace:!1,splitSpaces:a.getOption("lineWrapping")};b.measure={};for(var d=0;d<=(b.rest?b.rest.length:0);d++){var e=
d?b.rest[d-1]:b.line,f=void 0;c.pos=0;c.addToken=wg;var g;g=a.display.measure;if(null!=id)g=id;else{var h=Z(g,document.createTextNode("AخA")),k=db(h,0,1).getBoundingClientRect(),h=db(h,1,2).getBoundingClientRect();ea(g);g=k&&k.left!=k.right?id=3>h.right-k.right:!1}g&&(f=ua(e,a.doc.direction))&&(c.addToken=xg(c.addToken,f));c.map=[];g=b!=a.display.externalMeasured&&B(e);a:{f=c;g=le(a,e,g);var l=e.markedSpans,k=e.text,h=0;if(l)for(var m=k.length,p=0,n=1,r="",W=void 0,q=void 0,t=0,u=void 0,v=void 0,
y=void 0,x=void 0,Q=void 0;;){if(t==p){for(var u=v=y=x=q="",Q=null,t=Infinity,A=[],X=void 0,z=0;z<l.length;++z){var M=l[z],w=M.marker;"bookmark"==w.type&&M.from==p&&w.widgetNode?A.push(w):M.from<=p&&(null==M.to||M.to>p||w.collapsed&&M.to==p&&M.from==p)?(null!=M.to&&M.to!=p&&t>M.to&&(t=M.to,v=""),w.className&&(u+=" "+w.className),w.css&&(q=(q?q+";":"")+w.css),w.startStyle&&M.from==p&&(y+=" "+w.startStyle),w.endStyle&&M.to==t&&(X||(X=[])).push(w.endStyle,M.to),w.title&&!x&&(x=w.title),w.collapsed&&
(!Q||0>Yc(Q.marker,w))&&(Q=M)):M.from>p&&t>M.from&&(t=M.from)}if(X)for(z=0;z<X.length;z+=2)X[z+1]==t&&(v+=" "+X[z]);if(!Q||Q.from==p)for(X=0;X<A.length;++X)se(f,0,A[X]);if(Q&&(Q.from||0)==p){se(f,(null==Q.to?m+1:Q.to)-p,Q.marker,null==Q.from);if(null==Q.to)break a;Q.to==p&&(Q=!1)}}if(p>=m)break;for(A=Math.min(m,t);;){if(r){X=p+r.length;Q||(z=X>A?r.slice(0,A-p):r,f.addToken(f,z,W?W+u:u,y,p+z.length==t?v:"",x,q));if(X>=A){r=r.slice(A-p);p=A;break}p=X;y=""}r=k.slice(h,h=g[n++]);W=qe(g[n++],f.cm.options)}}else for(l=
1;l<g.length;l+=2)f.addToken(f,k.slice(h,h=g[l]),qe(g[l+1],f.cm.options))}e.styleClasses&&(e.styleClasses.bgClass&&(c.bgClass=Nc(e.styleClasses.bgClass,c.bgClass||"")),e.styleClasses.textClass&&(c.textClass=Nc(e.styleClasses.textClass,c.textClass||"")));0==c.map.length&&c.map.push(0,0,c.content.appendChild(pg(a.display.measure)));0==d?(b.measure.map=c.map,b.measure.cache={}):((b.measure.maps||(b.measure.maps=[])).push(c.map),(b.measure.caches||(b.measure.caches=[])).push({}))}P&&(d=c.content.lastChild,
/\bcm-tab\b/.test(d.className)||d.querySelector&&d.querySelector(".cm-tab"))&&(c.content.className="cm-tab-wrap-hack");F(a,"renderLine",a,b.line,c.pre);c.pre.className&&(c.textClass=Nc(c.pre.className,c.textClass||""));return c}function yg(a){var b=u("span","•","cm-invalidchar");b.title="\\u"+a.charCodeAt(0).toString(16);b.setAttribute("aria-label",b.title);return b}function wg(a,b,c,d,e,f,g){if(b){var h;if(a.splitSpaces)if(h=a.trailingSpace,1<b.length&&!/  /.test(b))h=b;else{for(var k="",l=0;l<b.length;l++){var m=
b.charAt(l);" "!=m||!h||l!=b.length-1&&32!=b.charCodeAt(l+1)||(m=" ");k+=m;h=" "==m}h=k}else h=b;k=h;l=a.cm.state.specialChars;m=!1;if(l.test(b)){h=document.createDocumentFragment();for(var p=0;;){l.lastIndex=p;var n=l.exec(b),r=n?n.index-p:b.length-p;if(r){var W=document.createTextNode(k.slice(p,p+r));A&&9>D?h.appendChild(u("span",[W])):h.appendChild(W);a.map.push(a.pos,a.pos+r,W);a.col+=r;a.pos+=r}if(!n)break;p+=r+1;r=void 0;"\t"==n[0]?(n=a.cm.options.tabSize,n-=a.col%n,r=h.appendChild(u("span",
Qc(n),"cm-tab")),r.setAttribute("role","presentation"),r.setAttribute("cm-text","\t"),a.col+=n):("\r"==n[0]||"\n"==n[0]?(r=h.appendChild(u("span","\r"==n[0]?"␍":"␤","cm-invalidchar")),r.setAttribute("cm-text",n[0])):(r=a.cm.options.specialCharPlaceholder(n[0]),r.setAttribute("cm-text",n[0]),A&&9>D?h.appendChild(u("span",[r])):h.appendChild(r)),a.col+=1);a.map.push(a.pos,a.pos+1,r);a.pos++}}else a.col+=b.length,h=document.createTextNode(k),a.map.push(a.pos,a.pos+b.length,h),A&&9>D&&(m=!0),a.pos+=b.length;
a.trailingSpace=32==k.charCodeAt(b.length-1);if(c||d||e||m||g)return b=c||"",d&&(b+=d),e&&(b+=e),d=u("span",[h],b,g),f&&(d.title=f),a.content.appendChild(d);a.content.appendChild(h)}}function xg(a,b){return function(c,d,e,f,g,h,k){e=e?e+" cm-force-border":"cm-force-border";for(var l=c.pos,m=l+d.length;;){for(var p=void 0,n=0;n<b.length&&!(p=b[n],p.to>l&&p.from<=l);n++);if(p.to>=m)return a(c,d,e,f,g,h,k);a(c,d.slice(0,p.to-l),e,f,null,h,k);f=null;d=d.slice(p.to-l);l=p.to}}}function se(a,b,c,d){var e=
!d&&c.widgetNode;e&&a.map.push(a.pos,a.pos+b,e);!d&&a.cm.display.input.needsContentAttribute&&(e||(e=a.content.appendChild(document.createElement("span"))),e.setAttribute("cm-marker",c.id));e&&(a.cm.display.input.setUneditable(e),a.content.appendChild(e));a.pos+=b;a.trailingSpace=!1}function te(a,b,c){for(var d=this.line=b,e;d=$a(d,!1);)d=d.find(1,!0).line,(e||(e=[])).push(d);this.size=(this.rest=e)?B(w(this.rest))-c+1:1;this.node=this.text=null;this.hidden=za(a,b)}function pc(a,b,c){var d=[],e;for(e=
b;e<c;)b=new te(a.doc,t(a.doc,e),e),e+=b.size,d.push(b);return d}function zg(a,b){var c=a.ownsGroup;if(c)try{var d=c.delayedCallbacks,e=0;do{for(;e<d.length;e++)d[e].call(null);for(var f=0;f<c.ops.length;f++){var g=c.ops[f];if(g.cursorActivityHandlers)for(;g.cursorActivityCalled<g.cursorActivityHandlers.length;)g.cursorActivityHandlers[g.cursorActivityCalled++].call(null,g.cm)}}while(e<d.length)}finally{eb=null,b(c)}}function N(a,b){var c=a._handlers&&a._handlers[b]||mc;if(c.length){var d=Array.prototype.slice.call(arguments,
2),e;eb?e=eb.delayedCallbacks:zb?e=zb:(e=zb=[],setTimeout(Ag,0));for(var f=function(a){e.push(function(){return c[a].apply(null,d)})},g=0;g<c.length;++g)f(g)}}function Ag(){var a=zb;zb=null;for(var b=0;b<a.length;++b)a[b]()}function ue(a,b,c,d){for(var e=0;e<b.changes.length;e++){var f=b.changes[e];if("text"==f){var f=a,g=b,h=g.text.className,k=ve(f,g);g.text==g.node&&(g.node=k.pre);g.text.parentNode.replaceChild(k.pre,g.text);g.text=k.pre;k.bgClass!=g.bgClass||k.textClass!=g.textClass?(g.bgClass=
k.bgClass,g.textClass=k.textClass,jd(f,g)):h&&(g.text.className=h)}else if("gutter"==f)we(a,b,c,d);else if("class"==f)jd(a,b);else if("widget"==f){f=a;g=b;h=d;g.alignable&&(g.alignable=null);for(var k=g.node.firstChild,l=void 0;k;k=l)l=k.nextSibling,"CodeMirror-linewidget"==k.className&&g.node.removeChild(k);xe(f,g,h)}}b.changes=null}function Ab(a){a.node==a.text&&(a.node=u("div",null,null,"position: relative"),a.text.parentNode&&a.text.parentNode.replaceChild(a.node,a.text),a.node.appendChild(a.text),
A&&8>D&&(a.node.style.zIndex=2));return a.node}function ve(a,b){var c=a.display.externalMeasured;return c&&c.line==b.line?(a.display.externalMeasured=null,b.measure=c.measure,c.built):re(a,b)}function jd(a,b){var c=b.bgClass?b.bgClass+" "+(b.line.bgClass||""):b.line.bgClass;c&&(c+=" CodeMirror-linebackground");if(b.background)c?b.background.className=c:(b.background.parentNode.removeChild(b.background),b.background=null);else if(c){var d=Ab(b);b.background=d.insertBefore(u("div",null,c),d.firstChild);
a.display.input.setUneditable(b.background)}b.line.wrapClass?Ab(b).className=b.line.wrapClass:b.node!=b.text&&(b.node.className="");b.text.className=(b.textClass?b.textClass+" "+(b.line.textClass||""):b.line.textClass)||""}function we(a,b,c,d){b.gutter&&(b.node.removeChild(b.gutter),b.gutter=null);b.gutterBackground&&(b.node.removeChild(b.gutterBackground),b.gutterBackground=null);if(b.line.gutterClass){var e=Ab(b);b.gutterBackground=u("div",null,"CodeMirror-gutter-background "+b.line.gutterClass,
"left: "+(a.options.fixedGutter?d.fixedPos:-d.gutterTotalWidth)+"px; width: "+d.gutterTotalWidth+"px");a.display.input.setUneditable(b.gutterBackground);e.insertBefore(b.gutterBackground,b.text)}e=b.line.gutterMarkers;if(a.options.lineNumbers||e){var f=Ab(b),g=b.gutter=u("div",null,"CodeMirror-gutter-wrapper","left: "+(a.options.fixedGutter?d.fixedPos:-d.gutterTotalWidth)+"px");a.display.input.setUneditable(g);f.insertBefore(g,b.text);b.line.gutterClass&&(g.className+=" "+b.line.gutterClass);!a.options.lineNumbers||
e&&e["CodeMirror-linenumbers"]||(b.lineNumber=g.appendChild(u("div",Uc(a.options,c),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+d.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+a.display.lineNumInnerWidth+"px")));if(e)for(b=0;b<a.options.gutters.length;++b)c=a.options.gutters[b],(f=e.hasOwnProperty(c)&&e[c])&&g.appendChild(u("div",[f],"CodeMirror-gutter-elt","left: "+d.gutterLeft[c]+"px; width: "+d.gutterWidth[c]+"px"))}}function Bg(a,b,c,d){var e=ve(a,b);b.text=b.node=e.pre;e.bgClass&&
(b.bgClass=e.bgClass);e.textClass&&(b.textClass=e.textClass);jd(a,b);we(a,b,c,d);xe(a,b,d);return b.node}function xe(a,b,c){ye(a,b.line,b,c,!0);if(b.rest)for(var d=0;d<b.rest.length;d++)ye(a,b.rest[d],b,c,!1)}function ye(a,b,c,d,e){if(b.widgets){var f=Ab(c),g=0;for(b=b.widgets;g<b.length;++g){var h=b[g],k=u("div",[h.node],"CodeMirror-linewidget");h.handleMouseEvents||k.setAttribute("cm-ignore-events","true");var l=h,m=k,p=d;if(l.noHScroll){(c.alignable||(c.alignable=[])).push(m);var n=p.wrapperWidth;
m.style.left=p.fixedPos+"px";l.coverGutter||(n-=p.gutterTotalWidth,m.style.paddingLeft=p.gutterTotalWidth+"px");m.style.width=n+"px"}l.coverGutter&&(m.style.zIndex=5,m.style.position="relative",l.noHScroll||(m.style.marginLeft=-p.gutterTotalWidth+"px"));a.display.input.setUneditable(k);e&&h.above?f.insertBefore(k,c.gutter||c.text):f.appendChild(k);N(h,"redraw")}}}function Bb(a){if(null!=a.height)return a.height;var b=a.doc.cm;if(!b)return 0;if(!xa(document.body,a.node)){var c="position: relative;";
a.coverGutter&&(c+="margin-left: -"+b.display.gutters.offsetWidth+"px;");a.noHScroll&&(c+="width: "+b.display.wrapper.clientWidth+"px;");Z(b.display.measure,u("div",[a.node],null,c))}return a.height=a.node.parentNode.offsetHeight}function va(a,b){for(var c=b.target||b.srcElement;c!=a.wrapper;c=c.parentNode)if(!c||1==c.nodeType&&"true"==c.getAttribute("cm-ignore-events")||c.parentNode==a.sizer&&c!=a.mover)return!0}function kd(a){return a.mover.offsetHeight-a.lineSpace.offsetHeight}function ze(a){if(a.cachedPaddingH)return a.cachedPaddingH;
var b=Z(a.measure,u("pre","x")),b=window.getComputedStyle?window.getComputedStyle(b):b.currentStyle,b={left:parseInt(b.paddingLeft),right:parseInt(b.paddingRight)};isNaN(b.left)||isNaN(b.right)||(a.cachedPaddingH=b);return b}function qa(a){return 30-a.display.nativeBarWidth}function La(a){return a.display.scroller.clientWidth-qa(a)-a.display.barWidth}function ld(a){return a.display.scroller.clientHeight-qa(a)-a.display.barHeight}function Ae(a,b,c){if(a.line==b)return{map:a.measure.map,cache:a.measure.cache};
for(var d=0;d<a.rest.length;d++)if(a.rest[d]==b)return{map:a.measure.maps[d],cache:a.measure.caches[d]};for(b=0;b<a.rest.length;b++)if(B(a.rest[b])>c)return{map:a.measure.maps[b],cache:a.measure.caches[b],before:!0}}function md(a,b){if(b>=a.display.viewFrom&&b<a.display.viewTo)return a.display.view[Ma(a,b)];var c=a.display.externalMeasured;if(c&&b>=c.lineN&&b<c.lineN+c.size)return c}function Na(a,b){var c=B(b),d=md(a,c);d&&!d.text?d=null:d&&d.changes&&(ue(a,d,c,nd(a)),a.curOp.forceUpdate=!0);if(!d){var e;
e=na(b);d=B(e);e=a.display.externalMeasured=new te(a.doc,e,d);e.lineN=d;d=e.built=re(a,e);e.text=d.pre;Z(a.display.lineMeasure,d.pre);d=e}c=Ae(d,b,c);return{line:b,view:d,rect:null,map:c.map,cache:c.cache,before:c.before,hasHeights:!1}}function ia(a,b,c,d,e){b.before&&(c=-1);var f=c+(d||"");if(b.cache.hasOwnProperty(f))a=b.cache[f];else{b.rect||(b.rect=b.view.text.getBoundingClientRect());if(!b.hasHeights){var g=b.view,h=b.rect,k=a.options.lineWrapping,l=k&&La(a);if(!g.measure.heights||k&&g.measure.width!=
l){var m=g.measure.heights=[];if(k)for(g.measure.width=l,g=g.text.firstChild.getClientRects(),k=0;k<g.length-1;k++){var l=g[k],p=g[k+1];2<Math.abs(l.bottom-p.bottom)&&m.push((l.bottom+p.top)/2-h.top)}m.push(h.bottom-h.top)}b.hasHeights=!0}m=d;g=Be(b.map,c,m);d=g.node;h=g.start;k=g.end;c=g.collapse;var n;if(3==d.nodeType){for(var r=0;4>r;r++){for(;h&&Sc(b.line.text.charAt(g.coverStart+h));)--h;for(;g.coverStart+k<g.coverEnd&&Sc(b.line.text.charAt(g.coverStart+k));)++k;if(A&&9>D&&0==h&&k==g.coverEnd-
g.coverStart)n=d.parentNode.getBoundingClientRect();else{n=db(d,h,k).getClientRects();k=Ce;if("left"==m)for(l=0;l<n.length&&(k=n[l]).left==k.right;l++);else for(l=n.length-1;0<=l&&(k=n[l]).left==k.right;l--);n=k}if(n.left||n.right||0==h)break;k=h;--h;c="right"}A&&11>D&&((r=!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI)||(null!=od?r=od:(m=Z(a.display.measure,u("span","x")),r=m.getBoundingClientRect(),m=db(m,0,1).getBoundingClientRect(),r=od=1<Math.abs(r.left-m.left)),
r=!r),r||(r=screen.logicalXDPI/screen.deviceXDPI,m=screen.logicalYDPI/screen.deviceYDPI,n={left:n.left*r,right:n.right*r,top:n.top*m,bottom:n.bottom*m}))}else 0<h&&(c=m="right"),n=a.options.lineWrapping&&1<(r=d.getClientRects()).length?r["right"==m?r.length-1:0]:d.getBoundingClientRect();!(A&&9>D)||h||n&&(n.left||n.right)||(n=(n=d.parentNode.getClientRects()[0])?{left:n.left,right:n.left+Cb(a.display),top:n.top,bottom:n.bottom}:Ce);d=n.top-b.rect.top;h=n.bottom-b.rect.top;r=(d+h)/2;m=b.view.measure.heights;
for(g=0;g<m.length-1&&!(r<m[g]);g++);c={left:("right"==c?n.right:n.left)-b.rect.left,right:("left"==c?n.left:n.right)-b.rect.left,top:g?m[g-1]:0,bottom:m[g]};n.left||n.right||(c.bogus=!0);a.options.singleCursorHeightPerLine||(c.rtop=d,c.rbottom=h);a=c;a.bogus||(b.cache[f]=a)}return{left:a.left,right:a.right,top:e?a.rtop:a.top,bottom:e?a.rbottom:a.bottom}}function Be(a,b,c){for(var d,e,f,g,h,k,l=0;l<a.length;l+=3){h=a[l];k=a[l+1];if(b<h)e=0,f=1,g="left";else if(b<k)e=b-h,f=e+1;else if(l==a.length-
3||b==k&&a[l+3]>b)f=k-h,e=f-1,b>=k&&(g="right");if(null!=e){d=a[l+2];h==k&&c==(d.insertLeft?"left":"right")&&(g=c);if("left"==c&&0==e)for(;l&&a[l-2]==a[l-3]&&a[l-1].insertLeft;)d=a[(l-=3)+2],g="left";if("right"==c&&e==k-h)for(;l<a.length-3&&a[l+3]==a[l+4]&&!a[l+5].insertLeft;)d=a[(l+=3)+2],g="right";break}}return{node:d,start:e,end:f,collapse:g,coverStart:h,coverEnd:k}}function De(a){if(a.measure&&(a.measure.cache={},a.measure.heights=null,a.rest))for(var b=0;b<a.rest.length;b++)a.measure.caches[b]=
{}}function Ee(a){a.display.externalMeasure=null;ea(a.display.lineMeasure);for(var b=0;b<a.display.view.length;b++)De(a.display.view[b])}function Db(a){Ee(a);a.display.cachedCharWidth=a.display.cachedTextHeight=a.display.cachedPaddingH=null;a.options.lineWrapping||(a.display.maxLineChanged=!0);a.display.lineNumChars=null}function Fe(){return qc&&rc?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}
function Ge(){return qc&&rc?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function pd(a){var b=0;if(a.widgets)for(var c=0;c<a.widgets.length;++c)a.widgets[c].above&&(b+=Bb(a.widgets[c]));return b}function sc(a,b,c,d,e){e||(e=pd(b),c.top+=e,c.bottom+=e);if("line"==d)return c;d||(d="local");b=oa(b);b="local"==d?b+a.display.lineSpace.offsetTop:b-a.display.viewOffset;if("page"==d||
"window"==d)a=a.display.lineSpace.getBoundingClientRect(),b+=a.top+("window"==d?0:Ge()),d=a.left+("window"==d?0:Fe()),c.left+=d,c.right+=d;c.top+=b;c.bottom+=b;return c}function He(a,b,c){if("div"==c)return b;var d=b.left;b=b.top;"page"==c?(d-=Fe(),b-=Ge()):"local"!=c&&c||(c=a.display.sizer.getBoundingClientRect(),d+=c.left,b+=c.top);a=a.display.lineSpace.getBoundingClientRect();return{left:d-a.left,top:b-a.top}}function qd(a,b,c,d,e){d||(d=t(a.doc,b.line));var f=d;b=b.ch;d=ia(a,Na(a,d),b,e);return sc(a,
f,d,c)}function ja(a,b,c,d,e,f){function g(b,g){var h=ia(a,e,b,g?"right":"left",f);g?h.left=h.right:h.right=h.left;return sc(a,d,h,c)}function h(a,b,d){return g(d?a-1:a,1==k[b].level!=d)}d=d||t(a.doc,b.line);e||(e=Na(a,d));var k=ua(d,a.doc.direction),l=b.ch;b=b.sticky;l>=d.text.length?(l=d.text.length,b="before"):0>=l&&(l=0,b="after");if(!k)return g("before"==b?l-1:l,"before"==b);var m=vb(k,l,b),p=wb,m=h(l,m,"before"==b);null!=p&&(m.other=h(l,p,"before"!=b));return m}function Ie(a,b){var c=0;b=x(a.doc,
b);a.options.lineWrapping||(c=Cb(a.display)*b.ch);var d=t(a.doc,b.line),e=oa(d)+a.display.lineSpace.offsetTop;return{left:c,right:c,top:e,bottom:e+d.height}}function rd(a,b,c,d,e){a=q(a,b,c);a.xRel=e;d&&(a.outside=!0);return a}function sd(a,b,c){var d=a.doc;c+=a.display.viewOffset;if(0>c)return rd(d.first,0,null,!0,-1);var e=Ja(d,c),f=d.first+d.size-1;if(e>f)return rd(d.first+d.size-1,t(d,f).text.length,null,!0,1);0>b&&(b=0);for(var g=t(d,e);;){var f=Cg(a,g,e,b,c),h;h=f.ch+(0<f.xRel?1:0);var g=ta&&
g.markedSpans,k=void 0;if(g)for(var l=0;l<g.length;++l){var m=g[l];m.marker.collapsed&&(null==m.from||m.from<h)&&(null==m.to||m.to>h)&&(!k||0>Yc(k,m.marker))&&(k=m.marker)}h=k;if(!h)return f;f=h.find(1);if(f.line==e)return f;g=t(d,e=f.line)}}function Je(a,b,c,d){d-=pd(b);b=b.text.length;var e=rb(function(b){return ia(a,c,b-1).bottom<=d},b,0);b=rb(function(b){return ia(a,c,b).top>d},e,b);return{begin:e,end:b}}function Ke(a,b,c,d){c||(c=Na(a,b));d=sc(a,b,ia(a,c,d),"line").top;return Je(a,b,c,d)}function td(a,
b,c,d){return a.bottom<=c?!1:a.top>c?!0:(d?a.left:a.right)>b}function Cg(a,b,c,d,e){e-=oa(b);var f=Na(a,b),g=pd(b),h=0,k=b.text.length,l=!0,m=ua(b,a.doc.direction);m&&(m=(a.options.lineWrapping?Dg:Eg)(a,b,c,f,m,d,e),h=(l=1!=m.level)?m.from:m.to-1,k=l?m.to:m.from-1);var p=null,n=null,m=rb(function(b){var c=ia(a,f,b);c.top+=g;c.bottom+=g;if(!td(c,d,e,!1))return!1;c.top<=e&&c.left<=d&&(p=b,n=c);return!0},h,k),r=!1;n?(h=d-n.left<n.right-d,l=h==l,m=p+(l?0:1),l=l?"after":"before",h=h?n.left:n.right):(l||
m!=k&&m!=h||m++,l=0==m?"after":m==b.text.length?"before":ia(a,f,m-(l?1:0)).bottom+g<=e==l?"after":"before",r=ja(a,q(c,m,l),"line",b,f),h=r.left,r=e<r.top||e>=r.bottom);m=Zd(b.text,m,1);return rd(c,m,l,r,d-h)}function Eg(a,b,c,d,e,f,g){var h=rb(function(h){h=e[h];var k=1!=h.level;return td(ja(a,q(c,k?h.to:h.from,k?"before":"after"),"line",b,d),f,g,!0)},0,e.length-1),k=e[h];if(0<h){var l=1!=k.level,l=ja(a,q(c,l?k.from:k.to,l?"after":"before"),"line",b,d);td(l,f,g,!0)&&l.top>g&&(k=e[h-1])}return k}function Dg(a,
b,c,d,e,f,g){g=Je(a,b,d,g);c=g.begin;g=g.end;/\s/.test(b.text.charAt(g-1))&&g--;for(var h=b=null,k=0;k<e.length;k++){var l=e[k];if(!(l.from>=g||l.to<=c)){var m=ia(a,d,1!=l.level?Math.min(g,l.to)-1:Math.max(c,l.from)).right,m=m<f?f-m+1E9:m-f;if(!b||h>m)b=l,h=m}}b||(b=e[e.length-1]);b.from<c&&(b={from:c,to:b.to,level:b.level});b.to>g&&(b={from:b.from,to:g,level:b.level});return b}function Oa(a){if(null!=a.cachedTextHeight)return a.cachedTextHeight;if(null==Pa){Pa=u("pre");for(var b=0;49>b;++b)Pa.appendChild(document.createTextNode("x")),
Pa.appendChild(u("br"));Pa.appendChild(document.createTextNode("x"))}Z(a.measure,Pa);b=Pa.offsetHeight/50;3<b&&(a.cachedTextHeight=b);ea(a.measure);return b||1}function Cb(a){if(null!=a.cachedCharWidth)return a.cachedCharWidth;var b=u("span","xxxxxxxxxx"),c=u("pre",[b]);Z(a.measure,c);b=b.getBoundingClientRect();b=(b.right-b.left)/10;2<b&&(a.cachedCharWidth=b);return b||10}function nd(a){for(var b=a.display,c={},d={},e=b.gutters.clientLeft,f=b.gutters.firstChild,g=0;f;f=f.nextSibling,++g)c[a.options.gutters[g]]=
f.offsetLeft+f.clientLeft+e,d[a.options.gutters[g]]=f.clientWidth;return{fixedPos:ud(b),gutterTotalWidth:b.gutters.offsetWidth,gutterLeft:c,gutterWidth:d,wrapperWidth:b.wrapper.clientWidth}}function ud(a){return a.scroller.getBoundingClientRect().left-a.sizer.getBoundingClientRect().left}function Le(a){var b=Oa(a.display),c=a.options.lineWrapping,d=c&&Math.max(5,a.display.scroller.clientWidth/Cb(a.display)-3);return function(e){if(za(a.doc,e))return 0;var f=0;if(e.widgets)for(var g=0;g<e.widgets.length;g++)e.widgets[g].height&&
(f+=e.widgets[g].height);return c?f+(Math.ceil(e.text.length/d)||1)*b:f+b}}function vd(a){var b=a.doc,c=Le(a);b.iter(function(a){var b=c(a);b!=a.height&&ma(a,b)})}function Qa(a,b,c,d){var e=a.display;if(!c&&"true"==(b.target||b.srcElement).getAttribute("cm-not-content"))return null;var f,g;c=e.lineSpace.getBoundingClientRect();try{f=b.clientX-c.left,g=b.clientY-c.top}catch(k){return null}b=sd(a,f,g);var h;d&&1==b.xRel&&(h=t(a.doc,b.line).text).length==b.ch&&(d=fa(h,h.length,a.options.tabSize)-h.length,
b=q(b.line,Math.max(0,Math.round((f-ze(a.display).left)/Cb(a.display))-d)));return b}function Ma(a,b){if(b>=a.display.viewTo)return null;b-=a.display.viewFrom;if(0>b)return null;for(var c=a.display.view,d=0;d<c.length;d++)if(b-=c[d].size,0>b)return d}function Eb(a){a.display.input.showSelection(a.display.input.prepareSelection())}function Me(a,b){void 0===b&&(b=!0);for(var c=a.doc,d={},e=d.cursors=document.createDocumentFragment(),f=d.selection=document.createDocumentFragment(),g=0;g<c.sel.ranges.length;g++)if(b||
g!=c.sel.primIndex){var h=c.sel.ranges[g];if(!(h.from().line>=a.display.viewTo||h.to().line<a.display.viewFrom)){var k=h.empty();(k||a.options.showCursorWhenSelecting)&&Ne(a,h.head,e);k||Fg(a,h,f)}}return d}function Ne(a,b,c){b=ja(a,b,"div",null,null,!a.options.singleCursorHeightPerLine);var d=c.appendChild(u("div"," ","CodeMirror-cursor"));d.style.left=b.left+"px";d.style.top=b.top+"px";d.style.height=Math.max(0,b.bottom-b.top)*a.options.cursorHeight+"px";b.other&&(a=c.appendChild(u("div"," ","CodeMirror-cursor CodeMirror-secondarycursor")),
a.style.display="",a.style.left=b.other.left+"px",a.style.top=b.other.top+"px",a.style.height=.85*(b.other.bottom-b.other.top)+"px")}function tc(a,b){return a.top-b.top||a.left-b.left}function Fg(a,b,c){function d(a,b,d,c){0>b&&(b=0);b=Math.round(b);c=Math.round(c);h.appendChild(u("div",null,"CodeMirror-selected","position: absolute; left: "+a+"px;\n                             top: "+b+"px; width: "+(null==d?m-a:d)+"px;\n                             height: "+(c-b)+"px"))}function e(b,c,e){function f(c,
d){return qd(a,q(b,c),"div",k,d)}function h(b,c,d){b=Ke(a,k,null,b);c="ltr"==c==("after"==d)?"left":"right";d="after"==d?b.begin:b.end-(/\s/.test(k.text.charAt(b.end-1))?2:1);return f(d,c)[c]}var k=t(g,b),n=k.text.length,u,v,y=ua(k,g.direction);ng(y,c||0,null==e?n:e,function(a,b,g,k){var r="ltr"==g,q=f(a,r?"left":"right"),t=f(b-1,r?"right":"left"),x=null==c&&0==a,w=null==e&&b==n,z=0==k;k=!y||k==y.length-1;3>=t.top-q.top?(b=(p?x:w)&&z?l:(r?q:t).left,d(b,q.top,((p?w:x)&&k?m:(r?t:q).right)-b,q.bottom)):
(r?(r=p&&x&&z?l:q.left,x=p?m:h(a,g,"before"),a=p?l:h(b,g,"after"),w=p&&w&&k?m:t.right):(r=p?h(a,g,"before"):l,x=!p&&x&&z?m:q.right,a=!p&&w&&k?l:t.left,w=p?h(b,g,"after"):m),d(r,q.top,x-r,q.bottom),q.bottom<t.top&&d(l,q.bottom,null,t.top),d(a,t.top,w-a,t.bottom));if(!u||0>tc(q,u))u=q;0>tc(t,u)&&(u=t);if(!v||0>tc(q,v))v=q;0>tc(t,v)&&(v=t)});return{start:u,end:v}}var f=a.display,g=a.doc,h=document.createDocumentFragment(),k=ze(a.display),l=k.left,m=Math.max(f.sizerWidth,La(a)-f.sizer.offsetLeft)-k.right,
p="ltr"==g.direction,f=b.from();b=b.to();if(f.line==b.line)e(f.line,f.ch,b.ch);else{var n=t(g,f.line),k=t(g,b.line),k=na(n)==na(k),f=e(f.line,f.ch,k?n.text.length+1:null).end;b=e(b.line,k?0:null,b.ch).start;k&&(f.top<b.top-2?(d(f.right,f.top,null,f.bottom),d(l,b.top,b.left,b.bottom)):d(f.right,f.top,b.left-f.right,f.bottom));f.bottom<b.top&&d(l,f.bottom,null,b.top)}c.appendChild(h)}function wd(a){if(a.state.focused){var b=a.display;clearInterval(b.blinker);var c=!0;b.cursorDiv.style.visibility="";
0<a.options.cursorBlinkRate?b.blinker=setInterval(function(){return b.cursorDiv.style.visibility=(c=!c)?"":"hidden"},a.options.cursorBlinkRate):0>a.options.cursorBlinkRate&&(b.cursorDiv.style.visibility="hidden")}}function Oe(a){a.state.focused||(a.display.input.focus(),xd(a))}function Pe(a){a.state.delayingBlurEvent=!0;setTimeout(function(){a.state.delayingBlurEvent&&(a.state.delayingBlurEvent=!1,Fb(a))},100)}function xd(a,b){a.state.delayingBlurEvent&&(a.state.delayingBlurEvent=!1);"nocursor"!=
a.options.readOnly&&(a.state.focused||(F(a,"focus",a,b),a.state.focused=!0,Ga(a.display.wrapper,"CodeMirror-focused"),a.curOp||a.display.selForContextMenu==a.doc.sel||(a.display.input.reset(),P&&setTimeout(function(){return a.display.input.reset(!0)},20)),a.display.input.receivedFocus()),wd(a))}function Fb(a,b){a.state.delayingBlurEvent||(a.state.focused&&(F(a,"blur",a,b),a.state.focused=!1,Ra(a.display.wrapper,"CodeMirror-focused")),clearInterval(a.display.blinker),setTimeout(function(){a.state.focused||
(a.display.shift=!1)},150))}function uc(a){a=a.display;for(var b=a.lineDiv.offsetTop,c=0;c<a.view.length;c++){var d=a.view[c],e=void 0;if(!d.hidden){if(A&&8>D)var f=d.node.offsetTop+d.node.offsetHeight,e=f-b,b=f;else e=d.node.getBoundingClientRect(),e=e.bottom-e.top;f=d.line.height-e;2>e&&(e=Oa(a));if(.005<f||-.005>f)if(ma(d.line,e),Qe(d.line),d.rest)for(e=0;e<d.rest.length;e++)Qe(d.rest[e])}}}function Qe(a){if(a.widgets)for(var b=0;b<a.widgets.length;++b){var c=a.widgets[b],d=c.node.parentNode;d&&
(c.height=d.offsetHeight)}}function yd(a,b,c){var d=c&&null!=c.top?Math.max(0,c.top):a.scroller.scrollTop,d=Math.floor(d-a.lineSpace.offsetTop),e=c&&null!=c.bottom?c.bottom:d+a.wrapper.clientHeight,d=Ja(b,d),e=Ja(b,e);if(c&&c.ensure){var f=c.ensure.from.line;c=c.ensure.to.line;f<d?(d=f,e=Ja(b,oa(t(b,f))+a.wrapper.clientHeight)):Math.min(c,b.lastLine())>=e&&(d=Ja(b,oa(t(b,c))-a.wrapper.clientHeight),e=c)}return{from:d,to:Math.max(e,d+1)}}function Re(a){var b=a.display,c=b.view;if(b.alignWidgets||b.gutters.firstChild&&
a.options.fixedGutter){for(var d=ud(b)-b.scroller.scrollLeft+a.doc.scrollLeft,e=b.gutters.offsetWidth,f=d+"px",g=0;g<c.length;g++)if(!c[g].hidden){a.options.fixedGutter&&(c[g].gutter&&(c[g].gutter.style.left=f),c[g].gutterBackground&&(c[g].gutterBackground.style.left=f));var h=c[g].alignable;if(h)for(var k=0;k<h.length;k++)h[k].style.left=f}a.options.fixedGutter&&(b.gutters.style.left=d+e+"px")}}function Se(a){if(!a.options.lineNumbers)return!1;var b=a.doc,b=Uc(a.options,b.first+b.size-1),c=a.display;
if(b.length!=c.lineNumChars){var d=c.measure.appendChild(u("div",[u("div",b)],"CodeMirror-linenumber CodeMirror-gutter-elt")),e=d.firstChild.offsetWidth,d=d.offsetWidth-e;c.lineGutter.style.width="";c.lineNumInnerWidth=Math.max(e,c.lineGutter.offsetWidth-d)+1;c.lineNumWidth=c.lineNumInnerWidth+d;c.lineNumChars=c.lineNumInnerWidth?b.length:-1;c.lineGutter.style.width=c.lineNumWidth+"px";zd(a);return!0}return!1}function Ad(a,b){var c=a.display,d=Oa(a.display);0>b.top&&(b.top=0);var e=a.curOp&&null!=
a.curOp.scrollTop?a.curOp.scrollTop:c.scroller.scrollTop,f=ld(a),g={};b.bottom-b.top>f&&(b.bottom=b.top+f);var h=a.doc.height+kd(c),k=b.top<d,d=b.bottom>h-d;b.top<e?g.scrollTop=k?0:b.top:b.bottom>e+f&&(f=Math.min(b.top,(d?h:b.bottom)-f),f!=e&&(g.scrollTop=f));e=a.curOp&&null!=a.curOp.scrollLeft?a.curOp.scrollLeft:c.scroller.scrollLeft;c=La(a)-(a.options.fixedGutter?c.gutters.offsetWidth:0);if(f=b.right-b.left>c)b.right=b.left+c;10>b.left?g.scrollLeft=0:b.left<e?g.scrollLeft=Math.max(0,b.left-(f?0:
10)):b.right>c+e-3&&(g.scrollLeft=b.right+(f?0:10)-c);return g}function vc(a,b){null!=b&&(wc(a),a.curOp.scrollTop=(null==a.curOp.scrollTop?a.doc.scrollTop:a.curOp.scrollTop)+b)}function fb(a){wc(a);var b=a.getCursor();a.curOp.scrollToPos={from:b,to:b,margin:a.options.cursorScrollMargin}}function Gb(a,b,c){null==b&&null==c||wc(a);null!=b&&(a.curOp.scrollLeft=b);null!=c&&(a.curOp.scrollTop=c)}function wc(a){var b=a.curOp.scrollToPos;if(b){a.curOp.scrollToPos=null;var c=Ie(a,b.from),d=Ie(a,b.to);Te(a,
c,d,b.margin)}}function Te(a,b,c,d){b=Ad(a,{left:Math.min(b.left,c.left),top:Math.min(b.top,c.top)-d,right:Math.max(b.right,c.right),bottom:Math.max(b.bottom,c.bottom)+d});Gb(a,b.scrollLeft,b.scrollTop)}function Hb(a,b){2>Math.abs(a.doc.scrollTop-b)||(ya||Bd(a,{top:b}),Ue(a,b,!0),ya&&Bd(a),Ib(a,100))}function Ue(a,b,c){b=Math.min(a.display.scroller.scrollHeight-a.display.scroller.clientHeight,b);if(a.display.scroller.scrollTop!=b||c)a.doc.scrollTop=b,a.display.scrollbars.setScrollTop(b),a.display.scroller.scrollTop!=
b&&(a.display.scroller.scrollTop=b)}function Sa(a,b,c,d){b=Math.min(b,a.display.scroller.scrollWidth-a.display.scroller.clientWidth);(c?b==a.doc.scrollLeft:2>Math.abs(a.doc.scrollLeft-b))&&!d||(a.doc.scrollLeft=b,Re(a),a.display.scroller.scrollLeft!=b&&(a.display.scroller.scrollLeft=b),a.display.scrollbars.setScrollLeft(b))}function Jb(a){var b=a.display,c=b.gutters.offsetWidth,d=Math.round(a.doc.height+kd(a.display));return{clientHeight:b.scroller.clientHeight,viewHeight:b.wrapper.clientHeight,scrollWidth:b.scroller.scrollWidth,
clientWidth:b.scroller.clientWidth,viewWidth:b.wrapper.clientWidth,barLeft:a.options.fixedGutter?c:0,docHeight:d,scrollHeight:d+qa(a)+b.barHeight,nativeBarWidth:b.nativeBarWidth,gutterWidth:c}}function gb(a,b){b||(b=Jb(a));var c=a.display.barWidth,d=a.display.barHeight;Ve(a,b);for(var e=0;4>e&&c!=a.display.barWidth||d!=a.display.barHeight;e++)c!=a.display.barWidth&&a.options.lineWrapping&&uc(a),Ve(a,Jb(a)),c=a.display.barWidth,d=a.display.barHeight}function Ve(a,b){var c=a.display,d=c.scrollbars.update(b);
c.sizer.style.paddingRight=(c.barWidth=d.right)+"px";c.sizer.style.paddingBottom=(c.barHeight=d.bottom)+"px";c.heightForcer.style.borderBottom=d.bottom+"px solid transparent";d.right&&d.bottom?(c.scrollbarFiller.style.display="block",c.scrollbarFiller.style.height=d.bottom+"px",c.scrollbarFiller.style.width=d.right+"px"):c.scrollbarFiller.style.display="";d.bottom&&a.options.coverGutterNextToScrollbar&&a.options.fixedGutter?(c.gutterFiller.style.display="block",c.gutterFiller.style.height=d.bottom+
"px",c.gutterFiller.style.width=b.gutterWidth+"px"):c.gutterFiller.style.display=""}function We(a){a.display.scrollbars&&(a.display.scrollbars.clear(),a.display.scrollbars.addClass&&Ra(a.display.wrapper,a.display.scrollbars.addClass));a.display.scrollbars=new Xe[a.options.scrollbarStyle](function(b){a.display.wrapper.insertBefore(b,a.display.scrollbarFiller);v(b,"mousedown",function(){a.state.focused&&setTimeout(function(){return a.display.input.focus()},0)});b.setAttribute("cm-not-content","true")},
function(b,c){"horizontal"==c?Sa(a,b):Hb(a,b)},a);a.display.scrollbars.addClass&&Ga(a.display.wrapper,a.display.scrollbars.addClass)}function Ta(a){a.curOp={cm:a,viewChanged:!1,startHeight:a.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++Gg};a=a.curOp;eb?eb.ops.push(a):a.ownsGroup=eb={ops:[a],delayedCallbacks:[]}}function Ua(a){zg(a.curOp,
function(a){for(var c=0;c<a.ops.length;c++)a.ops[c].cm.curOp=null;a=a.ops;for(c=0;c<a.length;c++){var d=a[c],e=d.cm,f=e.display,g=e.display;!g.scrollbarsClipped&&g.scroller.offsetWidth&&(g.nativeBarWidth=g.scroller.offsetWidth-g.scroller.clientWidth,g.heightForcer.style.height=qa(e)+"px",g.sizer.style.marginBottom=-g.nativeBarWidth+"px",g.sizer.style.borderRightWidth=qa(e)+"px",g.scrollbarsClipped=!0);d.updateMaxLine&&ad(e);d.mustUpdate=d.viewChanged||d.forceUpdate||null!=d.scrollTop||d.scrollToPos&&
(d.scrollToPos.from.line<f.viewFrom||d.scrollToPos.to.line>=f.viewTo)||f.maxLineChanged&&e.options.lineWrapping;d.update=d.mustUpdate&&new xc(e,d.mustUpdate&&{top:d.scrollTop,ensure:d.scrollToPos},d.forceUpdate)}for(c=0;c<a.length;c++)d=a[c],d.updatedDisplay=d.mustUpdate&&Cd(d.cm,d.update);for(c=0;c<a.length;c++)if(d=a[c],e=d.cm,f=e.display,d.updatedDisplay&&uc(e),d.barMeasure=Jb(e),f.maxLineChanged&&!e.options.lineWrapping&&(g=void 0,g=f.maxLine.text.length,g=ia(e,Na(e,f.maxLine),g,void 0),d.adjustWidthTo=
g.left+3,e.display.sizerWidth=d.adjustWidthTo,d.barMeasure.scrollWidth=Math.max(f.scroller.clientWidth,f.sizer.offsetLeft+d.adjustWidthTo+qa(e)+e.display.barWidth),d.maxScrollLeft=Math.max(0,f.sizer.offsetLeft+d.adjustWidthTo-La(e))),d.updatedDisplay||d.selectionChanged)d.preparedSelection=f.input.prepareSelection();for(c=0;c<a.length;c++)d=a[c],e=d.cm,null!=d.adjustWidthTo&&(e.display.sizer.style.minWidth=d.adjustWidthTo+"px",d.maxScrollLeft<e.doc.scrollLeft&&Sa(e,Math.min(e.display.scroller.scrollLeft,
d.maxScrollLeft),!0),e.display.maxLineChanged=!1),f=d.focus&&d.focus==sa(),d.preparedSelection&&e.display.input.showSelection(d.preparedSelection,f),(d.updatedDisplay||d.startHeight!=e.doc.height)&&gb(e,d.barMeasure),d.updatedDisplay&&Dd(e,d.barMeasure),d.selectionChanged&&wd(e),e.state.focused&&d.updateInput&&e.display.input.reset(d.typing),f&&Oe(d.cm);for(c=0;c<a.length;c++){d=a[c];e=d.cm;f=e.display;g=e.doc;d.updatedDisplay&&Ye(e,d.update);null==f.wheelStartX||null==d.scrollTop&&null==d.scrollLeft&&
!d.scrollToPos||(f.wheelStartX=f.wheelStartY=null);null!=d.scrollTop&&Ue(e,d.scrollTop,d.forceScroll);null!=d.scrollLeft&&Sa(e,d.scrollLeft,!0,!0);if(d.scrollToPos){var h=x(g,d.scrollToPos.from),k=x(g,d.scrollToPos.to),l=d.scrollToPos.margin;null==l&&(l=0);var m=void 0;e.options.lineWrapping||h!=k||(h=h.ch?q(h.line,"before"==h.sticky?h.ch-1:h.ch,"after"):h,k="before"==h.sticky?q(h.line,h.ch+1,"before"):h);for(var p=0;5>p;p++){var n=!1,m=ja(e,h),r=k&&k!=h?ja(e,k):m,m={left:Math.min(m.left,r.left),
top:Math.min(m.top,r.top)-l,right:Math.max(m.left,r.left),bottom:Math.max(m.bottom,r.bottom)+l},r=Ad(e,m),W=e.doc.scrollTop,t=e.doc.scrollLeft;null!=r.scrollTop&&(Hb(e,r.scrollTop),1<Math.abs(e.doc.scrollTop-W)&&(n=!0));null!=r.scrollLeft&&(Sa(e,r.scrollLeft),1<Math.abs(e.doc.scrollLeft-t)&&(n=!0));if(!n)break}k=m;I(e,"scrollCursorIntoView")||(l=e.display,p=l.sizer.getBoundingClientRect(),h=null,0>k.top+p.top?h=!0:k.bottom+p.top>(window.innerHeight||document.documentElement.clientHeight)&&(h=!1),
null==h||Hg||(k=u("div","​",null,"position: absolute;\n                         top: "+(k.top-l.viewOffset-e.display.lineSpace.offsetTop)+"px;\n                         height: "+(k.bottom-k.top+qa(e)+l.barHeight)+"px;\n                         left: "+k.left+"px; width: "+Math.max(2,k.right-k.left)+"px;"),e.display.lineSpace.appendChild(k),k.scrollIntoView(h),e.display.lineSpace.removeChild(k)))}k=d.maybeHiddenMarkers;h=d.maybeUnhiddenMarkers;if(k)for(l=0;l<k.length;++l)k[l].lines.length||F(k[l],
"hide");if(h)for(k=0;k<h.length;++k)h[k].lines.length&&F(h[k],"unhide");f.wrapper.offsetHeight&&(g.scrollTop=e.display.scroller.scrollTop);d.changeObjs&&F(e,"changes",e,d.changeObjs);d.update&&d.update.finish()}})}function Y(a,b){if(a.curOp)return b();Ta(a);try{return b()}finally{Ua(a)}}function J(a,b){return function(){if(a.curOp)return b.apply(a,arguments);Ta(a);try{return b.apply(a,arguments)}finally{Ua(a)}}}function R(a){return function(){if(this.curOp)return a.apply(this,arguments);Ta(this);
try{return a.apply(this,arguments)}finally{Ua(this)}}}function K(a){return function(){var b=this.cm;if(!b||b.curOp)return a.apply(this,arguments);Ta(b);try{return a.apply(this,arguments)}finally{Ua(b)}}}function U(a,b,c,d){null==b&&(b=a.doc.first);null==c&&(c=a.doc.first+a.doc.size);d||(d=0);var e=a.display;d&&c<e.viewTo&&(null==e.updateLineNumbers||e.updateLineNumbers>b)&&(e.updateLineNumbers=b);a.curOp.viewChanged=!0;if(b>=e.viewTo)ta&&Zc(a.doc,b)<e.viewTo&&Aa(a);else if(c<=e.viewFrom)ta&&ee(a.doc,
c+d)>e.viewFrom?Aa(a):(e.viewFrom+=d,e.viewTo+=d);else if(b<=e.viewFrom&&c>=e.viewTo)Aa(a);else if(b<=e.viewFrom){var f=yc(a,c,c+d,1);f?(e.view=e.view.slice(f.index),e.viewFrom=f.lineN,e.viewTo+=d):Aa(a)}else if(c>=e.viewTo)(f=yc(a,b,b,-1))?(e.view=e.view.slice(0,f.index),e.viewTo=f.lineN):Aa(a);else{var f=yc(a,b,b,-1),g=yc(a,c,c+d,1);f&&g?(e.view=e.view.slice(0,f.index).concat(pc(a,f.lineN,g.lineN)).concat(e.view.slice(g.index)),e.viewTo+=d):Aa(a)}if(a=e.externalMeasured)c<a.lineN?a.lineN+=d:b<a.lineN+
a.size&&(e.externalMeasured=null)}function Ba(a,b,c){a.curOp.viewChanged=!0;var d=a.display,e=a.display.externalMeasured;e&&b>=e.lineN&&b<e.lineN+e.size&&(d.externalMeasured=null);b<d.viewFrom||b>=d.viewTo||(a=d.view[Ma(a,b)],null!=a.node&&(a=a.changes||(a.changes=[]),-1==L(a,c)&&a.push(c)))}function Aa(a){a.display.viewFrom=a.display.viewTo=a.doc.first;a.display.view=[];a.display.viewOffset=0}function yc(a,b,c,d){var e=Ma(a,b),f=a.display.view;if(!ta||c==a.doc.first+a.doc.size)return{index:e,lineN:c};
for(var g=a.display.viewFrom,h=0;h<e;h++)g+=f[h].size;if(g!=b){if(0<d){if(e==f.length-1)return null;b=g+f[e].size-b;e++}else b=g-b;c+=b}for(;Zc(a.doc,c)!=c;){if(e==(0>d?0:f.length-1))return null;c+=d*f[e-(0>d?1:0)].size;e+=d}return{index:e,lineN:c}}function Ze(a){a=a.display.view;for(var b=0,c=0;c<a.length;c++){var d=a[c];d.hidden||d.node&&!d.changes||++b}return b}function Ib(a,b){a.doc.highlightFrontier<a.display.viewTo&&a.state.highlight.set(b,Oc(Ig,a))}function Ig(a){var b=a.doc;if(!(b.highlightFrontier>=
a.display.viewTo)){var c=+new Date+a.options.workTime,d=yb(a,b.highlightFrontier),e=[];b.iter(d.line,Math.min(b.first+b.size,a.display.viewTo+500),function(f){if(d.line>=a.display.viewFrom){var g=f.styles,h=f.text.length>a.options.maxHighlightLength?Ka(b.mode,d.state):null,k=je(a,f,d,!0);h&&(d.state=h);f.styles=k.styles;h=f.styleClasses;(k=k.classes)?f.styleClasses=k:h&&(f.styleClasses=null);k=!g||g.length!=f.styles.length||h!=k&&(!h||!k||h.bgClass!=k.bgClass||h.textClass!=k.textClass);for(h=0;!k&&
h<g.length;++h)k=g[h]!=f.styles[h];k&&e.push(d.line);f.stateAfter=d.save()}else f.text.length<=a.options.maxHighlightLength&&gd(a,f.text,d),f.stateAfter=0==d.line%5?d.save():null;d.nextLine();if(+new Date>c)return Ib(a,a.options.workDelay),!0});b.highlightFrontier=d.line;b.modeFrontier=Math.max(b.modeFrontier,d.line);e.length&&Y(a,function(){for(var b=0;b<e.length;b++)Ba(a,e[b],"text")})}}function Cd(a,b){var c=a.display,d=a.doc;if(b.editorIsHidden)return Aa(a),!1;if(!b.force&&b.visible.from>=c.viewFrom&&
b.visible.to<=c.viewTo&&(null==c.updateLineNumbers||c.updateLineNumbers>=c.viewTo)&&c.renderedView==c.view&&0==Ze(a))return!1;Se(a)&&(Aa(a),b.dims=nd(a));var e=d.first+d.size,f=Math.max(b.visible.from-a.options.viewportMargin,d.first),g=Math.min(e,b.visible.to+a.options.viewportMargin);c.viewFrom<f&&20>f-c.viewFrom&&(f=Math.max(d.first,c.viewFrom));c.viewTo>g&&20>c.viewTo-g&&(g=Math.min(e,c.viewTo));ta&&(f=Zc(a.doc,f),g=ee(a.doc,g));d=f!=c.viewFrom||g!=c.viewTo||c.lastWrapHeight!=b.wrapperHeight||
c.lastWrapWidth!=b.wrapperWidth;e=a.display;0==e.view.length||f>=e.viewTo||g<=e.viewFrom?(e.view=pc(a,f,g),e.viewFrom=f):(e.viewFrom>f?e.view=pc(a,f,e.viewFrom).concat(e.view):e.viewFrom<f&&(e.view=e.view.slice(Ma(a,f))),e.viewFrom=f,e.viewTo<g?e.view=e.view.concat(pc(a,e.viewTo,g)):e.viewTo>g&&(e.view=e.view.slice(0,Ma(a,g))));e.viewTo=g;c.viewOffset=oa(t(a.doc,c.viewFrom));a.display.mover.style.top=c.viewOffset+"px";g=Ze(a);if(!d&&0==g&&!b.force&&c.renderedView==c.view&&(null==c.updateLineNumbers||
c.updateLineNumbers>=c.viewTo))return!1;a.hasFocus()?f=null:(f=sa())&&xa(a.display.lineDiv,f)?(f={activeElt:f},window.getSelection&&(e=window.getSelection(),e.anchorNode&&e.extend&&xa(a.display.lineDiv,e.anchorNode)&&(f.anchorNode=e.anchorNode,f.anchorOffset=e.anchorOffset,f.focusNode=e.focusNode,f.focusOffset=e.focusOffset))):f=null;4<g&&(c.lineDiv.style.display="none");Jg(a,c.updateLineNumbers,b.dims);4<g&&(c.lineDiv.style.display="");c.renderedView=c.view;(g=f)&&g.activeElt&&g.activeElt!=sa()&&
(g.activeElt.focus(),g.anchorNode&&xa(document.body,g.anchorNode)&&xa(document.body,g.focusNode)&&(f=window.getSelection(),e=document.createRange(),e.setEnd(g.anchorNode,g.anchorOffset),e.collapse(!1),f.removeAllRanges(),f.addRange(e),f.extend(g.focusNode,g.focusOffset)));ea(c.cursorDiv);ea(c.selectionDiv);c.gutters.style.height=c.sizer.style.minHeight=0;d&&(c.lastWrapHeight=b.wrapperHeight,c.lastWrapWidth=b.wrapperWidth,Ib(a,400));c.updateLineNumbers=null;return!0}function Ye(a,b){for(var c=b.viewport,
d=!0;;d=!1){if(!d||!a.options.lineWrapping||b.oldDisplayWidth==La(a))if(c&&null!=c.top&&(c={top:Math.min(a.doc.height+kd(a.display)-ld(a),c.top)}),b.visible=yd(a.display,a.doc,c),b.visible.from>=a.display.viewFrom&&b.visible.to<=a.display.viewTo)break;if(!Cd(a,b))break;uc(a);d=Jb(a);Eb(a);gb(a,d);Dd(a,d);b.force=!1}b.signal(a,"update",a);if(a.display.viewFrom!=a.display.reportedViewFrom||a.display.viewTo!=a.display.reportedViewTo)b.signal(a,"viewportChange",a,a.display.viewFrom,a.display.viewTo),
a.display.reportedViewFrom=a.display.viewFrom,a.display.reportedViewTo=a.display.viewTo}function Bd(a,b){var c=new xc(a,b);if(Cd(a,c)){uc(a);Ye(a,c);var d=Jb(a);Eb(a);gb(a,d);Dd(a,d);c.finish()}}function Jg(a,b,c){function d(b){var c=b.nextSibling;P&&ha&&a.display.currentWheelTarget==b?b.style.display="none":b.parentNode.removeChild(b);return c}for(var e=a.display,f=a.options.lineNumbers,g=e.lineDiv,h=g.firstChild,k=e.view,e=e.viewFrom,l=0;l<k.length;l++){var m=k[l];if(!m.hidden)if(m.node&&m.node.parentNode==
g){for(;h!=m.node;)h=d(h);h=f&&null!=b&&b<=e&&m.lineNumber;m.changes&&(-1<L(m.changes,"gutter")&&(h=!1),ue(a,m,e,c));h&&(ea(m.lineNumber),m.lineNumber.appendChild(document.createTextNode(Uc(a.options,e))));h=m.node.nextSibling}else{var p=Bg(a,m,e,c);g.insertBefore(p,h)}e+=m.size}for(;h;)h=d(h)}function zd(a){a.display.sizer.style.marginLeft=a.display.gutters.offsetWidth+"px"}function Dd(a,b){a.display.sizer.style.minHeight=b.docHeight+"px";a.display.heightForcer.style.top=b.docHeight+"px";a.display.gutters.style.height=
b.docHeight+a.display.barHeight+qa(a)+"px"}function $e(a){var b=a.display.gutters,c=a.options.gutters;ea(b);for(var d=0;d<c.length;++d){var e=c[d],f=b.appendChild(u("div",null,"CodeMirror-gutter "+e));"CodeMirror-linenumbers"==e&&(a.display.lineGutter=f,f.style.width=(a.display.lineNumWidth||1)+"px")}b.style.display=d?"":"none";zd(a)}function Ed(a){var b=L(a.gutters,"CodeMirror-linenumbers");-1==b&&a.lineNumbers?a.gutters=a.gutters.concat(["CodeMirror-linenumbers"]):-1<b&&!a.lineNumbers&&(a.gutters=
a.gutters.slice(0),a.gutters.splice(b,1))}function af(a){var b=a.wheelDeltaX,c=a.wheelDeltaY;null==b&&a.detail&&a.axis==a.HORIZONTAL_AXIS&&(b=a.detail);null==c&&a.detail&&a.axis==a.VERTICAL_AXIS?c=a.detail:null==c&&(c=a.wheelDelta);return{x:b,y:c}}function Kg(a){a=af(a);a.x*=ba;a.y*=ba;return a}function bf(a,b){var c=af(b),d=c.x,c=c.y,e=a.display,f=e.scroller,g=f.scrollWidth>f.clientWidth,h=f.scrollHeight>f.clientHeight;if(d&&g||c&&h){if(c&&ha&&P){var g=b.target,k=e.view;a:for(;g!=f;g=g.parentNode)for(var l=
0;l<k.length;l++)if(k[l].node==g){a.display.currentWheelTarget=g;break a}}!d||ya||ka||null==ba?(c&&null!=ba&&(h=c*ba,g=a.doc.scrollTop,k=g+e.wrapper.clientHeight,0>h?g=Math.max(0,g+h-50):k=Math.min(a.doc.height,k+h+50),Bd(a,{top:g,bottom:k})),20>zc&&(null==e.wheelStartX?(e.wheelStartX=f.scrollLeft,e.wheelStartY=f.scrollTop,e.wheelDX=d,e.wheelDY=c,setTimeout(function(){if(null!=e.wheelStartX){var a=f.scrollLeft-e.wheelStartX,b=f.scrollTop-e.wheelStartY,a=b&&e.wheelDY&&b/e.wheelDY||a&&e.wheelDX&&a/
e.wheelDX;e.wheelStartX=e.wheelStartY=null;a&&(ba=(ba*zc+a)/(zc+1),++zc)}},200)):(e.wheelDX+=d,e.wheelDY+=c))):(c&&h&&Hb(a,Math.max(0,f.scrollTop+c*ba)),Sa(a,Math.max(0,f.scrollLeft+d*ba)),(!c||c&&h)&&T(b),e.wheelStartX=null)}}function la(a,b){var c=a[b];a.sort(function(a,b){return y(a.from(),b.from())});b=L(a,c);for(c=1;c<a.length;c++){var d=a[c],e=a[c-1];if(0<=y(e.to(),d.from())){var f=jc(e.from(),d.from()),g=ic(e.to(),d.to()),d=e.empty()?d.from()==d.head:e.from()==e.head;c<=b&&--b;a.splice(--c,
2,new z(d?g:f,d?f:g))}}return new ca(a,b)}function wa(a,b){return new ca([new z(a,b||a)],0)}function Ca(a){return a.text?q(a.from.line+a.text.length-1,w(a.text).length+(1==a.text.length?a.from.ch:0)):a.to}function cf(a,b){if(0>y(a,b.from))return a;if(0>=y(a,b.to))return Ca(b);var c=a.line+b.text.length-(b.to.line-b.from.line)-1,d=a.ch;a.line==b.to.line&&(d+=Ca(b).ch-b.to.ch);return q(c,d)}function Fd(a,b){for(var c=[],d=0;d<a.sel.ranges.length;d++){var e=a.sel.ranges[d];c.push(new z(cf(e.anchor,b),
cf(e.head,b)))}return la(c,a.sel.primIndex)}function df(a,b,c){return a.line==b.line?q(c.line,a.ch-b.ch+c.ch):q(c.line+(a.line-b.line),a.ch)}function Gd(a){a.doc.mode=ed(a.options,a.doc.modeOption);Kb(a)}function Kb(a){a.doc.iter(function(a){a.stateAfter&&(a.stateAfter=null);a.styles&&(a.styles=null)});a.doc.modeFrontier=a.doc.highlightFrontier=a.doc.first;Ib(a,100);a.state.modeGen++;a.curOp&&U(a)}function ef(a,b){return 0==b.from.ch&&0==b.to.ch&&""==w(b.text)&&(!a.cm||a.cm.options.wholeLineUpdateBefore)}
function Hd(a,b,c,d){function e(a,c,e){a.text=c;a.stateAfter&&(a.stateAfter=null);a.styles&&(a.styles=null);null!=a.order&&(a.order=null);be(a);ce(a,e);c=d?d(a):1;c!=a.height&&ma(a,c);N(a,"change",a,b)}function f(a,b){for(var e=[],f=a;f<b;++f)e.push(new hb(k[f],c?c[f]:null,d));return e}var g=b.from,h=b.to,k=b.text,l=t(a,g.line),m=t(a,h.line),p=w(k),n=c?c[k.length-1]:null,r=h.line-g.line;b.full?(a.insert(0,f(0,k.length)),a.remove(k.length,a.size-k.length)):ef(a,b)?(h=f(0,k.length-1),e(m,m.text,n),
r&&a.remove(g.line,r),h.length&&a.insert(g.line,h)):l==m?1==k.length?e(l,l.text.slice(0,g.ch)+p+l.text.slice(h.ch),n):(r=f(1,k.length-1),r.push(new hb(p+l.text.slice(h.ch),n,d)),e(l,l.text.slice(0,g.ch)+k[0],c?c[0]:null),a.insert(g.line+1,r)):1==k.length?(e(l,l.text.slice(0,g.ch)+k[0]+m.text.slice(h.ch),c?c[0]:null),a.remove(g.line+1,r)):(e(l,l.text.slice(0,g.ch)+k[0],c?c[0]:null),e(m,p+m.text.slice(h.ch),n),n=f(1,k.length-1),1<r&&a.remove(g.line+1,r-1),a.insert(g.line+1,n));N(a,"change",a,b)}function Va(a,
b,c){function d(a,f,g){if(a.linked)for(var h=0;h<a.linked.length;++h){var k=a.linked[h];if(k.doc!=f){var l=g&&k.sharedHist;if(!c||l)b(k.doc,l),d(k.doc,a,l)}}}d(a,null,!0)}function ff(a,b){if(b.cm)throw Error("This document is already in use.");a.doc=b;b.cm=a;vd(a);Gd(a);gf(a);a.options.lineWrapping||ad(a);a.options.mode=b.modeOption;U(a)}function gf(a){("rtl"==a.doc.direction?Ga:Ra)(a.display.lineDiv,"CodeMirror-rtl")}function Lg(a){Y(a,function(){gf(a);U(a)})}function Ac(a){this.done=[];this.undone=
[];this.undoDepth=Infinity;this.lastModTime=this.lastSelTime=0;this.lastOrigin=this.lastSelOrigin=this.lastOp=this.lastSelOp=null;this.generation=this.maxGeneration=a||1}function Id(a,b){var c={from:Wc(b.from),to:Ca(b),text:Ia(a,b.from,b.to)};hf(a,c,b.from.line,b.to.line+1);Va(a,function(a){return hf(a,c,b.from.line,b.to.line+1)},!0);return c}function jf(a){for(;a.length;)if(w(a).ranges)a.pop();else break}function kf(a,b,c,d){var e=a.history;e.undone.length=0;var f=+new Date,g,h,k;if(k=e.lastOp==
d||e.lastOrigin==b.origin&&b.origin&&("+"==b.origin.charAt(0)&&e.lastModTime>f-(a.cm?a.cm.options.historyEventDelay:500)||"*"==b.origin.charAt(0)))e.lastOp==d?(jf(e.done),g=w(e.done)):e.done.length&&!w(e.done).ranges?g=w(e.done):1<e.done.length&&!e.done[e.done.length-2].ranges?(e.done.pop(),g=w(e.done)):g=void 0,k=g;if(k)h=w(g.changes),0==y(b.from,b.to)&&0==y(b.from,h.to)?h.to=Ca(b):g.changes.push(Id(a,b));else for((g=w(e.done))&&g.ranges||Bc(a.sel,e.done),g={changes:[Id(a,b)],generation:e.generation},
e.done.push(g);e.done.length>e.undoDepth;)e.done.shift(),e.done[0].ranges||e.done.shift();e.done.push(c);e.generation=++e.maxGeneration;e.lastModTime=e.lastSelTime=f;e.lastOp=e.lastSelOp=d;e.lastOrigin=e.lastSelOrigin=b.origin;h||F(a,"historyAdded")}function Bc(a,b){var c=w(b);c&&c.ranges&&c.equals(a)||b.push(a)}function hf(a,b,c,d){var e=b["spans_"+a.id],f=0;a.iter(Math.max(a.first,c),Math.min(a.first+a.size,d),function(c){c.markedSpans&&((e||(e=b["spans_"+a.id]={}))[f]=c.markedSpans);++f})}function Mg(a){if(!a)return null;
for(var b,c=0;c<a.length;++c)a[c].marker.explicitlyCleared?b||(b=a.slice(0,c)):b&&b.push(a[c]);return b?b.length?b:null:a}function lf(a,b){var c;if(c=b["spans_"+a.id]){for(var d=[],e=0;e<b.text.length;++e)d.push(Mg(c[e]));c=d}else c=null;d=Xc(a,b);if(!c)return d;if(!d)return c;for(e=0;e<c.length;++e){var f=c[e],g=d[e];if(f&&g){var h=0;a:for(;h<g.length;++h){for(var k=g[h],l=0;l<f.length;++l)if(f[l].marker==k.marker)continue a;f.push(k)}}else g&&(c[e]=g)}return c}function ib(a,b,c){for(var d=[],e=
0;e<a.length;++e){var f=a[e];if(f.ranges)d.push(c?ca.prototype.deepCopy.call(f):f);else{var f=f.changes,g=[];d.push({changes:g});for(var h=0;h<f.length;++h){var k=f[h],l=void 0;g.push({from:k.from,to:k.to,text:k.text});if(b)for(var m in k)(l=m.match(/^spans_(\d+)$/))&&-1<L(b,Number(l[1]))&&(w(g)[m]=k[m],delete k[m])}}}return d}function Jd(a,b,c,d){return d?(a=a.anchor,c&&(d=0>y(b,a),d!=0>y(c,a)?(a=b,b=c):d!=0>y(b,c)&&(b=c)),new z(a,b)):new z(c||b,b)}function Cc(a,b,c,d,e){null==e&&(e=a.cm&&(a.cm.display.shift||
a.extend));O(a,new ca([Jd(a.sel.primary(),b,c,e)],0),d)}function mf(a,b,c){for(var d=[],e=a.cm&&(a.cm.display.shift||a.extend),f=0;f<a.sel.ranges.length;f++)d[f]=Jd(a.sel.ranges[f],b[f],null,e);b=la(d,a.sel.primIndex);O(a,b,c)}function Kd(a,b,c,d){var e=a.sel.ranges.slice(0);e[b]=c;O(a,la(e,a.sel.primIndex),d)}function Ng(a,b,c){c={ranges:b.ranges,update:function(b){this.ranges=[];for(var c=0;c<b.length;c++)this.ranges[c]=new z(x(a,b[c].anchor),x(a,b[c].head))},origin:c&&c.origin};F(a,"beforeSelectionChange",
a,c);a.cm&&F(a.cm,"beforeSelectionChange",a.cm,c);return c.ranges!=b.ranges?la(c.ranges,c.ranges.length-1):b}function nf(a,b,c){var d=a.history.done,e=w(d);e&&e.ranges?(d[d.length-1]=b,Dc(a,b,c)):O(a,b,c)}function O(a,b,c){Dc(a,b,c);b=a.sel;var d=a.cm?a.cm.curOp.id:NaN,e=a.history,f=c&&c.origin,g;if(!(g=d==e.lastSelOp)&&(g=f&&e.lastSelOrigin==f)&&!(g=e.lastModTime==e.lastSelTime&&e.lastOrigin==f)){g=w(e.done);var h=f.charAt(0);g="*"==h||"+"==h&&g.ranges.length==b.ranges.length&&g.somethingSelected()==
b.somethingSelected()&&new Date-a.history.lastSelTime<=(a.cm?a.cm.options.historyEventDelay:500)}g?e.done[e.done.length-1]=b:Bc(b,e.done);e.lastSelTime=+new Date;e.lastSelOrigin=f;e.lastSelOp=d;c&&!1!==c.clearRedo&&jf(e.undone)}function Dc(a,b,c){if(ga(a,"beforeSelectionChange")||a.cm&&ga(a.cm,"beforeSelectionChange"))b=Ng(a,b,c);var d=c&&c.bias||(0>y(b.primary().head,a.sel.primary().head)?-1:1);of(a,pf(a,b,d,!0));c&&!1===c.scroll||!a.cm||fb(a.cm)}function of(a,b){b.equals(a.sel)||(a.sel=b,a.cm&&
(a.cm.curOp.updateInput=a.cm.curOp.selectionChanged=!0,fe(a.cm)),N(a,"cursorActivity",a))}function qf(a){of(a,pf(a,a.sel,null,!1))}function pf(a,b,c,d){for(var e,f=0;f<b.ranges.length;f++){var g=b.ranges[f],h=b.ranges.length==a.sel.ranges.length&&a.sel.ranges[f],k=Ld(a,g.anchor,h&&h.anchor,c,d),h=Ld(a,g.head,h&&h.head,c,d);if(e||k!=g.anchor||h!=g.head)e||(e=b.ranges.slice(0,f)),e[f]=new z(k,h)}return e?la(e,b.primIndex):b}function jb(a,b,c,d,e){var f=t(a,b.line);if(f.markedSpans)for(var g=0;g<f.markedSpans.length;++g){var h=
f.markedSpans[g],k=h.marker;if((null==h.from||(k.inclusiveLeft?h.from<=b.ch:h.from<b.ch))&&(null==h.to||(k.inclusiveRight?h.to>=b.ch:h.to>b.ch))){if(e&&(F(k,"beforeCursorEnter"),k.explicitlyCleared))if(f.markedSpans){--g;continue}else break;if(k.atomic){if(c){g=k.find(0>d?1:-1);h=void 0;if(0>d?k.inclusiveRight:k.inclusiveLeft)g=rf(a,g,-d,g&&g.line==b.line?f:null);if(g&&g.line==b.line&&(h=y(g,c))&&(0>d?0>h:0<h))return jb(a,g,b,d,e)}c=k.find(0>d?-1:1);if(0>d?k.inclusiveLeft:k.inclusiveRight)c=rf(a,
c,d,c.line==b.line?f:null);return c?jb(a,c,b,d,e):null}}}return b}function Ld(a,b,c,d,e){d=d||1;b=jb(a,b,c,d,e)||!e&&jb(a,b,c,d,!0)||jb(a,b,c,-d,e)||!e&&jb(a,b,c,-d,!0);return b?b:(a.cantEdit=!0,q(a.first,0))}function rf(a,b,c,d){return 0>c&&0==b.ch?b.line>a.first?x(a,q(b.line-1)):null:0<c&&b.ch==(d||t(a,b.line)).text.length?b.line<a.first+a.size-1?q(b.line+1,0):null:new q(b.line,b.ch+c)}function sf(a){a.setSelection(q(a.firstLine(),0),q(a.lastLine()),ra)}function tf(a,b,c){var d={canceled:!1,from:b.from,
to:b.to,text:b.text,origin:b.origin,cancel:function(){return d.canceled=!0}};c&&(d.update=function(b,c,g,h){b&&(d.from=x(a,b));c&&(d.to=x(a,c));g&&(d.text=g);void 0!==h&&(d.origin=h)});F(a,"beforeChange",a,d);a.cm&&F(a.cm,"beforeChange",a.cm,d);return d.canceled?null:{from:d.from,to:d.to,text:d.text,origin:d.origin}}function kb(a,b,c){if(a.cm){if(!a.cm.curOp)return J(a.cm,kb)(a,b,c);if(a.cm.state.suppressEdits)return}if(ga(a,"beforeChange")||a.cm&&ga(a.cm,"beforeChange"))if(b=tf(a,b,!0),!b)return;
if(c=uf&&!c&&mg(a,b.from,b.to))for(var d=c.length-1;0<=d;--d)vf(a,{from:c[d].from,to:c[d].to,text:d?[""]:b.text,origin:b.origin});else vf(a,b)}function vf(a,b){if(1!=b.text.length||""!=b.text[0]||0!=y(b.from,b.to)){var c=Fd(a,b);kf(a,b,c,a.cm?a.cm.curOp.id:NaN);Lb(a,b,c,Xc(a,b));var d=[];Va(a,function(a,c){c||-1!=L(d,a.history)||(wf(a.history,b),d.push(a.history));Lb(a,b,null,Xc(a,b))})}}function Ec(a,b,c){var d=a.cm&&a.cm.state.suppressEdits;if(!d||c){for(var e=a.history,f,g=a.sel,h="undo"==b?e.done:
e.undone,k="undo"==b?e.undone:e.done,l=0;l<h.length&&(f=h[l],c?!f.ranges||f.equals(a.sel):f.ranges);l++);if(l!=h.length){for(e.lastOrigin=e.lastSelOrigin=null;;)if(f=h.pop(),f.ranges){Bc(f,k);if(c&&!f.equals(a.sel)){O(a,f,{clearRedo:!1});return}g=f}else{if(d){h.push(f);return}break}var m=[];Bc(g,k);k.push({changes:m,generation:e.generation});e.generation=f.generation||++e.maxGeneration;var p=ga(a,"beforeChange")||a.cm&&ga(a.cm,"beforeChange");c=function(c){var d=f.changes[c];d.origin=b;if(p&&!tf(a,
d,!1))return h.length=0,{};m.push(Id(a,d));var e=c?Fd(a,d):w(h);Lb(a,d,e,lf(a,d));!c&&a.cm&&a.cm.scrollIntoView({from:d.from,to:Ca(d)});var g=[];Va(a,function(a,b){b||-1!=L(g,a.history)||(wf(a.history,d),g.push(a.history));Lb(a,d,null,lf(a,d))})};for(d=f.changes.length-1;0<=d;--d)if(e=c(d))return e.v}}}function xf(a,b){if(0!=b&&(a.first+=b,a.sel=new ca(gc(a.sel.ranges,function(a){return new z(q(a.anchor.line+b,a.anchor.ch),q(a.head.line+b,a.head.ch))}),a.sel.primIndex),a.cm)){U(a.cm,a.first,a.first-
b,b);for(var c=a.cm.display,d=c.viewFrom;d<c.viewTo;d++)Ba(a.cm,d,"gutter")}}function Lb(a,b,c,d){if(a.cm&&!a.cm.curOp)return J(a.cm,Lb)(a,b,c,d);if(b.to.line<a.first)xf(a,b.text.length-1-(b.to.line-b.from.line));else if(!(b.from.line>a.lastLine())){if(b.from.line<a.first){var e=b.text.length-1-(a.first-b.from.line);xf(a,e);b={from:q(a.first,0),to:q(b.to.line+e,b.to.ch),text:[w(b.text)],origin:b.origin}}e=a.lastLine();b.to.line>e&&(b={from:b.from,to:q(e,t(a,e).text.length),text:[b.text[0]],origin:b.origin});
b.removed=Ia(a,b.from,b.to);c||(c=Fd(a,b));a.cm?Og(a.cm,b,d):Hd(a,b,d);Dc(a,c,ra)}}function Og(a,b,c){var d=a.doc,e=a.display,f=b.from,g=b.to,h=!1,k=f.line;a.options.lineWrapping||(k=B(na(t(d,f.line))),d.iter(k,g.line+1,function(a){if(a==e.maxLine)return h=!0}));-1<d.sel.contains(b.from,b.to)&&fe(a);Hd(d,b,c,Le(a));a.options.lineWrapping||(d.iter(k,f.line+b.text.length,function(a){var b=lc(a);b>e.maxLineLength&&(e.maxLine=a,e.maxLineLength=b,e.maxLineChanged=!0,h=!1)}),h&&(a.curOp.updateMaxLine=!0));
tg(d,f.line);Ib(a,400);c=b.text.length-(g.line-f.line)-1;b.full?U(a):f.line!=g.line||1!=b.text.length||ef(a.doc,b)?U(a,f.line,g.line+1,c):Ba(a,f.line,"text");c=ga(a,"changes");if((d=ga(a,"change"))||c)b={from:f,to:g,text:b.text,removed:b.removed,origin:b.origin},d&&N(a,"change",a,b),c&&(a.curOp.changeObjs||(a.curOp.changeObjs=[])).push(b);a.display.selForContextMenu=null}function lb(a,b,c,d,e){d||(d=c);if(0>y(d,c)){var f;f=[d,c];c=f[0];d=f[1];f}"string"==typeof b&&(b=a.splitLines(b));kb(a,{from:c,
to:d,text:b,origin:e})}function yf(a,b,c,d){c<a.line?a.line+=d:b<a.line&&(a.line=b,a.ch=0)}function zf(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e],g=!0;if(f.ranges)for(f.copied||(f=a[e]=f.deepCopy(),f.copied=!0),g=0;g<f.ranges.length;g++)yf(f.ranges[g].anchor,b,c,d),yf(f.ranges[g].head,b,c,d);else{for(var h=0;h<f.changes.length;++h){var k=f.changes[h];if(c<k.from.line)k.from=q(k.from.line+d,k.from.ch),k.to=q(k.to.line+d,k.to.ch);else if(b<=k.to.line){g=!1;break}}g||(a.splice(0,e+1),e=0)}}}function wf(a,
b){var c=b.from.line,d=b.to.line,e=b.text.length-(d-c)-1;zf(a.done,c,d,e);zf(a.undone,c,d,e)}function Mb(a,b,c,d){var e=b,f=b;"number"==typeof b?f=t(a,Math.max(a.first,Math.min(b,a.first+a.size-1))):e=B(b);if(null==e)return null;d(f,e)&&a.cm&&Ba(a.cm,e,c);return f}function Nb(a){this.lines=a;this.parent=null;for(var b=0,c=0;c<a.length;++c)a[c].parent=this,b+=a[c].height;this.height=b}function Ob(a){this.children=a;for(var b=0,c=0,d=0;d<a.length;++d){var e=a[d],b=b+e.chunkSize(),c=c+e.height;e.parent=
this}this.size=b;this.height=c;this.parent=null}function Pg(a,b,c,d){var e=new Pb(a,c,d),f=a.cm;f&&e.noHScroll&&(f.display.alignWidgets=!0);Mb(a,b,"widget",function(b){var c=b.widgets||(b.widgets=[]);null==e.insertAt?c.push(e):c.splice(Math.min(c.length-1,Math.max(0,e.insertAt)),0,e);e.line=b;f&&!za(a,b)&&(c=oa(b)<a.scrollTop,ma(b,b.height+Bb(e)),c&&vc(f,e.height),f.curOp.forceUpdate=!0);return!0});f&&N(f,"lineWidgetAdded",f,e,"number"==typeof b?b:B(b));return e}function mb(a,b,c,d,e){if(d&&d.shared)return Qg(a,
b,c,d,e);if(a.cm&&!a.cm.curOp)return J(a.cm,mb)(a,b,c,d,e);var f=new Da(a,e);e=y(b,c);d&&Ha(d,f,!1);if(0<e||0==e&&!1!==f.clearWhenEmpty)return f;f.replacedWith&&(f.collapsed=!0,f.widgetNode=Za("span",[f.replacedWith],"CodeMirror-widget"),d.handleMouseEvents||f.widgetNode.setAttribute("cm-ignore-events","true"),d.insertLeft&&(f.widgetNode.insertLeft=!0));if(f.collapsed){if(de(a,b.line,b,c,f)||b.line!=c.line&&de(a,c.line,b,c,f))throw Error("Inserting collapsed marker partially overlapping an existing one");
ta=!0}f.addToHistory&&kf(a,{from:b,to:c,origin:"markText"},a.sel,NaN);var g=b.line,h=a.cm,k;a.iter(g,c.line+1,function(a){h&&f.collapsed&&!h.options.lineWrapping&&na(a)==h.display.maxLine&&(k=!0);f.collapsed&&g!=b.line&&ma(a,0);var d=new kc(f,g==b.line?b.ch:null,g==c.line?c.ch:null);a.markedSpans=a.markedSpans?a.markedSpans.concat([d]):[d];d.marker.attachLine(a);++g});f.collapsed&&a.iter(b.line,c.line+1,function(b){za(a,b)&&ma(b,0)});f.clearOnEnter&&v(f,"beforeCursorEnter",function(){return f.clear()});
f.readOnly&&(uf=!0,(a.history.done.length||a.history.undone.length)&&a.clearHistory());f.collapsed&&(f.id=++Af,f.atomic=!0);if(h){k&&(h.curOp.updateMaxLine=!0);if(f.collapsed)U(h,b.line,c.line+1);else if(f.className||f.title||f.startStyle||f.endStyle||f.css)for(d=b.line;d<=c.line;d++)Ba(h,d,"text");f.atomic&&qf(h.doc);N(h,"markerAdded",h,f)}return f}function Qg(a,b,c,d,e){d=Ha(d);d.shared=!1;var f=[mb(a,b,c,d,e)],g=f[0],h=d.widgetNode;Va(a,function(a){h&&(d.widgetNode=h.cloneNode(!0));f.push(mb(a,
x(a,b),x(a,c),d,e));for(var l=0;l<a.linked.length;++l)if(a.linked[l].isParent)return;g=w(f)});return new Qb(f,g)}function Bf(a){return a.findMarks(q(a.first,0),a.clipPos(q(a.lastLine())),function(a){return a.parent})}function Rg(a){for(var b=function(b){b=a[b];var c=[b.primary.doc];Va(b.primary.doc,function(a){return c.push(a)});for(var f=0;f<b.markers.length;f++){var g=b.markers[f];-1==L(c,g.doc)&&(g.parent=null,b.markers.splice(f--,1))}},c=0;c<a.length;c++)b(c)}function Sg(a){var b=this;Cf(b);if(!I(b,
a)&&!va(b.display,a)){T(a);A&&(Df=+new Date);var c=Qa(b,a,!0),d=a.dataTransfer.files;if(c&&!b.isReadOnly())if(d&&d.length&&window.FileReader&&window.File)for(var e=d.length,f=Array(e),g=0,h=function(a,d){if(!b.options.allowDropFileTypes||-1!=L(b.options.allowDropFileTypes,a.type)){var h=new FileReader;h.onload=J(b,function(){var a=h.result;/[\x00-\x08\x0e-\x1f]{2}/.test(a)&&(a="");f[d]=a;++g==e&&(c=x(b.doc,c),a={from:c,to:c,text:b.doc.splitLines(f.join(b.doc.lineSeparator())),origin:"paste"},kb(b.doc,
a),nf(b.doc,wa(c,Ca(a))))});h.readAsText(a)}},k=0;k<e;++k)h(d[k],k);else if(b.state.draggingText&&-1<b.doc.sel.contains(c))b.state.draggingText(a),setTimeout(function(){return b.display.input.focus()},20);else try{if(h=a.dataTransfer.getData("Text")){b.state.draggingText&&!b.state.draggingText.copy&&(k=b.listSelections());Dc(b.doc,wa(c,c));if(k)for(d=0;d<k.length;++d)lb(b.doc,"",k[d].anchor,k[d].head,"drag");b.replaceSelection(h,"around","paste");b.display.input.focus()}}catch(l){}}}function Cf(a){a.display.dragCursor&&
(a.display.lineSpace.removeChild(a.display.dragCursor),a.display.dragCursor=null)}function Ef(a){if(document.getElementsByClassName)for(var b=document.getElementsByClassName("CodeMirror"),c=0;c<b.length;c++){var d=b[c].CodeMirror;d&&a(d)}}function Tg(){var a;v(window,"resize",function(){null==a&&(a=setTimeout(function(){a=null;Ef(Ug)},100))});v(window,"blur",function(){return Ef(Fb)})}function Ug(a){var b=a.display;b.cachedCharWidth=b.cachedTextHeight=b.cachedPaddingH=null;b.scrollbarsClipped=!1;
a.setSize()}function Vg(a){var b=a.split(/-(?!$)/);a=b[b.length-1];for(var c,d,e,f,g=0;g<b.length-1;g++){var h=b[g];if(/^(cmd|meta|m)$/i.test(h))f=!0;else if(/^a(lt)?$/i.test(h))c=!0;else if(/^(c|ctrl|control)$/i.test(h))d=!0;else if(/^s(hift)?$/i.test(h))e=!0;else throw Error("Unrecognized modifier name: "+h);}c&&(a="Alt-"+a);d&&(a="Ctrl-"+a);f&&(a="Cmd-"+a);e&&(a="Shift-"+a);return a}function Wg(a){var b={},c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!/^(name|fallthrough|(de|at)tach)$/.test(c)){if("..."!=
d)for(var e=gc(c.split(" "),Vg),f=0;f<e.length;f++){var g=void 0,h=void 0;f==e.length-1?(h=e.join(" "),g=d):(h=e.slice(0,f+1).join(" "),g="...");var k=b[h];if(!k)b[h]=g;else if(k!=g)throw Error("Inconsistent bindings for "+h);}delete a[c]}}for(var l in b)a[l]=b[l];return a}function nb(a,b,c,d){b=Fc(b);var e=b.call?b.call(a,d):b[a];if(!1===e)return"nothing";if("..."===e)return"multi";if(null!=e&&c(e))return"handled";if(b.fallthrough){if("[object Array]"!=Object.prototype.toString.call(b.fallthrough))return nb(a,
b.fallthrough,c,d);for(e=0;e<b.fallthrough.length;e++){var f=nb(a,b.fallthrough[e],c,d);if(f)return f}}}function Ff(a){a="string"==typeof a?a:Ea[a.keyCode];return"Ctrl"==a||"Alt"==a||"Shift"==a||"Mod"==a}function Gf(a,b,c){var d=a;b.altKey&&"Alt"!=d&&(a="Alt-"+a);(Hf?b.metaKey:b.ctrlKey)&&"Ctrl"!=d&&(a="Ctrl-"+a);(Hf?b.ctrlKey:b.metaKey)&&"Cmd"!=d&&(a="Cmd-"+a);!c&&b.shiftKey&&"Shift"!=d&&(a="Shift-"+a);return a}function If(a,b){if(ka&&34==a.keyCode&&a["char"])return!1;var c=Ea[a.keyCode];if(null==
c||a.altGraphKey)return!1;3==a.keyCode&&a.code&&(c=a.code);return Gf(c,a,b)}function Fc(a){return"string"==typeof a?Rb[a]:a}function ob(a,b){for(var c=a.doc.sel.ranges,d=[],e=0;e<c.length;e++){for(var f=b(c[e]);d.length&&0>=y(f.from,w(d).to);){var g=d.pop();if(0>y(g.from,f.from)){f.from=g.from;break}}d.push(f)}Y(a,function(){for(var b=d.length-1;0<=b;b--)lb(a.doc,"",d[b].from,d[b].to,"+delete");fb(a)})}function Md(a,b,c){b=Zd(a.text,b+c,c);return 0>b||b>a.text.length?null:b}function Nd(a,b,c){a=Md(a,
b.ch,c);return null==a?null:new q(b.line,a,0>c?"after":"before")}function Od(a,b,c,d,e){if(a&&(a=ua(c,b.doc.direction))){a=0>e?w(a):a[0];var f=0>e==(1==a.level)?"after":"before",g;if(0<a.level||"rtl"==b.doc.direction){var h=Na(b,c);g=0>e?c.text.length-1:0;var k=ia(b,h,g).top;g=rb(function(a){return ia(b,h,a).top==k},0>e==(1==a.level)?a.from:a.to-1,g);"before"==f&&(g=Md(c,g,1))}else g=0>e?a.to:a.from;return new q(d,g,f)}return new q(d,0>e?c.text.length:0,0>e?"before":"after")}function Xg(a,b,c,d){var e=
ua(b,a.doc.direction);if(!e)return Nd(b,c,d);c.ch>=b.text.length?(c.ch=b.text.length,c.sticky="before"):0>=c.ch&&(c.ch=0,c.sticky="after");var f=vb(e,c.ch,c.sticky),g=e[f];if("ltr"==a.doc.direction&&0==g.level%2&&(0<d?g.to>c.ch:g.from<c.ch))return Nd(b,c,d);var h=function(a,c){return Md(b,a instanceof q?a.ch:a,c)},k,l=function(c){if(!a.options.lineWrapping)return{begin:0,end:b.text.length};k=k||Na(a,b);return Ke(a,b,k,c)},m=l("before"==c.sticky?h(c,-1):c.ch);if("rtl"==a.doc.direction||1==g.level){var p=
1==g.level==0>d,n=h(c,p?1:-1);if(null!=n&&(p?n<=g.to&&n<=m.end:n>=g.from&&n>=m.begin))return new q(c.line,n,p?"before":"after")}g=function(a,b,d){for(var f=function(a,b){return b?new q(c.line,h(a,1),"before"):new q(c.line,a,"after")};0<=a&&a<e.length;a+=b){var g=e[a],k=0<b==(1!=g.level),l=k?d.begin:h(d.end,-1);if(g.from<=l&&l<g.to)return f(l,k);l=k?g.from:h(g.to,-1);if(d.begin<=l&&l<d.end)return f(l,k)}};if(f=g(f+d,d,m))return f;m=0<d?m.end:h(m.begin,-1);return null==m||0<d&&m==b.text.length||!(f=
g(0<d?0:e.length-1,d,l(m)))?null:f}function Jf(a,b){var c=t(a.doc,b),d=na(c);d!=c&&(b=B(d));return Od(!0,a,d,b,1)}function Kf(a,b){var c=Jf(a,b.line),d=t(a.doc,c.line),e=ua(d,a.doc.direction);return e&&0!=e[0].level?c:(d=Math.max(0,d.text.search(/\S/)),q(c.line,b.line==c.line&&b.ch<=d&&b.ch?0:d,c.sticky))}function Gc(a,b,c){if("string"==typeof b&&(b=Sb[b],!b))return!1;a.display.input.ensurePolled();var d=a.display.shift,e=!1;try{a.isReadOnly()&&(a.state.suppressEdits=!0),c&&(a.display.shift=!1),e=
b(a)!=Hc}finally{a.display.shift=d,a.state.suppressEdits=!1}return e}function Tb(a,b,c,d){var e=a.state.keySeq;if(e){if(Ff(b))return"handled";/\'$/.test(b)?a.state.keySeq=null:Yg.set(50,function(){a.state.keySeq==e&&(a.state.keySeq=null,a.display.input.reset())});if(Lf(a,e+" "+b,c,d))return!0}return Lf(a,b,c,d)}function Lf(a,b,c,d){a:{for(var e=0;e<a.state.keyMaps.length;e++){var f=nb(b,a.state.keyMaps[e],d,a);if(f){d=f;break a}}d=a.options.extraKeys&&nb(b,a.options.extraKeys,d,a)||nb(b,a.options.keyMap,
d,a)}"multi"==d&&(a.state.keySeq=b);"handled"==d&&N(a,"keyHandled",a,b,c);if("handled"==d||"multi"==d)T(c),wd(a);return!!d}function Mf(a,b){var c=If(b,!0);return c?b.shiftKey&&!a.state.keySeq?Tb(a,"Shift-"+c,b,function(b){return Gc(a,b,!0)})||Tb(a,c,b,function(b){if("string"==typeof b?/^go[A-Z]/.test(b):b.motion)return Gc(a,b)}):Tb(a,c,b,function(b){return Gc(a,b)}):!1}function Zg(a,b,c){return Tb(a,"'"+c+"'",b,function(b){return Gc(a,b,!0)})}function Nf(a){this.curOp.focus=sa();if(!I(this,a)){A&&
11>D&&27==a.keyCode&&(a.returnValue=!1);var b=a.keyCode;this.display.shift=16==b||a.shiftKey;var c=Mf(this,a);ka&&(Pd=c?b:null,!c&&88==b&&!$g&&(ha?a.metaKey:a.ctrlKey)&&this.replaceSelection("",null,"cut"));18!=b||/\bCodeMirror-crosshair\b/.test(this.display.lineDiv.className)||ah(this)}}function ah(a){function b(a){18!=a.keyCode&&a.altKey||(Ra(c,"CodeMirror-crosshair"),aa(document,"keyup",b),aa(document,"mouseover",b))}var c=a.display.lineDiv;Ga(c,"CodeMirror-crosshair");v(document,"keyup",b);v(document,
"mouseover",b)}function Of(a){16==a.keyCode&&(this.doc.sel.shift=!1);I(this,a)}function Pf(a){if(!(va(this.display,a)||I(this,a)||a.ctrlKey&&!a.altKey||ha&&a.metaKey)){var b=a.keyCode,c=a.charCode;if(ka&&b==Pd)Pd=null,T(a);else if(!ka||a.which&&!(10>a.which)||!Mf(this,a))if(b=String.fromCharCode(null==c?b:c),"\b"!=b&&!Zg(this,a,b))this.display.input.onKeyPress(a)}}function bh(a,b){var c=+new Date;if(Ub&&Ub.compare(c,a,b))return Vb=Ub=null,"triple";if(Vb&&Vb.compare(c,a,b))return Ub=new Qd(c,a,b),
Vb=null,"double";Vb=new Qd(c,a,b);Ub=null;return"single"}function Qf(a){var b=this.display;if(!(I(this,a)||b.activeTouch&&b.input.supportsTouch()))if(b.input.ensurePolled(),b.shift=a.shiftKey,va(b,a))P||(b.scroller.draggable=!1,setTimeout(function(){return b.scroller.draggable=!0},100));else{var c=he(a);if(3==c&&Ic?!Rf(this,a):!Jc(this,a,"gutterClick",!0)){var d=Qa(this,a),e=d?bh(d,c):"single";window.focus();1==c&&this.state.selectingText&&this.state.selectingText(a);d&&ch(this,c,d,e,a)||(1==c?d?
dh(this,d,e,a):(a.target||a.srcElement)==b.scroller&&T(a):2==c?(d&&Cc(this.doc,d),setTimeout(function(){return b.input.focus()},20)):3==c&&(Ic?Sf(this,a):Pe(this)))}}}function ch(a,b,c,d,e){var f="Click";"double"==d?f="Double"+f:"triple"==d&&(f="Triple"+f);return Tb(a,Gf((1==b?"Left":2==b?"Middle":"Right")+f,e),e,function(b){"string"==typeof b&&(b=Sb[b]);if(!b)return!1;var d=!1;try{a.isReadOnly()&&(a.state.suppressEdits=!0),d=b(a,c)!=Hc}finally{a.state.suppressEdits=!1}return d})}function dh(a,b,
c,d){A?setTimeout(Oc(Oe,a),0):a.curOp.focus=sa();var e=a.getOption("configureMouse"),e=e?e(a,c,d):{};null==e.unit&&(e.unit=(eh?d.shiftKey&&d.metaKey:d.altKey)?"rectangle":"single"==c?"char":"double"==c?"word":"line");if(null==e.extend||a.doc.extend)e.extend=a.doc.extend||d.shiftKey;null==e.addNew&&(e.addNew=ha?d.metaKey:d.ctrlKey);null==e.moveOnDrag&&(e.moveOnDrag=!(ha?d.altKey:d.ctrlKey));var f=a.doc.sel,g;a.options.dragDrop&&fh&&!a.isReadOnly()&&"single"==c&&-1<(g=f.contains(b))&&(0>y((g=f.ranges[g]).from(),
b)||0<b.xRel)&&(0<y(g.to(),b)||0>b.xRel)?gh(a,d,b,e):hh(a,d,b,e)}function gh(a,b,c,d){var e=a.display,f=!1,g=J(a,function(b){P&&(e.scroller.draggable=!1);a.state.draggingText=!1;aa(e.wrapper.ownerDocument,"mouseup",g);aa(e.wrapper.ownerDocument,"mousemove",h);aa(e.scroller,"dragstart",k);aa(e.scroller,"drop",g);f||(T(b),d.addNew||Cc(a.doc,c,null,null,d.extend),P||A&&9==D?setTimeout(function(){e.wrapper.ownerDocument.body.focus();e.input.focus()},20):e.input.focus())}),h=function(a){f=f||10<=Math.abs(b.clientX-
a.clientX)+Math.abs(b.clientY-a.clientY)},k=function(){return f=!0};P&&(e.scroller.draggable=!0);a.state.draggingText=g;g.copy=!d.moveOnDrag;e.scroller.dragDrop&&e.scroller.dragDrop();v(e.wrapper.ownerDocument,"mouseup",g);v(e.wrapper.ownerDocument,"mousemove",h);v(e.scroller,"dragstart",k);v(e.scroller,"drop",g);Pe(a);setTimeout(function(){return e.input.focus()},20)}function Tf(a,b,c){if("char"==c)return new z(b,b);if("word"==c)return a.findWordAt(b);if("line"==c)return new z(q(b.line,0),x(a.doc,
q(b.line+1,0)));a=c(a,b);return new z(a.from,a.to)}function hh(a,b,c,d){function e(b){if(0!=y(r,b))if(r=b,"rectangle"==d.unit){for(var e=[],f=a.options.tabSize,g=fa(t(k,c.line).text,c.ch,f),h=fa(t(k,b.line).text,b.ch,f),n=Math.min(g,h),g=Math.max(g,h),h=Math.min(c.line,b.line),W=Math.min(a.lastLine(),Math.max(c.line,b.line));h<=W;h++){var u=t(k,h).text,v=Pc(u,n,f);n==g?e.push(new z(q(h,v),q(h,v))):u.length>v&&e.push(new z(q(h,v),q(h,Pc(u,g,f))))}e.length||e.push(new z(c,c));O(k,la(p.ranges.slice(0,
m).concat(e),m),{origin:"*mouse",scroll:!1});a.scrollIntoView(b)}else e=l,n=Tf(a,b,d.unit),b=e.anchor,0<y(n.anchor,b)?(f=n.head,b=jc(e.from(),n.anchor)):(f=n.anchor,b=ic(e.to(),n.head)),e=p.ranges.slice(0),e[m]=ih(a,new z(x(k,b),f)),O(k,la(e,m),Rd)}function f(b){var c=++u,g=Qa(a,b,!0,"rectangle"==d.unit);if(g)if(0!=y(g,r)){a.curOp.focus=sa();e(g);var l=yd(h,k);(g.line>=l.to||g.line<l.from)&&setTimeout(J(a,function(){u==c&&f(b)}),150)}else{var m=b.clientY<W.top?-20:b.clientY>W.bottom?20:0;m&&setTimeout(J(a,
function(){u==c&&(h.scroller.scrollTop+=m,f(b))}),50)}}function g(b){a.state.selectingText=!1;u=Infinity;T(b);h.input.focus();aa(h.wrapper.ownerDocument,"mousemove",w);aa(h.wrapper.ownerDocument,"mouseup",A);k.history.lastSelOrigin=null}var h=a.display,k=a.doc;T(b);var l,m,p=k.sel,n=p.ranges;d.addNew&&!d.extend?(m=k.sel.contains(c),l=-1<m?n[m]:new z(c,c)):(l=k.sel.primary(),m=k.sel.primIndex);"rectangle"==d.unit?(d.addNew||(l=new z(c,c)),c=Qa(a,b,!0,!0),m=-1):(b=Tf(a,c,d.unit),l=d.extend?Jd(l,b.anchor,
b.head,d.extend):b);d.addNew?-1==m?(m=n.length,O(k,la(n.concat([l]),m),{scroll:!1,origin:"*mouse"})):1<n.length&&n[m].empty()&&"char"==d.unit&&!d.extend?(O(k,la(n.slice(0,m).concat(n.slice(m+1)),0),{scroll:!1,origin:"*mouse"}),p=k.sel):Kd(k,m,l,Rd):(m=0,O(k,new ca([l],0),Rd),p=k.sel);var r=c,W=h.wrapper.getBoundingClientRect(),u=0,w=J(a,function(a){0!==a.buttons&&he(a)?f(a):g(a)}),A=J(a,g);a.state.selectingText=A;v(h.wrapper.ownerDocument,"mousemove",w);v(h.wrapper.ownerDocument,"mouseup",A)}function ih(a,
b){var c=b.anchor,d=b.head,e=t(a.doc,c.line);if(0==y(c,d)&&c.sticky==d.sticky)return b;e=ua(e);if(!e)return b;var f=vb(e,c.ch,c.sticky),g=e[f];if(g.from!=c.ch&&g.to!=c.ch)return b;var h=f+(g.from==c.ch==(1!=g.level)?0:1);if(0==h||h==e.length)return b;var k;d.line!=c.line?k=0<(d.line-c.line)*("ltr"==a.doc.direction?1:-1):(k=vb(e,d.ch,d.sticky),f=k-f||(d.ch-c.ch)*(1==g.level?-1:1),k=k==h-1||k==h?0>f:0<f);e=e[h+(k?-1:0)];e=(h=k==(1==e.level))?e.from:e.to;h=h?"after":"before";return c.ch==e&&c.sticky==
h?b:new z(new q(c.line,e,h),d)}function Jc(a,b,c,d){var e,f;if(b.touches)e=b.touches[0].clientX,f=b.touches[0].clientY;else try{e=b.clientX,f=b.clientY}catch(k){return!1}if(e>=Math.floor(a.display.gutters.getBoundingClientRect().right))return!1;d&&T(b);d=a.display;var g=d.lineDiv.getBoundingClientRect();if(f>g.bottom||!ga(a,c))return bd(b);f-=g.top-d.viewOffset;for(g=0;g<a.options.gutters.length;++g){var h=d.gutters.childNodes[g];if(h&&h.getBoundingClientRect().right>=e)return e=Ja(a.doc,f),F(a,c,
a,e,a.options.gutters[g],b),bd(b)}}function Sf(a,b){if(!va(a.display,b)&&!Rf(a,b)&&!I(a,b,"contextmenu"))a.display.input.onContextMenu(b)}function Rf(a,b){return ga(a,"gutterContextMenu")?Jc(a,b,"gutterContextMenu",!1):!1}function Uf(a){a.display.wrapper.className=a.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+a.options.theme.replace(/(^|\s)\s*/g," cm-s-");Db(a)}function Wb(a){$e(a);U(a);Re(a)}function jh(a,b,c){!b!=!(c&&c!=pb)&&(c=a.display.dragFunctions,b=b?v:aa,b(a.display.scroller,"dragstart",
c.start),b(a.display.scroller,"dragenter",c.enter),b(a.display.scroller,"dragover",c.over),b(a.display.scroller,"dragleave",c.leave),b(a.display.scroller,"drop",c.drop))}function kh(a){a.options.lineWrapping?(Ga(a.display.wrapper,"CodeMirror-wrap"),a.display.sizer.style.minWidth="",a.display.sizerWidth=null):(Ra(a.display.wrapper,"CodeMirror-wrap"),ad(a));vd(a);U(a);Db(a);setTimeout(function(){return gb(a)},100)}function E(a,b){var c=this;if(!(this instanceof E))return new E(a,b);this.options=b=b?
Ha(b):{};Ha(Vf,b,!1);Ed(b);var d=b.value;"string"==typeof d?d=new V(d,b.mode,null,b.lineSeparator,b.direction):b.mode&&(d.modeOption=b.mode);this.doc=d;var e=new E.inputStyles[b.inputStyle](this),e=this.display=new lg(a,d,e);e.wrapper.CodeMirror=this;$e(this);Uf(this);b.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap");We(this);this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,
draggingText:!1,highlight:new Wa,keySeq:null,specialChars:null};b.autofocus&&!sb&&e.input.focus();A&&11>D&&setTimeout(function(){return c.display.input.reset(!0)},20);lh(this);Wf||(Tg(),Wf=!0);Ta(this);this.curOp.forceUpdate=!0;ff(this,d);b.autofocus&&!sb||this.hasFocus()?setTimeout(Oc(xd,this),20):Fb(this);for(var f in Kc)if(Kc.hasOwnProperty(f))Kc[f](c,b[f],pb);Se(this);b.finishInit&&b.finishInit(this);for(d=0;d<Sd.length;++d)Sd[d](c);Ua(this);P&&b.lineWrapping&&"optimizelegibility"==getComputedStyle(e.lineDiv).textRendering&&
(e.lineDiv.style.textRendering="auto")}function lh(a){function b(){d.activeTouch&&(e=setTimeout(function(){return d.activeTouch=null},1E3),f=d.activeTouch,f.end=+new Date)}function c(a,b){if(null==b.left)return!0;var c=b.left-a.left,d=b.top-a.top;return 400<c*c+d*d}var d=a.display;v(d.scroller,"mousedown",J(a,Qf));A&&11>D?v(d.scroller,"dblclick",J(a,function(b){if(!I(a,b)){var c=Qa(a,b);!c||Jc(a,b,"gutterClick",!0)||va(a.display,b)||(T(b),b=a.findWordAt(c),Cc(a.doc,b.anchor,b.head))}})):v(d.scroller,
"dblclick",function(b){return I(a,b)||T(b)});Ic||v(d.scroller,"contextmenu",function(b){return Sf(a,b)});var e,f={end:0};v(d.scroller,"touchstart",function(b){var c;if(c=!I(a,b))1!=b.touches.length?c=!1:(c=b.touches[0],c=1>=c.radiusX&&1>=c.radiusY),c=!c;c&&!Jc(a,b,"gutterClick",!0)&&(d.input.ensurePolled(),clearTimeout(e),c=+new Date,d.activeTouch={start:c,moved:!1,prev:300>=c-f.end?f:null},1==b.touches.length&&(d.activeTouch.left=b.touches[0].pageX,d.activeTouch.top=b.touches[0].pageY))});v(d.scroller,
"touchmove",function(){d.activeTouch&&(d.activeTouch.moved=!0)});v(d.scroller,"touchend",function(e){var f=d.activeTouch;if(f&&!va(d,e)&&null!=f.left&&!f.moved&&300>new Date-f.start){var g=a.coordsChar(d.activeTouch,"page"),f=!f.prev||c(f,f.prev)?new z(g,g):!f.prev.prev||c(f,f.prev.prev)?a.findWordAt(g):new z(q(g.line,0),x(a.doc,q(g.line+1,0)));a.setSelection(f.anchor,f.head);a.focus();T(e)}b()});v(d.scroller,"touchcancel",b);v(d.scroller,"scroll",function(){d.scroller.clientHeight&&(Hb(a,d.scroller.scrollTop),
Sa(a,d.scroller.scrollLeft,!0),F(a,"scroll",a))});v(d.scroller,"mousewheel",function(b){return bf(a,b)});v(d.scroller,"DOMMouseScroll",function(b){return bf(a,b)});v(d.wrapper,"scroll",function(){return d.wrapper.scrollTop=d.wrapper.scrollLeft=0});d.dragFunctions={enter:function(b){I(a,b)||xb(b)},over:function(b){if(!I(a,b)){var c=Qa(a,b);if(c){var d=document.createDocumentFragment();Ne(a,c,d);a.display.dragCursor||(a.display.dragCursor=u("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),a.display.lineSpace.insertBefore(a.display.dragCursor,
a.display.cursorDiv));Z(a.display.dragCursor,d)}xb(b)}},start:function(b){if(A&&(!a.state.draggingText||100>+new Date-Df))xb(b);else if(!I(a,b)&&!va(a.display,b)&&(b.dataTransfer.setData("Text",a.getSelection()),b.dataTransfer.effectAllowed="copyMove",b.dataTransfer.setDragImage&&!Xf)){var c=u("img",null,null,"position: fixed; left: 0; top: 0;");c.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\x3d\x3d";ka&&(c.width=c.height=1,a.display.wrapper.appendChild(c),c._top=
c.offsetTop);b.dataTransfer.setDragImage(c,0,0);ka&&c.parentNode.removeChild(c)}},drop:J(a,Sg),leave:function(b){I(a,b)||Cf(a)}};var g=d.input.getField();v(g,"keyup",function(b){return Of.call(a,b)});v(g,"keydown",J(a,Nf));v(g,"keypress",J(a,Pf));v(g,"focus",function(b){return xd(a,b)});v(g,"blur",function(b){return Fb(a,b)})}function Xb(a,b,c,d){var e=a.doc,f;null==c&&(c="add");"smart"==c&&(e.mode.indent?f=yb(a,b).state:c="prev");var g=a.options.tabSize,h=t(e,b),k=fa(h.text,null,g);h.stateAfter&&
(h.stateAfter=null);var l=h.text.match(/^\s*/)[0],m;if(!d&&!/\S/.test(h.text))m=0,c="not";else if("smart"==c&&(m=e.mode.indent(f,h.text.slice(l.length),h.text),m==Hc||150<m)){if(!d)return;c="prev"}"prev"==c?m=b>e.first?fa(t(e,b-1).text,null,g):0:"add"==c?m=k+a.options.indentUnit:"subtract"==c?m=k-a.options.indentUnit:"number"==typeof c&&(m=k+c);m=Math.max(0,m);c="";d=0;if(a.options.indentWithTabs)for(a=Math.floor(m/g);a;--a)d+=g,c+="\t";d<m&&(c+=Qc(m-d));if(c!=l)return lb(e,c,q(b,0),q(b,l.length),
"+input"),h.stateAfter=null,!0;for(g=0;g<e.sel.ranges.length;g++)if(h=e.sel.ranges[g],h.head.line==b&&h.head.ch<l.length){b=q(b,l.length);Kd(e,g,new z(b,b));break}}function Yf(a){da=a}function Td(a,b,c,d,e){var f=a.doc;a.display.shift=!1;d||(d=f.sel);var g=a.state.pasteIncoming||"paste"==e,h=Ud(b),k=null;if(g&&1<d.ranges.length)if(da&&da.text.join("\n")==b){if(0==d.ranges.length%da.text.length)for(var k=[],l=0;l<da.text.length;l++)k.push(f.splitLines(da.text[l]))}else h.length==d.ranges.length&&a.options.pasteLinesPerSelection&&
(k=gc(h,function(a){return[a]}));for(var m,l=d.ranges.length-1;0<=l;l--){m=d.ranges[l];var p=m.from(),n=m.to();m.empty()&&(c&&0<c?p=q(p.line,p.ch-c):a.state.overwrite&&!g?n=q(n.line,Math.min(t(f,n.line).text.length,n.ch+w(h).length)):da&&da.lineWise&&da.text.join("\n")==b&&(p=n=q(p.line,0)));m=a.curOp.updateInput;p={from:p,to:n,text:k?k[l%k.length]:h,origin:e||(g?"paste":a.state.cutIncoming?"cut":"+input")};kb(a.doc,p);N(a,"inputRead",a,p)}b&&!g&&Zf(a,b);fb(a);a.curOp.updateInput=m;a.curOp.typing=
!0;a.state.pasteIncoming=a.state.cutIncoming=!1}function $f(a,b){var c=a.clipboardData&&a.clipboardData.getData("Text");if(c)return a.preventDefault(),b.isReadOnly()||b.options.disableInput||Y(b,function(){return Td(b,c,0,null,"paste")}),!0}function Zf(a,b){if(a.options.electricChars&&a.options.smartIndent)for(var c=a.doc.sel,d=c.ranges.length-1;0<=d;d--){var e=c.ranges[d];if(!(100<e.head.ch||d&&c.ranges[d-1].head.line==e.head.line)){var f=a.getModeAt(e.head),g=!1;if(f.electricChars)for(var h=0;h<
f.electricChars.length;h++){if(-1<b.indexOf(f.electricChars.charAt(h))){g=Xb(a,e.head.line,"smart");break}}else f.electricInput&&f.electricInput.test(t(a.doc,e.head.line).text.slice(0,e.head.ch))&&(g=Xb(a,e.head.line,"smart"));g&&N(a,"electricInput",a,e.head.line)}}}function ag(a){for(var b=[],c=[],d=0;d<a.doc.sel.ranges.length;d++){var e=a.doc.sel.ranges[d].head.line,e={anchor:q(e,0),head:q(e+1,0)};c.push(e);b.push(a.getRange(e.anchor,e.head))}return{text:b,ranges:c}}function bg(a,b){a.setAttribute("autocorrect",
"off");a.setAttribute("autocapitalize","off");a.setAttribute("spellcheck",!!b)}function cg(){var a=u("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),b=u("div",[a],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");P?a.style.width="1000px":a.setAttribute("wrap","off");Yb&&(a.style.border="1px solid black");bg(a);return b}function Vd(a,b,c,d,e){function f(d){var f;f=e?Xg(a.cm,k,b,c):Nd(k,b,c);if(null==f){if(d=!d)d=b.line+
c,d<a.first||d>=a.first+a.size?d=!1:(b=new q(d,b.ch,b.sticky),d=k=t(a,d));if(d)b=Od(e,a.cm,k,b.line,c);else return!1}else b=f;return!0}var g=b,h=c,k=t(a,b.line);if("char"==d)f();else if("column"==d)f(!0);else if("word"==d||"group"==d){var l=null;d="group"==d;for(var m=a.cm&&a.cm.getHelper(b,"wordChars"),p=!0;!(0>c)||f(!p);p=!1){var n=k.text.charAt(b.ch)||"\n",n=hc(n,m)?"w":d&&"\n"==n?"n":!d||/\s/.test(n)?null:"p";!d||p||n||(n="s");if(l&&l!=n){0>c&&(c=1,f(),b.sticky="after");break}n&&(l=n);if(0<c&&
!f(!p))break}}h=Ld(a,b,g,h,!0);Vc(g,h)&&(h.hitSide=!0);return h}function dg(a,b,c,d){var e=a.doc,f=b.left,g;"page"==d?(g=Math.max(Math.min(a.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight)-.5*Oa(a.display),3),g=(0<c?b.bottom:b.top)+c*g):"line"==d&&(g=0<c?b.bottom+3:b.top-3);for(;;){b=sd(a,f,g);if(!b.outside)break;if(0>c?0>=g:g>=e.height){b.hitSide=!0;break}g+=5*c}return b}function eg(a,b){var c=md(a,b.line);if(!c||c.hidden)return null;var d=t(a.doc,b.line),
c=Ae(c,d,b.line),d=ua(d,a.doc.direction),e="left";d&&(e=vb(d,b.ch)%2?"right":"left");c=Be(c.map,b.ch,e);c.offset="right"==c.collapse?c.end:c.start;return c}function mh(a){for(;a;a=a.parentNode)if(/CodeMirror-gutter-wrapper/.test(a.className))return!0;return!1}function qb(a,b){b&&(a.bad=!0);return a}function nh(a,b,c,d,e){function f(a){return function(b){return b.id==a}}function g(){m&&(l+=p,n&&(l+=p),m=n=!1)}function h(a){a&&(g(),l+=a)}function k(b){if(1==b.nodeType){var c=b.getAttribute("cm-text");
if(c)h(c);else{var c=b.getAttribute("cm-marker"),l;if(c)b=a.findMarks(q(d,0),q(e+1,0),f(+c)),b.length&&(l=b[0].find(0))&&h(Ia(a.doc,l.from,l.to).join(p));else if("false"!=b.getAttribute("contenteditable")&&(l=/^(pre|div|p|li|table|br)$/i.test(b.nodeName),/^br$/i.test(b.nodeName)||0!=b.textContent.length)){l&&g();for(c=0;c<b.childNodes.length;c++)k(b.childNodes[c]);/^(pre|p)$/i.test(b.nodeName)&&(n=!0);l&&(m=!0)}}}else 3==b.nodeType&&h(b.nodeValue.replace(/\u200b/g,"").replace(/\u00a0/g," "))}for(var l=
"",m=!1,p=a.doc.lineSeparator(),n=!1;;){k(b);if(b==c)break;b=b.nextSibling;n=!1}return l}function Lc(a,b,c){var d;if(b==a.display.lineDiv){d=a.display.lineDiv.childNodes[c];if(!d)return qb(a.clipPos(q(a.display.viewTo-1)),!0);b=null;c=0}else for(d=b;;d=d.parentNode){if(!d||d==a.display.lineDiv)return null;if(d.parentNode&&d.parentNode==a.display.lineDiv)break}for(var e=0;e<a.display.view.length;e++){var f=a.display.view[e];if(f.node==d)return oh(f,b,c)}}function oh(a,b,c){function d(b,c,d){for(var e=
-1;e<(l?l.length:0);e++)for(var f=0>e?k.map:l[e],g=0;g<f.length;g+=3){var h=f[g+2];if(h==b||h==c){c=B(0>e?a.line:a.rest[e]);e=f[g]+d;if(0>d||h!=b)e=f[g+(d?1:0)];return q(c,e)}}}var e=a.text.firstChild,f=!1;if(!b||!xa(e,b))return qb(q(B(a.line),0),!0);if(b==e&&(f=!0,b=e.childNodes[c],c=0,!b))return c=a.rest?w(a.rest):a.line,qb(q(B(c),c.text.length),f);var g=3==b.nodeType?b:null,h=b;g||1!=b.childNodes.length||3!=b.firstChild.nodeType||(g=b.firstChild,c&&(c=g.nodeValue.length));for(;h.parentNode!=e;)h=
h.parentNode;var k=a.measure,l=k.maps;if(b=d(g,h,c))return qb(b,f);e=h.nextSibling;for(g=g?g.nodeValue.length-c:0;e;e=e.nextSibling){if(b=d(e,e.firstChild,0))return qb(q(b.line,b.ch-g),f);g+=e.textContent.length}for(h=h.previousSibling;h;h=h.previousSibling){if(b=d(h,h.firstChild,-1))return qb(q(b.line,b.ch+c),f);c+=h.textContent.length}}var S=navigator.userAgent,fg=navigator.platform,ya=/gecko\/\d/i.test(S),gg=/MSIE \d/.test(S),hg=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(S),Zb=/Edge\/(\d+)/.exec(S),
A=gg||hg||Zb,D=A&&(gg?document.documentMode||6:+(Zb||hg)[1]),P=!Zb&&/WebKit\//.test(S),ph=P&&/Qt\/\d+\.\d+/.test(S),qc=!Zb&&/Chrome\//.test(S),ka=/Opera\//.test(S),Xf=/Apple Computer/.test(navigator.vendor),qh=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(S),Hg=/PhantomJS/.test(S),Yb=!Zb&&/AppleWebKit/.test(S)&&/Mobile\/\w+/.test(S),rc=/Android/.test(S),sb=Yb||rc||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(S),ha=Yb||/Mac/.test(fg),eh=/\bCrOS\b/.test(S),rh=/win/i.test(fg),Xa=ka&&S.match(/Version\/(\d*\.\d*)/);
Xa&&(Xa=Number(Xa[1]));Xa&&15<=Xa&&(ka=!1,P=!0);var Hf=ha&&(ph||ka&&(null==Xa||12.11>Xa)),Ic=ya||A&&9<=D,Ra=function(a,b){var c=a.className,d=Fa(b).exec(c);if(d){var e=c.slice(d.index+d[0].length);a.className=c.slice(0,d.index)+(e?d[1]+e:"")}},db;db=document.createRange?function(a,b,c,d){var e=document.createRange();e.setEnd(d||a,c);e.setStart(a,b);return e}:function(a,b,c){var d=document.body.createTextRange();try{d.moveToElementText(a.parentNode)}catch(e){return d}d.collapse(!0);d.moveEnd("character",
c);d.moveStart("character",b);return d};var $b=function(a){a.select()};Yb?$b=function(a){a.selectionStart=0;a.selectionEnd=a.value.length}:A&&($b=function(a){try{a.select()}catch(b){}});var Wa=function(){this.id=null};Wa.prototype.set=function(a,b){clearTimeout(this.id);this.id=setTimeout(b,a)};var Hc={toString:function(){return"CodeMirror.Pass"}},ra={scroll:!1},Rd={origin:"*mouse"},ac={origin:"+move"},fc=[""],jg=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,
kg=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,
uf=!1,ta=!1,wb=null,og=function(){function a(a){return 247>=a?"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(a):1424<=a&&1524>=a?"R":1536<=a&&1785>=a?"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(a-
1536):1774<=a&&2220>=a?"r":8192<=a&&8203>=a?"w":8204==a?"b":"L"}function b(a,b,c){this.level=a;this.from=b;this.to=c}var c=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,d=/[stwN]/,e=/[LRr]/,f=/[Lb1n]/,g=/[1n]/;return function(h,k){var l="ltr"==k?"L":"R";if(0==h.length||"ltr"==k&&!c.test(h))return!1;for(var m=h.length,p=[],n=0;n<m;++n)p.push(a(h.charCodeAt(n)));for(var n=0,r=l;n<m;++n){var q=p[n];"m"==q?p[n]=r:r=q}n=0;for(r=l;n<m;++n)q=p[n],"1"==q&&"r"==r?p[n]="n":e.test(q)&&(r=q,"r"==q&&(p[n]="R"));
n=1;for(r=p[0];n<m-1;++n)q=p[n],"+"==q&&"1"==r&&"1"==p[n+1]?p[n]="1":","!=q||r!=p[n+1]||"1"!=r&&"n"!=r||(p[n]=r),r=q;for(n=0;n<m;++n)if(r=p[n],","==r)p[n]="N";else if("%"==r){r=void 0;for(r=n+1;r<m&&"%"==p[r];++r);for(q=n&&"!"==p[n-1]||r<m&&"1"==p[r]?"1":"N";n<r;++n)p[n]=q;n=r-1}n=0;for(r=l;n<m;++n)q=p[n],"L"==r&&"1"==q?p[n]="L":e.test(q)&&(r=q);for(r=0;r<m;++r)if(d.test(p[r])){n=void 0;for(n=r+1;n<m&&d.test(p[n]);++n);q="L"==(r?p[r-1]:l);for(q=q==("L"==(n<m?p[n]:l))?q?"L":"R":l;r<n;++r)p[r]=q;r=
n-1}for(var l=[],t,n=0;n<m;)if(f.test(p[n])){r=n;for(++n;n<m&&f.test(p[n]);++n);l.push(new b(0,r,n))}else{var u=n,r=l.length;for(++n;n<m&&"L"!=p[n];++n);for(q=u;q<n;)if(g.test(p[q])){u<q&&l.splice(r,0,new b(1,u,q));u=q;for(++q;q<n&&g.test(p[q]);++q);l.splice(r,0,new b(2,u,q));u=q}else++q;u<n&&l.splice(r,0,new b(1,u,n))}"ltr"==k&&(1==l[0].level&&(t=h.match(/^\s+/))&&(l[0].from=t[0].length,l.unshift(new b(0,0,t[0].length))),1==w(l).level&&(t=h.match(/\s+$/))&&(w(l).to-=t[0].length,l.push(new b(0,m-
t[0].length,m))));return"rtl"==k?l.reverse():l}}(),mc=[],v=function(a,b,c){a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent?a.attachEvent("on"+b,c):(a=a._handlers||(a._handlers={}),a[b]=(a[b]||mc).concat(c))},fh=function(){if(A&&9>D)return!1;var a=u("div");return"draggable"in a||"dragDrop"in a}(),cd,id,Ud=3!="\n\nb".split(/\n/).length?function(a){for(var b=0,c=[],d=a.length;b<=d;){var e=a.indexOf("\n",b);-1==e&&(e=a.length);var f=a.slice(b,"\r"==a.charAt(e-1)?e-1:e),g=f.indexOf("\r");-1!=
g?(c.push(f.slice(0,g)),b+=g+1):(c.push(f),b=e+1)}return c}:function(a){return a.split(/\r\n?|\n/)},sh=window.getSelection?function(a){try{return a.selectionStart!=a.selectionEnd}catch(b){return!1}}:function(a){var b;try{b=a.ownerDocument.selection.createRange()}catch(c){}return b&&b.parentElement()==a?0!=b.compareEndPoints("StartToEnd",b):!1},$g=function(){var a=u("div");if("oncopy"in a)return!0;a.setAttribute("oncopy","return;");return"function"==typeof a.oncopy}(),od=null,dd={},bb={},cb={},G=function(a,
b,c){this.pos=this.start=0;this.string=a;this.tabSize=b||8;this.lineStart=this.lastColumnPos=this.lastColumnValue=0;this.lineOracle=c};G.prototype.eol=function(){return this.pos>=this.string.length};G.prototype.sol=function(){return this.pos==this.lineStart};G.prototype.peek=function(){return this.string.charAt(this.pos)||void 0};G.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)};G.prototype.eat=function(a){var b=this.string.charAt(this.pos);if("string"==
typeof a?b==a:b&&(a.test?a.test(b):a(b)))return++this.pos,b};G.prototype.eatWhile=function(a){for(var b=this.pos;this.eat(a););return this.pos>b};G.prototype.eatSpace=function(){for(var a=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>a};G.prototype.skipToEnd=function(){this.pos=this.string.length};G.prototype.skipTo=function(a){a=this.string.indexOf(a,this.pos);if(-1<a)return this.pos=a,!0};G.prototype.backUp=function(a){this.pos-=a};G.prototype.column=function(){this.lastColumnPos<
this.start&&(this.lastColumnValue=fa(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start);return this.lastColumnValue-(this.lineStart?fa(this.string,this.lineStart,this.tabSize):0)};G.prototype.indentation=function(){return fa(this.string,null,this.tabSize)-(this.lineStart?fa(this.string,this.lineStart,this.tabSize):0)};G.prototype.match=function(a,b,c){if("string"==typeof a){var d=function(a){return c?a.toLowerCase():a},e=this.string.substr(this.pos,
a.length);if(d(e)==d(a))return!1!==b&&(this.pos+=a.length),!0}else{if((a=this.string.slice(this.pos).match(a))&&0<a.index)return null;a&&!1!==b&&(this.pos+=a[0].length);return a}};G.prototype.current=function(){return this.string.slice(this.start,this.pos)};G.prototype.hideFirstChars=function(a,b){this.lineStart+=a;try{return b()}finally{this.lineStart-=a}};G.prototype.lookAhead=function(a){var b=this.lineOracle;return b&&b.lookAhead(a)};G.prototype.baseToken=function(){var a=this.lineOracle;return a&&
a.baseToken(this.pos)};var oc=function(a,b){this.state=a;this.lookAhead=b},pa=function(a,b,c,d){this.state=b;this.doc=a;this.line=c;this.maxLookAhead=d||0;this.baseTokens=null;this.baseTokenPos=1};pa.prototype.lookAhead=function(a){var b=this.doc.getLine(this.line+a);null!=b&&a>this.maxLookAhead&&(this.maxLookAhead=a);return b};pa.prototype.baseToken=function(a){if(!this.baseTokens)return null;for(;this.baseTokens[this.baseTokenPos]<=a;)this.baseTokenPos+=2;var b=this.baseTokens[this.baseTokenPos+
1];return{type:b&&b.replace(/( |^)overlay .*/,""),size:this.baseTokens[this.baseTokenPos]-a}};pa.prototype.nextLine=function(){this.line++;0<this.maxLookAhead&&this.maxLookAhead--};pa.fromSaved=function(a,b,c){return b instanceof oc?new pa(a,Ka(a.mode,b.state),c,b.lookAhead):new pa(a,Ka(a.mode,b),c)};pa.prototype.save=function(a){a=!1!==a?Ka(this.doc.mode,this.state):this.state;return 0<this.maxLookAhead?new oc(a,this.maxLookAhead):a};var oe=function(a,b,c){this.start=a.start;this.end=a.pos;this.string=
a.current();this.type=b||null;this.state=c},hb=function(a,b,c){this.text=a;ce(this,b);this.height=c?c(this):1};hb.prototype.lineNo=function(){return B(this)};ab(hb);var vg={},ug={},eb=null,zb=null,Ce={left:0,right:0,top:0,bottom:0},Pa,Ya=function(a,b,c){this.cm=c;var d=this.vert=u("div",[u("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),e=this.horiz=u("div",[u("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");d.tabIndex=e.tabIndex=-1;a(d);a(e);v(d,"scroll",function(){d.clientHeight&&
b(d.scrollTop,"vertical")});v(e,"scroll",function(){e.clientWidth&&b(e.scrollLeft,"horizontal")});this.checkedZeroWidth=!1;A&&8>D&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};Ya.prototype.update=function(a){var b=a.scrollWidth>a.clientWidth+1,c=a.scrollHeight>a.clientHeight+1,d=a.nativeBarWidth;c?(this.vert.style.display="block",this.vert.style.bottom=b?d+"px":"0",this.vert.firstChild.style.height=Math.max(0,a.scrollHeight-a.clientHeight+(a.viewHeight-(b?d:0)))+"px"):(this.vert.style.display=
"",this.vert.firstChild.style.height="0");b?(this.horiz.style.display="block",this.horiz.style.right=c?d+"px":"0",this.horiz.style.left=a.barLeft+"px",this.horiz.firstChild.style.width=Math.max(0,a.scrollWidth-a.clientWidth+(a.viewWidth-a.barLeft-(c?d:0)))+"px"):(this.horiz.style.display="",this.horiz.firstChild.style.width="0");!this.checkedZeroWidth&&0<a.clientHeight&&(0==d&&this.zeroWidthHack(),this.checkedZeroWidth=!0);return{right:c?d:0,bottom:b?d:0}};Ya.prototype.setScrollLeft=function(a){this.horiz.scrollLeft!=
a&&(this.horiz.scrollLeft=a);this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")};Ya.prototype.setScrollTop=function(a){this.vert.scrollTop!=a&&(this.vert.scrollTop=a);this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")};Ya.prototype.zeroWidthHack=function(){this.horiz.style.height=this.vert.style.width=ha&&!qh?"12px":"18px";this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none";this.disableHoriz=new Wa;this.disableVert=new Wa};Ya.prototype.enableZeroWidthBar=
function(a,b,c){function d(){var e=a.getBoundingClientRect();("vert"==c?document.elementFromPoint(e.right-1,(e.top+e.bottom)/2):document.elementFromPoint((e.right+e.left)/2,e.bottom-1))!=a?a.style.pointerEvents="none":b.set(1E3,d)}a.style.pointerEvents="auto";b.set(1E3,d)};Ya.prototype.clear=function(){var a=this.horiz.parentNode;a.removeChild(this.horiz);a.removeChild(this.vert)};var bc=function(){};bc.prototype.update=function(){return{bottom:0,right:0}};bc.prototype.setScrollLeft=function(){};
bc.prototype.setScrollTop=function(){};bc.prototype.clear=function(){};var Xe={"native":Ya,"null":bc},Gg=0,xc=function(a,b,c){var d=a.display;this.viewport=b;this.visible=yd(d,a.doc,b);this.editorIsHidden=!d.wrapper.offsetWidth;this.wrapperHeight=d.wrapper.clientHeight;this.wrapperWidth=d.wrapper.clientWidth;this.oldDisplayWidth=La(a);this.force=c;this.dims=nd(a);this.events=[]};xc.prototype.signal=function(a,b){ga(a,b)&&this.events.push(arguments)};xc.prototype.finish=function(){for(var a=0;a<this.events.length;a++)F.apply(null,
this.events[a])};var zc=0,ba=null;A?ba=-.53:ya?ba=15:qc?ba=-.7:Xf&&(ba=-1/3);var ca=function(a,b){this.ranges=a;this.primIndex=b};ca.prototype.primary=function(){return this.ranges[this.primIndex]};ca.prototype.equals=function(a){if(a==this)return!0;if(a.primIndex!=this.primIndex||a.ranges.length!=this.ranges.length)return!1;for(var b=0;b<this.ranges.length;b++){var c=this.ranges[b],d=a.ranges[b];if(!Vc(c.anchor,d.anchor)||!Vc(c.head,d.head))return!1}return!0};ca.prototype.deepCopy=function(){for(var a=
[],b=0;b<this.ranges.length;b++)a[b]=new z(Wc(this.ranges[b].anchor),Wc(this.ranges[b].head));return new ca(a,this.primIndex)};ca.prototype.somethingSelected=function(){for(var a=0;a<this.ranges.length;a++)if(!this.ranges[a].empty())return!0;return!1};ca.prototype.contains=function(a,b){b||(b=a);for(var c=0;c<this.ranges.length;c++){var d=this.ranges[c];if(0<=y(b,d.from())&&0>=y(a,d.to()))return c}return-1};var z=function(a,b){this.anchor=a;this.head=b};z.prototype.from=function(){return jc(this.anchor,
this.head)};z.prototype.to=function(){return ic(this.anchor,this.head)};z.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch};Nb.prototype={chunkSize:function(){return this.lines.length},removeInner:function(a,b){for(var c=a,d=a+b;c<d;++c){var e=this.lines[c];this.height-=e.height;var f=e;f.parent=null;be(f);N(e,"delete")}this.lines.splice(a,b)},collapse:function(a){a.push.apply(a,this.lines)},insertInner:function(a,b,c){this.height+=c;this.lines=this.lines.slice(0,
a).concat(b).concat(this.lines.slice(a));for(a=0;a<b.length;++a)b[a].parent=this},iterN:function(a,b,c){for(b=a+b;a<b;++a)if(c(this.lines[a]))return!0}};Ob.prototype={chunkSize:function(){return this.size},removeInner:function(a,b){this.size-=b;for(var c=0;c<this.children.length;++c){var d=this.children[c],e=d.chunkSize();if(a<e){var f=Math.min(b,e-a),g=d.height;d.removeInner(a,f);this.height-=g-d.height;e==f&&(this.children.splice(c--,1),d.parent=null);if(0==(b-=f))break;a=0}else a-=e}25>this.size-
b&&(1<this.children.length||!(this.children[0]instanceof Nb))&&(c=[],this.collapse(c),this.children=[new Nb(c)],this.children[0].parent=this)},collapse:function(a){for(var b=0;b<this.children.length;++b)this.children[b].collapse(a)},insertInner:function(a,b,c){this.size+=b.length;this.height+=c;for(var d=0;d<this.children.length;++d){var e=this.children[d],f=e.chunkSize();if(a<=f){e.insertInner(a,b,c);if(e.lines&&50<e.lines.length){for(b=a=e.lines.length%25+25;b<e.lines.length;)c=new Nb(e.lines.slice(b,
b+=25)),e.height-=c.height,this.children.splice(++d,0,c),c.parent=this;e.lines=e.lines.slice(0,a);this.maybeSpill()}break}a-=f}},maybeSpill:function(){if(!(10>=this.children.length)){var a=this;do{var b=a.children.splice(a.children.length-5,5),b=new Ob(b);if(a.parent){a.size-=b.size;a.height-=b.height;var c=L(a.parent.children,a);a.parent.children.splice(c+1,0,b)}else c=new Ob(a.children),c.parent=a,a.children=[c,b],a=c;b.parent=a.parent}while(10<a.children.length);a.parent.maybeSpill()}},iterN:function(a,
b,c){for(var d=0;d<this.children.length;++d){var e=this.children[d],f=e.chunkSize();if(a<f){f=Math.min(b,f-a);if(e.iterN(a,f,c))return!0;if(0==(b-=f))break;a=0}else a-=f}}};var Pb=function(a,b,c){if(c)for(var d in c)c.hasOwnProperty(d)&&(this[d]=c[d]);this.doc=a;this.node=b};Pb.prototype.clear=function(){var a=this.doc.cm,b=this.line.widgets,c=this.line,d=B(c);if(null!=d&&b){for(var e=0;e<b.length;++e)b[e]==this&&b.splice(e--,1);b.length||(c.widgets=null);var f=Bb(this);ma(c,Math.max(0,c.height-f));
a&&(Y(a,function(){var b=-f;oa(c)<(a.curOp&&a.curOp.scrollTop||a.doc.scrollTop)&&vc(a,b);Ba(a,d,"widget")}),N(a,"lineWidgetCleared",a,this,d))}};Pb.prototype.changed=function(){var a=this,b=this.height,c=this.doc.cm,d=this.line;this.height=null;var e=Bb(this)-b;e&&(za(this.doc,d)||ma(d,d.height+e),c&&Y(c,function(){c.curOp.forceUpdate=!0;oa(d)<(c.curOp&&c.curOp.scrollTop||c.doc.scrollTop)&&vc(c,e);N(c,"lineWidgetChanged",c,a,B(d))}))};ab(Pb);var Af=0,Da=function(a,b){this.lines=[];this.type=b;this.doc=
a;this.id=++Af};Da.prototype.clear=function(){if(!this.explicitlyCleared){var a=this.doc.cm,b=a&&!a.curOp;b&&Ta(a);if(ga(this,"clear")){var c=this.find();c&&N(this,"clear",c.from,c.to)}for(var d=c=null,e=0;e<this.lines.length;++e){var f=this.lines[e],g=ub(f.markedSpans,this);a&&!this.collapsed?Ba(a,B(f),"text"):a&&(null!=g.to&&(d=B(f)),null!=g.from&&(c=B(f)));for(var h=f,k=f.markedSpans,l=g,m=void 0,p=0;p<k.length;++p)k[p]!=l&&(m||(m=[])).push(k[p]);h.markedSpans=m;null==g.from&&this.collapsed&&!za(this.doc,
f)&&a&&ma(f,Oa(a.display))}if(a&&this.collapsed&&!a.options.lineWrapping)for(e=0;e<this.lines.length;++e)f=na(this.lines[e]),g=lc(f),g>a.display.maxLineLength&&(a.display.maxLine=f,a.display.maxLineLength=g,a.display.maxLineChanged=!0);null!=c&&a&&this.collapsed&&U(a,c,d+1);this.lines.length=0;this.explicitlyCleared=!0;this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,a&&qf(a.doc));a&&N(a,"markerCleared",a,this,c,d);b&&Ua(a);this.parent&&this.parent.clear()}};Da.prototype.find=function(a,b){null==
a&&"bookmark"==this.type&&(a=1);for(var c,d,e=0;e<this.lines.length;++e){var f=this.lines[e],g=ub(f.markedSpans,this);if(null!=g.from&&(c=q(b?f:B(f),g.from),-1==a))return c;if(null!=g.to&&(d=q(b?f:B(f),g.to),1==a))return d}return c&&{from:c,to:d}};Da.prototype.changed=function(){var a=this,b=this.find(-1,!0),c=this,d=this.doc.cm;b&&d&&Y(d,function(){var e=b.line,f=B(b.line);if(f=md(d,f))De(f),d.curOp.selectionChanged=d.curOp.forceUpdate=!0;d.curOp.updateMaxLine=!0;za(c.doc,e)||null==c.height||(f=
c.height,c.height=null,(f=Bb(c)-f)&&ma(e,e.height+f));N(d,"markerChanged",d,a)})};Da.prototype.attachLine=function(a){if(!this.lines.length&&this.doc.cm){var b=this.doc.cm.curOp;b.maybeHiddenMarkers&&-1!=L(b.maybeHiddenMarkers,this)||(b.maybeUnhiddenMarkers||(b.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(a)};Da.prototype.detachLine=function(a){this.lines.splice(L(this.lines,a),1);!this.lines.length&&this.doc.cm&&(a=this.doc.cm.curOp,(a.maybeHiddenMarkers||(a.maybeHiddenMarkers=[])).push(this))};
ab(Da);var Qb=function(a,b){this.markers=a;this.primary=b;for(var c=0;c<a.length;++c)a[c].parent=this};Qb.prototype.clear=function(){if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var a=0;a<this.markers.length;++a)this.markers[a].clear();N(this,"clear")}};Qb.prototype.find=function(a,b){return this.primary.find(a,b)};ab(Qb);var th=0,V=function(a,b,c,d,e){if(!(this instanceof V))return new V(a,b,c,d,e);null==c&&(c=0);Ob.call(this,[new Nb([new hb("",null)])]);this.first=c;this.scrollTop=
this.scrollLeft=0;this.cantEdit=!1;this.cleanGeneration=1;this.modeFrontier=this.highlightFrontier=c;c=q(c,0);this.sel=wa(c);this.history=new Ac(null);this.id=++th;this.modeOption=b;this.lineSep=d;this.direction="rtl"==e?"rtl":"ltr";this.extend=!1;"string"==typeof a&&(a=this.splitLines(a));Hd(this,{from:c,to:c,text:a});O(this,wa(c),ra)};V.prototype=Xd(Ob.prototype,{constructor:V,iter:function(a,b,c){c?this.iterN(a-this.first,b-a,c):this.iterN(this.first,this.first+this.size,a)},insert:function(a,
b){for(var c=0,d=0;d<b.length;++d)c+=b[d].height;this.insertInner(a-this.first,b,c)},remove:function(a,b){this.removeInner(a-this.first,b)},getValue:function(a){var b=Tc(this,this.first,this.first+this.size);return!1===a?b:b.join(a||this.lineSeparator())},setValue:K(function(a){var b=q(this.first,0),c=this.first+this.size-1;kb(this,{from:b,to:q(c,t(this,c).text.length),text:this.splitLines(a),origin:"setValue",full:!0},!0);this.cm&&Gb(this.cm,0,0);O(this,wa(b),ra)}),replaceRange:function(a,b,c,d){b=
x(this,b);c=c?x(this,c):b;lb(this,a,b,c,d)},getRange:function(a,b,c){a=Ia(this,x(this,a),x(this,b));return!1===c?a:a.join(c||this.lineSeparator())},getLine:function(a){return(a=this.getLineHandle(a))&&a.text},getLineHandle:function(a){if(tb(this,a))return t(this,a)},getLineNumber:function(a){return B(a)},getLineHandleVisualStart:function(a){"number"==typeof a&&(a=t(this,a));return na(a)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+
this.size-1},clipPos:function(a){return x(this,a)},getCursor:function(a){var b=this.sel.primary();return null==a||"head"==a?b.head:"anchor"==a?b.anchor:"end"==a||"to"==a||!1===a?b.to():b.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:K(function(a,b,c){a=x(this,"number"==typeof a?q(a,b||0):a);O(this,wa(a,null),c)}),setSelection:K(function(a,b,c){var d=x(this,a);a=x(this,b||a);O(this,wa(d,a),c)}),extendSelection:K(function(a,
b,c){Cc(this,x(this,a),b&&x(this,b),c)}),extendSelections:K(function(a,b){mf(this,$d(this,a),b)}),extendSelectionsBy:K(function(a,b){var c=gc(this.sel.ranges,a);mf(this,$d(this,c),b)}),setSelections:K(function(a,b,c){if(a.length){for(var d=[],e=0;e<a.length;e++)d[e]=new z(x(this,a[e].anchor),x(this,a[e].head));null==b&&(b=Math.min(a.length-1,this.sel.primIndex));O(this,la(d,b),c)}}),addSelection:K(function(a,b,c){var d=this.sel.ranges.slice(0);d.push(new z(x(this,a),x(this,b||a)));O(this,la(d,d.length-
1),c)}),getSelection:function(a){for(var b=this.sel.ranges,c,d=0;d<b.length;d++){var e=Ia(this,b[d].from(),b[d].to());c=c?c.concat(e):e}return!1===a?c:c.join(a||this.lineSeparator())},getSelections:function(a){for(var b=[],c=this.sel.ranges,d=0;d<c.length;d++){var e=Ia(this,c[d].from(),c[d].to());!1!==a&&(e=e.join(a||this.lineSeparator()));b[d]=e}return b},replaceSelection:function(a,b,c){for(var d=[],e=0;e<this.sel.ranges.length;e++)d[e]=a;this.replaceSelections(d,b,c||"+input")},replaceSelections:K(function(a,
b,c){for(var d=[],e=this.sel,f=0;f<e.ranges.length;f++){var g=e.ranges[f];d[f]={from:g.from(),to:g.to(),text:this.splitLines(a[f]),origin:c}}if(a=b&&"end"!=b){a=[];e=c=q(this.first,0);for(f=0;f<d.length;f++){var h=d[f],g=df(h.from,c,e),k=df(Ca(h),c,e);c=h.to;e=k;"around"==b?(h=this.sel.ranges[f],h=0>y(h.head,h.anchor),a[f]=new z(h?k:g,h?g:k)):a[f]=new z(g,g)}a=new ca(a,this.sel.primIndex)}b=a;for(a=d.length-1;0<=a;a--)kb(this,d[a]);b?nf(this,b):this.cm&&fb(this.cm)}),undo:K(function(){Ec(this,"undo")}),
redo:K(function(){Ec(this,"redo")}),undoSelection:K(function(){Ec(this,"undo",!0)}),redoSelection:K(function(){Ec(this,"redo",!0)}),setExtending:function(a){this.extend=a},getExtending:function(){return this.extend},historySize:function(){for(var a=this.history,b=0,c=0,d=0;d<a.done.length;d++)a.done[d].ranges||++b;for(d=0;d<a.undone.length;d++)a.undone[d].ranges||++c;return{undo:b,redo:c}},clearHistory:function(){this.history=new Ac(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=
this.changeGeneration(!0)},changeGeneration:function(a){a&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null);return this.history.generation},isClean:function(a){return this.history.generation==(a||this.cleanGeneration)},getHistory:function(){return{done:ib(this.history.done),undone:ib(this.history.undone)}},setHistory:function(a){var b=this.history=new Ac(this.history.maxGeneration);b.done=ib(a.done.slice(0),null,!0);b.undone=ib(a.undone.slice(0),null,!0)},setGutterMarker:K(function(a,
b,c){return Mb(this,a,"gutter",function(a){var e=a.gutterMarkers||(a.gutterMarkers={});e[b]=c;!c&&Yd(e)&&(a.gutterMarkers=null);return!0})}),clearGutter:K(function(a){var b=this;this.iter(function(c){c.gutterMarkers&&c.gutterMarkers[a]&&Mb(b,c,"gutter",function(){c.gutterMarkers[a]=null;Yd(c.gutterMarkers)&&(c.gutterMarkers=null);return!0})})}),lineInfo:function(a){var b;if("number"==typeof a){if(!tb(this,a))return null;b=a;a=t(this,a);if(!a)return null}else if(b=B(a),null==b)return null;return{line:b,
handle:a,text:a.text,gutterMarkers:a.gutterMarkers,textClass:a.textClass,bgClass:a.bgClass,wrapClass:a.wrapClass,widgets:a.widgets}},addLineClass:K(function(a,b,c){return Mb(this,a,"gutter"==b?"gutter":"class",function(a){var e="text"==b?"textClass":"background"==b?"bgClass":"gutter"==b?"gutterClass":"wrapClass";if(a[e]){if(Fa(c).test(a[e]))return!1;a[e]+=" "+c}else a[e]=c;return!0})}),removeLineClass:K(function(a,b,c){return Mb(this,a,"gutter"==b?"gutter":"class",function(a){var e="text"==b?"textClass":
"background"==b?"bgClass":"gutter"==b?"gutterClass":"wrapClass",f=a[e];if(f)if(null==c)a[e]=null;else{var g=f.match(Fa(c));if(!g)return!1;var h=g.index+g[0].length;a[e]=f.slice(0,g.index)+(g.index&&h!=f.length?" ":"")+f.slice(h)||null}else return!1;return!0})}),addLineWidget:K(function(a,b,c){return Pg(this,a,b,c)}),removeLineWidget:function(a){a.clear()},markText:function(a,b,c){return mb(this,x(this,a),x(this,b),c,c&&c.type||"range")},setBookmark:function(a,b){var c={replacedWith:b&&(null==b.nodeType?
b.widget:b),insertLeft:b&&b.insertLeft,clearWhenEmpty:!1,shared:b&&b.shared,handleMouseEvents:b&&b.handleMouseEvents};a=x(this,a);return mb(this,a,a,c,"bookmark")},findMarksAt:function(a){a=x(this,a);var b=[],c=t(this,a.line).markedSpans;if(c)for(var d=0;d<c.length;++d){var e=c[d];(null==e.from||e.from<=a.ch)&&(null==e.to||e.to>=a.ch)&&b.push(e.marker.parent||e.marker)}return b},findMarks:function(a,b,c){a=x(this,a);b=x(this,b);var d=[],e=a.line;this.iter(a.line,b.line+1,function(f){if(f=f.markedSpans)for(var g=
0;g<f.length;g++){var h=f[g];null!=h.to&&e==a.line&&a.ch>=h.to||null==h.from&&e!=a.line||null!=h.from&&e==b.line&&h.from>=b.ch||c&&!c(h.marker)||d.push(h.marker.parent||h.marker)}++e});return d},getAllMarks:function(){var a=[];this.iter(function(b){if(b=b.markedSpans)for(var c=0;c<b.length;++c)null!=b[c].from&&a.push(b[c].marker)});return a},posFromIndex:function(a){var b,c=this.first,d=this.lineSeparator().length;this.iter(function(e){e=e.text.length+d;if(e>a)return b=a,!0;a-=e;++c});return x(this,
q(c,b))},indexFromPos:function(a){a=x(this,a);var b=a.ch;if(a.line<this.first||0>a.ch)return 0;var c=this.lineSeparator().length;this.iter(this.first,a.line,function(a){b+=a.text.length+c});return b},copy:function(a){var b=new V(Tc(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);b.scrollTop=this.scrollTop;b.scrollLeft=this.scrollLeft;b.sel=this.sel;b.extend=!1;a&&(b.history.undoDepth=this.history.undoDepth,b.setHistory(this.getHistory()));return b},linkedDoc:function(a){a||
(a={});var b=this.first,c=this.first+this.size;null!=a.from&&a.from>b&&(b=a.from);null!=a.to&&a.to<c&&(c=a.to);b=new V(Tc(this,b,c),a.mode||this.modeOption,b,this.lineSep,this.direction);a.sharedHist&&(b.history=this.history);(this.linked||(this.linked=[])).push({doc:b,sharedHist:a.sharedHist});b.linked=[{doc:this,isParent:!0,sharedHist:a.sharedHist}];a=Bf(this);for(c=0;c<a.length;c++){var d=a[c],e=d.find(),f=b.clipPos(e.from),e=b.clipPos(e.to);y(f,e)&&(f=mb(b,f,e,d.primary,d.primary.type),d.markers.push(f),
f.parent=d)}return b},unlinkDoc:function(a){a instanceof E&&(a=a.doc);if(this.linked)for(var b=0;b<this.linked.length;++b)if(this.linked[b].doc==a){this.linked.splice(b,1);a.unlinkDoc(this);Rg(Bf(this));break}if(a.history==this.history){var c=[a.id];Va(a,function(a){return c.push(a.id)},!0);a.history=new Ac(null);a.history.done=ib(this.history.done,c);a.history.undone=ib(this.history.undone,c)}},iterLinkedDocs:function(a){Va(this,a)},getMode:function(){return this.mode},getEditor:function(){return this.cm},
splitLines:function(a){return this.lineSep?a.split(this.lineSep):Ud(a)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:K(function(a){"rtl"!=a&&(a="ltr");a!=this.direction&&(this.direction=a,this.iter(function(a){return a.order=null}),this.cm&&Lg(this.cm))})});V.prototype.eachLine=V.prototype.iter;for(var Df=0,Wf=!1,Ea={3:"Pause",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",
37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"\x3d",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"\x3d",109:"-",110:".",111:"/",127:"Delete",145:"ScrollLock",173:"-",186:";",187:"\x3d",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},cc=0;10>cc;cc++)Ea[cc+48]=Ea[cc+96]=String(cc);for(var Mc=65;90>=Mc;Mc++)Ea[Mc]=
String.fromCharCode(Mc);for(var dc=1;12>=dc;dc++)Ea[dc+111]=Ea[dc+63235]="F"+dc;var Rb={basic:{Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},pcDefault:{"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo",
"Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection",
"Alt-U":"redoSelection",fallthrough:"basic"},emacsy:{"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},macDefault:{"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo",
"Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft",
"Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]}};Rb["default"]=ha?Rb.macDefault:Rb.pcDefault;var Sb={selectAll:sf,singleSelection:function(a){return a.setSelection(a.getCursor("anchor"),a.getCursor("head"),ra)},killLine:function(a){return ob(a,function(b){if(b.empty()){var c=t(a.doc,b.head.line).text.length;return b.head.ch==c&&b.head.line<a.lastLine()?{from:b.head,to:q(b.head.line+
1,0)}:{from:b.head,to:q(b.head.line,c)}}return{from:b.from(),to:b.to()}})},deleteLine:function(a){return ob(a,function(b){return{from:q(b.from().line,0),to:x(a.doc,q(b.to().line+1,0))}})},delLineLeft:function(a){return ob(a,function(a){return{from:q(a.from().line,0),to:a.from()}})},delWrappedLineLeft:function(a){return ob(a,function(b){var c=a.charCoords(b.head,"div").top+5;return{from:a.coordsChar({left:0,top:c},"div"),to:b.from()}})},delWrappedLineRight:function(a){return ob(a,function(b){var c=
a.charCoords(b.head,"div").top+5,c=a.coordsChar({left:a.display.lineDiv.offsetWidth+100,top:c},"div");return{from:b.from(),to:c}})},undo:function(a){return a.undo()},redo:function(a){return a.redo()},undoSelection:function(a){return a.undoSelection()},redoSelection:function(a){return a.redoSelection()},goDocStart:function(a){return a.extendSelection(q(a.firstLine(),0))},goDocEnd:function(a){return a.extendSelection(q(a.lastLine()))},goLineStart:function(a){return a.extendSelectionsBy(function(b){return Jf(a,
b.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(a){return a.extendSelectionsBy(function(b){return Kf(a,b.head)},{origin:"+move",bias:1})},goLineEnd:function(a){return a.extendSelectionsBy(function(b){b=b.head.line;var c=t(a.doc,b),d;d=c;for(var e;e=$a(d,!1);)d=e.find(1,!0).line;d!=c&&(b=B(d));return Od(!0,a,c,b,-1)},{origin:"+move",bias:-1})},goLineRight:function(a){return a.extendSelectionsBy(function(b){b=a.cursorCoords(b.head,"div").top+5;return a.coordsChar({left:a.display.lineDiv.offsetWidth+
100,top:b},"div")},ac)},goLineLeft:function(a){return a.extendSelectionsBy(function(b){b=a.cursorCoords(b.head,"div").top+5;return a.coordsChar({left:0,top:b},"div")},ac)},goLineLeftSmart:function(a){return a.extendSelectionsBy(function(b){var c=a.cursorCoords(b.head,"div").top+5,c=a.coordsChar({left:0,top:c},"div");return c.ch<a.getLine(c.line).search(/\S/)?Kf(a,b.head):c},ac)},goLineUp:function(a){return a.moveV(-1,"line")},goLineDown:function(a){return a.moveV(1,"line")},goPageUp:function(a){return a.moveV(-1,
"page")},goPageDown:function(a){return a.moveV(1,"page")},goCharLeft:function(a){return a.moveH(-1,"char")},goCharRight:function(a){return a.moveH(1,"char")},goColumnLeft:function(a){return a.moveH(-1,"column")},goColumnRight:function(a){return a.moveH(1,"column")},goWordLeft:function(a){return a.moveH(-1,"word")},goGroupRight:function(a){return a.moveH(1,"group")},goGroupLeft:function(a){return a.moveH(-1,"group")},goWordRight:function(a){return a.moveH(1,"word")},delCharBefore:function(a){return a.deleteH(-1,
"char")},delCharAfter:function(a){return a.deleteH(1,"char")},delWordBefore:function(a){return a.deleteH(-1,"word")},delWordAfter:function(a){return a.deleteH(1,"word")},delGroupBefore:function(a){return a.deleteH(-1,"group")},delGroupAfter:function(a){return a.deleteH(1,"group")},indentAuto:function(a){return a.indentSelection("smart")},indentMore:function(a){return a.indentSelection("add")},indentLess:function(a){return a.indentSelection("subtract")},insertTab:function(a){return a.replaceSelection("\t")},
insertSoftTab:function(a){for(var b=[],c=a.listSelections(),d=a.options.tabSize,e=0;e<c.length;e++){var f=c[e].from(),f=fa(a.getLine(f.line),f.ch,d);b.push(Qc(d-f%d))}a.replaceSelections(b)},defaultTab:function(a){a.somethingSelected()?a.indentSelection("add"):a.execCommand("insertTab")},transposeChars:function(a){return Y(a,function(){for(var b=a.listSelections(),c=[],d=0;d<b.length;d++)if(b[d].empty()){var e=b[d].head,f=t(a.doc,e.line).text;if(f)if(e.ch==f.length&&(e=new q(e.line,e.ch-1)),0<e.ch)e=
new q(e.line,e.ch+1),a.replaceRange(f.charAt(e.ch-1)+f.charAt(e.ch-2),q(e.line,e.ch-2),e,"+transpose");else if(e.line>a.doc.first){var g=t(a.doc,e.line-1).text;g&&(e=new q(e.line,1),a.replaceRange(f.charAt(0)+a.doc.lineSeparator()+g.charAt(g.length-1),q(e.line-1,g.length-1),e,"+transpose"))}c.push(new z(e,e))}a.setSelections(c)})},newlineAndIndent:function(a){return Y(a,function(){for(var b=a.listSelections(),c=b.length-1;0<=c;c--)a.replaceRange(a.doc.lineSeparator(),b[c].anchor,b[c].head,"+input");
b=a.listSelections();for(c=0;c<b.length;c++)a.indentLine(b[c].from().line,null,!0);fb(a)})},openLine:function(a){return a.replaceSelection("\n","start")},toggleOverwrite:function(a){return a.toggleOverwrite()}},Yg=new Wa,Pd=null,Qd=function(a,b,c){this.time=a;this.pos=b;this.button=c};Qd.prototype.compare=function(a,b,c){return this.time+400>a&&0==y(b,this.pos)&&c==this.button};var Vb,Ub,pb={toString:function(){return"CodeMirror.Init"}},Vf={},Kc={};E.defaults=Vf;E.optionHandlers=Kc;var Sd=[];E.defineInitHook=
function(a){return Sd.push(a)};var da=null,C=function(a){this.cm=a;this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null;this.polling=new Wa;this.composing=null;this.gracePeriod=!1;this.readDOMTimeout=null};C.prototype.init=function(a){function b(a){if(!I(e,a)){if(e.somethingSelected())Yf({lineWise:!1,text:e.getSelections()}),"cut"==a.type&&e.replaceSelection("",null,"cut");else if(e.options.lineWiseCopyCut){var b=ag(e);Yf({lineWise:!0,text:b.text});"cut"==a.type&&
e.operation(function(){e.setSelections(b.ranges,0,ra);e.replaceSelection("",null,"cut")})}else return;if(a.clipboardData){a.clipboardData.clearData();var c=da.text.join("\n");a.clipboardData.setData("Text",c);if(a.clipboardData.getData("Text")==c){a.preventDefault();return}}var l=cg();a=l.firstChild;e.display.lineSpace.insertBefore(l,e.display.lineSpace.firstChild);a.value=da.text.join("\n");var m=document.activeElement;$b(a);setTimeout(function(){e.display.lineSpace.removeChild(l);m.focus();m==f&&
d.showPrimarySelection()},50)}}var c=this,d=this,e=d.cm,f=d.div=a.lineDiv;bg(f,e.options.spellcheck);v(f,"paste",function(a){I(e,a)||$f(a,e)||11>=D&&setTimeout(J(e,function(){return c.updateFromDOM()}),20)});v(f,"compositionstart",function(a){c.composing={data:a.data,done:!1}});v(f,"compositionupdate",function(a){c.composing||(c.composing={data:a.data,done:!1})});v(f,"compositionend",function(a){c.composing&&(a.data!=c.composing.data&&c.readFromDOMSoon(),c.composing.done=!0)});v(f,"touchstart",function(){return d.forceCompositionEnd()});
v(f,"input",function(){c.composing||c.readFromDOMSoon()});v(f,"copy",b);v(f,"cut",b)};C.prototype.prepareSelection=function(){var a=Me(this.cm,!1);a.focus=this.cm.state.focused;return a};C.prototype.showSelection=function(a,b){a&&this.cm.display.view.length&&((a.focus||b)&&this.showPrimarySelection(),this.showMultipleSelections(a))};C.prototype.getSelection=function(){return this.cm.display.wrapper.ownerDocument.getSelection()};C.prototype.showPrimarySelection=function(){var a=this.getSelection(),
b=this.cm,c=b.doc.sel.primary(),d=c.from(),c=c.to();if(b.display.viewTo==b.display.viewFrom||d.line>=b.display.viewTo||c.line<b.display.viewFrom)a.removeAllRanges();else{var e=Lc(b,a.anchorNode,a.anchorOffset),f=Lc(b,a.focusNode,a.focusOffset);if(!e||e.bad||!f||f.bad||0!=y(jc(e,f),d)||0!=y(ic(e,f),c))if(e=b.display.view,d=d.line>=b.display.viewFrom&&eg(b,d)||{node:e[0].measure.map[2],offset:0},c=c.line<b.display.viewTo&&eg(b,c),c||(c=e[e.length-1].measure,c=c.maps?c.maps[c.maps.length-1]:c.map,c=
{node:c[c.length-1],offset:c[c.length-2]-c[c.length-3]}),d&&c){var e=a.rangeCount&&a.getRangeAt(0),g;try{g=db(d.node,d.offset,c.offset,c.node)}catch(h){}g&&(!ya&&b.state.focused?(a.collapse(d.node,d.offset),g.collapsed||(a.removeAllRanges(),a.addRange(g))):(a.removeAllRanges(),a.addRange(g)),e&&null==a.anchorNode?a.addRange(e):ya&&this.startGracePeriod());this.rememberSelection()}else a.removeAllRanges()}};C.prototype.startGracePeriod=function(){var a=this;clearTimeout(this.gracePeriod);this.gracePeriod=
setTimeout(function(){a.gracePeriod=!1;a.selectionChanged()&&a.cm.operation(function(){return a.cm.curOp.selectionChanged=!0})},20)};C.prototype.showMultipleSelections=function(a){Z(this.cm.display.cursorDiv,a.cursors);Z(this.cm.display.selectionDiv,a.selection)};C.prototype.rememberSelection=function(){var a=this.getSelection();this.lastAnchorNode=a.anchorNode;this.lastAnchorOffset=a.anchorOffset;this.lastFocusNode=a.focusNode;this.lastFocusOffset=a.focusOffset};C.prototype.selectionInEditor=function(){var a=
this.getSelection();if(!a.rangeCount)return!1;a=a.getRangeAt(0).commonAncestorContainer;return xa(this.div,a)};C.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())};C.prototype.blur=function(){this.div.blur()};C.prototype.getField=function(){return this.div};C.prototype.supportsTouch=function(){return!0};C.prototype.receivedFocus=function(){function a(){b.cm.state.focused&&(b.pollSelection(),
b.polling.set(b.cm.options.pollInterval,a))}var b=this;this.selectionInEditor()?this.pollSelection():Y(this.cm,function(){return b.cm.curOp.selectionChanged=!0});this.polling.set(this.cm.options.pollInterval,a)};C.prototype.selectionChanged=function(){var a=this.getSelection();return a.anchorNode!=this.lastAnchorNode||a.anchorOffset!=this.lastAnchorOffset||a.focusNode!=this.lastFocusNode||a.focusOffset!=this.lastFocusOffset};C.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&
this.selectionChanged()){var a=this.getSelection(),b=this.cm;if(rc&&qc&&this.cm.options.gutters.length&&mh(a.anchorNode))this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),this.focus();else if(!this.composing){this.rememberSelection();var c=Lc(b,a.anchorNode,a.anchorOffset),d=Lc(b,a.focusNode,a.focusOffset);c&&d&&Y(b,function(){O(b.doc,wa(c,d),ra);if(c.bad||d.bad)b.curOp.selectionChanged=!0})}}};C.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),
this.readDOMTimeout=null);var a=this.cm,b=a.display,c=a.doc.sel.primary(),d=c.from(),e=c.to();0==d.ch&&d.line>a.firstLine()&&(d=q(d.line-1,t(a.doc,d.line-1).length));e.ch==t(a.doc,e.line).text.length&&e.line<a.lastLine()&&(e=q(e.line+1,0));if(d.line<b.viewFrom||e.line>b.viewTo-1)return!1;var f;d.line==b.viewFrom||0==(f=Ma(a,d.line))?(c=B(b.view[0].line),f=b.view[0].node):(c=B(b.view[f].line),f=b.view[f-1].node.nextSibling);var g=Ma(a,e.line);g==b.view.length-1?(e=b.viewTo-1,b=b.lineDiv.lastChild):
(e=B(b.view[g+1].line)-1,b=b.view[g+1].node.previousSibling);if(!f)return!1;b=a.doc.splitLines(nh(a,f,b,c,e));for(f=Ia(a.doc,q(c,0),q(e,t(a.doc,e).text.length));1<b.length&&1<f.length;)if(w(b)==w(f))b.pop(),f.pop(),e--;else if(b[0]==f[0])b.shift(),f.shift(),c++;else break;for(var h=0,g=0,k=b[0],l=f[0],m=Math.min(k.length,l.length);h<m&&k.charCodeAt(h)==l.charCodeAt(h);)++h;k=w(b);l=w(f);for(m=Math.min(k.length-(1==b.length?h:0),l.length-(1==f.length?h:0));g<m&&k.charCodeAt(k.length-g-1)==l.charCodeAt(l.length-
g-1);)++g;if(1==b.length&&1==f.length&&c==d.line)for(;h&&h>d.ch&&k.charCodeAt(k.length-g-1)==l.charCodeAt(l.length-g-1);)h--,g++;b[b.length-1]=k.slice(0,k.length-g).replace(/^\u200b+/,"");b[0]=b[0].slice(h).replace(/\u200b+$/,"");d=q(c,h);c=q(e,f.length?w(f).length-g:0);if(1<b.length||b[0]||y(d,c))return lb(a.doc,b,d,c,"+input"),!0};C.prototype.ensurePolled=function(){this.forceCompositionEnd()};C.prototype.reset=function(){this.forceCompositionEnd()};C.prototype.forceCompositionEnd=function(){this.composing&&
(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())};C.prototype.readFromDOMSoon=function(){var a=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){a.readDOMTimeout=null;if(a.composing)if(a.composing.done)a.composing=null;else return;a.updateFromDOM()},80))};C.prototype.updateFromDOM=function(){var a=this;!this.cm.isReadOnly()&&this.pollContent()||Y(this.cm,function(){return U(a.cm)})};C.prototype.setUneditable=function(a){a.contentEditable=
"false"};C.prototype.onKeyPress=function(a){0==a.charCode||this.composing||(a.preventDefault(),this.cm.isReadOnly()||J(this.cm,Td)(this.cm,String.fromCharCode(null==a.charCode?a.keyCode:a.charCode),0))};C.prototype.readOnlyChanged=function(a){this.div.contentEditable=String("nocursor"!=a)};C.prototype.onContextMenu=function(){};C.prototype.resetPosition=function(){};C.prototype.needsContentAttribute=!0;var H=function(a){this.cm=a;this.prevInput="";this.pollingFast=!1;this.polling=new Wa;this.hasSelection=
!1;this.composing=null};H.prototype.init=function(a){function b(a){if(!I(e,a)){if(e.somethingSelected())da={lineWise:!1,text:e.getSelections()};else if(e.options.lineWiseCopyCut){var b=ag(e);da={lineWise:!0,text:b.text};"cut"==a.type?e.setSelections(b.ranges,null,ra):(d.prevInput="",f.value=b.text.join("\n"),$b(f))}else return;"cut"==a.type&&(e.state.cutIncoming=!0)}}var c=this,d=this,e=this.cm;this.createField(a);var f=this.textarea;a.wrapper.insertBefore(this.wrapper,a.wrapper.firstChild);Yb&&(f.style.width=
"0px");v(f,"input",function(){A&&9<=D&&c.hasSelection&&(c.hasSelection=null);d.poll()});v(f,"paste",function(a){I(e,a)||$f(a,e)||(e.state.pasteIncoming=!0,d.fastPoll())});v(f,"cut",b);v(f,"copy",b);v(a.scroller,"paste",function(b){va(a,b)||I(e,b)||(e.state.pasteIncoming=!0,d.focus())});v(a.lineSpace,"selectstart",function(b){va(a,b)||T(b)});v(f,"compositionstart",function(){var a=e.getCursor("from");d.composing&&d.composing.range.clear();d.composing={start:a,range:e.markText(a,e.getCursor("to"),{className:"CodeMirror-composing"})}});
v(f,"compositionend",function(){d.composing&&(d.poll(),d.composing.range.clear(),d.composing=null)})};H.prototype.createField=function(a){this.wrapper=cg();this.textarea=this.wrapper.firstChild};H.prototype.prepareSelection=function(){var a=this.cm,b=a.display,c=a.doc,d=Me(a);if(a.options.moveInputWithCursor){var a=ja(a,c.sel.primary().head,"div"),c=b.wrapper.getBoundingClientRect(),e=b.lineDiv.getBoundingClientRect();d.teTop=Math.max(0,Math.min(b.wrapper.clientHeight-10,a.top+e.top-c.top));d.teLeft=
Math.max(0,Math.min(b.wrapper.clientWidth-10,a.left+e.left-c.left))}return d};H.prototype.showSelection=function(a){var b=this.cm.display;Z(b.cursorDiv,a.cursors);Z(b.selectionDiv,a.selection);null!=a.teTop&&(this.wrapper.style.top=a.teTop+"px",this.wrapper.style.left=a.teLeft+"px")};H.prototype.reset=function(a){if(!this.contextMenuPending&&!this.composing){var b=this.cm;b.somethingSelected()?(this.prevInput="",a=b.getSelection(),this.textarea.value=a,b.state.focused&&$b(this.textarea),A&&9<=D&&
(this.hasSelection=a)):a||(this.prevInput=this.textarea.value="",A&&9<=D&&(this.hasSelection=null))}};H.prototype.getField=function(){return this.textarea};H.prototype.supportsTouch=function(){return!1};H.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!sb||sa()!=this.textarea))try{this.textarea.focus()}catch(a){}};H.prototype.blur=function(){this.textarea.blur()};H.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0};H.prototype.receivedFocus=
function(){this.slowPoll()};H.prototype.slowPoll=function(){var a=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){a.poll();a.cm.state.focused&&a.slowPoll()})};H.prototype.fastPoll=function(){function a(){c.poll()||b?(c.pollingFast=!1,c.slowPoll()):(b=!0,c.polling.set(60,a))}var b=!1,c=this;c.pollingFast=!0;c.polling.set(20,a)};H.prototype.poll=function(){var a=this,b=this.cm,c=this.textarea,d=this.prevInput;if(this.contextMenuPending||!b.state.focused||sh(c)&&!d&&!this.composing||
b.isReadOnly()||b.options.disableInput||b.state.keySeq)return!1;var e=c.value;if(e==d&&!b.somethingSelected())return!1;if(A&&9<=D&&this.hasSelection===e||ha&&/[\uf700-\uf7ff]/.test(e))return b.display.input.reset(),!1;if(b.doc.sel==b.display.selForContextMenu){var f=e.charCodeAt(0);8203!=f||d||(d="​");if(8666==f)return this.reset(),this.cm.execCommand("undo")}for(var g=0,f=Math.min(d.length,e.length);g<f&&d.charCodeAt(g)==e.charCodeAt(g);)++g;Y(b,function(){Td(b,e.slice(g),d.length-g,null,a.composing?
"*compose":null);1E3<e.length||-1<e.indexOf("\n")?c.value=a.prevInput="":a.prevInput=e;a.composing&&(a.composing.range.clear(),a.composing.range=b.markText(a.composing.start,b.getCursor("to"),{className:"CodeMirror-composing"}))});return!0};H.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)};H.prototype.onKeyPress=function(){A&&9<=D&&(this.hasSelection=null);this.fastPoll()};H.prototype.onContextMenu=function(a){function b(){if(null!=g.selectionStart){var a=e.somethingSelected(),
b="​"+(a?g.value:"");g.value="⇚";g.value=b;d.prevInput=a?"":"​";g.selectionStart=1;g.selectionEnd=b.length;f.selForContextMenu=e.doc.sel}}function c(){d.contextMenuPending=!1;d.wrapper.style.cssText=m;g.style.cssText=l;A&&9>D&&f.scrollbars.setScrollTop(f.scroller.scrollTop=k);if(null!=g.selectionStart){(!A||A&&9>D)&&b();var a=0,c=function(){f.selForContextMenu==e.doc.sel&&0==g.selectionStart&&0<g.selectionEnd&&"​"==d.prevInput?J(e,sf)(e):10>a++?f.detectingSelectAll=setTimeout(c,500):(f.selForContextMenu=
null,f.input.reset())};f.detectingSelectAll=setTimeout(c,200)}}var d=this,e=d.cm,f=e.display,g=d.textarea,h=Qa(e,a),k=f.scroller.scrollTop;if(h&&!ka){e.options.resetSelectionOnContextMenu&&-1==e.doc.sel.contains(h)&&J(e,O)(e.doc,wa(h),ra);var l=g.style.cssText,m=d.wrapper.style.cssText;d.wrapper.style.cssText="position: absolute";h=d.wrapper.getBoundingClientRect();g.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(a.clientY-h.top-5)+"px; left: "+(a.clientX-h.left-5)+"px;\n      z-index: 1000; background: "+
(A?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity\x3d5);";var p;P&&(p=window.scrollY);f.input.focus();P&&window.scrollTo(null,p);f.input.reset();e.somethingSelected()||(g.value=d.prevInput=" ");d.contextMenuPending=!0;f.selForContextMenu=e.doc.sel;clearTimeout(f.detectingSelectAll);A&&9<=D&&b();if(Ic){xb(a);var n=function(){aa(window,"mouseup",n);setTimeout(c,20)};v(window,"mouseup",n)}else setTimeout(c,
50)}};H.prototype.readOnlyChanged=function(a){a||this.reset();this.textarea.disabled="nocursor"==a};H.prototype.setUneditable=function(){};H.prototype.needsContentAttribute=!1;(function(a){function b(b,e,f,g){a.defaults[b]=e;f&&(c[b]=g?function(a,b,c){c!=pb&&f(a,b,c)}:f)}var c=a.optionHandlers;a.defineOption=b;a.Init=pb;b("value","",function(a,b){return a.setValue(b)},!0);b("mode",null,function(a,b){a.doc.modeOption=b;Gd(a)},!0);b("indentUnit",2,Gd,!0);b("indentWithTabs",!1);b("smartIndent",!0);b("tabSize",
4,function(a){Kb(a);Db(a);U(a)},!0);b("lineSeparator",null,function(a,b){if(a.doc.lineSep=b){var c=[],g=a.doc.first;a.doc.iter(function(a){for(var d=0;;){var h=a.text.indexOf(b,d);if(-1==h)break;d=h+b.length;c.push(q(g,h))}g++});for(var h=c.length-1;0<=h;h--)lb(a.doc,b,c[h],q(c[h].line,c[h].ch+b.length))}});b("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(a,b,c){a.state.specialChars=new RegExp(b.source+(b.test("\t")?"":"|\t"),"g");c!=pb&&a.refresh()});
b("specialCharPlaceholder",yg,function(a){return a.refresh()},!0);b("electricChars",!0);b("inputStyle",sb?"contenteditable":"textarea",function(){throw Error("inputStyle can not (yet) be changed in a running editor");},!0);b("spellcheck",!1,function(a,b){return a.getInputField().spellcheck=b},!0);b("rtlMoveVisually",!rh);b("wholeLineUpdateBefore",!0);b("theme","default",function(a){Uf(a);Wb(a)},!0);b("keyMap","default",function(a,b,c){b=Fc(b);(c=c!=pb&&Fc(c))&&c.detach&&c.detach(a,b);b.attach&&b.attach(a,
c||null)});b("extraKeys",null);b("configureMouse",null);b("lineWrapping",!1,kh,!0);b("gutters",[],function(a){Ed(a.options);Wb(a)},!0);b("fixedGutter",!0,function(a,b){a.display.gutters.style.left=b?ud(a.display)+"px":"0";a.refresh()},!0);b("coverGutterNextToScrollbar",!1,function(a){return gb(a)},!0);b("scrollbarStyle","native",function(a){We(a);gb(a);a.display.scrollbars.setScrollTop(a.doc.scrollTop);a.display.scrollbars.setScrollLeft(a.doc.scrollLeft)},!0);b("lineNumbers",!1,function(a){Ed(a.options);
Wb(a)},!0);b("firstLineNumber",1,Wb,!0);b("lineNumberFormatter",function(a){return a},Wb,!0);b("showCursorWhenSelecting",!1,Eb,!0);b("resetSelectionOnContextMenu",!0);b("lineWiseCopyCut",!0);b("pasteLinesPerSelection",!0);b("readOnly",!1,function(a,b){"nocursor"==b&&(Fb(a),a.display.input.blur());a.display.input.readOnlyChanged(b)});b("disableInput",!1,function(a,b){b||a.display.input.reset()},!0);b("dragDrop",!0,jh);b("allowDropFileTypes",null);b("cursorBlinkRate",530);b("cursorScrollMargin",0);
b("cursorHeight",1,Eb,!0);b("singleCursorHeightPerLine",!0,Eb,!0);b("workTime",100);b("workDelay",100);b("flattenSpans",!0,Kb,!0);b("addModeClass",!1,Kb,!0);b("pollInterval",100);b("undoDepth",200,function(a,b){return a.doc.history.undoDepth=b});b("historyEventDelay",1250);b("viewportMargin",10,function(a){return a.refresh()},!0);b("maxHighlightLength",1E4,Kb,!0);b("moveInputWithCursor",!0,function(a,b){b||a.display.input.resetPosition()});b("tabindex",null,function(a,b){return a.display.input.getField().tabIndex=
b||""});b("autofocus",null);b("direction","ltr",function(a,b){return a.doc.setDirection(b)},!0);b("phrases",null)})(E);(function(a){var b=a.optionHandlers,c=a.helpers={};a.prototype={constructor:a,focus:function(){window.focus();this.display.input.focus()},setOption:function(a,c){var f=this.options,g=f[a];if(f[a]!=c||"mode"==a)f[a]=c,b.hasOwnProperty(a)&&J(this,b[a])(this,c,g),F(this,"optionChange",this,a)},getOption:function(a){return this.options[a]},getDoc:function(){return this.doc},addKeyMap:function(a,
b){this.state.keyMaps[b?"push":"unshift"](Fc(a))},removeKeyMap:function(a){for(var b=this.state.keyMaps,c=0;c<b.length;++c)if(b[c]==a||b[c].name==a)return b.splice(c,1),!0},addOverlay:R(function(b,c){var f=b.token?b:a.getMode(this.options,b);if(f.startState)throw Error("Overlays may not be stateful.");ig(this.state.overlays,{mode:f,modeSpec:b,opaque:c&&c.opaque,priority:c&&c.priority||0},function(a){return a.priority});this.state.modeGen++;U(this)}),removeOverlay:R(function(a){for(var b=this.state.overlays,
c=0;c<b.length;++c){var g=b[c].modeSpec;if(g==a||"string"==typeof a&&g.name==a){b.splice(c,1);this.state.modeGen++;U(this);break}}}),indentLine:R(function(a,b,c){"string"!=typeof b&&"number"!=typeof b&&(b=null==b?this.options.smartIndent?"smart":"prev":b?"add":"subtract");tb(this.doc,a)&&Xb(this,a,b,c)}),indentSelection:R(function(a){for(var b=this.doc.sel.ranges,c=-1,g=0;g<b.length;g++){var h=b[g];if(h.empty())h.head.line>c&&(Xb(this,h.head.line,a,!0),c=h.head.line,g==this.doc.sel.primIndex&&fb(this));
else{for(var k=h.from(),h=h.to(),l=Math.max(c,k.line),c=Math.min(this.lastLine(),h.line-(h.ch?0:1))+1,h=l;h<c;++h)Xb(this,h,a);h=this.doc.sel.ranges;0==k.ch&&b.length==h.length&&0<h[g].from().ch&&Kd(this.doc,g,new z(k,h[g].to()),ra)}}}),getTokenAt:function(a,b){return ne(this,a,b)},getLineTokens:function(a,b){return ne(this,q(a),b,!0)},getTokenTypeAt:function(a){a=x(this.doc,a);var b=le(this,t(this.doc,a.line)),c=0,g=(b.length-1)/2;a=a.ch;if(0==a)b=b[2];else for(;;){var h=c+g>>1;if((h?b[2*h-1]:0)>=
a)g=h;else if(b[2*h+1]<a)c=h+1;else{b=b[2*h+2];break}}c=b?b.indexOf("overlay "):-1;return 0>c?b:0==c?null:b.slice(0,c-1)},getModeAt:function(b){var c=this.doc.mode;return c.innerMode?a.innerMode(c,this.getTokenAt(b).state).mode:c},getHelper:function(a,b){return this.getHelpers(a,b)[0]},getHelpers:function(a,b){var f=[];if(!c.hasOwnProperty(b))return f;var g=c[b],h=this.getModeAt(a);if("string"==typeof h[b])g[h[b]]&&f.push(g[h[b]]);else if(h[b])for(var k=0;k<h[b].length;k++){var l=g[h[b][k]];l&&f.push(l)}else h.helperType&&
g[h.helperType]?f.push(g[h.helperType]):g[h.name]&&f.push(g[h.name]);for(k=0;k<g._global.length;k++)l=g._global[k],l.pred(h,this)&&-1==L(f,l.val)&&f.push(l.val);return f},getStateAfter:function(a,b){var c=this.doc;a=Math.max(c.first,Math.min(null==a?c.first+c.size-1:a,c.first+c.size-1));return yb(this,a+1,b).state},cursorCoords:function(a,b){var c;c=this.doc.sel.primary();c=null==a?c.head:"object"==typeof a?x(this.doc,a):a?c.from():c.to();return ja(this,c,b||"page")},charCoords:function(a,b){return qd(this,
x(this.doc,a),b||"page")},coordsChar:function(a,b){a=He(this,a,b||"page");return sd(this,a.left,a.top)},lineAtHeight:function(a,b){a=He(this,{top:a,left:0},b||"page").top;return Ja(this.doc,a+this.display.viewOffset)},heightAtLine:function(a,b,c){var g=!1;if("number"==typeof a){var h=this.doc.first+this.doc.size-1;a<this.doc.first?a=this.doc.first:a>h&&(a=h,g=!0);a=t(this.doc,a)}return sc(this,a,{top:0,left:0},b||"page",c||g).top+(g?this.doc.height-oa(a):0)},defaultTextHeight:function(){return Oa(this.display)},
defaultCharWidth:function(){return Cb(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(a,b,c,g,h){var k=this.display;a=ja(this,x(this.doc,a));var l=a.bottom,m=a.left;b.style.position="absolute";b.setAttribute("cm-ignore-events","true");this.display.input.setUneditable(b);k.sizer.appendChild(b);if("over"==g)l=a.top;else if("above"==g||"near"==g){var p=Math.max(k.wrapper.clientHeight,this.doc.height),n=Math.max(k.sizer.clientWidth,k.lineSpace.clientWidth);
("above"==g||a.bottom+b.offsetHeight>p)&&a.top>b.offsetHeight?l=a.top-b.offsetHeight:a.bottom+b.offsetHeight<=p&&(l=a.bottom);m+b.offsetWidth>n&&(m=n-b.offsetWidth)}b.style.top=l+"px";b.style.left=b.style.right="";"right"==h?(m=k.sizer.clientWidth-b.offsetWidth,b.style.right="0px"):("left"==h?m=0:"middle"==h&&(m=(k.sizer.clientWidth-b.offsetWidth)/2),b.style.left=m+"px");c&&(a=Ad(this,{left:m,top:l,right:m+b.offsetWidth,bottom:l+b.offsetHeight}),null!=a.scrollTop&&Hb(this,a.scrollTop),null!=a.scrollLeft&&
Sa(this,a.scrollLeft))},triggerOnKeyDown:R(Nf),triggerOnKeyPress:R(Pf),triggerOnKeyUp:Of,triggerOnMouseDown:R(Qf),execCommand:function(a){if(Sb.hasOwnProperty(a))return Sb[a].call(null,this)},triggerElectric:R(function(a){Zf(this,a)}),findPosH:function(a,b,c,g){var h=1;0>b&&(h=-1,b=-b);a=x(this.doc,a);for(var k=0;k<b&&(a=Vd(this.doc,a,h,c,g),!a.hitSide);++k);return a},moveH:R(function(a,b){var c=this;this.extendSelectionsBy(function(g){return c.display.shift||c.doc.extend||g.empty()?Vd(c.doc,g.head,
a,b,c.options.rtlMoveVisually):0>a?g.from():g.to()},ac)}),deleteH:R(function(a,b){var c=this.doc;this.doc.sel.somethingSelected()?c.replaceSelection("",null,"+delete"):ob(this,function(g){var h=Vd(c,g.head,a,b,!1);return 0>a?{from:h,to:g.head}:{from:g.head,to:h}})}),findPosV:function(a,b,c,g){var h=1;0>b&&(h=-1,b=-b);var k=x(this.doc,a);for(a=0;a<b&&(k=ja(this,k,"div"),null==g?g=k.left:k.left=g,k=dg(this,k,h,c),!k.hitSide);++a);return k},moveV:R(function(a,b){var c=this,g=this.doc,h=[],k=!this.display.shift&&
!g.extend&&g.sel.somethingSelected();g.extendSelectionsBy(function(l){if(k)return 0>a?l.from():l.to();var p=ja(c,l.head,"div");null!=l.goalColumn&&(p.left=l.goalColumn);h.push(p.left);var n=dg(c,p,a,b);"page"==b&&l==g.sel.primary()&&vc(c,qd(c,n,"div").top-p.top);return n},ac);if(h.length)for(var l=0;l<g.sel.ranges.length;l++)g.sel.ranges[l].goalColumn=h[l]}),findWordAt:function(a){var b=t(this.doc,a.line).text,c=a.ch,g=a.ch;if(b){var h=this.getHelper(a,"wordChars");"before"!=a.sticky&&g!=b.length||
!c?++g:--c;for(var k=b.charAt(c),k=hc(k,h)?function(a){return hc(a,h)}:/\s/.test(k)?function(a){return/\s/.test(a)}:function(a){return!/\s/.test(a)&&!hc(a)};0<c&&k(b.charAt(c-1));)--c;for(;g<b.length&&k(b.charAt(g));)++g}return new z(q(a.line,c),q(a.line,g))},toggleOverwrite:function(a){if(null==a||a!=this.state.overwrite)(this.state.overwrite=!this.state.overwrite)?Ga(this.display.cursorDiv,"CodeMirror-overwrite"):Ra(this.display.cursorDiv,"CodeMirror-overwrite"),F(this,"overwriteToggle",this,this.state.overwrite)},
hasFocus:function(){return this.display.input.getField()==sa()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:R(function(a,b){Gb(this,a,b)}),getScrollInfo:function(){var a=this.display.scroller;return{left:a.scrollLeft,top:a.scrollTop,height:a.scrollHeight-qa(this)-this.display.barHeight,width:a.scrollWidth-qa(this)-this.display.barWidth,clientHeight:ld(this),clientWidth:La(this)}},scrollIntoView:R(function(a,b){null==a?(a={from:this.doc.sel.primary().head,to:null},
null==b&&(b=this.options.cursorScrollMargin)):"number"==typeof a?a={from:q(a,0),to:null}:null==a.from&&(a={from:a,to:null});a.to||(a.to=a.from);a.margin=b||0;if(null!=a.from.line){var c=a;wc(this);this.curOp.scrollToPos=c}else Te(this,a.from,a.to,a.margin)}),setSize:R(function(a,b){var c=this,g=function(a){return"number"==typeof a||/^\d+$/.test(String(a))?a+"px":a};null!=a&&(this.display.wrapper.style.width=g(a));null!=b&&(this.display.wrapper.style.height=g(b));this.options.lineWrapping&&Ee(this);
var h=this.display.viewFrom;this.doc.iter(h,this.display.viewTo,function(a){if(a.widgets)for(var b=0;b<a.widgets.length;b++)if(a.widgets[b].noHScroll){Ba(c,h,"widget");break}++h});this.curOp.forceUpdate=!0;F(this,"refresh",this)}),operation:function(a){return Y(this,a)},startOperation:function(){return Ta(this)},endOperation:function(){return Ua(this)},refresh:R(function(){var a=this.display.cachedTextHeight;U(this);this.curOp.forceUpdate=!0;Db(this);Gb(this,this.doc.scrollLeft,this.doc.scrollTop);
zd(this);(null==a||.5<Math.abs(a-Oa(this.display)))&&vd(this);F(this,"refresh",this)}),swapDoc:R(function(a){var b=this.doc;b.cm=null;ff(this,a);Db(this);this.display.input.reset();Gb(this,a.scrollLeft,a.scrollTop);this.curOp.forceScroll=!0;N(this,"swapDoc",this,b);return b}),phrase:function(a){var b=this.options.phrases;return b&&Object.prototype.hasOwnProperty.call(b,a)?b[a]:a},getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},
getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}};ab(a);a.registerHelper=function(b,e,f){c.hasOwnProperty(b)||(c[b]=a[b]={_global:[]});c[b][e]=f};a.registerGlobalHelper=function(b,e,f,g){a.registerHelper(b,e,g);c[b]._global.push({pred:f,val:g})}})(E);var uh="iter insert remove copy getEditor constructor".split(" "),ec;for(ec in V.prototype)V.prototype.hasOwnProperty(ec)&&0>L(uh,ec)&&(E.prototype[ec]=function(a){return function(){return a.apply(this.doc,
arguments)}}(V.prototype[ec]));ab(V);E.inputStyles={textarea:H,contenteditable:C};E.defineMode=function(a){E.defaults.mode||"null"==a||(E.defaults.mode=a);qg.apply(this,arguments)};E.defineMIME=function(a,b){bb[a]=b};E.defineMode("null",function(){return{token:function(a){return a.skipToEnd()}}});E.defineMIME("text/plain","null");E.defineExtension=function(a,b){E.prototype[a]=b};E.defineDocExtension=function(a,b){V.prototype[a]=b};E.fromTextArea=function(a,b){function c(){a.value=h.getValue()}b=b?
Ha(b):{};b.value=a.value;!b.tabindex&&a.tabIndex&&(b.tabindex=a.tabIndex);!b.placeholder&&a.placeholder&&(b.placeholder=a.placeholder);if(null==b.autofocus){var d=sa();b.autofocus=d==a||null!=a.getAttribute("autofocus")&&d==document.body}var e;if(a.form&&(v(a.form,"submit",c),!b.leaveSubmitMethodAlone)){var f=a.form;e=f.submit;try{var g=f.submit=function(){c();f.submit=e;f.submit();f.submit=g}}catch(k){}}b.finishInit=function(b){b.save=c;b.getTextArea=function(){return a};b.toTextArea=function(){b.toTextArea=
isNaN;c();a.parentNode.removeChild(b.getWrapperElement());a.style.display="";a.form&&(aa(a.form,"submit",c),"function"==typeof a.form.submit&&(a.form.submit=e))}};a.style.display="none";var h=E(function(b){return a.parentNode.insertBefore(b,a.nextSibling)},b);return h};(function(a){a.off=aa;a.on=v;a.wheelEventPixels=Kg;a.Doc=V;a.splitLines=Ud;a.countColumn=fa;a.findColumn=Pc;a.isWordChar=Rc;a.Pass=Hc;a.signal=F;a.Line=hb;a.changeEnd=Ca;a.scrollbarModel=Xe;a.Pos=q;a.cmpPos=y;a.modes=dd;a.mimeModes=
bb;a.resolveMode=nc;a.getMode=ed;a.modeExtensions=cb;a.extendMode=rg;a.copyState=Ka;a.startState=ie;a.innerMode=fd;a.commands=Sb;a.keyMap=Rb;a.keyName=If;a.isModifierKey=Ff;a.lookupKey=nb;a.normalizeKeyMap=Wg;a.StringStream=G;a.SharedTextMarker=Qb;a.TextMarker=Da;a.LineWidget=Pb;a.e_preventDefault=T;a.e_stopPropagation=ge;a.e_stop=xb;a.addClass=Ga;a.contains=xa;a.rmClass=Ra;a.keyNames=Ea})(E);E.version="5.40.2";return E});
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports === "object" && typeof module === "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define === "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
            ;

CodeMirror.defineMode("clojure", function (options) {
  var atoms = ["false", "nil", "true"];
  var specialForms = [".", "catch", "def", "do", "if", "monitor-enter",
      "monitor-exit", "new", "quote", "recur", "set!", "throw", "try", "var"];
  var coreSymbols = ["*", "*'", "*1", "*2", "*3", "*agent*",
      "*allow-unresolved-vars*", "*assert*", "*clojure-version*",
      "*command-line-args*", "*compile-files*", "*compile-path*",
      "*compiler-options*", "*data-readers*", "*default-data-reader-fn*", "*e",
      "*err*", "*file*", "*flush-on-newline*", "*fn-loader*", "*in*",
      "*math-context*", "*ns*", "*out*", "*print-dup*", "*print-length*",
      "*print-level*", "*print-meta*", "*print-namespace-maps*",
      "*print-readably*", "*read-eval*", "*reader-resolver*", "*source-path*",
      "*suppress-read*", "*unchecked-math*", "*use-context-classloader*",
      "*verbose-defrecords*", "*warn-on-reflection*", "+", "+'", "-", "-'",
      "->", "->>", "->ArrayChunk", "->Eduction", "->Vec", "->VecNode",
      "->VecSeq", "-cache-protocol-fn", "-reset-methods", "..", "/", "<", "<=",
      "=", "==", ">", ">=", "EMPTY-NODE", "Inst", "StackTraceElement->vec",
      "Throwable->map", "accessor", "aclone", "add-classpath", "add-watch",
      "agent", "agent-error", "agent-errors", "aget", "alength", "alias",
      "all-ns", "alter", "alter-meta!", "alter-var-root", "amap", "ancestors",
      "and", "any?", "apply", "areduce", "array-map", "as->", "aset",
      "aset-boolean", "aset-byte", "aset-char", "aset-double", "aset-float",
      "aset-int", "aset-long", "aset-short", "assert", "assoc", "assoc!",
      "assoc-in", "associative?", "atom", "await", "await-for", "await1",
      "bases", "bean", "bigdec", "bigint", "biginteger", "binding", "bit-and",
      "bit-and-not", "bit-clear", "bit-flip", "bit-not", "bit-or", "bit-set",
      "bit-shift-left", "bit-shift-right", "bit-test", "bit-xor", "boolean",
      "boolean-array", "boolean?", "booleans", "bound-fn", "bound-fn*",
      "bound?", "bounded-count", "butlast", "byte", "byte-array", "bytes",
      "bytes?", "case", "cast", "cat", "char", "char-array",
      "char-escape-string", "char-name-string", "char?", "chars", "chunk",
      "chunk-append", "chunk-buffer", "chunk-cons", "chunk-first", "chunk-next",
      "chunk-rest", "chunked-seq?", "class", "class?", "clear-agent-errors",
      "clojure-version", "coll?", "comment", "commute", "comp", "comparator",
      "compare", "compare-and-set!", "compile", "complement", "completing",
      "concat", "cond", "cond->", "cond->>", "condp", "conj", "conj!", "cons",
      "constantly", "construct-proxy", "contains?", "count", "counted?",
      "create-ns", "create-struct", "cycle", "dec", "dec'", "decimal?",
      "declare", "dedupe", "default-data-readers", "definline", "definterface",
      "defmacro", "defmethod", "defmulti", "defn", "defn-", "defonce",
      "defprotocol", "defrecord", "defstruct", "deftype", "delay", "delay?",
      "deliver", "denominator", "deref", "derive", "descendants", "destructure",
      "disj", "disj!", "dissoc", "dissoc!", "distinct", "distinct?", "doall",
      "dorun", "doseq", "dosync", "dotimes", "doto", "double", "double-array",
      "double?", "doubles", "drop", "drop-last", "drop-while", "eduction",
      "empty", "empty?", "ensure", "ensure-reduced", "enumeration-seq",
      "error-handler", "error-mode", "eval", "even?", "every-pred", "every?",
      "ex-data", "ex-info", "extend", "extend-protocol", "extend-type",
      "extenders", "extends?", "false?", "ffirst", "file-seq", "filter",
      "filterv", "find", "find-keyword", "find-ns", "find-protocol-impl",
      "find-protocol-method", "find-var", "first", "flatten", "float",
      "float-array", "float?", "floats", "flush", "fn", "fn?", "fnext", "fnil",
      "for", "force", "format", "frequencies", "future", "future-call",
      "future-cancel", "future-cancelled?", "future-done?", "future?",
      "gen-class", "gen-interface", "gensym", "get", "get-in", "get-method",
      "get-proxy-class", "get-thread-bindings", "get-validator", "group-by",
      "halt-when", "hash", "hash-combine", "hash-map", "hash-ordered-coll",
      "hash-set", "hash-unordered-coll", "ident?", "identical?", "identity",
      "if-let", "if-not", "if-some", "ifn?", "import", "in-ns", "inc", "inc'",
      "indexed?", "init-proxy", "inst-ms", "inst-ms*", "inst?", "instance?",
      "int", "int-array", "int?", "integer?", "interleave", "intern",
      "interpose", "into", "into-array", "ints", "io!", "isa?", "iterate",
      "iterator-seq", "juxt", "keep", "keep-indexed", "key", "keys", "keyword",
      "keyword?", "last", "lazy-cat", "lazy-seq", "let", "letfn", "line-seq",
      "list", "list*", "list?", "load", "load-file", "load-reader",
      "load-string", "loaded-libs", "locking", "long", "long-array", "longs",
      "loop", "macroexpand", "macroexpand-1", "make-array", "make-hierarchy",
      "map", "map-entry?", "map-indexed", "map?", "mapcat", "mapv", "max",
      "max-key", "memfn", "memoize", "merge", "merge-with", "meta",
      "method-sig", "methods", "min", "min-key", "mix-collection-hash", "mod",
      "munge", "name", "namespace", "namespace-munge", "nat-int?", "neg-int?",
      "neg?", "newline", "next", "nfirst", "nil?", "nnext", "not", "not-any?",
      "not-empty", "not-every?", "not=", "ns", "ns-aliases", "ns-imports",
      "ns-interns", "ns-map", "ns-name", "ns-publics", "ns-refers",
      "ns-resolve", "ns-unalias", "ns-unmap", "nth", "nthnext", "nthrest",
      "num", "number?", "numerator", "object-array", "odd?", "or", "parents",
      "partial", "partition", "partition-all", "partition-by", "pcalls", "peek",
      "persistent!", "pmap", "pop", "pop!", "pop-thread-bindings", "pos-int?",
      "pos?", "pr", "pr-str", "prefer-method", "prefers",
      "primitives-classnames", "print", "print-ctor", "print-dup",
      "print-method", "print-simple", "print-str", "printf", "println",
      "println-str", "prn", "prn-str", "promise", "proxy",
      "proxy-call-with-super", "proxy-mappings", "proxy-name", "proxy-super",
      "push-thread-bindings", "pvalues", "qualified-ident?",
      "qualified-keyword?", "qualified-symbol?", "quot", "rand", "rand-int",
      "rand-nth", "random-sample", "range", "ratio?", "rational?",
      "rationalize", "re-find", "re-groups", "re-matcher", "re-matches",
      "re-pattern", "re-seq", "read", "read-line", "read-string",
      "reader-conditional", "reader-conditional?", "realized?", "record?",
      "reduce", "reduce-kv", "reduced", "reduced?", "reductions", "ref",
      "ref-history-count", "ref-max-history", "ref-min-history", "ref-set",
      "refer", "refer-clojure", "reify", "release-pending-sends", "rem",
      "remove", "remove-all-methods", "remove-method", "remove-ns",
      "remove-watch", "repeat", "repeatedly", "replace", "replicate", "require",
      "reset!", "reset-meta!", "reset-vals!", "resolve", "rest",
      "restart-agent", "resultset-seq", "reverse", "reversible?", "rseq",
      "rsubseq", "run!", "satisfies?", "second", "select-keys", "send",
      "send-off", "send-via", "seq", "seq?", "seqable?", "seque", "sequence",
      "sequential?", "set", "set-agent-send-executor!",
      "set-agent-send-off-executor!", "set-error-handler!", "set-error-mode!",
      "set-validator!", "set?", "short", "short-array", "shorts", "shuffle",
      "shutdown-agents", "simple-ident?", "simple-keyword?", "simple-symbol?",
      "slurp", "some", "some->", "some->>", "some-fn", "some?", "sort",
      "sort-by", "sorted-map", "sorted-map-by", "sorted-set", "sorted-set-by",
      "sorted?", "special-symbol?", "spit", "split-at", "split-with", "str",
      "string?", "struct", "struct-map", "subs", "subseq", "subvec", "supers",
      "swap!", "swap-vals!", "symbol", "symbol?", "sync", "tagged-literal",
      "tagged-literal?", "take", "take-last", "take-nth", "take-while", "test",
      "the-ns", "thread-bound?", "time", "to-array", "to-array-2d",
      "trampoline", "transduce", "transient", "tree-seq", "true?", "type",
      "unchecked-add", "unchecked-add-int", "unchecked-byte", "unchecked-char",
      "unchecked-dec", "unchecked-dec-int", "unchecked-divide-int",
      "unchecked-double", "unchecked-float", "unchecked-inc",
      "unchecked-inc-int", "unchecked-int", "unchecked-long",
      "unchecked-multiply", "unchecked-multiply-int", "unchecked-negate",
      "unchecked-negate-int", "unchecked-remainder-int", "unchecked-short",
      "unchecked-subtract", "unchecked-subtract-int", "underive", "unquote",
      "unquote-splicing", "unreduced", "unsigned-bit-shift-right", "update",
      "update-in", "update-proxy", "uri?", "use", "uuid?", "val", "vals",
      "var-get", "var-set", "var?", "vary-meta", "vec", "vector", "vector-of",
      "vector?", "volatile!", "volatile?", "vreset!", "vswap!", "when",
      "when-first", "when-let", "when-not", "when-some", "while",
      "with-bindings", "with-bindings*", "with-in-str", "with-loading-context",
      "with-local-vars", "with-meta", "with-open", "with-out-str",
      "with-precision", "with-redefs", "with-redefs-fn", "xml-seq", "zero?",
      "zipmap"];
  var haveBodyParameter = [
      "->", "->>", "as->", "binding", "bound-fn", "case", "catch", "comment",
      "cond", "cond->", "cond->>", "condp", "def", "definterface", "defmethod",
      "defn", "defmacro", "defprotocol", "defrecord", "defstruct", "deftype",
      "do", "doseq", "dotimes", "doto", "extend", "extend-protocol",
      "extend-type", "fn", "for", "future", "if", "if-let", "if-not", "if-some",
      "let", "letfn", "locking", "loop", "ns", "proxy", "reify", "struct-map",
      "some->", "some->>", "try", "when", "when-first", "when-let", "when-not",
      "when-some", "while", "with-bindings", "with-bindings*", "with-in-str",
      "with-loading-context", "with-local-vars", "with-meta", "with-open",
      "with-out-str", "with-precision", "with-redefs", "with-redefs-fn"];

  CodeMirror.registerHelper("hintWords", "clojure",
    [].concat(atoms, specialForms, coreSymbols));

  var atom = createLookupMap(atoms);
  var specialForm = createLookupMap(specialForms);
  var coreSymbol = createLookupMap(coreSymbols);
  var hasBodyParameter = createLookupMap(haveBodyParameter);
  var delimiter = /^(?:[\\\[\]\s"(),;@^`{}~]|$)/;
  var numberLiteral = /^(?:[+\-]?\d+(?:(?:N|(?:[eE][+\-]?\d+))|(?:\.?\d*(?:M|(?:[eE][+\-]?\d+))?)|\/\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\[\]\s"#'(),;@^`{}~]|$))/;
  var characterLiteral = /^(?:\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\[\]\s"(),;@^`{}~]|$))/;

  // simple-namespace := /^[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*/
  // simple-symbol    := /^(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)/
  // qualified-symbol := (<simple-namespace>(<.><simple-namespace>)*</>)?<simple-symbol>
  var qualifiedSymbol = /^(?:(?:[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*(?:\.[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*\/)?(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*(?=[\\\[\]\s"(),;@^`{}~]|$))/;

  function base(stream, state) {
    if (stream.eatSpace()) return ["space", null];
    if (stream.match(numberLiteral)) return [null, "number"];
    if (stream.match(characterLiteral)) return [null, "string-2"];
    if (stream.eat(/^"/)) return (state.tokenize = inString)(stream, state);
    if (stream.eat(/^[(\[{]/)) return ["open", "bracket"];
    if (stream.eat(/^[)\]}]/)) return ["close", "bracket"];
    if (stream.eat(/^;/)) {stream.skipToEnd(); return ["space", "comment"];}
    if (stream.eat(/^[#'@^`~]/)) return [null, "meta"];

    var matches = stream.match(qualifiedSymbol);
    var symbol = matches && matches[0];

    if (!symbol) {
      // advance stream by at least one character so we don't get stuck.
      stream.next();
      stream.eatWhile(function (c) {return !is(c, delimiter);});
      return [null, "error"];
    }

    if (symbol === "comment" && state.lastToken === "(")
      return (state.tokenize = inComment)(stream, state);
    if (is(symbol, atom) || symbol.charAt(0) === ":") return ["symbol", "atom"];
    if (is(symbol, specialForm) || is(symbol, coreSymbol)) return ["symbol", "keyword"];
    if (state.lastToken === "(") return ["symbol", "builtin"]; // other operator

    return ["symbol", "variable"];
  }

  function inString(stream, state) {
    var escaped = false, next;

    while (next = stream.next()) {
      if (next === "\"" && !escaped) {state.tokenize = base; break;}
      escaped = !escaped && next === "\\";
    }

    return [null, "string"];
  }

  function inComment(stream, state) {
    var parenthesisCount = 1;
    var next;

    while (next = stream.next()) {
      if (next === ")") parenthesisCount--;
      if (next === "(") parenthesisCount++;
      if (parenthesisCount === 0) {
        stream.backUp(1);
        state.tokenize = base;
        break;
      }
    }

    return ["space", "comment"];
  }

  function createLookupMap(words) {
    var obj = {};

    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;

    return obj;
  }

  function is(value, test) {
    if (test instanceof RegExp) return test.test(value);
    if (test instanceof Object) return test.propertyIsEnumerable(value);
  }

  return {
    startState: function () {
      return {
        ctx: {prev: null, start: 0, indentTo: 0},
        lastToken: null,
        tokenize: base
      };
    },

    token: function (stream, state) {
      if (stream.sol() && (typeof state.ctx.indentTo !== "number"))
        state.ctx.indentTo = state.ctx.start + 1;

      var typeStylePair = state.tokenize(stream, state);
      var type = typeStylePair[0];
      var style = typeStylePair[1];
      var current = stream.current();

      if (type !== "space") {
        if (state.lastToken === "(" && state.ctx.indentTo === null) {
          if (type === "symbol" && is(current, hasBodyParameter))
            state.ctx.indentTo = state.ctx.start + options.indentUnit;
          else state.ctx.indentTo = "next";
        } else if (state.ctx.indentTo === "next") {
          state.ctx.indentTo = stream.column();
        }

        state.lastToken = current;
      }

      if (type === "open")
        state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};
      else if (type === "close") state.ctx = state.ctx.prev || state.ctx;

      return style;
    },

    indent: function (state) {
      var i = state.ctx.indentTo;

      return (typeof i === "number") ?
        i :
        state.ctx.start + 1;
    },

    closeBrackets: {pairs: "()[]{}\"\""},
    lineComment: ";;"
  };
});

CodeMirror.defineMIME("text/x-clojure", "clojure");
CodeMirror.defineMIME("text/x-clojurescript", "clojure");
CodeMirror.defineMIME("application/edn", "clojure");

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = {hint: getHints};
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function(options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections()
    if (selections.length > 1) return;
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++)
        if (selections[i].head.line != selections[i].anchor.line) return;
    }

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

    var self = this;
    cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
  }

  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 1000/60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function() {
      return this.cm.state.completionActive == this;
    },

    pick: function(data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);
      else this.cm.replaceRange(getText(completion), completion.from || data.from,
                                completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },

    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function() {self.update();});
        if (this.widget) this.widget.disable();
      }
    },

    update: function(first) {
      if (this.tick == null) return
      var self = this, myTick = ++this.tick
      fetchHints(this.options.hint, this.cm, this.options, function(data) {
        if (self.tick == myTick) self.finishUpdate(data, first)
      })
    },

    finishUpdate: function(data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
      if (this.widget) this.widget.close();

      this.data = data;

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor) for (var prop in editor)
      if (editor[prop] !== undefined) out[prop] = editor[prop];
    if (options) for (var prop in options)
      if (options[prop] !== undefined) out[prop] = options[prop];
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
    return out;
  }

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {handle.moveFocus(-1);},
      Down: function() {handle.moveFocus(1);},
      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
      Home: function() {handle.setFocus(0);},
      End: function() {handle.setFocus(handle.length - 1);},
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;

    var hints = this.hints = document.createElement("ul");
    var theme = completion.cm.options.theme;
    hints.className = "CodeMirror-hints " + theme;
    this.selectedHint = data.selectedHint || 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    hints.style.left = left + "px";
    hints.style.top = top + "px";
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
    (completion.options.container || document.body).appendChild(hints);
    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
    var scrolls = hints.scrollHeight > hints.clientHeight + 1
    var startScroll = cm.getScrollInfo();

    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = pos.top - height) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
      node.style.paddingRight = cm.display.nativeBarWidth + "px"

    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function(n) { widget.changeActive(n); },
      menuSize: function() { return widget.screenAmount(); },
      length: completions.length,
      close: function() { completion.close(); },
      pick: function() { widget.pick(); },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
    }

    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
    });

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
    });

    CodeMirror.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function(){cm.focus();}, 20);
    });

    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }

  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = {Enter: function() { widget.picked = true; }};
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0  : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers
    var result = []
    for (var i = 0; i < helpers.length; i++)
      if (helpers[i].supportsSelection) result.push(helpers[i])
    return result
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options)
    } else {
      var result = hint(cm, options)
      if (result && result.then) result.then(callback)
      else callback(result)
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words
    if (helpers.length) {
      var resolved = function(cm, callback, options) {
        var app = applicableHelpers(cm, helpers);
        function run(i) {
          if (i == app.length) return callback(null)
          fetchHints(app[i], cm, options, function(result) {
            if (result && result.list.length > 0) callback(result)
            else run(i + 1)
          })
        }
        run(0)
      }
      resolved.async = true
      resolved.supportsSelection = true
      return resolved
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }
    } else if (CodeMirror.hint.anyword) {
      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }
    } else {
      return function() {}
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });

  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur)
    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur
    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start)
    } else {
      term = ""
      from = cur
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }

    if (found.length) return {list: found, from: from, to: to};
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null
  };

  CodeMirror.defineOption("hintOptions", null);
});

(function(l,m){"function"===typeof define&&define.amd?define([],m):"object"===typeof module&&module.exports?module.exports=m():l.parinferCodeMirror=m()})(this,function(){function l(a){return"parinferCodeMirror: "+a}function m(a){if(-1===v.indexOf(a))throw l('Mode "'+a+'" is invalid. Must be one of: '+v.join(","));}function p(a){a=a.__parinfer__;if(!a)throw l("You must call parinferCodeMirror.init(cm) on a CodeMirror instance before you can use the rest of the API.");return a}function G(a){return a.map(function(a){return{x:a.from.ch,
lineNo:a.from.line,oldText:a.removed.join("\n"),newText:a.text.join("\n")}})}function k(a,d){var b,c=a.getAllMarks();for(b=0;b<c.length;b++)c[b].className===d&&c[b].clear()}function r(a,d,b,c,e){a.markText({line:d,ch:b},{line:d,ch:c},{className:e})}function H(a,d){k(a,"parinfer-error");d&&(r(a,d.lineNo,d.x,d.x+1,"parinfer-error"),d.extra&&r(a,d.extra.lineNo,d.extra.x,d.extra.x+1,"parinfer-error"))}function I(a,d){k(a,"parinfer-paren-trail");if(d){var b,c;for(b=0;b<d.length;b++)c=d[b],r(a,c.lineNo,
c.startX,c.endX,"parinfer-paren-trail")}}function w(a){a=a.listSelections()[0];return Math.min(a.head.line,a.anchor.line)}function x(a,d,b){if(!a)return null;var c,e,g,f;for(c=0;c<a.length;c++){e=a[c];if(d<e){g=e;break}d>e&&(f=e)}if(-1===b)return f;if(1===b)return g}function y(a,d){var b=a.getLine(d),c;for(c=0;c<b.length;c++)if(" "!==b[c])return c;return null}function z(a,d){var b=a.somethingSelected(),c;if(c=p(a).tabStops){var e=[],g,f;for(g=0;g<c.length;g++)f=c[g],-1>=f.x&&e.pop(),e.push(f.x),e.push(f.x+
("("===f.ch?2:1)),null!=f.argX&&e.push(f.argX);c=e}else c=null;b?(b=c,c=w(a),c=y(a,c),b=x(b,c,d),null==b&&(b=Math.max(0,c+2*d)),a.indentSelection(b-c)):(g=c,e=a.getCursor(),b=e.line,c=e.ch,e=y(a,e.line),g=x(g,c,d),g=null==g||null!=e&&c!==e?Math.max(0,c+2*d):g,null!=e&&e<c&&c<g?(b=Array(g-c+1).join(" "),a.replaceSelection(b)):(c=g-c,""!==a.getDoc().getLine(b).trim()?a.indentLine(b,c):0<c?(b=Array(c+1).join(" "),a.replaceSelection(b)):(e=a.getCursor().ch,a.replaceRange("",{line:b,ch:e+c},{line:b,ch:e},
"+indent"))))}function A(a,d){return d.line===a.lineNo&&a.startX<=d.ch}function B(a,d){var b;for(b=0;b<d.length;b++){var c=a,e=d[b],g=c.getDoc().sel,f=g.ranges[0];(f=e.lineNo===e.closer.lineNo||!e.closer.trail||A(e.closer.trail,f.anchor)||A(e.closer.trail,f.head))||(f=e.closer,f=-1!==g.contains({line:f.lineNo,ch:f.x}));f||r(c,e.closer.lineNo,e.closer.x,e.closer.x+1,"parinfer-locus-paren");B(c,e.children)}}function t(a,d){var b=a.charCoords({line:d.lineNo,ch:d.x},"local");return{midx:b.left+(b.right-
b.left)/2,right:b.right,left:b.left,top:b.top,bottom:b.bottom}}function u(a,d){var b;for(b=0;b<d.length;b++){var c=a,e=d[b],g=c.__parinfer__.layer,f=g.paper,n=t(c,e),C=t(c,e.closer);if(e.closer.trail&&e.lineNo!==e.closer.lineNo)switch(g.type){case "guides":f.path(["M",n.midx,n.bottom,"V",C.bottom].join(" "));break;case "locus":for(var g=c,m=e.lineNo,h=e.closer.lineNo,q=g.getDoc(),l=0,p=0,k=void 0,k=m;k<=h;k++)m=q.getLine(k),m.length>l&&(l=m.length,p=k);g=t(g,{lineNo:p,x:l}).right;f.path(["M",n.midx,
n.top+4,"A",4,4,0,0,1,n.midx+4,n.top,"H",g-4,"A",4,4,0,0,1,g,n.top+4,"V",C.bottom,"H",n.midx,"V",n.bottom].join(" "))}u(c,e.children)}}function D(a,d){var b=a.__parinfer__.layer;b.type=d;var c=document.createElement("div");c.style.position="absolute";c.style.left="0";c.style.top="0";c.style["z-index"]=100;c.className="parinfer-locus";b.el=c;b.container.appendChild(c);b.paper=Raphael(c,b.container.clientWidth,b.container.clientHeight)}function E(a){(a=a.__parinfer__.layer)&&a.el&&a.container.removeChild(a.el)}
function J(a,d){k(a,"parinfer-locus-paren");d&&(B(a,d),E(a),D(a,"guides"),u(a,d))}function K(a,d){d&&(E(a),D(a,"guides"),u(a,d))}function q(a,d){var b=a.cm,c=b.getValue(),e=b.somethingSelected(),g=b.listSelections(),f=b.getCursor(),n=b.getScrollerElement(),f={cursorLine:f.line,cursorX:f.ch,prevCursorLine:a.prevCursorLine,prevCursorX:a.prevCursorX};e&&(f.selectionStartLine=w(b));if(a.options)for(var k in a.options)a.options.hasOwnProperty(k)&&(f[k]=a.options[k]);d&&(f.changes=G(d));k=a.options&&a.options.locus;
var l=a.options&&a.options.guides;if(k||l)delete f.locus,delete f.guides,f.returnParens=!0;var h,p=a.fixMode?"paren":a.mode;switch(p){case "indent":h=parinfer.indentMode(c,f);break;case "paren":h=parinfer.parenMode(c,f);break;case "smart":h=parinfer.smartMode(c,f);break;default:m(p)}a.parens=h.parens;a.tabStops=h.tabStops;c!==h.text&&(c=b.getHistory(),b.setValue(h.text),a.monitorCursor=!1,e?b.setSelections(g):b.setCursor(h.cursorLine,h.cursorX),b.setHistory(c),setTimeout(function(){a.monitorCursor=
!0},0),b.scrollTo(n.scrollLeft,n.scrollTop));H(b,h.error);I(b,h.parenTrails);a.prevCursorLine=h.cursorLine;a.prevCursorX=h.cursorX;k?J(b,h.parens):l&&K(b,h.parens);return a.fixMode&&h.success?(a.fixMode=!1,q(a,d)):h.success}function L(a){clearTimeout(a.cursorTimeout);a.monitorCursor&&(a.cursorTimeout=setTimeout(function(){q(a)},0))}function M(a){if(!a.enabled){a.callbackCursor=function(b){L(a)};a.callbackChanges=function(b,c){clearTimeout(a.cursorTimeout);"setValue"!==c[0].origin&&q(a,c)};var d=a.cm;
d.on("cursorActivity",a.callbackCursor);d.on("changes",a.callbackChanges);a.parinferKeys={Tab:function(a){z(a,1)},"Shift-Tab":function(a){z(a,-1)}};d.addKeyMap(a.parinferKeys);a.enabled=!0}}function F(a){a=p(a);"paren"!==a.mode&&(a.fixMode=!0);M(a);return q(a)}var v=["paren","indent","smart"];return{version:"1.4.1",init:function(a,d,b){var c=a.__parinfer__;if(c)throw l("init has already been called on this CodeMirror instance");d=d||"smart";m(d);c={cm:a,mode:d,options:b,enabled:!1,cursorTimeout:null,
monitorCursor:!0,prevCursorX:null,prevCursorLine:null,callbackCursor:null,callbackChanges:null};d=a.__parinfer__=c;b=a.getWrapperElement().querySelector(".CodeMirror-lines").parentNode;d.layer={container:b};return F(a)},enable:F,disable:function(a){a=p(a);if(a.enabled){var d=a.cm;k(d,"parinfer-error");k(d,"parinfer-paren-trail");d.off("cursorActivity",a.callbackCursor);d.off("changes",a.callbackChanges);d.removeKeyMap(a.parinferKeys);a.enabled=!1}},setMode:function(a,d){var b=p(a);m(d);b.mode=d;return q(b)},
setOptions:function(a,d){var b=p(a);b.options=d;return q(b)}}});
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
    (document.documentMode == null || document.documentMode < 8);

  var Pos = CodeMirror.Pos;

  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};

  function findMatchingBracket(cm, where, config) {
    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
    var afterCursor = config && config.afterCursor
    if (afterCursor == null)
      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)

    // A cursor is defined as between two characters, but in in vim command mode
    // (i.e. not insert mode), the cursor is visually represented as a
    // highlighted box on top of the 2nd character. Otherwise, we allow matches
    // from before or after the cursor.
    var match = (!afterCursor && pos >= 0 && matching[line.text.charAt(pos)]) ||
        matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));

    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
    if (found == null) return null;
    return {from: Pos(where.line, pos), to: found && found.pos,
            match: found && found.ch == match.charAt(0), forward: dir > 0};
  }

  // bracketRegex is used to specify which type of bracket to scan
  // should be a regexp, e.g. /[[\]]/
  //
  // Note: If "where" is on an open bracket, then this bracket is ignored.
  //
  // Returns false when no bracket was found, null when it reached
  // maxScanLines and gave up
  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = (config && config.maxScanLineLength) || 10000;
    var maxScanLines = (config && config.maxScanLines) || 1000;

    var stack = [];
    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\]]/;
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)
                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);
        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
          var match = matching[ch];
          if ((match.charAt(1) == ">") == (dir > 0)) stack.push(ch);
          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};
          else stack.pop();
        }
      }
    }
    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }

  function matchBrackets(cm, autoclear, config) {
    // Disable brace matching in long lines, since it'll cause hugely slow updates
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
    var marks = [], ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));
      }
    }

    if (marks.length) {
      // Kludge to work around the IE bug from issue #1193, where text
      // input stops going to the textare whever this fires.
      if (ie_lt8 && cm.state.focused) cm.focus();

      var clear = function() {
        cm.operation(function() {
          for (var i = 0; i < marks.length; i++) marks[i].clear();
        });
      };
      if (autoclear) setTimeout(clear, 800);
      else return clear;
    }
  }

  function doMatchBrackets(cm) {
    cm.operation(function() {
      if (cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }

  CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", doMatchBrackets);
      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
    }
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
    }
  });

  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
  CodeMirror.defineExtension("findMatchingBracket", function(pos, config, oldConfig){
    // Backwards-compatibility kludge
    if (oldConfig || typeof config == "boolean") {
      if (!oldConfig) {
        config = config ? {strict: true} : null
      } else {
        oldConfig.strict = config
        config = oldConfig
      }
    }
    return findMatchingBracket(this, pos, config)
  });
  CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config){
    return scanForBracket(this, pos, dir, style, config);
  });
});

var f,aa=this;function ba(a){return"string"==typeof a}function ca(a,b){a=a.split(".");var c=aa;a[0]in c||!c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)a.length||void 0===b?c=c[d]&&c[d]!==Object.prototype[d]?c[d]:c[d]={}:c[d]=b}
function da(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function fa(a){return"function"==da(a)}function ha(a){return a[ia]||(a[ia]=++ja)}var ia="closure_uid_"+(1E9*Math.random()>>>0),ja=0;function ka(a,b,c){return a.call.apply(a.bind,arguments)}
function la(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function ma(a,b,c){ma=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ka:la;return ma.apply(null,arguments)}var na=Date.now||function(){return+new Date};
function oa(a,b){function c(){}c.prototype=b.prototype;a.Ie=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,g){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};var pa=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},ra=String.prototype.repeat?function(a,b){return a.repeat(b)}:function(a,b){return Array(b+1).join(a)};function sa(a){a=String(a);var b=a.indexOf(".");-1==b&&(b=a.length);return ra("0",Math.max(0,2-b))+a}function ta(a){return String(a.charAt(0)).toUpperCase()+String(a.substr(1)).toLowerCase()};function ua(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};function va(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};function wa(a,b){this.da=[];this.ga=b;for(var c=!0,d=a.length-1;0<=d;d--){var e=a[d]|0;c&&e==b||(this.da[d]=e,c=!1)}}var xa={};function ya(a){if(-128<=a&&128>a){var b=xa[a];if(b)return b}b=new wa([a|0],0>a?-1:0);-128<=a&&128>a&&(xa[a]=b);return b}function za(a){if(isNaN(a)||!isFinite(a))return Ba;if(0>a)return Ca(za(-a));for(var b=[],c=1,d=0;a>=c;d++)b[d]=a/c|0,c*=Da;return new wa(b,0)}var Da=4294967296,Ba=ya(0),Ea=ya(1),Fa=ya(16777216);
function Ga(a){if(-1==a.ga)return-Ga(Ca(a));for(var b=0,c=1,d=0;d<a.da.length;d++){var e=Ia(a,d);b+=(0<=e?e:Da+e)*c;c*=Da}return b}f=wa.prototype;f.toString=function(a){a=a||10;if(2>a||36<a)throw Error("radix out of range: "+a);if(this.ib())return"0";if(-1==this.ga)return"-"+Ca(this).toString(a);for(var b=za(Math.pow(a,6)),c=this,d="";;){var e=Ja(c,b),g=e.multiply(b);c=c.add(Ca(g));g=((0<c.da.length?c.da[0]:c.ga)>>>0).toString(a);c=e;if(c.ib())return g+d;for(;6>g.length;)g="0"+g;d=""+g+d}};
function Ia(a,b){return 0>b?0:b<a.da.length?a.da[b]:a.ga}f.ib=function(){if(0!=this.ga)return!1;for(var a=0;a<this.da.length;a++)if(0!=this.da[a])return!1;return!0};f.compare=function(a){a=this.add(Ca(a));return-1==a.ga?-1:a.ib()?0:1};function Ca(a){for(var b=a.da.length,c=[],d=0;d<b;d++)c[d]=~a.da[d];return(new wa(c,~a.ga)).add(Ea)}
f.add=function(a){for(var b=Math.max(this.da.length,a.da.length),c=[],d=0,e=0;e<=b;e++){var g=d+(Ia(this,e)&65535)+(Ia(a,e)&65535),h=(g>>>16)+(Ia(this,e)>>>16)+(Ia(a,e)>>>16);d=h>>>16;g&=65535;h&=65535;c[e]=h<<16|g}return new wa(c,c[c.length-1]&-2147483648?-1:0)};
f.multiply=function(a){if(this.ib()||a.ib())return Ba;if(-1==this.ga)return-1==a.ga?Ca(this).multiply(Ca(a)):Ca(Ca(this).multiply(a));if(-1==a.ga)return Ca(this.multiply(Ca(a)));if(0>this.compare(Fa)&&0>a.compare(Fa))return za(Ga(this)*Ga(a));for(var b=this.da.length+a.da.length,c=[],d=0;d<2*b;d++)c[d]=0;for(d=0;d<this.da.length;d++)for(var e=0;e<a.da.length;e++){var g=Ia(this,d)>>>16,h=Ia(this,d)&65535,l=Ia(a,e)>>>16,m=Ia(a,e)&65535;c[2*d+2*e]+=h*m;Ma(c,2*d+2*e);c[2*d+2*e+1]+=g*m;Ma(c,2*d+2*e+1);
c[2*d+2*e+1]+=h*l;Ma(c,2*d+2*e+1);c[2*d+2*e+2]+=g*l;Ma(c,2*d+2*e+2)}for(d=0;d<b;d++)c[d]=c[2*d+1]<<16|c[2*d];for(d=b;d<2*b;d++)c[d]=0;return new wa(c,0)};function Ma(a,b){for(;(a[b]&65535)!=a[b];)a[b+1]+=a[b]>>>16,a[b]&=65535,b++}
function Ja(a,b){if(b.ib())throw Error("division by zero");if(a.ib())return Ba;if(-1==a.ga)return-1==b.ga?Ja(Ca(a),Ca(b)):Ca(Ja(Ca(a),b));if(-1==b.ga)return Ca(Ja(a,Ca(b)));if(30<a.da.length){if(-1==a.ga||-1==b.ga)throw Error("slowDivide_ only works with positive integers.");for(var c=Ea;0>=b.compare(a);)c=c.shiftLeft(1),b=b.shiftLeft(1);var d=Na(c,1),e=Na(b,1);b=Na(b,2);for(c=Na(c,2);!b.ib();){var g=e.add(b);0>=g.compare(a)&&(d=d.add(c),e=g);b=Na(b,1);c=Na(c,1)}return d}for(c=Ba;0<=a.compare(b);){d=
Math.max(1,Math.floor(Ga(a)/Ga(b)));e=Math.ceil(Math.log(d)/Math.LN2);e=48>=e?1:Math.pow(2,e-48);g=za(d);for(var h=g.multiply(b);-1==h.ga||0<h.compare(a);)d-=e,g=za(d),h=g.multiply(b);g.ib()&&(g=Ea);c=c.add(g);a=a.add(Ca(h))}return c}f.and=function(a){for(var b=Math.max(this.da.length,a.da.length),c=[],d=0;d<b;d++)c[d]=Ia(this,d)&Ia(a,d);return new wa(c,this.ga&a.ga)};f.or=function(a){for(var b=Math.max(this.da.length,a.da.length),c=[],d=0;d<b;d++)c[d]=Ia(this,d)|Ia(a,d);return new wa(c,this.ga|a.ga)};
f.xor=function(a){for(var b=Math.max(this.da.length,a.da.length),c=[],d=0;d<b;d++)c[d]=Ia(this,d)^Ia(a,d);return new wa(c,this.ga^a.ga)};f.shiftLeft=function(a){var b=a>>5;a%=32;for(var c=this.da.length+b+(0<a?1:0),d=[],e=0;e<c;e++)d[e]=0<a?Ia(this,e-b)<<a|Ia(this,e-b-1)>>>32-a:Ia(this,e-b);return new wa(d,this.ga)};function Na(a,b){var c=b>>5;b%=32;for(var d=a.da.length-c,e=[],g=0;g<d;g++)e[g]=0<b?Ia(a,g+c)>>>b|Ia(a,g+c+1)<<32-b:Ia(a,g+c);return new wa(e,a.ga)};function Pa(a,b){null!=a&&this.append.apply(this,arguments)}f=Pa.prototype;f.qb="";f.set=function(a){this.qb=""+a};f.append=function(a,b,c){this.qb+=String(a);if(null!=b)for(var d=1;d<arguments.length;d++)this.qb+=arguments[d];return this};f.clear=function(){this.qb=""};f.toString=function(){return this.qb};var Qa={},Sa={},Ta;if("undefined"===typeof Qa||"undefined"===typeof Sa||"undefined"===typeof k)var k={};if("undefined"===typeof Qa||"undefined"===typeof Sa||"undefined"===typeof Ua)var Ua=null;if("undefined"===typeof Qa||"undefined"===typeof Sa||"undefined"===typeof Va)var Va=null;var Wa=null;if("undefined"===typeof Qa||"undefined"===typeof Sa||"undefined"===typeof Xa)var Xa=null;
function Za(){return new p(null,5,[new q(null,"flush-on-newline","flush-on-newline",-151457939),!0,new q(null,"readably","readably",1129599760),!0,new q(null,"meta","meta",1499536964),!1,new q(null,"dup","dup",556298533),!1,new q(null,"print-length","print-length",1931866356),null],null)}function $a(){Ua=function(){return console.log.apply(console,ua(arguments))};Va=function(){return console.error.apply(console,ua(arguments))}}function t(a){return null!=a&&!1!==a}function ab(a){return null==a}
function bb(a){return a instanceof Array}function cb(a){return"number"===typeof a}function eb(a){return null==a?!0:!1===a?!0:!1}function fb(a){return ba(a)}function gb(a,b){return a[da(null==b?null:b)]?!0:a._?!0:!1}function hb(a){return null==a?null:a.constructor}function jb(a,b){var c=hb(b);c=t(t(c)?c.Kc:c)?c.Yb:da(b);return Error(["No protocol method ",a," defined for type ",c,": ",b].join(""))}function kb(a){var b=a.Yb;return t(b)?b:u.h(a)}
var lb="undefined"!==typeof Symbol&&"function"===da(Symbol)?Symbol.iterator:"@@iterator";function mb(a){for(var b=a.length,c=Array(b),d=0;;)if(d<b)c[d]=a[d],d+=1;else break;return c}function nb(a){return pb(function(a,c){a.push(c);return a},[],a)}function qb(){}function rb(){}function sb(){}
var tb=function tb(a){if(null!=a&&null!=a.Y)return a.Y(a);var c=tb[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=tb._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("ICounted.-count",a);};function ub(){}var vb=function vb(a){if(null!=a&&null!=a.aa)return a.aa(a);var c=vb[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=vb._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IEmptyableCollection.-empty",a);};function wb(){}
var xb=function xb(a,b){if(null!=a&&null!=a.$)return a.$(a,b);var d=xb[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=xb._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("ICollection.-conj",a);};function yb(){}var zb=function zb(a){switch(arguments.length){case 2:return zb.c(arguments[0],arguments[1]);case 3:return zb.j(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};
zb.c=function(a,b){if(null!=a&&null!=a.N)return a.N(a,b);var c=zb[da(null==a?null:a)];if(null!=c)return c.c?c.c(a,b):c.call(null,a,b);c=zb._;if(null!=c)return c.c?c.c(a,b):c.call(null,a,b);throw jb("IIndexed.-nth",a);};zb.j=function(a,b,c){if(null!=a&&null!=a.ha)return a.ha(a,b,c);var d=zb[da(null==a?null:a)];if(null!=d)return d.j?d.j(a,b,c):d.call(null,a,b,c);d=zb._;if(null!=d)return d.j?d.j(a,b,c):d.call(null,a,b,c);throw jb("IIndexed.-nth",a);};zb.D=3;function Ab(){}
var Cb=function Cb(a){if(null!=a&&null!=a.ma)return a.ma(a);var c=Cb[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Cb._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("ISeq.-first",a);},Db=function Db(a){if(null!=a&&null!=a.qa)return a.qa(a);var c=Db[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Db._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("ISeq.-rest",a);};function Eb(){}
var Fb=function Fb(a){if(null!=a&&null!=a.ia)return a.ia(a);var c=Fb[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Fb._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("INext.-next",a);};function Gb(){}var Hb=function Hb(a){switch(arguments.length){case 2:return Hb.c(arguments[0],arguments[1]);case 3:return Hb.j(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};
Hb.c=function(a,b){if(null!=a&&null!=a.Z)return a.Z(a,b);var c=Hb[da(null==a?null:a)];if(null!=c)return c.c?c.c(a,b):c.call(null,a,b);c=Hb._;if(null!=c)return c.c?c.c(a,b):c.call(null,a,b);throw jb("ILookup.-lookup",a);};Hb.j=function(a,b,c){if(null!=a&&null!=a.L)return a.L(a,b,c);var d=Hb[da(null==a?null:a)];if(null!=d)return d.j?d.j(a,b,c):d.call(null,a,b,c);d=Hb._;if(null!=d)return d.j?d.j(a,b,c):d.call(null,a,b,c);throw jb("ILookup.-lookup",a);};Hb.D=3;
var Ib=function Ib(a,b,c){if(null!=a&&null!=a.hb)return a.hb(a,b,c);var e=Ib[da(null==a?null:a)];if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);e=Ib._;if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);throw jb("IAssociative.-assoc",a);},Jb=function Jb(a,b){if(null!=a&&null!=a.Gb)return a.Gb(a,b);var d=Jb[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=Jb._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("IFind.-find",a);};function Kb(){}
var Lb=function Lb(a,b){if(null!=a&&null!=a.pc)return a.pc(a,b);var d=Lb[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=Lb._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("IMap.-dissoc",a);},Mb=function Mb(a){if(null!=a&&null!=a.wd)return a.key;var c=Mb[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Mb._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IMapEntry.-key",a);},Nb=function Nb(a){if(null!=a&&null!=a.xd)return a.K;var c=Nb[da(null==
a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Nb._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IMapEntry.-val",a);};function Ob(){}
var Pb=function Pb(a,b){if(null!=a&&null!=a.Uc)return a.Uc(a,b);var d=Pb[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=Pb._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("ISet.-disjoin",a);},Qb=function Qb(a){if(null!=a&&null!=a.vb)return a.vb(a);var c=Qb[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Qb._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IStack.-peek",a);},Rb=function Rb(a){if(null!=a&&null!=a.wb)return a.wb(a);var c=Rb[da(null==
a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Rb._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IStack.-pop",a);};function Sb(){}var Tb=function Tb(a,b,c){if(null!=a&&null!=a.xb)return a.xb(a,b,c);var e=Tb[da(null==a?null:a)];if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);e=Tb._;if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);throw jb("IVector.-assoc-n",a);};function Ub(){}
var w=function w(a){if(null!=a&&null!=a.jb)return a.jb(a);var c=w[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=w._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IDeref.-deref",a);};function Vb(){}
var Xb=function Xb(a){if(null!=a&&null!=a.S)return a.S(a);var c=Xb[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Xb._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IMeta.-meta",a);},Yb=function Yb(a,b){if(null!=a&&null!=a.T)return a.T(a,b);var d=Yb[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=Yb._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("IWithMeta.-with-meta",a);};function Zb(){}
var $b=function $b(a){switch(arguments.length){case 2:return $b.c(arguments[0],arguments[1]);case 3:return $b.j(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};$b.c=function(a,b){if(null!=a&&null!=a.oa)return a.oa(a,b);var c=$b[da(null==a?null:a)];if(null!=c)return c.c?c.c(a,b):c.call(null,a,b);c=$b._;if(null!=c)return c.c?c.c(a,b):c.call(null,a,b);throw jb("IReduce.-reduce",a);};
$b.j=function(a,b,c){if(null!=a&&null!=a.pa)return a.pa(a,b,c);var d=$b[da(null==a?null:a)];if(null!=d)return d.j?d.j(a,b,c):d.call(null,a,b,c);d=$b._;if(null!=d)return d.j?d.j(a,b,c):d.call(null,a,b,c);throw jb("IReduce.-reduce",a);};$b.D=3;function ac(){}
var bc=function bc(a,b,c){if(null!=a&&null!=a.Hb)return a.Hb(a,b,c);var e=bc[da(null==a?null:a)];if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);e=bc._;if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);throw jb("IKVReduce.-kv-reduce",a);},cc=function cc(a,b){if(null!=a&&null!=a.H)return a.H(a,b);var d=cc[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=cc._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("IEquiv.-equiv",a);},dc=function dc(a){if(null!=a&&null!=
a.R)return a.R(a);var c=dc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=dc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IHash.-hash",a);};function ec(){}var fc=function fc(a){if(null!=a&&null!=a.V)return a.V(a);var c=fc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=fc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("ISeqable.-seq",a);};function gc(){}function hc(){}function ic(){}function jc(){}
var kc=function kc(a){if(null!=a&&null!=a.Ub)return a.Ub(a);var c=kc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=kc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IReversible.-rseq",a);},mc=function mc(a,b){if(null!=a&&null!=a.Vc)return a.Vc(a,b);var d=mc[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=mc._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("IWriter.-write",a);};function nc(){}
var oc=function oc(a,b,c){if(null!=a&&null!=a.P)return a.P(a,b,c);var e=oc[da(null==a?null:a)];if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);e=oc._;if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);throw jb("IPrintWithWriter.-pr-writer",a);},pc=function pc(a,b,c){if(null!=a&&null!=a.Wb)return a.Wb(a,b,c);var e=pc[da(null==a?null:a)];if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);e=pc._;if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);throw jb("IWatchable.-add-watch",a);},qc=function qc(a,
b){if(null!=a&&null!=a.Xb)return a.Xb(a,b);var d=qc[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=qc._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("IWatchable.-remove-watch",a);},rc=function rc(a){if(null!=a&&null!=a.Fb)return a.Fb(a);var c=rc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=rc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IEditableCollection.-as-transient",a);},sc=function sc(a,b){if(null!=a&&null!=a.Jb)return a.Jb(a,
b);var d=sc[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=sc._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("ITransientCollection.-conj!",a);},tc=function tc(a){if(null!=a&&null!=a.Vb)return a.Vb(a);var c=tc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=tc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("ITransientCollection.-persistent!",a);},uc=function uc(a,b,c){if(null!=a&&null!=a.Ib)return a.Ib(a,b,c);var e=uc[da(null==a?null:a)];
if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);e=uc._;if(null!=e)return e.j?e.j(a,b,c):e.call(null,a,b,c);throw jb("ITransientAssociative.-assoc!",a);},vc=function vc(a){if(null!=a&&null!=a.Fc)return a.Fc(a);var c=vc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=vc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IChunk.-drop-first",a);},wc=function wc(a){if(null!=a&&null!=a.nc)return a.nc(a);var c=wc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);
c=wc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IChunkedSeq.-chunked-first",a);},xc=function xc(a){if(null!=a&&null!=a.Eb)return a.Eb(a);var c=xc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=xc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IChunkedSeq.-chunked-rest",a);},yc=function yc(a){if(null!=a&&null!=a.qc)return a.qc(a);var c=yc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=yc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("INamed.-name",
a);},zc=function zc(a){if(null!=a&&null!=a.rc)return a.rc(a);var c=zc[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=zc._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("INamed.-namespace",a);},Ac=function Ac(a,b){if(null!=a&&null!=a.Ia)return a.Ia(a,b);var d=Ac[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=Ac._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("IReset.-reset!",a);},Cc=function Cc(a){switch(arguments.length){case 2:return Cc.c(arguments[0],
arguments[1]);case 3:return Cc.j(arguments[0],arguments[1],arguments[2]);case 4:return Cc.G(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return Cc.J(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};
Cc.c=function(a,b){if(null!=a&&null!=a.sc)return a.sc(a,b);var c=Cc[da(null==a?null:a)];if(null!=c)return c.c?c.c(a,b):c.call(null,a,b);c=Cc._;if(null!=c)return c.c?c.c(a,b):c.call(null,a,b);throw jb("ISwap.-swap!",a);};Cc.j=function(a,b,c){if(null!=a&&null!=a.tc)return a.tc(a,b,c);var d=Cc[da(null==a?null:a)];if(null!=d)return d.j?d.j(a,b,c):d.call(null,a,b,c);d=Cc._;if(null!=d)return d.j?d.j(a,b,c):d.call(null,a,b,c);throw jb("ISwap.-swap!",a);};
Cc.G=function(a,b,c,d){if(null!=a&&null!=a.uc)return a.uc(a,b,c,d);var e=Cc[da(null==a?null:a)];if(null!=e)return e.G?e.G(a,b,c,d):e.call(null,a,b,c,d);e=Cc._;if(null!=e)return e.G?e.G(a,b,c,d):e.call(null,a,b,c,d);throw jb("ISwap.-swap!",a);};Cc.J=function(a,b,c,d,e){if(null!=a&&null!=a.vc)return a.vc(a,b,c,d,e);var g=Cc[da(null==a?null:a)];if(null!=g)return g.J?g.J(a,b,c,d,e):g.call(null,a,b,c,d,e);g=Cc._;if(null!=g)return g.J?g.J(a,b,c,d,e):g.call(null,a,b,c,d,e);throw jb("ISwap.-swap!",a);};
Cc.D=5;function Dc(){}var Ec=function Ec(a){if(null!=a&&null!=a.La)return a.La(a);var c=Ec[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Ec._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IIterable.-iterator",a);};function Fc(a){this.Pd=a;this.o=1073741824;this.I=0}Fc.prototype.Vc=function(a,b){return this.Pd.append(b)};function Gc(a){var b=new Pa;a.P(null,new Fc(b),Za());return u.h(b)}
var Hc="undefined"!==typeof Math&&"undefined"!==typeof Math.imul&&0!==Math.imul(4294967295,5)?function(a,b){return Math.imul(a,b)}:function(a,b){var c=a&65535,d=b&65535;return c*d+((a>>>16&65535)*d+c*(b>>>16&65535)<<16>>>0)|0};function Ic(a){a=Hc(a|0,-862048943);return Hc(a<<15|a>>>-15,461845907)}function Jc(a,b){a=(a|0)^(b|0);return Hc(a<<13|a>>>-13,5)+-430675100|0}function Kc(a,b){a=(a|0)^b;a=Hc(a^a>>>16,-2048144789);a=Hc(a^a>>>13,-1028477387);return a^a>>>16}
function Lc(a){a:{var b=1;for(var c=0;;)if(b<a.length){var d=b+2;c=Jc(c,Ic(a.charCodeAt(b-1)|a.charCodeAt(b)<<16));b=d}else{b=c;break a}}b=1===(a.length&1)?b^Ic(a.charCodeAt(a.length-1)):b;return Kc(b,Hc(2,a.length))}var Mc={},Nc=0;function Oc(a){255<Nc&&(Mc={},Nc=0);if(null==a)return 0;var b=Mc[a];if("number"===typeof b)a=b;else{a:if(null!=a)if(b=a.length,0<b)for(var c=0,d=0;;)if(c<b){var e=c+1;d=Hc(31,d)+a.charCodeAt(c);c=e}else{b=d;break a}else b=0;else b=0;Mc[a]=b;Nc+=1;a=b}return a}
function Pc(a){if(null!=a&&(a.o&4194304||k===a.xe))return dc(a)^0;if("number"===typeof a){if(t(isFinite(a)))return Math.floor(a)%2147483647;switch(a){case Infinity:return 2146435072;case -Infinity:return-1048576;default:return 2146959360}}else return!0===a?a=1231:!1===a?a=1237:"string"===typeof a?(a=Oc(a),0!==a&&(a=Ic(a),a=Jc(0,a),a=Kc(a,4))):a=a instanceof Date?a.valueOf()^0:null==a?0:dc(a)^0,a}function Qc(a,b){return a^b+2654435769+(a<<6)+(a>>2)}function Rc(a,b){return b instanceof a}
function Sc(a,b,c,d,e){this.Pb=a;this.name=b;this.sb=c;this.Db=d;this.fb=e;this.o=2154168321;this.I=4096}f=Sc.prototype;f.toString=function(){return this.sb};f.equiv=function(a){return this.H(null,a)};f.H=function(a,b){return b instanceof Sc?this.sb===b.sb:!1};
f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return A.c(c,this);case 3:return A.j(c,this,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return A.c(c,this)};a.j=function(a,c,d){return A.j(c,this,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return A.c(a,this)};f.c=function(a,b){return A.j(a,this,b)};f.S=function(){return this.fb};
f.T=function(a,b){return new Sc(this.Pb,this.name,this.sb,this.Db,b)};f.R=function(){var a=this.Db;return null!=a?a:this.Db=a=Qc(Lc(this.name),Oc(this.Pb))};f.qc=function(){return this.name};f.rc=function(){return this.Pb};f.P=function(a,b){return mc(b,this.sb)};var Tc=function Tc(a){switch(arguments.length){case 1:return Tc.h(arguments[0]);case 2:return Tc.c(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};
Tc.h=function(a){for(;;){if(a instanceof Sc)return a;if("string"===typeof a){var b=a.indexOf("/");return 1>b?Tc.c(null,a):Tc.c(a.substring(0,b),a.substring(b+1,a.length))}if(a instanceof q)a=a.U;else throw Error("no conversion to symbol");}};Tc.c=function(a,b){var c=null!=a?[u.h(a),"/",u.h(b)].join(""):b;return new Sc(a,b,c,null,null)};Tc.D=2;function Uc(a){return null!=a?a.I&131072||k===a.ye?!0:a.I?!1:gb(Dc,a):gb(Dc,a)}
function B(a){if(null==a)return null;if(null!=a&&(a.o&8388608||k===a.zd))return fc(a);if(bb(a)||"string"===typeof a)return 0===a.length?null:new D(a,0,null);if(gb(ec,a))return fc(a);throw Error([u.h(a)," is not ISeqable"].join(""));}function E(a){if(null==a)return null;if(null!=a&&(a.o&64||k===a.M))return Cb(a);a=B(a);return null==a?null:Cb(a)}function Vc(a){return null!=a?null!=a&&(a.o&64||k===a.M)?Db(a):(a=B(a))?a.qa(null):Wc:Wc}
function G(a){return null==a?null:null!=a&&(a.o&128||k===a.Tb)?Fb(a):B(Vc(a))}var H=function H(a){switch(arguments.length){case 1:return H.h(arguments[0]);case 2:return H.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return H.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};H.h=function(){return!0};H.c=function(a,b){return null==a?null==b:a===b||cc(a,b)};
H.l=function(a,b,c){for(;;)if(H.c(a,b))if(G(c))a=b,b=E(c),c=G(c);else return H.c(b,E(c));else return!1};H.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};H.D=2;function Xc(a){this.s=a}Xc.prototype.next=function(){if(null!=this.s){var a=E(this.s);this.s=G(this.s);return{value:a,done:!1}}return{value:null,done:!0}};function Yc(a){return new Xc(B(a))}function Zc(a,b){a=Ic(a);a=Jc(0,a);return Kc(a,b)}
function $c(a){var b=0,c=1;for(a=B(a);;)if(null!=a)b+=1,c=Hc(31,c)+Pc(E(a))|0,a=G(a);else return Zc(c,b)}var ad=Zc(1,0);function bd(a){var b=0,c=0;for(a=B(a);;)if(null!=a)b+=1,c=c+Pc(E(a))|0,a=G(a);else return Zc(c,b)}var cd=Zc(0,0);sb["null"]=!0;tb["null"]=function(){return 0};Date.prototype.H=function(a,b){return b instanceof Date&&this.valueOf()===b.valueOf()};cc.number=function(a,b){return a===b};qb["function"]=!0;Vb["function"]=!0;Xb["function"]=function(){return null};dc._=function(a){return ha(a)};
function dd(a){return a+1}function ed(){this.K=!1;this.o=32768;this.I=0}ed.prototype.jb=function(){return this.K};function fd(a){return a instanceof ed}function gd(a){return w(a)}function hd(a,b){var c=tb(a);if(0===c)return b.B?b.B():b.call(null);for(var d=zb.c(a,0),e=1;;)if(e<c){var g=zb.c(a,e);d=b.c?b.c(d,g):b.call(null,d,g);if(fd(d))return w(d);e+=1}else return d}
function id(a,b,c){var d=tb(a),e=c;for(c=0;;)if(c<d){var g=zb.c(a,c);e=b.c?b.c(e,g):b.call(null,e,g);if(fd(e))return w(e);c+=1}else return e}function jd(a,b){var c=a.length;if(0===a.length)return b.B?b.B():b.call(null);for(var d=a[0],e=1;;)if(e<c){var g=a[e];d=b.c?b.c(d,g):b.call(null,d,g);if(fd(d))return w(d);e+=1}else return d}function kd(a,b,c){var d=a.length,e=c;for(c=0;;)if(c<d){var g=a[c];e=b.c?b.c(e,g):b.call(null,e,g);if(fd(e))return w(e);c+=1}else return e}
function ld(a,b,c,d){for(var e=a.length;;)if(d<e){var g=a[d];c=b.c?b.c(c,g):b.call(null,c,g);if(fd(c))return w(c);d+=1}else return c}function nd(a){return null!=a?a.o&2||k===a.nd?!0:a.o?!1:gb(sb,a):gb(sb,a)}function od(a){return null!=a?a.o&16||k===a.Rc?!0:a.o?!1:gb(yb,a):gb(yb,a)}function J(a,b,c){var d=K(a);if(c>=d)return-1;!(0<c)&&0>c&&(c+=d,c=0>c?0:c);for(;;)if(c<d){if(H.c(pd(a,c),b))return c;c+=1}else return-1}
function qd(a,b,c){var d=K(a);if(0===d)return-1;0<c?(--d,c=d<c?d:c):c=0>c?d+c:c;for(;;)if(0<=c){if(H.c(pd(a,c),b))return c;--c}else return-1}function rd(a,b){this.m=a;this.i=b}rd.prototype.ca=function(){return this.i<this.m.length};rd.prototype.next=function(){var a=this.m[this.i];this.i+=1;return a};function D(a,b,c){this.m=a;this.i=b;this.meta=c;this.o=166592766;this.I=139264}f=D.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.N=function(a,b){a=b+this.i;if(0<=a&&a<this.m.length)return this.m[a];throw Error("Index out of bounds");};f.ha=function(a,b,c){a=b+this.i;return 0<=a&&a<this.m.length?this.m[a]:c};f.La=function(){return new rd(this.m,this.i)};
f.S=function(){return this.meta};f.ia=function(){return this.i+1<this.m.length?new D(this.m,this.i+1,null):null};f.Y=function(){var a=this.m.length-this.i;return 0>a?0:a};f.Ub=function(){var a=this.Y(null);return 0<a?new sd(this,a-1,null):null};f.R=function(){return $c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};f.oa=function(a,b){return ld(this.m,b,this.m[this.i],this.i+1)};f.pa=function(a,b,c){return ld(this.m,b,c,this.i)};f.ma=function(){return this.m[this.i]};
f.qa=function(){return this.i+1<this.m.length?new D(this.m,this.i+1,null):Wc};f.V=function(){return this.i<this.m.length?this:null};f.T=function(a,b){return b===this.meta?this:new D(this.m,this.i,b)};f.$=function(a,b){return ud(b,this)};D.prototype[lb]=function(){return Yc(this)};function L(a){return 0<a.length?new D(a,0,null):null}function sd(a,b,c){this.mc=a;this.i=b;this.meta=c;this.o=32374990;this.I=8192}f=sd.prototype;f.toString=function(){return Gc(this)};
f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){return 0<this.i?new sd(this.mc,this.i-1,null):null};f.Y=function(){return this.i+1};f.R=function(){return $c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};
f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){return zb.c(this.mc,this.i)};f.qa=function(){return 0<this.i?new sd(this.mc,this.i-1,null):Wc};f.V=function(){return this};f.T=function(a,b){return b===this.meta?this:new sd(this.mc,this.i,b)};f.$=function(a,b){return ud(b,this)};sd.prototype[lb]=function(){return Yc(this)};function xd(a){for(;;){var b=G(a);if(null!=b)a=b;else return E(a)}}cc._=function(a,b){return a===b};
var yd=function yd(a){switch(arguments.length){case 0:return yd.B();case 1:return yd.h(arguments[0]);case 2:return yd.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return yd.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};yd.B=function(){return zd};yd.h=function(a){return a};yd.c=function(a,b){return null!=a?xb(a,b):new Ad(null,b,null,1,null)};
yd.l=function(a,b,c){for(;;)if(t(c))a=yd.c(a,b),b=E(c),c=G(c);else return yd.c(a,b)};yd.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};yd.D=2;function Bd(a){return null==a?null:null!=a&&(a.o&4||k===a.pd)?vb(a):(null!=a?a.o&4||k===a.pd||(a.o?0:gb(ub,a)):gb(ub,a))?vb(a):null}
function K(a){if(null!=a)if(null!=a&&(a.o&2||k===a.nd))a=tb(a);else if(bb(a))a=a.length;else if("string"===typeof a)a=a.length;else if(null!=a&&(a.o&8388608||k===a.zd))a:{a=B(a);for(var b=0;;){if(nd(a)){a=b+tb(a);break a}a=G(a);b+=1}}else a=tb(a);else a=0;return a}function Cd(a,b,c){for(;;){if(null==a)return c;if(0===b)return B(a)?E(a):c;if(od(a))return zb.j(a,b,c);if(B(a))a=G(a),--b;else return c}}
function pd(a,b){if("number"!==typeof b)throw Error("Index argument to nth must be a number");if(null==a)return a;if(null!=a&&(a.o&16||k===a.Rc))return zb.c(a,b);if(bb(a)){if(-1<b&&b<a.length)return a[b|0];throw Error("Index out of bounds");}if("string"===typeof a){if(-1<b&&b<a.length)return a.charAt(b|0);throw Error("Index out of bounds");}if(null!=a&&(a.o&64||k===a.M)||null!=a&&(a.o&16777216||k===a.Ic)){if(0>b)throw Error("Index out of bounds");a:for(;;){if(null==a)throw Error("Index out of bounds");
if(0===b){if(B(a)){a=E(a);break a}throw Error("Index out of bounds");}if(od(a)){a=zb.c(a,b);break a}if(B(a))a=G(a),--b;else throw Error("Index out of bounds");}return a}if(gb(yb,a))return zb.c(a,b);throw Error(["nth not supported on this type ",u.h(kb(hb(a)))].join(""));}
function M(a,b,c){if("number"!==typeof b)throw Error("Index argument to nth must be a number.");if(null==a)return c;if(null!=a&&(a.o&16||k===a.Rc))return zb.j(a,b,c);if(bb(a))return-1<b&&b<a.length?a[b|0]:c;if("string"===typeof a)return-1<b&&b<a.length?a.charAt(b|0):c;if(null!=a&&(a.o&64||k===a.M)||null!=a&&(a.o&16777216||k===a.Ic))return 0>b?c:Cd(a,b,c);if(gb(yb,a))return zb.j(a,b,c);throw Error(["nth not supported on this type ",u.h(kb(hb(a)))].join(""));}
var A=function A(a){switch(arguments.length){case 2:return A.c(arguments[0],arguments[1]);case 3:return A.j(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};A.c=function(a,b){return null==a?null:null!=a&&(a.o&256||k===a.ud)?Hb.c(a,b):bb(a)?null!=b&&b<a.length?a[b|0]:null:"string"===typeof a?null!=b&&b<a.length?a.charAt(b|0):null:gb(Gb,a)?Hb.c(a,b):null};
A.j=function(a,b,c){return null!=a?null!=a&&(a.o&256||k===a.ud)?Hb.j(a,b,c):bb(a)?null!=b&&-1<b&&b<a.length?a[b|0]:c:"string"===typeof a?null!=b&&-1<b&&b<a.length?a.charAt(b|0):c:gb(Gb,a)?Hb.j(a,b,c):c:c};A.D=3;var Dd=function Dd(a){switch(arguments.length){case 3:return Dd.j(arguments[0],arguments[1],arguments[2]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Dd.l(arguments[0],arguments[1],arguments[2],new D(c.slice(3),0,null))}};
Dd.j=function(a,b,c){return null!=a?Ib(a,b,c):Ed([b,c])};Dd.l=function(a,b,c,d){for(;;)if(a=Dd.j(a,b,c),t(d))b=E(d),c=E(G(d)),d=G(G(d));else return a};Dd.C=function(a){var b=E(a),c=G(a);a=E(c);var d=G(c);c=E(d);d=G(d);return this.l(b,a,c,d)};Dd.D=3;
var Fd=function Fd(a){switch(arguments.length){case 1:return Fd.h(arguments[0]);case 2:return Fd.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Fd.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};Fd.h=function(a){return a};Fd.c=function(a,b){return null==a?null:Lb(a,b)};Fd.l=function(a,b,c){for(;;){if(null==a)return null;a=Fd.c(a,b);if(t(c))b=E(c),c=G(c);else return a}};
Fd.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};Fd.D=2;function Gd(a){var b=fa(a);return b?b:null!=a?k===a.md?!0:a.Jc?!1:gb(qb,a):gb(qb,a)}function Hd(a,b){this.v=a;this.meta=b;this.o=393217;this.I=0}f=Hd.prototype;f.S=function(){return this.meta};f.T=function(a,b){return new Hd(this.v,b)};f.md=k;
f.call=function(){function a(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T,W,Q,ea){return N.l(this.v,b,c,d,e,L([g,h,l,m,n,v,r,x,y,z,C,F,I,T,W,Q,ea]))}function b(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T,W,Q){a=this;return a.v.Ba?a.v.Ba(b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T,W,Q):a.v.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T,W,Q)}function c(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T,W){a=this;return a.v.Aa?a.v.Aa(b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T,W):a.v.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T,W)}function d(a,
b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T){a=this;return a.v.za?a.v.za(b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T):a.v.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I,T)}function e(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I){a=this;return a.v.ya?a.v.ya(b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I):a.v.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F,I)}function g(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F){a=this;return a.v.xa?a.v.xa(b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F):a.v.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C,F)}function h(a,b,c,d,e,g,h,l,m,n,v,r,
x,y,z,C){a=this;return a.v.wa?a.v.wa(b,c,d,e,g,h,l,m,n,v,r,x,y,z,C):a.v.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,C)}function l(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z){a=this;return a.v.va?a.v.va(b,c,d,e,g,h,l,m,n,v,r,x,y,z):a.v.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z)}function m(a,b,c,d,e,g,h,l,m,n,v,r,x,y){a=this;return a.v.ua?a.v.ua(b,c,d,e,g,h,l,m,n,v,r,x,y):a.v.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y)}function n(a,b,c,d,e,g,h,l,m,n,v,r,x){a=this;return a.v.ta?a.v.ta(b,c,d,e,g,h,l,m,n,v,r,x):a.v.call(null,b,c,d,
e,g,h,l,m,n,v,r,x)}function r(a,b,c,d,e,g,h,l,m,n,v,r){a=this;return a.v.sa?a.v.sa(b,c,d,e,g,h,l,m,n,v,r):a.v.call(null,b,c,d,e,g,h,l,m,n,v,r)}function v(a,b,c,d,e,g,h,l,m,n,v){a=this;return a.v.ra?a.v.ra(b,c,d,e,g,h,l,m,n,v):a.v.call(null,b,c,d,e,g,h,l,m,n,v)}function x(a,b,c,d,e,g,h,l,m,n){a=this;return a.v.Da?a.v.Da(b,c,d,e,g,h,l,m,n):a.v.call(null,b,c,d,e,g,h,l,m,n)}function y(a,b,c,d,e,g,h,l,m){a=this;return a.v.la?a.v.la(b,c,d,e,g,h,l,m):a.v.call(null,b,c,d,e,g,h,l,m)}function z(a,b,c,d,e,g,
h,l){a=this;return a.v.Ca?a.v.Ca(b,c,d,e,g,h,l):a.v.call(null,b,c,d,e,g,h,l)}function C(a,b,c,d,e,g,h){a=this;return a.v.fa?a.v.fa(b,c,d,e,g,h):a.v.call(null,b,c,d,e,g,h)}function F(a,b,c,d,e,g){a=this;return a.v.J?a.v.J(b,c,d,e,g):a.v.call(null,b,c,d,e,g)}function I(a,b,c,d,e){a=this;return a.v.G?a.v.G(b,c,d,e):a.v.call(null,b,c,d,e)}function T(a,b,c,d){a=this;return a.v.j?a.v.j(b,c,d):a.v.call(null,b,c,d)}function W(a,b,c){a=this;return a.v.c?a.v.c(b,c):a.v.call(null,b,c)}function ea(a,b){a=this;
return a.v.h?a.v.h(b):a.v.call(null,b)}function Ha(a){a=this;return a.v.B?a.v.B():a.v.call(null)}var Q=null;Q=function(X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Q,Wb,lc,Bc,md,Zd,ff,nh,Jk){switch(arguments.length){case 1:return Ha.call(this,X);case 2:return ea.call(this,X,Y);case 3:return W.call(this,X,Y,qa);case 4:return T.call(this,X,Y,qa,ib);case 5:return I.call(this,X,Y,qa,ib,Aa);case 6:return F.call(this,X,Y,qa,ib,Aa,Ka);case 7:return C.call(this,X,Y,qa,ib,Aa,Ka,La);case 8:return z.call(this,X,Y,qa,
ib,Aa,Ka,La,Oa);case 9:return y.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra);case 10:return x.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya);case 11:return v.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db);case 12:return r.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob);case 13:return n.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb);case 14:return m.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Q);case 15:return l.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Q,Wb);case 16:return h.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,
db,ob,Bb,Q,Wb,lc);case 17:return g.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Q,Wb,lc,Bc);case 18:return e.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Q,Wb,lc,Bc,md);case 19:return d.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Q,Wb,lc,Bc,md,Zd);case 20:return c.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Q,Wb,lc,Bc,md,Zd,ff);case 21:return b.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Q,Wb,lc,Bc,md,Zd,ff,nh);case 22:return a.call(this,X,Y,qa,ib,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Q,Wb,lc,Bc,
md,Zd,ff,nh,Jk)}throw Error("Invalid arity: "+(arguments.length-1));};Q.h=Ha;Q.c=ea;Q.j=W;Q.G=T;Q.J=I;Q.fa=F;Q.Ca=C;Q.la=z;Q.Da=y;Q.ra=x;Q.sa=v;Q.ta=r;Q.ua=n;Q.va=m;Q.wa=l;Q.xa=h;Q.ya=g;Q.za=e;Q.Aa=d;Q.Ba=c;Q.Hc=b;Q.sd=a;return Q}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.B=function(){return this.v.B?this.v.B():this.v.call(null)};f.h=function(a){return this.v.h?this.v.h(a):this.v.call(null,a)};f.c=function(a,b){return this.v.c?this.v.c(a,b):this.v.call(null,a,b)};
f.j=function(a,b,c){return this.v.j?this.v.j(a,b,c):this.v.call(null,a,b,c)};f.G=function(a,b,c,d){return this.v.G?this.v.G(a,b,c,d):this.v.call(null,a,b,c,d)};f.J=function(a,b,c,d,e){return this.v.J?this.v.J(a,b,c,d,e):this.v.call(null,a,b,c,d,e)};f.fa=function(a,b,c,d,e,g){return this.v.fa?this.v.fa(a,b,c,d,e,g):this.v.call(null,a,b,c,d,e,g)};f.Ca=function(a,b,c,d,e,g,h){return this.v.Ca?this.v.Ca(a,b,c,d,e,g,h):this.v.call(null,a,b,c,d,e,g,h)};
f.la=function(a,b,c,d,e,g,h,l){return this.v.la?this.v.la(a,b,c,d,e,g,h,l):this.v.call(null,a,b,c,d,e,g,h,l)};f.Da=function(a,b,c,d,e,g,h,l,m){return this.v.Da?this.v.Da(a,b,c,d,e,g,h,l,m):this.v.call(null,a,b,c,d,e,g,h,l,m)};f.ra=function(a,b,c,d,e,g,h,l,m,n){return this.v.ra?this.v.ra(a,b,c,d,e,g,h,l,m,n):this.v.call(null,a,b,c,d,e,g,h,l,m,n)};f.sa=function(a,b,c,d,e,g,h,l,m,n,r){return this.v.sa?this.v.sa(a,b,c,d,e,g,h,l,m,n,r):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r)};
f.ta=function(a,b,c,d,e,g,h,l,m,n,r,v){return this.v.ta?this.v.ta(a,b,c,d,e,g,h,l,m,n,r,v):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r,v)};f.ua=function(a,b,c,d,e,g,h,l,m,n,r,v,x){return this.v.ua?this.v.ua(a,b,c,d,e,g,h,l,m,n,r,v,x):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x)};f.va=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y){return this.v.va?this.v.va(a,b,c,d,e,g,h,l,m,n,r,v,x,y):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y)};
f.wa=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z){return this.v.wa?this.v.wa(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z)};f.xa=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C){return this.v.xa?this.v.xa(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C)};f.ya=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F){return this.v.ya?this.v.ya(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F)};
f.za=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I){return this.v.za?this.v.za(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I)};f.Aa=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T){return this.v.Aa?this.v.Aa(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T)};
f.Ba=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W){return this.v.Ba?this.v.Ba(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W):this.v.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W)};f.Hc=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W,ea){return N.l(this.v,a,b,c,d,L([e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W,ea]))};function Id(a,b){return fa(a)?new Hd(a,b):null==a?null:Yb(a,b)}function Jd(a){var b=null!=a;return(b?null!=a?a.o&131072||k===a.Sc||(a.o?0:gb(Vb,a)):gb(Vb,a):b)?Xb(a):null}
function Kd(a){return null==a?null:Qb(a)}var Ld=function Ld(a){switch(arguments.length){case 1:return Ld.h(arguments[0]);case 2:return Ld.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ld.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};Ld.h=function(a){return a};Ld.c=function(a,b){return null==a?null:Pb(a,b)};Ld.l=function(a,b,c){for(;;){if(null==a)return null;a=Ld.c(a,b);if(t(c))b=E(c),c=G(c);else return a}};
Ld.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};Ld.D=2;function Md(a){return null==a||eb(B(a))}function Nd(a){return null==a?!1:null!=a?a.o&8||k===a.ve?!0:a.o?!1:gb(wb,a):gb(wb,a)}function Od(a){return null==a?!1:null!=a?a.o&4096||k===a.Ad?!0:a.o?!1:gb(Ob,a):gb(Ob,a)}function Pd(a){return null!=a?a.o&16777216||k===a.Ic?!0:a.o?!1:gb(gc,a):gb(gc,a)}function Qd(a){return null==a?!1:null!=a?a.o&1024||k===a.vd?!0:a.o?!1:gb(Kb,a):gb(Kb,a)}
function Rd(a){return null!=a?a.o&67108864||k===a.Ce?!0:a.o?!1:gb(ic,a):gb(ic,a)}function Sd(a){return null!=a?a.o&16384||k===a.Ee?!0:a.o?!1:gb(Sb,a):gb(Sb,a)}function Td(a){return null!=a?a.I&512||k===a.ue?!0:!1:!1}function Ud(a,b,c,d,e){for(;0!==e;)c[d]=a[b],d+=1,--e,b+=1}var Vd={};function Wd(a){return!0===a}function Xd(a){return null==a?!1:null!=a?a.o&64||k===a.M?!0:a.o?!1:gb(Ab,a):gb(Ab,a)}function $d(a){return null==a?!1:!1===a?!1:!0}
function ee(a){var b=Gd(a);return b?b:null!=a?a.o&1||k===a.we?!0:a.o?!1:gb(rb,a):gb(rb,a)}function fe(a,b){return A.j(a,b,Vd)===Vd?!1:!0}function vd(a,b){return(b=B(b))?pb(a,E(b),G(b)):a.B?a.B():a.call(null)}function wd(a,b,c){for(c=B(c);;)if(c){var d=E(c);b=a.c?a.c(b,d):a.call(null,b,d);if(fd(b))return w(b);c=G(c)}else return b}
function ge(a,b){a=Ec(a);if(t(a.ca()))for(var c=a.next();;)if(a.ca()){var d=a.next();c=b.c?b.c(c,d):b.call(null,c,d);if(fd(c))return w(c)}else return c;else return b.B?b.B():b.call(null)}function he(a,b,c){for(a=Ec(a);;)if(a.ca()){var d=a.next();c=b.c?b.c(c,d):b.call(null,c,d);if(fd(c))return w(c)}else return c}function ie(a,b){return null!=b&&(b.o&524288||k===b.yd)?$b.c(b,a):bb(b)?jd(b,a):"string"===typeof b?jd(b,a):gb(Zb,b)?$b.c(b,a):Uc(b)?ge(b,a):vd(a,b)}
function pb(a,b,c){return null!=c&&(c.o&524288||k===c.yd)?$b.j(c,a,b):bb(c)?kd(c,a,b):"string"===typeof c?kd(c,a,b):gb(Zb,c)?$b.j(c,a,b):Uc(c)?he(c,a,b):wd(a,b,c)}function je(a,b,c){return null!=c?bc(c,a,b):b}function ke(a){return a}function le(a,b,c,d){a=a.h?a.h(b):a.call(null,b);c=pb(a,c,d);return a.h?a.h(c):a.call(null,c)}
var me=function me(a){switch(arguments.length){case 0:return me.B();case 1:return me.h(arguments[0]);case 2:return me.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return me.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};me.B=function(){return 0};me.h=function(a){return a};me.c=function(a,b){return a+b};me.l=function(a,b,c){return pb(me,a+b,c)};me.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};
me.D=2;function ne(a){return a-1}var oe=function oe(a){switch(arguments.length){case 1:return oe.h(arguments[0]);case 2:return oe.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return oe.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};oe.h=function(a){return a};oe.c=function(a,b){return a>b?a:b};oe.l=function(a,b,c){return pb(oe,a>b?a:b,c)};oe.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};oe.D=2;
function pe(a){if("number"===typeof a)return String.fromCharCode(a);if("string"===typeof a&&1===a.length)return a;throw Error("Argument to char must be a character or number");}function qe(a,b){a=(a-a%b)/b;return 0<=a?Math.floor(a):Math.ceil(a)}function re(a){a-=a>>1&1431655765;a=(a&858993459)+(a>>2&858993459);return 16843009*(a+(a>>4)&252645135)>>24}
var u=function u(a){switch(arguments.length){case 0:return u.B();case 1:return u.h(arguments[0]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return u.l(arguments[0],new D(c.slice(1),0,null))}};u.B=function(){return""};u.h=function(a){return null==a?"":[a].join("")};u.l=function(a,b){for(a=new Pa(u.h(a));;)if(t(b))a=a.append(u.h(E(b))),b=G(b);else return a.toString()};u.C=function(a){var b=E(a);a=G(a);return this.l(b,a)};u.D=1;
function td(a,b){if(Pd(b))if(nd(a)&&nd(b)&&K(a)!==K(b))a=!1;else a:for(a=B(a),b=B(b);;){if(null==a){a=null==b;break a}if(null!=b&&H.c(E(a),E(b)))a=G(a),b=G(b);else{a=!1;break a}}else a=null;return $d(a)}function Ad(a,b,c,d,e){this.meta=a;this.first=b;this.nb=c;this.count=d;this.F=e;this.o=65937646;this.I=8192}f=Ad.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,this.count)}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){return 1===this.count?null:this.nb};f.Y=function(){return this.count};f.vb=function(){return this.first};f.wb=function(){return this.qa(null)};
f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Yb(Wc,this.meta)};f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){return this.first};f.qa=function(){return 1===this.count?Wc:this.nb};f.V=function(){return this};f.T=function(a,b){return b===this.meta?this:new Ad(b,this.first,this.nb,this.count,this.F)};f.$=function(a,b){return new Ad(this.meta,b,this,this.count+1,null)};
function se(a){return null!=a?a.o&33554432||k===a.Ae?!0:a.o?!1:gb(hc,a):gb(hc,a)}Ad.prototype[lb]=function(){return Yc(this)};function te(a){this.meta=a;this.o=65937614;this.I=8192}f=te.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){return null};f.Y=function(){return 0};f.vb=function(){return null};f.wb=function(){throw Error("Can't pop empty list");};f.R=function(){return ad};
f.H=function(a,b){return se(b)||Pd(b)?null==B(b):!1};f.aa=function(){return this};f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){return null};f.qa=function(){return Wc};f.V=function(){return null};f.T=function(a,b){return b===this.meta?this:new te(b)};f.$=function(a,b){return new Ad(this.meta,b,null,1,null)};var Wc=new te(null);te.prototype[lb]=function(){return Yc(this)};
function ue(a){return(null!=a?a.o&134217728||k===a.De||(a.o?0:gb(jc,a)):gb(jc,a))?(a=kc(a))?a:Wc:pb(yd,Wc,a)}var ve=function ve(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return ve.l(0<c.length?new D(c.slice(0),0,null):null)};ve.l=function(a){if(a instanceof D&&0===a.i)var b=a.m;else a:for(b=[];;)if(null!=a)b.push(Cb(a)),a=Fb(a);else break a;a=b.length;for(var c=Wc;;)if(0<a){var d=a-1;c=xb(c,b[a-1]);a=d}else return c};ve.D=0;ve.C=function(a){return this.l(B(a))};
function we(a,b,c,d){this.meta=a;this.first=b;this.nb=c;this.F=d;this.o=65929452;this.I=8192}f=we.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){return null==this.nb?null:B(this.nb)};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};
f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){return this.first};f.qa=function(){return null==this.nb?Wc:this.nb};f.V=function(){return this};f.T=function(a,b){return b===this.meta?this:new we(b,this.first,this.nb,this.F)};f.$=function(a,b){return new we(null,b,this,null)};we.prototype[lb]=function(){return Yc(this)};
function ud(a,b){return null==b?new Ad(null,a,null,1,null):null!=b&&(b.o&64||k===b.M)?new we(null,a,b,null):new we(null,a,B(b),null)}function q(a,b,c,d){this.Pb=a;this.name=b;this.U=c;this.Db=d;this.o=2153775105;this.I=4096}f=q.prototype;f.toString=function(){return[":",u.h(this.U)].join("")};f.equiv=function(a){return this.H(null,a)};f.H=function(a,b){return b instanceof q?this.U===b.U:!1};
f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return A.c(c,this);case 3:return A.j(c,this,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return A.c(c,this)};a.j=function(a,c,d){return A.j(c,this,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return A.c(a,this)};f.c=function(a,b){return A.j(a,this,b)};
f.R=function(){var a=this.Db;return null!=a?a:this.Db=a=Qc(Lc(this.name),Oc(this.Pb))+2654435769|0};f.qc=function(){return this.name};f.rc=function(){return this.Pb};f.P=function(a,b){return mc(b,[":",u.h(this.U)].join(""))};function xe(a,b){return a===b?!0:a instanceof q&&b instanceof q?a.U===b.U:!1}function ye(a){if(null!=a&&(a.I&4096||k===a.Tc))return zc(a);throw Error(["Doesn't support namespace: ",u.h(a)].join(""));}
var ze=function ze(a){switch(arguments.length){case 1:return ze.h(arguments[0]);case 2:return ze.c(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};ze.h=function(a){if(a instanceof q)return a;if(a instanceof Sc)return new q(ye(a),Ae(a),a.sb,null);if("string"===typeof a){var b=a.split("/");return 2===b.length?new q(b[0],b[1],a,null):new q(null,b[0],a,null)}return null};
ze.c=function(a,b){a=a instanceof q?Ae(a):a instanceof Sc?Ae(a):a;b=b instanceof q?Ae(b):b instanceof Sc?Ae(b):b;return new q(a,b,[t(a)?[u.h(a),"/"].join(""):null,u.h(b)].join(""),null)};ze.D=2;function Be(a,b,c,d){this.meta=a;this.$b=b;this.s=c;this.F=d;this.o=32374988;this.I=1}f=Be.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};function Ce(a){null!=a.$b&&(a.s=a.$b.B?a.$b.B():a.$b.call(null),a.$b=null);return a.s}
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){this.V(null);return null==this.s?null:G(this.s)};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){return td(this,b)};
f.aa=function(){return Yb(Wc,this.meta)};f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){this.V(null);return null==this.s?null:E(this.s)};f.qa=function(){this.V(null);return null!=this.s?Vc(this.s):Wc};f.V=function(){Ce(this);if(null==this.s)return null;for(var a=this.s;;)if(a instanceof Be)a=Ce(a);else return this.s=a,B(this.s)};f.T=function(a,b){return b===this.meta?this:new Be(b,function(a){return function(){return a.V(null)}}(this),null,this.F)};
f.$=function(a,b){return ud(b,this)};Be.prototype[lb]=function(){return Yc(this)};function De(a){this.ub=a;this.end=0;this.o=2;this.I=0}De.prototype.add=function(a){this.ub[this.end]=a;return this.end+=1};De.prototype.ka=function(){var a=new Ee(this.ub,0,this.end);this.ub=null;return a};De.prototype.Y=function(){return this.end};function Fe(a){return new De(Array(a))}function Ee(a,b,c){this.m=a;this.off=b;this.end=c;this.o=524306;this.I=0}f=Ee.prototype;f.Y=function(){return this.end-this.off};
f.N=function(a,b){return this.m[this.off+b]};f.ha=function(a,b,c){return 0<=b&&b<this.end-this.off?this.m[this.off+b]:c};f.Fc=function(){if(this.off===this.end)throw Error("-drop-first of empty chunk");return new Ee(this.m,this.off+1,this.end)};f.oa=function(a,b){return ld(this.m,b,this.m[this.off],this.off+1)};f.pa=function(a,b,c){return ld(this.m,b,c,this.off)};function Ge(a,b,c,d){this.ka=a;this.$a=b;this.meta=c;this.F=d;this.o=31850732;this.I=1536}f=Ge.prototype;f.toString=function(){return Gc(this)};
f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){return 1<tb(this.ka)?new Ge(vc(this.ka),this.$a,null,null):null==this.$a?null:fc(this.$a)};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};
f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};f.ma=function(){return zb.c(this.ka,0)};f.qa=function(){return 1<tb(this.ka)?new Ge(vc(this.ka),this.$a,null,null):null==this.$a?Wc:this.$a};f.V=function(){return this};f.nc=function(){return this.ka};f.Eb=function(){return null==this.$a?Wc:this.$a};f.T=function(a,b){return b===this.meta?this:new Ge(this.ka,this.$a,b,this.F)};f.$=function(a,b){return ud(b,this)};f.Gc=function(){return null==this.$a?null:this.$a};Ge.prototype[lb]=function(){return Yc(this)};
function He(a,b){return 0===tb(a)?b:new Ge(a,b,null,null)}function Ie(a,b){a.add(b)}function Je(a){var b=[];for(a=B(a);;)if(null!=a)b.push(E(a)),a=G(a);else return b}function Ke(a,b){if(nd(b))return K(b);var c=0;for(b=B(b);;)if(null!=b&&c<a)c+=1,b=G(b);else return c}
var Le=function Le(a){if(null==a)return null;var c=G(a);return null==c?B(E(a)):ud(E(a),Le.h?Le.h(c):Le.call(null,c))},Me=function Me(a){switch(arguments.length){case 0:return Me.B();case 1:return Me.h(arguments[0]);case 2:return Me.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Me.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};Me.B=function(){return new Be(null,function(){return null},null,null)};
Me.h=function(a){return new Be(null,function(){return a},null,null)};Me.c=function(a,b){return new Be(null,function(){var c=B(a);return c?Td(c)?He(wc(c),Me.c(xc(c),b)):ud(E(c),Me.c(Vc(c),b)):b},null,null)};Me.l=function(a,b,c){return function h(a,b){return new Be(null,function(){var c=B(a);return c?Td(c)?He(wc(c),h(xc(c),b)):ud(E(c),h(Vc(c),b)):t(b)?h(E(b),G(b)):null},null,null)}(Me.c(a,b),c)};Me.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};Me.D=2;
var Ne=function Ne(a){switch(arguments.length){case 0:return Ne.B();case 1:return Ne.h(arguments[0]);case 2:return Ne.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ne.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};Ne.B=function(){return rc(zd)};Ne.h=function(a){return a};Ne.c=function(a,b){return sc(a,b)};Ne.l=function(a,b,c){for(;;)if(a=sc(a,b),t(c))b=E(c),c=G(c);else return a};
Ne.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};Ne.D=2;
function Oe(a,b,c){var d=B(c);if(0===b)return a.B?a.B():a.call(null);c=Cb(d);var e=Db(d);if(1===b)return a.h?a.h(c):a.call(null,c);d=Cb(e);var g=Db(e);if(2===b)return a.c?a.c(c,d):a.call(null,c,d);e=Cb(g);var h=Db(g);if(3===b)return a.j?a.j(c,d,e):a.call(null,c,d,e);g=Cb(h);var l=Db(h);if(4===b)return a.G?a.G(c,d,e,g):a.call(null,c,d,e,g);h=Cb(l);var m=Db(l);if(5===b)return a.J?a.J(c,d,e,g,h):a.call(null,c,d,e,g,h);l=Cb(m);var n=Db(m);if(6===b)return a.fa?a.fa(c,d,e,g,h,l):a.call(null,c,d,e,g,h,l);
m=Cb(n);var r=Db(n);if(7===b)return a.Ca?a.Ca(c,d,e,g,h,l,m):a.call(null,c,d,e,g,h,l,m);n=Cb(r);var v=Db(r);if(8===b)return a.la?a.la(c,d,e,g,h,l,m,n):a.call(null,c,d,e,g,h,l,m,n);r=Cb(v);var x=Db(v);if(9===b)return a.Da?a.Da(c,d,e,g,h,l,m,n,r):a.call(null,c,d,e,g,h,l,m,n,r);v=Cb(x);var y=Db(x);if(10===b)return a.ra?a.ra(c,d,e,g,h,l,m,n,r,v):a.call(null,c,d,e,g,h,l,m,n,r,v);x=Cb(y);var z=Db(y);if(11===b)return a.sa?a.sa(c,d,e,g,h,l,m,n,r,v,x):a.call(null,c,d,e,g,h,l,m,n,r,v,x);y=Cb(z);var C=Db(z);
if(12===b)return a.ta?a.ta(c,d,e,g,h,l,m,n,r,v,x,y):a.call(null,c,d,e,g,h,l,m,n,r,v,x,y);z=Cb(C);var F=Db(C);if(13===b)return a.ua?a.ua(c,d,e,g,h,l,m,n,r,v,x,y,z):a.call(null,c,d,e,g,h,l,m,n,r,v,x,y,z);C=Cb(F);var I=Db(F);if(14===b)return a.va?a.va(c,d,e,g,h,l,m,n,r,v,x,y,z,C):a.call(null,c,d,e,g,h,l,m,n,r,v,x,y,z,C);F=Cb(I);var T=Db(I);if(15===b)return a.wa?a.wa(c,d,e,g,h,l,m,n,r,v,x,y,z,C,F):a.call(null,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F);I=Cb(T);var W=Db(T);if(16===b)return a.xa?a.xa(c,d,e,g,h,l,m,
n,r,v,x,y,z,C,F,I):a.call(null,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I);T=Cb(W);var ea=Db(W);if(17===b)return a.ya?a.ya(c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T):a.call(null,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T);W=Cb(ea);var Ha=Db(ea);if(18===b)return a.za?a.za(c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W):a.call(null,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W);ea=Cb(Ha);Ha=Db(Ha);if(19===b)return a.Aa?a.Aa(c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W,ea):a.call(null,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W,ea);var Q=Cb(Ha);Db(Ha);if(20===b)return a.Ba?
a.Ba(c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W,ea,Q):a.call(null,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W,ea,Q);throw Error("Only up to 20 arguments supported on functions");}function Pe(a){return null!=a&&(a.o&128||k===a.Tb)?a.ia(null):B(Vc(a))}function Qe(a,b,c){return null==c?a.h?a.h(b):a.call(a,b):Re(a,b,Cb(c),Pe(c))}function Re(a,b,c,d){return null==d?a.c?a.c(b,c):a.call(a,b,c):Se(a,b,c,Cb(d),Pe(d))}function Se(a,b,c,d,e){return null==e?a.j?a.j(b,c,d):a.call(a,b,c,d):Te(a,b,c,d,Cb(e),Pe(e))}
function Te(a,b,c,d,e,g){if(null==g)return a.G?a.G(b,c,d,e):a.call(a,b,c,d,e);var h=Cb(g),l=G(g);if(null==l)return a.J?a.J(b,c,d,e,h):a.call(a,b,c,d,e,h);g=Cb(l);var m=G(l);if(null==m)return a.fa?a.fa(b,c,d,e,h,g):a.call(a,b,c,d,e,h,g);l=Cb(m);var n=G(m);if(null==n)return a.Ca?a.Ca(b,c,d,e,h,g,l):a.call(a,b,c,d,e,h,g,l);m=Cb(n);var r=G(n);if(null==r)return a.la?a.la(b,c,d,e,h,g,l,m):a.call(a,b,c,d,e,h,g,l,m);n=Cb(r);var v=G(r);if(null==v)return a.Da?a.Da(b,c,d,e,h,g,l,m,n):a.call(a,b,c,d,e,h,g,l,
m,n);r=Cb(v);var x=G(v);if(null==x)return a.ra?a.ra(b,c,d,e,h,g,l,m,n,r):a.call(a,b,c,d,e,h,g,l,m,n,r);v=Cb(x);var y=G(x);if(null==y)return a.sa?a.sa(b,c,d,e,h,g,l,m,n,r,v):a.call(a,b,c,d,e,h,g,l,m,n,r,v);x=Cb(y);var z=G(y);if(null==z)return a.ta?a.ta(b,c,d,e,h,g,l,m,n,r,v,x):a.call(a,b,c,d,e,h,g,l,m,n,r,v,x);y=Cb(z);var C=G(z);if(null==C)return a.ua?a.ua(b,c,d,e,h,g,l,m,n,r,v,x,y):a.call(a,b,c,d,e,h,g,l,m,n,r,v,x,y);z=Cb(C);var F=G(C);if(null==F)return a.va?a.va(b,c,d,e,h,g,l,m,n,r,v,x,y,z):a.call(a,
b,c,d,e,h,g,l,m,n,r,v,x,y,z);C=Cb(F);var I=G(F);if(null==I)return a.wa?a.wa(b,c,d,e,h,g,l,m,n,r,v,x,y,z,C):a.call(a,b,c,d,e,h,g,l,m,n,r,v,x,y,z,C);F=Cb(I);var T=G(I);if(null==T)return a.xa?a.xa(b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F):a.call(a,b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F);I=Cb(T);var W=G(T);if(null==W)return a.ya?a.ya(b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F,I):a.call(a,b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F,I);T=Cb(W);var ea=G(W);if(null==ea)return a.za?a.za(b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F,I,T):a.call(a,b,c,d,e,h,g,
l,m,n,r,v,x,y,z,C,F,I,T);W=Cb(ea);var Ha=G(ea);if(null==Ha)return a.Aa?a.Aa(b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F,I,T,W):a.call(a,b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F,I,T,W);ea=Cb(Ha);Ha=G(Ha);if(null==Ha)return a.Ba?a.Ba(b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F,I,T,W,ea):a.call(a,b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F,I,T,W,ea);b=[b,c,d,e,h,g,l,m,n,r,v,x,y,z,C,F,I,T,W,ea];for(c=Ha;;)if(c)b.push(Cb(c)),c=G(c);else break;return a.apply(a,b)}
var N=function N(a){switch(arguments.length){case 2:return N.c(arguments[0],arguments[1]);case 3:return N.j(arguments[0],arguments[1],arguments[2]);case 4:return N.G(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return N.J(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return N.l(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],new D(c.slice(5),0,null))}};
N.c=function(a,b){if(a.C){var c=a.D,d=Ke(c+1,b);return d<=c?Oe(a,d,b):a.C(b)}b=B(b);return null==b?a.B?a.B():a.call(a):Qe(a,Cb(b),Pe(b))};N.j=function(a,b,c){if(a.C){b=ud(b,c);var d=a.D;c=Ke(d,c)+1;return c<=d?Oe(a,c,b):a.C(b)}return Qe(a,b,B(c))};N.G=function(a,b,c,d){return a.C?(b=ud(b,ud(c,d)),c=a.D,d=2+Ke(c-1,d),d<=c?Oe(a,d,b):a.C(b)):Re(a,b,c,B(d))};N.J=function(a,b,c,d,e){return a.C?(b=ud(b,ud(c,ud(d,e))),c=a.D,e=3+Ke(c-2,e),e<=c?Oe(a,e,b):a.C(b)):Se(a,b,c,d,B(e))};
N.l=function(a,b,c,d,e,g){return a.C?(g=Le(g),b=ud(b,ud(c,ud(d,ud(e,g)))),c=a.D,g=4+Ke(c-3,g),g<=c?Oe(a,g,b):a.C(b)):Te(a,b,c,d,e,Le(g))};N.C=function(a){var b=E(a),c=G(a);a=E(c);var d=G(c);c=E(d);var e=G(d);d=E(e);var g=G(e);e=E(g);g=G(g);return this.l(b,a,c,d,e,g)};N.D=5;
var Ue=function Ue(a){switch(arguments.length){case 1:return Ue.h(arguments[0]);case 2:return Ue.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ue.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};Ue.h=function(){return!1};Ue.c=function(a,b){return!H.c(a,b)};Ue.l=function(a,b,c){return eb(N.G(H,a,b,c))};Ue.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};Ue.D=2;
function Ve(a){return B(a)?a:null}
function We(){if("undefined"===typeof Qa||"undefined"===typeof Sa||"undefined"===typeof Ta)Ta=function(a){this.Kd=a;this.o=393216;this.I=0},Ta.prototype.T=function(a,b){return new Ta(b)},Ta.prototype.S=function(){return this.Kd},Ta.prototype.ca=function(){return!1},Ta.prototype.next=function(){return Error("No such element")},Ta.prototype.remove=function(){return Error("Unsupported operation")},Ta.Id=function(){return new O(null,1,5,P,[new Sc(null,"meta11185","meta11185",1571633869,null)],null)},
Ta.Kc=!0,Ta.Yb="cljs.core/t_cljs$core11184",Ta.Wc=function(a){return mc(a,"cljs.core/t_cljs$core11184")};return new Ta(Xe)}var Ye={},Ze={};function $e(a){this.Rb=Ye;this.tb=a}$e.prototype.ca=function(){this.Rb===Ye?(this.Rb=Ze,this.tb=B(this.tb)):this.Rb===this.tb&&(this.tb=G(this.Rb));return null!=this.tb};$e.prototype.next=function(){if(this.ca())return this.Rb=this.tb,E(this.tb);throw Error("No such element");};$e.prototype.remove=function(){return Error("Unsupported operation")};
function af(a,b){for(;;){if(null==B(b))return!0;var c=E(b);c=a.h?a.h(c):a.call(null,c);if(t(c))b=G(b);else return!1}}function bf(a,b){for(;;)if(b=B(b)){var c=E(b);c=a.h?a.h(c):a.call(null,c);if(t(c))return c;b=G(b)}else return null}function cf(a){if("number"===typeof a&&!isNaN(a)&&Infinity!==a&&parseFloat(a)===parseInt(a,10))return 0===(a&1);throw Error(["Argument must be an integer: ",u.h(a)].join(""));}
function df(a){return function(){function b(b,c){return eb(a.c?a.c(b,c):a.call(null,b,c))}function c(b){return eb(a.h?a.h(b):a.call(null,b))}function d(){return eb(a.B?a.B():a.call(null))}var e=null,g=function(){function b(a,b,d){var e=null;if(2<arguments.length){e=0;for(var g=Array(arguments.length-2);e<g.length;)g[e]=arguments[e+2],++e;e=new D(g,0,null)}return c.call(this,a,b,e)}function c(b,c,d){return eb(N.G(a,b,c,d))}b.D=2;b.C=function(a){var b=E(a);a=G(a);var d=E(a);a=Vc(a);return c(b,d,a)};
b.l=c;return b}();e=function(a,e,m){switch(arguments.length){case 0:return d.call(this);case 1:return c.call(this,a);case 2:return b.call(this,a,e);default:var h=null;if(2<arguments.length){h=0;for(var l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new D(l,0,null)}return g.l(a,e,h)}throw Error("Invalid arity: "+arguments.length);};e.D=2;e.C=g.C;e.B=d;e.h=c;e.c=b;e.l=g.l;return e}()}
var ef=function ef(a){switch(arguments.length){case 0:return ef.B();case 1:return ef.h(arguments[0]);case 2:return ef.c(arguments[0],arguments[1]);case 3:return ef.j(arguments[0],arguments[1],arguments[2]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return ef.l(arguments[0],arguments[1],arguments[2],new D(c.slice(3),0,null))}};ef.B=function(){return ke};ef.h=function(a){return a};
ef.c=function(a,b){return function(){function c(c,d,e){c=b.j?b.j(c,d,e):b.call(null,c,d,e);return a.h?a.h(c):a.call(null,c)}function d(c,d){c=b.c?b.c(c,d):b.call(null,c,d);return a.h?a.h(c):a.call(null,c)}function e(c){c=b.h?b.h(c):b.call(null,c);return a.h?a.h(c):a.call(null,c)}function g(){var c=b.B?b.B():b.call(null);return a.h?a.h(c):a.call(null,c)}var h=null,l=function(){function c(a,b,c,e){var g=null;if(3<arguments.length){g=0;for(var h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+
3],++g;g=new D(h,0,null)}return d.call(this,a,b,c,g)}function d(c,d,e,g){c=N.J(b,c,d,e,g);return a.h?a.h(c):a.call(null,c)}c.D=3;c.C=function(a){var b=E(a);a=G(a);var c=E(a);a=G(a);var e=E(a);a=Vc(a);return d(b,c,e,a)};c.l=d;return c}();h=function(a,b,h,v){switch(arguments.length){case 0:return g.call(this);case 1:return e.call(this,a);case 2:return d.call(this,a,b);case 3:return c.call(this,a,b,h);default:var m=null;if(3<arguments.length){m=0;for(var n=Array(arguments.length-3);m<n.length;)n[m]=
arguments[m+3],++m;m=new D(n,0,null)}return l.l(a,b,h,m)}throw Error("Invalid arity: "+arguments.length);};h.D=3;h.C=l.C;h.B=g;h.h=e;h.c=d;h.j=c;h.l=l.l;return h}()};
ef.j=function(a,b,c){return function(){function d(d,e,g){d=c.j?c.j(d,e,g):c.call(null,d,e,g);d=b.h?b.h(d):b.call(null,d);return a.h?a.h(d):a.call(null,d)}function e(d,e){d=c.c?c.c(d,e):c.call(null,d,e);d=b.h?b.h(d):b.call(null,d);return a.h?a.h(d):a.call(null,d)}function g(d){d=c.h?c.h(d):c.call(null,d);d=b.h?b.h(d):b.call(null,d);return a.h?a.h(d):a.call(null,d)}function h(){var d=c.B?c.B():c.call(null);d=b.h?b.h(d):b.call(null,d);return a.h?a.h(d):a.call(null,d)}var l=null,m=function(){function d(a,
b,c,d){var g=null;if(3<arguments.length){g=0;for(var h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new D(h,0,null)}return e.call(this,a,b,c,g)}function e(d,e,g,h){d=N.J(c,d,e,g,h);d=b.h?b.h(d):b.call(null,d);return a.h?a.h(d):a.call(null,d)}d.D=3;d.C=function(a){var b=E(a);a=G(a);var c=E(a);a=G(a);var d=E(a);a=Vc(a);return e(b,c,d,a)};d.l=e;return d}();l=function(a,b,c,l){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return e.call(this,
a,b);case 3:return d.call(this,a,b,c);default:var n=null;if(3<arguments.length){n=0;for(var v=Array(arguments.length-3);n<v.length;)v[n]=arguments[n+3],++n;n=new D(v,0,null)}return m.l(a,b,c,n)}throw Error("Invalid arity: "+arguments.length);};l.D=3;l.C=m.C;l.B=h;l.h=g;l.c=e;l.j=d;l.l=m.l;return l}()};
ef.l=function(a,b,c,d){return function(a){return function(){function b(a){var b=null;if(0<arguments.length){b=0;for(var d=Array(arguments.length-0);b<d.length;)d[b]=arguments[b+0],++b;b=new D(d,0,null)}return c.call(this,b)}function c(b){b=N.c(E(a),b);for(var c=G(a);;)if(c){var d=E(c);b=d.h?d.h(b):d.call(null,b);c=G(c)}else return b}b.D=0;b.C=function(a){a=B(a);return c(a)};b.l=c;return b}()}(ue(ud(a,ud(b,ud(c,d)))))};
ef.C=function(a){var b=E(a),c=G(a);a=E(c);var d=G(c);c=E(d);d=G(d);return this.l(b,a,c,d)};ef.D=3;
var gf=function gf(a){switch(arguments.length){case 1:return gf.h(arguments[0]);case 2:return gf.c(arguments[0],arguments[1]);case 3:return gf.j(arguments[0],arguments[1],arguments[2]);case 4:return gf.G(arguments[0],arguments[1],arguments[2],arguments[3]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return gf.l(arguments[0],arguments[1],arguments[2],arguments[3],new D(c.slice(4),0,null))}};gf.h=function(a){return a};
gf.c=function(a,b){return function(){function c(c,d,e){return a.G?a.G(b,c,d,e):a.call(null,b,c,d,e)}function d(c,d){return a.j?a.j(b,c,d):a.call(null,b,c,d)}function e(c){return a.c?a.c(b,c):a.call(null,b,c)}function g(){return a.h?a.h(b):a.call(null,b)}var h=null,l=function(){function c(a,b,c,e){var g=null;if(3<arguments.length){g=0;for(var h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new D(h,0,null)}return d.call(this,a,b,c,g)}function d(c,d,e,g){return N.l(a,b,c,d,e,L([g]))}
c.D=3;c.C=function(a){var b=E(a);a=G(a);var c=E(a);a=G(a);var e=E(a);a=Vc(a);return d(b,c,e,a)};c.l=d;return c}();h=function(a,b,h,v){switch(arguments.length){case 0:return g.call(this);case 1:return e.call(this,a);case 2:return d.call(this,a,b);case 3:return c.call(this,a,b,h);default:var m=null;if(3<arguments.length){m=0;for(var n=Array(arguments.length-3);m<n.length;)n[m]=arguments[m+3],++m;m=new D(n,0,null)}return l.l(a,b,h,m)}throw Error("Invalid arity: "+arguments.length);};h.D=3;h.C=l.C;h.B=
g;h.h=e;h.c=d;h.j=c;h.l=l.l;return h}()};
gf.j=function(a,b,c){return function(){function d(d,e,g){return a.J?a.J(b,c,d,e,g):a.call(null,b,c,d,e,g)}function e(d,e){return a.G?a.G(b,c,d,e):a.call(null,b,c,d,e)}function g(d){return a.j?a.j(b,c,d):a.call(null,b,c,d)}function h(){return a.c?a.c(b,c):a.call(null,b,c)}var l=null,m=function(){function d(a,b,c,d){var g=null;if(3<arguments.length){g=0;for(var h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new D(h,0,null)}return e.call(this,a,b,c,g)}function e(d,e,g,h){return N.l(a,
b,c,d,e,L([g,h]))}d.D=3;d.C=function(a){var b=E(a);a=G(a);var c=E(a);a=G(a);var d=E(a);a=Vc(a);return e(b,c,d,a)};d.l=e;return d}();l=function(a,b,c,l){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return e.call(this,a,b);case 3:return d.call(this,a,b,c);default:var n=null;if(3<arguments.length){n=0;for(var v=Array(arguments.length-3);n<v.length;)v[n]=arguments[n+3],++n;n=new D(v,0,null)}return m.l(a,b,c,n)}throw Error("Invalid arity: "+arguments.length);
};l.D=3;l.C=m.C;l.B=h;l.h=g;l.c=e;l.j=d;l.l=m.l;return l}()};
gf.G=function(a,b,c,d){return function(){function e(e,g,h){return a.fa?a.fa(b,c,d,e,g,h):a.call(null,b,c,d,e,g,h)}function g(e,g){return a.J?a.J(b,c,d,e,g):a.call(null,b,c,d,e,g)}function h(e){return a.G?a.G(b,c,d,e):a.call(null,b,c,d,e)}function l(){return a.j?a.j(b,c,d):a.call(null,b,c,d)}var m=null,n=function(){function e(a,b,c,d){var e=null;if(3<arguments.length){e=0;for(var h=Array(arguments.length-3);e<h.length;)h[e]=arguments[e+3],++e;e=new D(h,0,null)}return g.call(this,a,b,c,e)}function g(e,
g,h,l){return N.l(a,b,c,d,e,L([g,h,l]))}e.D=3;e.C=function(a){var b=E(a);a=G(a);var c=E(a);a=G(a);var d=E(a);a=Vc(a);return g(b,c,d,a)};e.l=g;return e}();m=function(a,b,c,d){switch(arguments.length){case 0:return l.call(this);case 1:return h.call(this,a);case 2:return g.call(this,a,b);case 3:return e.call(this,a,b,c);default:var m=null;if(3<arguments.length){m=0;for(var v=Array(arguments.length-3);m<v.length;)v[m]=arguments[m+3],++m;m=new D(v,0,null)}return n.l(a,b,c,m)}throw Error("Invalid arity: "+
arguments.length);};m.D=3;m.C=n.C;m.B=l;m.h=h;m.c=g;m.j=e;m.l=n.l;return m}()};gf.l=function(a,b,c,d,e){return function(){function g(a){var b=null;if(0<arguments.length){b=0;for(var c=Array(arguments.length-0);b<c.length;)c[b]=arguments[b+0],++b;b=new D(c,0,null)}return h.call(this,b)}function h(g){return N.J(a,b,c,d,Me.c(e,g))}g.D=0;g.C=function(a){a=B(a);return h(a)};g.l=h;return g}()};gf.C=function(a){var b=E(a),c=G(a);a=E(c);var d=G(c);c=E(d);var e=G(d);d=E(e);e=G(e);return this.l(b,a,c,d,e)};
gf.D=4;
function hf(){var a=jf,b=kf;return function(){function c(c,d,e){c=null==c?b:c;return a.j?a.j(c,d,e):a.call(null,c,d,e)}function d(c,d){c=null==c?b:c;return a.c?a.c(c,d):a.call(null,c,d)}function e(c){c=null==c?b:c;return a.h?a.h(c):a.call(null,c)}var g=null,h=function(){function c(a,b,c,e){var g=null;if(3<arguments.length){g=0;for(var h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new D(h,0,null)}return d.call(this,a,b,c,g)}function d(c,d,e,g){return N.J(a,null==c?b:c,d,e,g)}c.D=
3;c.C=function(a){var b=E(a);a=G(a);var c=E(a);a=G(a);var e=E(a);a=Vc(a);return d(b,c,e,a)};c.l=d;return c}();g=function(a,b,g,r){switch(arguments.length){case 1:return e.call(this,a);case 2:return d.call(this,a,b);case 3:return c.call(this,a,b,g);default:var l=null;if(3<arguments.length){l=0;for(var m=Array(arguments.length-3);l<m.length;)m[l]=arguments[l+3],++l;l=new D(m,0,null)}return h.l(a,b,g,l)}throw Error("Invalid arity: "+arguments.length);};g.D=3;g.C=h.C;g.h=e;g.c=d;g.j=c;g.l=h.l;return g}()}
function lf(a,b){return new Be(null,function(){var c=B(b);if(c){if(Td(c)){for(var d=wc(c),e=K(d),g=Fe(e),h=0;;)if(h<e){var l=function(){var b=zb.c(d,h);return a.h?a.h(b):a.call(null,b)}();null!=l&&g.add(l);h+=1}else break;return He(g.ka(),lf(a,xc(c)))}e=function(){var b=E(c);return a.h?a.h(b):a.call(null,b)}();return null==e?lf(a,Vc(c)):ud(e,lf(a,Vc(c)))}return null},null,null)}function mf(a){this.state=a;this.na=this.Bb=this.meta=null;this.I=16386;this.o=6455296}f=mf.prototype;
f.equiv=function(a){return this.H(null,a)};f.H=function(a,b){return this===b};f.jb=function(){return this.state};f.S=function(){return this.meta};f.wc=function(a,b){for(var c=B(this.na),d=null,e=0,g=0;;)if(g<e){var h=d.N(null,g),l=M(h,0,null);h=M(h,1,null);h.G?h.G(l,this,a,b):h.call(null,l,this,a,b);g+=1}else if(c=B(c))Td(c)?(d=wc(c),c=xc(c),l=d,e=K(d),d=l):(d=E(c),l=M(d,0,null),h=M(d,1,null),h.G?h.G(l,this,a,b):h.call(null,l,this,a,b),c=G(c),d=null,e=0),g=0;else break};
f.Wb=function(a,b,c){this.na=Dd.j(this.na,b,c);return this};f.Xb=function(a,b){return this.na=Fd.c(this.na,b)};f.R=function(){return ha(this)};function nf(a){return new mf(a)}function of(a,b){if(a instanceof mf){var c=a.Bb;if(null!=c&&!t(c.h?c.h(b):c.call(null,b)))throw Error("Validator rejected reference state");c=a.state;a.state=b;null!=a.na&&a.wc(c,b);return b}return Ac(a,b)}
var pf=function pf(a){switch(arguments.length){case 2:return pf.c(arguments[0],arguments[1]);case 3:return pf.j(arguments[0],arguments[1],arguments[2]);case 4:return pf.G(arguments[0],arguments[1],arguments[2],arguments[3]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return pf.l(arguments[0],arguments[1],arguments[2],arguments[3],new D(c.slice(4),0,null))}};
pf.c=function(a,b){if(a instanceof mf){var c=a.state;b=b.h?b.h(c):b.call(null,c);a=of(a,b)}else a=Cc.c(a,b);return a};pf.j=function(a,b,c){if(a instanceof mf){var d=a.state;b=b.c?b.c(d,c):b.call(null,d,c);a=of(a,b)}else a=Cc.j(a,b,c);return a};pf.G=function(a,b,c,d){if(a instanceof mf){var e=a.state;b=b.j?b.j(e,c,d):b.call(null,e,c,d);a=of(a,b)}else a=Cc.G(a,b,c,d);return a};pf.l=function(a,b,c,d,e){return a instanceof mf?of(a,N.J(b,a.state,c,d,e)):Cc.J(a,b,c,d,e)};
pf.C=function(a){var b=E(a),c=G(a);a=E(c);var d=G(c);c=E(d);var e=G(d);d=E(e);e=G(e);return this.l(b,a,c,d,e)};pf.D=4;
var qf=function qf(a){switch(arguments.length){case 1:return qf.h(arguments[0]);case 2:return qf.c(arguments[0],arguments[1]);case 3:return qf.j(arguments[0],arguments[1],arguments[2]);case 4:return qf.G(arguments[0],arguments[1],arguments[2],arguments[3]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return qf.l(arguments[0],arguments[1],arguments[2],arguments[3],new D(c.slice(4),0,null))}};
qf.h=function(a){return function(b){return function(){function c(c,d){d=a.h?a.h(d):a.call(null,d);return b.c?b.c(c,d):b.call(null,c,d)}function d(a){return b.h?b.h(a):b.call(null,a)}function e(){return b.B?b.B():b.call(null)}var g=null,h=function(){function c(a,b,c){var e=null;if(2<arguments.length){e=0;for(var g=Array(arguments.length-2);e<g.length;)g[e]=arguments[e+2],++e;e=new D(g,0,null)}return d.call(this,a,b,e)}function d(c,d,e){d=N.j(a,d,e);return b.c?b.c(c,d):b.call(null,c,d)}c.D=2;c.C=function(a){var b=
E(a);a=G(a);var c=E(a);a=Vc(a);return d(b,c,a)};c.l=d;return c}();g=function(a,b,g){switch(arguments.length){case 0:return e.call(this);case 1:return d.call(this,a);case 2:return c.call(this,a,b);default:var l=null;if(2<arguments.length){l=0;for(var m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new D(m,0,null)}return h.l(a,b,l)}throw Error("Invalid arity: "+arguments.length);};g.D=2;g.C=h.C;g.B=e;g.h=d;g.c=c;g.l=h.l;return g}()}};
qf.c=function(a,b){return new Be(null,function(){var c=B(b);if(c){if(Td(c)){for(var d=wc(c),e=K(d),g=Fe(e),h=0;;)if(h<e)Ie(g,function(){var b=zb.c(d,h);return a.h?a.h(b):a.call(null,b)}()),h+=1;else break;return He(g.ka(),qf.c(a,xc(c)))}return ud(function(){var b=E(c);return a.h?a.h(b):a.call(null,b)}(),qf.c(a,Vc(c)))}return null},null,null)};
qf.j=function(a,b,c){return new Be(null,function(){var d=B(b),e=B(c);if(d&&e){var g=E(d);var h=E(e);g=a.c?a.c(g,h):a.call(null,g,h);d=ud(g,qf.j(a,Vc(d),Vc(e)))}else d=null;return d},null,null)};qf.G=function(a,b,c,d){return new Be(null,function(){var e=B(b),g=B(c),h=B(d);if(e&&g&&h){var l=E(e);var m=E(g),n=E(h);l=a.j?a.j(l,m,n):a.call(null,l,m,n);e=ud(l,qf.G(a,Vc(e),Vc(g),Vc(h)))}else e=null;return e},null,null)};
qf.l=function(a,b,c,d,e){var g=function m(a){return new Be(null,function(){var b=qf.c(B,a);return af(ke,b)?ud(qf.c(E,b),m(qf.c(Vc,b))):null},null,null)};return qf.c(function(){return function(b){return N.c(a,b)}}(g),g(yd.l(e,d,L([c,b]))))};qf.C=function(a){var b=E(a),c=G(a);a=E(c);var d=G(c);c=E(d);var e=G(d);d=E(e);e=G(e);return this.l(b,a,c,d,e)};qf.D=4;
function rf(a,b){if("number"!==typeof a)throw Error("Assert failed: (number? n)");return new Be(null,function(){if(0<a){var c=B(b);return c?ud(E(c),rf(a-1,Vc(c))):null}return null},null,null)}function sf(a,b){if("number"!==typeof a)throw Error("Assert failed: (number? n)");return new Be(null,function(c){return function(){return c(a,b)}}(function(a,b){for(;;)if(b=B(b),0<a&&b)--a,b=Vc(b);else return b}),null,null)}function tf(a){return qf.j(function(a){return a},a,sf(2,a))}
function uf(a,b,c,d){this.meta=a;this.count=b;this.K=c;this.next=d;this.F=null;this.o=32374988;this.I=1}f=uf.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,this.count)}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){return null==this.next?1<this.count?this.next=new uf(null,this.count-1,this.K,null):-1===this.count?this:null:this.next};
f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};f.oa=function(a,b){if(-1===this.count)for(var c=b.c?b.c(this.K,this.K):b.call(null,this.K,this.K);;){if(fd(c))return w(c);c=b.c?b.c(c,this.K):b.call(null,c,this.K)}else for(a=1,c=this.K;;)if(a<this.count){c=b.c?b.c(c,this.K):b.call(null,c,this.K);if(fd(c))return w(c);a+=1}else return c};
f.pa=function(a,b,c){if(-1===this.count)for(c=b.c?b.c(c,this.K):b.call(null,c,this.K);;){if(fd(c))return w(c);c=b.c?b.c(c,this.K):b.call(null,c,this.K)}else for(a=0;;)if(a<this.count){c=b.c?b.c(c,this.K):b.call(null,c,this.K);if(fd(c))return w(c);a+=1}else return c};f.ma=function(){return this.K};f.qa=function(){return null==this.next?1<this.count?this.next=new uf(null,this.count-1,this.K,null):-1===this.count?this:Wc:this.next};f.V=function(){return this};
f.T=function(a,b){return b===this.meta?this:new uf(b,this.count,this.K,this.next)};f.$=function(a,b){return ud(b,this)};function vf(a){return 0<a?new uf(null,a,null,null):Wc}var wf=function wf(a){switch(arguments.length){case 0:return wf.B();case 1:return wf.h(arguments[0]);case 2:return wf.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return wf.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};wf.B=function(){return Wc};
wf.h=function(a){return new Be(null,function(){return a},null,null)};wf.c=function(a,b){return new Be(null,function(){var c=B(a),d=B(b);return c&&d?ud(E(c),ud(E(d),wf.c(Vc(c),Vc(d)))):null},null,null)};wf.l=function(a,b,c){return new Be(null,function(){var d=qf.c(B,yd.l(c,b,L([a])));return af(ke,d)?Me.c(qf.c(E,d),N.c(wf,qf.c(Vc,d))):null},null,null)};wf.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};wf.D=2;function xf(a,b){return sf(1,wf.c(new uf(null,-1,a,null),b))}
function yf(a,b){return new Be(null,function(){var c=B(b);if(c){if(Td(c)){for(var d=wc(c),e=K(d),g=Fe(e),h=0;;)if(h<e){var l=zb.c(d,h);l=a.h?a.h(l):a.call(null,l);t(l)&&(l=zb.c(d,h),g.add(l));h+=1}else break;return He(g.ka(),yf(a,xc(c)))}d=E(c);c=Vc(c);return t(a.h?a.h(d):a.call(null,d))?ud(d,yf(a,c)):yf(a,c)}return null},null,null)}function zf(a,b){return yf(df(a),b)}
function Af(a){return function d(a){return new Be(null,function(){if(t(Pd.h?Pd.h(a):Pd.call(null,a))){var c=L([B.h?B.h(a):B.call(null,a)]);c=N.c(Me,N.j(qf,d,c))}else c=null;return ud(a,c)},null,null)}(a)}function Bf(a){return yf(function(a){return!Pd(a)},Vc(Af(a)))}
var jf=function jf(a){switch(arguments.length){case 0:return jf.B();case 1:return jf.h(arguments[0]);case 2:return jf.c(arguments[0],arguments[1]);case 3:return jf.j(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};jf.B=function(){return zd};jf.h=function(a){return a};jf.c=function(a,b){return null!=a?null!=a&&(a.I&4||k===a.od)?Yb(tc(pb(sc,rc(a),b)),Jd(a)):pb(xb,a,b):pb(yd,Wc,b)};
jf.j=function(a,b,c){return null!=a&&(a.I&4||k===a.od)?Yb(tc(le(b,Ne,rc(a),c)),Jd(a)):le(b,yd,a,c)};jf.D=3;function Cf(a){return tc(pb(function(a,c){return Ne.c(a,gd.h?gd.h(c):gd.call(null,c))},rc(zd),a))}function Df(a,b,c){return new Be(null,function(){var d=B(c);if(d){var e=rf(a,d);return a===K(e)?ud(e,Df(a,b,sf(b,d))):null}return null},null,null)}
var Ef=function Ef(a,b,c){b=B(b);var e=E(b),g=G(b);return g?Dd.j(a,e,function(){var b=A.c(a,e);return Ef.j?Ef.j(b,g,c):Ef.call(null,b,g,c)}()):Dd.j(a,e,c)},Ff=function Ff(a){switch(arguments.length){case 3:return Ff.j(arguments[0],arguments[1],arguments[2]);case 4:return Ff.G(arguments[0],arguments[1],arguments[2],arguments[3]);case 5:return Ff.J(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);case 6:return Ff.fa(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);
default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Ff.l(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],new D(c.slice(6),0,null))}};Ff.j=function(a,b,c){b=B(b);var d=E(b);return(b=G(b))?Dd.j(a,d,Ff.j(A.c(a,d),b,c)):Dd.j(a,d,function(){var b=A.c(a,d);return c.h?c.h(b):c.call(null,b)}())};
Ff.G=function(a,b,c,d){b=B(b);var e=E(b);return(b=G(b))?Dd.j(a,e,Ff.G(A.c(a,e),b,c,d)):Dd.j(a,e,function(){var b=A.c(a,e);return c.c?c.c(b,d):c.call(null,b,d)}())};Ff.J=function(a,b,c,d,e){b=B(b);var g=E(b);return(b=G(b))?Dd.j(a,g,Ff.J(A.c(a,g),b,c,d,e)):Dd.j(a,g,function(){var b=A.c(a,g);return c.j?c.j(b,d,e):c.call(null,b,d,e)}())};
Ff.fa=function(a,b,c,d,e,g){b=B(b);var h=E(b);return(b=G(b))?Dd.j(a,h,Ff.fa(A.c(a,h),b,c,d,e,g)):Dd.j(a,h,function(){var b=A.c(a,h);return c.G?c.G(b,d,e,g):c.call(null,b,d,e,g)}())};Ff.l=function(a,b,c,d,e,g,h){var l=B(b);b=E(l);return(l=G(l))?Dd.j(a,b,N.l(Ff,A.c(a,b),l,c,d,L([e,g,h]))):Dd.j(a,b,N.l(c,A.c(a,b),d,e,g,L([h])))};Ff.C=function(a){var b=E(a),c=G(a);a=E(c);var d=G(c);c=E(d);var e=G(d);d=E(e);var g=G(e);e=E(g);var h=G(g);g=E(h);h=G(h);return this.l(b,a,c,d,e,g,h)};Ff.D=6;
function Gf(a,b){var c=Hf;return Dd.j(a,c,function(){var d=A.c(a,c);return b.h?b.h(d):b.call(null,d)}())}function If(a,b){var c=Jf,d=hf();return Dd.j(a,c,function(){var e=A.c(a,c);return d.c?d.c(e,b):d.call(null,e,b)}())}function Kf(a,b){this.W=a;this.m=b}function Lf(a){return new Kf(a,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null])}function Mf(a){return new Kf(a.W,mb(a.m))}
function Nf(a){a=a.A;return 32>a?0:a-1>>>5<<5}function Of(a,b,c){for(;;){if(0===b)return c;var d=Lf(a);d.m[0]=c;c=d;b-=5}}var Pf=function Pf(a,b,c,d){var g=Mf(c),h=a.A-1>>>b&31;5===b?g.m[h]=d:(c=c.m[h],null!=c?(b-=5,a=Pf.G?Pf.G(a,b,c,d):Pf.call(null,a,b,c,d)):a=Of(null,b-5,d),g.m[h]=a);return g};function Qf(a,b){throw Error(["No item ",u.h(a)," in vector of length ",u.h(b)].join(""));}
function Rf(a,b){if(b>=Nf(a))return a.Ha;var c=a.root;for(a=a.shift;;)if(0<a){var d=a-5;c=c.m[b>>>a&31];a=d}else return c.m}var Sf=function Sf(a,b,c,d,e){var h=Mf(c);if(0===b)h.m[d&31]=e;else{var l=d>>>b&31;b-=5;c=c.m[l];a=Sf.J?Sf.J(a,b,c,d,e):Sf.call(null,a,b,c,d,e);h.m[l]=a}return h},Tf=function Tf(a,b,c){var e=a.A-2>>>b&31;if(5<b){b-=5;var g=c.m[e];a=Tf.j?Tf.j(a,b,g):Tf.call(null,a,b,g);if(null==a&&0===e)return null;c=Mf(c);c.m[e]=a;return c}if(0===e)return null;c=Mf(c);c.m[e]=null;return c};
function Uf(a,b,c,d,e,g){this.i=a;this.base=b;this.m=c;this.ja=d;this.start=e;this.end=g}Uf.prototype.ca=function(){return this.i<this.end};Uf.prototype.next=function(){32===this.i-this.base&&(this.m=Rf(this.ja,this.i),this.base+=32);var a=this.m[this.i&31];this.i+=1;return a};function Vf(a,b,c){return new Uf(b,b-b%32,b<K(a)?Rf(a,b):null,a,b,c)}function Wf(a,b,c,d){return c<d?Xf(a,b,pd(a,c),c+1,d):b.B?b.B():b.call(null)}
function Xf(a,b,c,d,e){var g=c;c=d;for(d=Rf(a,d);;)if(c<e){var h=c&31;d=0===h?Rf(a,c):d;h=d[h];g=b.c?b.c(g,h):b.call(null,g,h);if(fd(g))return w(g);c+=1}else return g}function O(a,b,c,d,e,g){this.meta=a;this.A=b;this.shift=c;this.root=d;this.Ha=e;this.F=g;this.o=167666463;this.I=139268}f=O.prototype;f.Gb=function(a,b){return 0<=b&&b<this.A?new Yf(b,Rf(this,b)[b&31]):null};f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.Z=function(a,b){return this.L(null,b,null)};f.L=function(a,b,c){return"number"===typeof b?this.ha(null,b,c):c};
f.Hb=function(a,b,c){a=0;for(var d=c;;)if(a<this.A){var e=Rf(this,a);c=e.length;a:for(var g=0;;)if(g<c){var h=g+a,l=e[g];d=b.j?b.j(d,h,l):b.call(null,d,h,l);if(fd(d)){e=d;break a}g+=1}else{e=d;break a}if(fd(e))return w(e);a+=c;d=e}else return d};f.Ec=k;f.N=function(a,b){return(0<=b&&b<this.A?Rf(this,b):Qf(b,this.A))[b&31]};f.ha=function(a,b,c){return 0<=b&&b<this.A?Rf(this,b)[b&31]:c};
f.xb=function(a,b,c){if(0<=b&&b<this.A)return Nf(this)<=b?(a=mb(this.Ha),a[b&31]=c,new O(this.meta,this.A,this.shift,this.root,a,null)):new O(this.meta,this.A,this.shift,Sf(this,this.shift,this.root,b,c),this.Ha,null);if(b===this.A)return this.$(null,c);throw Error(["Index ",u.h(b)," out of bounds  [0,",u.h(this.A),"]"].join(""));};f.La=function(){return Vf(this,0,this.A)};f.S=function(){return this.meta};f.Y=function(){return this.A};f.vb=function(){return 0<this.A?this.N(null,this.A-1):null};
f.wb=function(){if(0===this.A)throw Error("Can't pop empty vector");if(1===this.A)return Yb(zd,this.meta);if(1<this.A-Nf(this))return new O(this.meta,this.A-1,this.shift,this.root,this.Ha.slice(0,-1),null);var a=Rf(this,this.A-2),b=Tf(this,this.shift,this.root);b=null==b?P:b;var c=this.A-1;return 5<this.shift&&null==b.m[1]?new O(this.meta,c,this.shift-5,b.m[0],a,null):new O(this.meta,c,this.shift,b,a,null)};f.Ub=function(){return 0<this.A?new sd(this,this.A-1,null):null};
f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){if(b instanceof O)if(this.A===K(b))for(a=this.La(null),b=b.La(null);;)if(a.ca()){var c=a.next(),d=b.next();if(!H.c(c,d))return!1}else return!0;else return!1;else return td(this,b)};
f.Fb=function(){var a=this.A,b=this.shift,c=new Kf({},mb(this.root.m)),d=this.Ha,e=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];Ud(d,0,e,0,d.length);return new Zf(a,b,c,e)};f.aa=function(){return Yb(zd,this.meta)};f.oa=function(a,b){return Wf(this,b,0,this.A)};
f.pa=function(a,b,c){a=0;for(var d=c;;)if(a<this.A){var e=Rf(this,a);c=e.length;a:for(var g=0;;)if(g<c){var h=e[g];d=b.c?b.c(d,h):b.call(null,d,h);if(fd(d)){e=d;break a}g+=1}else{e=d;break a}if(fd(e))return w(e);a+=c;d=e}else return d};f.hb=function(a,b,c){if("number"===typeof b)return this.xb(null,b,c);throw Error("Vector's key for assoc must be a number.");};
f.V=function(){if(0===this.A)var a=null;else if(32>=this.A)a=new D(this.Ha,0,null);else{a:{a=this.root;for(var b=this.shift;;)if(0<b)b-=5,a=a.m[0];else{a=a.m;break a}}a=new $f(this,a,0,0,null)}return a};f.T=function(a,b){return b===this.meta?this:new O(b,this.A,this.shift,this.root,this.Ha,this.F)};
f.$=function(a,b){if(32>this.A-Nf(this)){a=this.Ha.length;for(var c=Array(a+1),d=0;;)if(d<a)c[d]=this.Ha[d],d+=1;else break;c[a]=b;return new O(this.meta,this.A+1,this.shift,this.root,c,null)}a=(c=this.A>>>5>1<<this.shift)?this.shift+5:this.shift;c?(c=Lf(null),c.m[0]=this.root,d=Of(null,this.shift,new Kf(null,this.Ha)),c.m[1]=d):c=Pf(this,this.shift,this.root,new Kf(null,this.Ha));return new O(this.meta,this.A+1,a,c,[b],null)};
f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return this.N(null,c);case 3:return this.ha(null,c,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return this.N(null,c)};a.j=function(a,c,d){return this.ha(null,c,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return this.N(null,a)};f.c=function(a,b){return this.ha(null,a,b)};
var P=new Kf(null,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]),zd=new O(null,0,5,P,[],ad);function ag(a){var b=a.length;if(32>b)return new O(null,b,5,P,a,null);for(var c=32,d=(new O(null,32,5,P,a.slice(0,32),null)).Fb(null);;)if(c<b){var e=c+1;d=Ne.c(d,a[c]);c=e}else return tc(d)}O.prototype[lb]=function(){return Yc(this)};
function bg(a){return cg(a)?new O(null,2,5,P,[Mb(a),Nb(a)],null):Sd(a)?Id(a,null):bb(a)?ag(a):tc(pb(sc,rc(zd),a))}var dg=function dg(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return dg.l(0<c.length?new D(c.slice(0),0,null):null)};dg.l=function(a){return a instanceof D&&0===a.i?ag(a.m):bg(a)};dg.D=0;dg.C=function(a){return this.l(B(a))};function $f(a,b,c,d,e){this.Ua=a;this.node=b;this.i=c;this.off=d;this.meta=e;this.F=null;this.o=32375020;this.I=1536}f=$f.prototype;
f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){if(this.off+1<this.node.length){var a=new $f(this.Ua,this.node,this.i,this.off+1,null);return null==a?null:a}return this.Gc()};
f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};f.oa=function(a,b){return Wf(this.Ua,b,this.i+this.off,K(this.Ua))};f.pa=function(a,b,c){return Xf(this.Ua,b,c,this.i+this.off,K(this.Ua))};f.ma=function(){return this.node[this.off]};f.qa=function(){if(this.off+1<this.node.length){var a=new $f(this.Ua,this.node,this.i,this.off+1,null);return null==a?Wc:a}return this.Eb(null)};f.V=function(){return this};
f.nc=function(){var a=this.node;return new Ee(a,this.off,a.length)};f.Eb=function(){var a=this.i+this.node.length;return a<tb(this.Ua)?new $f(this.Ua,Rf(this.Ua,a),a,0,null):Wc};f.T=function(a,b){return b===this.meta?this:new $f(this.Ua,this.node,this.i,this.off,b)};f.$=function(a,b){return ud(b,this)};f.Gc=function(){var a=this.i+this.node.length;return a<tb(this.Ua)?new $f(this.Ua,Rf(this.Ua,a),a,0,null):null};$f.prototype[lb]=function(){return Yc(this)};
function eg(a,b,c,d,e){this.meta=a;this.ja=b;this.start=c;this.end=d;this.F=e;this.o=167666463;this.I=139264}f=eg.prototype;f.Gb=function(a,b){if(0>b)return null;a=this.start+b;return a<this.end?new Yf(b,Hb.c(this.ja,a)):null};f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.Z=function(a,b){return this.L(null,b,null)};f.L=function(a,b,c){return"number"===typeof b?this.ha(null,b,c):c};
f.Hb=function(a,b,c){a=this.start;for(var d=0;;)if(a<this.end){var e=d,g=zb.c(this.ja,a);c=b.j?b.j(c,e,g):b.call(null,c,e,g);if(fd(c))return w(c);d+=1;a+=1}else return c};f.N=function(a,b){return 0>b||this.end<=this.start+b?Qf(b,this.end-this.start):zb.c(this.ja,this.start+b)};f.ha=function(a,b,c){return 0>b||this.end<=this.start+b?c:zb.j(this.ja,this.start+b,c)};
f.xb=function(a,b,c){a=this.start+b;if(0>b||this.end+1<=a)throw Error(["Index ",u.h(b)," out of bounds [0,",u.h(this.Y(null)),"]"].join(""));b=this.meta;c=Dd.j(this.ja,a,c);var d=this.end;a+=1;return fg(b,c,this.start,d>a?d:a,null)};f.La=function(){return null!=this.ja&&k===this.ja.Ec?Vf(this.ja,this.start,this.end):new $e(this)};f.S=function(){return this.meta};f.Y=function(){return this.end-this.start};f.vb=function(){return zb.c(this.ja,this.end-1)};
f.wb=function(){if(this.start===this.end)throw Error("Can't pop empty vector");return fg(this.meta,this.ja,this.start,this.end-1,null)};f.Ub=function(){return this.start!==this.end?new sd(this,this.end-this.start-1,null):null};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Yb(zd,this.meta)};f.oa=function(a,b){return null!=this.ja&&k===this.ja.Ec?Wf(this.ja,b,this.start,this.end):hd(this,b)};
f.pa=function(a,b,c){return null!=this.ja&&k===this.ja.Ec?Xf(this.ja,b,c,this.start,this.end):id(this,b,c)};f.hb=function(a,b,c){if("number"===typeof b)return this.xb(null,b,c);throw Error("Subvec's key for assoc must be a number.");};f.V=function(){var a=this;return function(b){return function e(d){return d===a.end?null:ud(zb.c(a.ja,d),new Be(null,function(){return function(){return e(d+1)}}(b),null,null))}}(this)(a.start)};
f.T=function(a,b){return b===this.meta?this:fg(b,this.ja,this.start,this.end,this.F)};f.$=function(a,b){return fg(this.meta,Tb(this.ja,this.end,b),this.start,this.end+1,null)};f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return this.N(null,c);case 3:return this.ha(null,c,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return this.N(null,c)};a.j=function(a,c,d){return this.ha(null,c,d)};return a}();
f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return this.N(null,a)};f.c=function(a,b){return this.ha(null,a,b)};eg.prototype[lb]=function(){return Yc(this)};function fg(a,b,c,d,e){for(;;)if(b instanceof eg)c=b.start+c,d=b.start+d,b=b.ja;else{if(!Sd(b))throw Error("v must satisfy IVector");var g=K(b);if(0>c||0>d||c>g||d>g)throw Error("Index out of bounds");return new eg(a,b,c,d,e)}}
var gg=function gg(a){switch(arguments.length){case 2:return gg.c(arguments[0],arguments[1]);case 3:return gg.j(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};gg.c=function(a,b){return gg.j(a,b,K(a))};gg.j=function(a,b,c){if(null==b||null==c)throw Error("Assert failed: (and (not (nil? start)) (not (nil? end)))");return fg(null,a,b|0,c|0,null)};gg.D=3;function hg(a,b){return a===b.W?b:new Kf(a,mb(b.m))}
var ig=function ig(a,b,c,d){c=hg(a.root.W,c);var g=a.A-1>>>b&31;if(5===b)a=d;else{var h=c.m[g];null!=h?(b-=5,a=ig.G?ig.G(a,b,h,d):ig.call(null,a,b,h,d)):a=Of(a.root.W,b-5,d)}c.m[g]=a;return c};function Zf(a,b,c,d){this.A=a;this.shift=b;this.root=c;this.Ha=d;this.I=88;this.o=275}f=Zf.prototype;
f.Jb=function(a,b){if(this.root.W){if(32>this.A-Nf(this))this.Ha[this.A&31]=b;else{a=new Kf(this.root.W,this.Ha);var c=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];c[0]=b;this.Ha=c;this.A>>>5>1<<this.shift?(b=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],c=this.shift+
5,b[0]=this.root,b[1]=Of(this.root.W,this.shift,a),this.root=new Kf(this.root.W,b),this.shift=c):this.root=ig(this,this.shift,this.root,a)}this.A+=1;return this}throw Error("conj! after persistent!");};f.Vb=function(){if(this.root.W){this.root.W=null;var a=this.A-Nf(this),b=Array(a);Ud(this.Ha,0,b,0,a);return new O(null,this.A,this.shift,this.root,b,null)}throw Error("persistent! called twice");};
f.Ib=function(a,b,c){if("number"===typeof b)return jg(this,b,c);throw Error("TransientVector's key for assoc! must be a number.");};
function jg(a,b,c){if(a.root.W){if(0<=b&&b<a.A){if(Nf(a)<=b)a.Ha[b&31]=c;else{var d=function(){return function(){return function l(d,h){h=hg(a.root.W,h);if(0===d)h.m[b&31]=c;else{var g=b>>>d&31;d=l(d-5,h.m[g]);h.m[g]=d}return h}}(a)(a.shift,a.root)}();a.root=d}return a}if(b===a.A)return a.Jb(null,c);throw Error(["Index ",u.h(b)," out of bounds for TransientVector of length",u.h(a.A)].join(""));}throw Error("assoc! after persistent!");}
f.Y=function(){if(this.root.W)return this.A;throw Error("count after persistent!");};f.N=function(a,b){if(this.root.W)return(0<=b&&b<this.A?Rf(this,b):Qf(b,this.A))[b&31];throw Error("nth after persistent!");};f.ha=function(a,b,c){return 0<=b&&b<this.A?this.N(null,b):c};f.Z=function(a,b){return this.L(null,b,null)};f.L=function(a,b,c){return"number"===typeof b?this.ha(null,b,c):c};
f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return this.Z(null,c);case 3:return this.L(null,c,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return this.Z(null,c)};a.j=function(a,c,d){return this.L(null,c,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return this.Z(null,a)};f.c=function(a,b){return this.L(null,a,b)};function kg(a,b){this.Nb=a;this.hc=b}
kg.prototype.ca=function(){var a=null!=this.Nb&&B(this.Nb);return a?a:(a=null!=this.hc)?this.hc.ca():a};kg.prototype.next=function(){if(null!=this.Nb){var a=E(this.Nb);this.Nb=G(this.Nb);return a}if(null!=this.hc&&this.hc.ca())return this.hc.next();throw Error("No such element");};kg.prototype.remove=function(){return Error("Unsupported operation")};function lg(a,b,c,d){this.meta=a;this.Ja=b;this.Qa=c;this.F=d;this.o=31850700;this.I=0}f=lg.prototype;f.toString=function(){return Gc(this)};
f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){var a=G(this.Ja);return a?new lg(this.meta,a,this.Qa,null):null!=this.Qa?new lg(this.meta,this.Qa,null,null):null};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};
f.H=function(a,b){return td(this,b)};f.aa=function(){return Yb(Wc,this.meta)};f.ma=function(){return E(this.Ja)};f.qa=function(){var a=G(this.Ja);return a?new lg(this.meta,a,this.Qa,null):null==this.Qa?this.aa(null):new lg(this.meta,this.Qa,null,null)};f.V=function(){return this};f.T=function(a,b){return b===this.meta?this:new lg(b,this.Ja,this.Qa,this.F)};f.$=function(a,b){return ud(b,this)};lg.prototype[lb]=function(){return Yc(this)};
function mg(a,b,c,d,e){this.meta=a;this.count=b;this.Ja=c;this.Qa=d;this.F=e;this.I=139264;this.o=31858766}f=mg.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,this.count.h?this.count.h(this):this.count.call(null,this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.La=function(){return new kg(this.Ja,Ec(this.Qa))};f.S=function(){return this.meta};f.Y=function(){return this.count};f.vb=function(){return E(this.Ja)};
f.wb=function(){if(t(this.Ja)){var a=G(this.Ja);return a?new mg(this.meta,this.count-1,a,this.Qa,null):new mg(this.meta,this.count-1,B(this.Qa),zd,null)}return this};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Yb(ng,this.meta)};f.ma=function(){return E(this.Ja)};f.qa=function(){return Vc(B(this))};f.V=function(){var a=B(this.Qa),b=this.Ja;return t(t(b)?b:a)?new lg(null,this.Ja,B(a),null):null};
f.T=function(a,b){return b===this.meta?this:new mg(b,this.count,this.Ja,this.Qa,this.F)};f.$=function(a,b){t(this.Ja)?(a=this.Qa,b=new mg(this.meta,this.count+1,this.Ja,yd.c(t(a)?a:zd,b),null)):b=new mg(this.meta,this.count+1,yd.c(this.Ja,b),zd,null);return b};var ng=new mg(null,0,null,zd,ad);mg.prototype[lb]=function(){return Yc(this)};function og(){this.o=2097152;this.I=0}og.prototype.equiv=function(a){return this.H(null,a)};og.prototype.H=function(){return!1};var pg=new og;
function qg(a,b){return $d(Qd(b)&&!Rd(b)?K(a)===K(b)?(null!=a?a.o&1048576||k===a.ze||(a.o?0:gb(ac,a)):gb(ac,a))?je(function(a,d,e){return H.c(A.j(b,d,pg),e)?!0:new ed},!0,a):af(function(a){return H.c(A.j(b,E(a),pg),E(G(a)))},a):null:null)}function rg(a,b,c){this.i=0;this.Od=a;this.Oc=4;this.Hd=b;this.Yc=c}rg.prototype.ca=function(){var a=this.i<this.Oc;return a?a:this.Yc.ca()};rg.prototype.next=function(){if(this.i<this.Oc){var a=pd(this.Hd,this.i);this.i+=1;return new Yf(a,Hb.c(this.Od,a))}return this.Yc.next()};
rg.prototype.remove=function(){return Error("Unsupported operation")};function sg(a){this.s=a}sg.prototype.next=function(){if(null!=this.s){var a=E(this.s),b=M(a,0,null);a=M(a,1,null);this.s=G(this.s);return{value:[b,a],done:!1}}return{value:null,done:!0}};function tg(a){this.s=a}tg.prototype.next=function(){if(null!=this.s){var a=E(this.s);this.s=G(this.s);return{value:[a,a],done:!1}}return{value:null,done:!0}};
function ug(a,b){if(b instanceof q)a:{var c=a.length;b=b.U;for(var d=0;;){if(c<=d){a=-1;break a}if(a[d]instanceof q&&b===a[d].U){a=d;break a}d+=2}}else if(ba(b)||"number"===typeof b)a:for(c=a.length,d=0;;){if(c<=d){a=-1;break a}if(b===a[d]){a=d;break a}d+=2}else if(b instanceof Sc)a:for(c=a.length,b=b.sb,d=0;;){if(c<=d){a=-1;break a}if(a[d]instanceof Sc&&b===a[d].sb){a=d;break a}d+=2}else if(null==b)a:for(b=a.length,c=0;;){if(b<=c){a=-1;break a}if(null==a[c]){a=c;break a}c+=2}else a:for(c=a.length,
d=0;;){if(c<=d){a=-1;break a}if(H.c(b,a[d])){a=d;break a}d+=2}return a}function Yf(a,b){this.key=a;this.K=b;this.F=null;this.o=166619935;this.I=0}f=Yf.prototype;f.Gb=function(a,b){switch(b){case 0:return new Yf(0,this.key);case 1:return new Yf(1,this.K);default:return null}};
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.Z=function(a,b){return this.ha(null,b,null)};f.L=function(a,b,c){return this.ha(null,b,c)};f.N=function(a,b){if(0===b)return this.key;if(1===b)return this.K;throw Error("Index out of bounds");};
f.ha=function(a,b,c){return 0===b?this.key:1===b?this.K:c};f.xb=function(a,b,c){return(new O(null,2,5,P,[this.key,this.K],null)).xb(null,b,c)};f.S=function(){return null};f.Y=function(){return 2};f.wd=function(){return this.key};f.xd=function(){return this.K};f.vb=function(){return this.K};f.wb=function(){return new O(null,1,5,P,[this.key],null)};f.Ub=function(){return new D([this.K,this.key],0,null)};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};
f.H=function(a,b){return td(this,b)};f.aa=function(){return null};f.oa=function(a,b){return hd(this,b)};f.pa=function(a,b,c){return id(this,b,c)};f.hb=function(a,b,c){return Dd.j(new O(null,2,5,P,[this.key,this.K],null),b,c)};f.V=function(){return new D([this.key,this.K],0,null)};f.T=function(a,b){return Id(new O(null,2,5,P,[this.key,this.K],null),b)};f.$=function(a,b){return new O(null,3,5,P,[this.key,this.K,b],null)};
f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return this.N(null,c);case 3:return this.ha(null,c,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return this.N(null,c)};a.j=function(a,c,d){return this.ha(null,c,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return this.N(null,a)};f.c=function(a,b){return this.ha(null,a,b)};function cg(a){return null!=a?a.o&2048||k===a.Be?!0:!1:!1}
function vg(a,b,c){this.m=a;this.i=b;this.fb=c;this.o=32374990;this.I=0}f=vg.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.fb};f.ia=function(){return this.i<this.m.length-2?new vg(this.m,this.i+2,null):null};f.Y=function(){return(this.m.length-this.i)/2};f.R=function(){return $c(this)};
f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){return new Yf(this.m[this.i],this.m[this.i+1])};f.qa=function(){return this.i<this.m.length-2?new vg(this.m,this.i+2,null):Wc};f.V=function(){return this};f.T=function(a,b){return b===this.fb?this:new vg(this.m,this.i,b)};f.$=function(a,b){return ud(b,this)};vg.prototype[lb]=function(){return Yc(this)};
function wg(a,b){this.m=a;this.i=0;this.A=b}wg.prototype.ca=function(){return this.i<this.A};wg.prototype.next=function(){var a=new Yf(this.m[this.i],this.m[this.i+1]);this.i+=2;return a};function p(a,b,c,d){this.meta=a;this.A=b;this.m=c;this.F=d;this.o=16647951;this.I=139268}f=p.prototype;f.Gb=function(a,b){a=ug(this.m,b);return-1===a?null:new Yf(this.m[a],this.m[a+1])};f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};f.keys=function(){return Yc(xg(this))};
f.entries=function(){return new sg(B(B(this)))};f.values=function(){return Yc(yg(this))};f.has=function(a){return fe(this,a)};f.get=function(a,b){return this.L(null,a,b)};f.forEach=function(a){for(var b=B(this),c=null,d=0,e=0;;)if(e<d){var g=c.N(null,e),h=M(g,0,null);g=M(g,1,null);a.c?a.c(g,h):a.call(null,g,h);e+=1}else if(b=B(b))Td(b)?(c=wc(b),b=xc(b),h=c,d=K(c),c=h):(c=E(b),h=M(c,0,null),g=M(c,1,null),a.c?a.c(g,h):a.call(null,g,h),b=G(b),c=null,d=0),e=0;else return null};
f.Z=function(a,b){return this.L(null,b,null)};f.L=function(a,b,c){a=ug(this.m,b);return-1===a?c:this.m[a+1]};f.Hb=function(a,b,c){a=this.m.length;for(var d=0;;)if(d<a){var e=this.m[d],g=this.m[d+1];c=b.j?b.j(c,e,g):b.call(null,c,e,g);if(fd(c))return w(c);d+=2}else return c};f.La=function(){return new wg(this.m,2*this.A)};f.S=function(){return this.meta};f.Y=function(){return this.A};f.R=function(){var a=this.F;return null!=a?a:this.F=a=bd(this)};
f.H=function(a,b){if(Qd(b)&&!Rd(b))if(a=this.m.length,this.A===b.Y(null))for(var c=0;;)if(c<a){var d=b.L(null,this.m[c],Vd);if(d!==Vd)if(H.c(this.m[c+1],d))c+=2;else return!1;else return!1}else return!0;else return!1;else return!1};f.Fb=function(){return new zg(this.m.length,mb(this.m))};f.aa=function(){return Yb(Xe,this.meta)};f.oa=function(a,b){return ge(this,b)};f.pa=function(a,b,c){return he(this,b,c)};
f.pc=function(a,b){if(0<=ug(this.m,b)){a=this.m.length;var c=a-2;if(0===c)return this.aa(null);c=Array(c);for(var d=0,e=0;;){if(d>=a)return new p(this.meta,this.A-1,c,null);H.c(b,this.m[d])?d+=2:(c[e]=this.m[d],c[e+1]=this.m[d+1],e+=2,d+=2)}}else return this};
f.hb=function(a,b,c){a=ug(this.m,b);if(-1===a){if(this.A<Ag){a=this.m;for(var d=a.length,e=Array(d+2),g=0;;)if(g<d)e[g]=a[g],g+=1;else break;e[d]=b;e[d+1]=c;return new p(this.meta,this.A+1,e,null)}return Yb(Ib(jf.c(Bg,this),b,c),this.meta)}if(c===this.m[a+1])return this;b=mb(this.m);b[a+1]=c;return new p(this.meta,this.A,b,null)};f.V=function(){var a=this.m;return 0<=a.length-2?new vg(a,0,null):null};f.T=function(a,b){return b===this.meta?this:new p(b,this.A,this.m,this.F)};
f.$=function(a,b){if(Sd(b))return this.hb(null,zb.c(b,0),zb.c(b,1));a=this;for(b=B(b);;){if(null==b)return a;var c=E(b);if(Sd(c))a=Ib(a,zb.c(c,0),zb.c(c,1)),b=G(b);else throw Error("conj on a map takes map entries or seqables of map entries");}};
f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return this.Z(null,c);case 3:return this.L(null,c,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return this.Z(null,c)};a.j=function(a,c,d){return this.L(null,c,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return this.Z(null,a)};f.c=function(a,b){return this.L(null,a,b)};var Xe=new p(null,0,[],cd),Ag=8;
function Ed(a){for(var b=[],c=0;;)if(c<a.length){var d=a[c],e=a[c+1],g=ug(b,d);-1===g?(g=b,g.push(d),g.push(e)):b[g+1]=e;c+=2}else break;return new p(null,b.length/2,b,null)}p.prototype[lb]=function(){return Yc(this)};function zg(a,b){this.Kb={};this.Ob=a;this.m=b;this.o=259;this.I=56}f=zg.prototype;f.Y=function(){if(t(this.Kb))return qe(this.Ob,2);throw Error("count after persistent!");};f.Z=function(a,b){return this.L(null,b,null)};
f.L=function(a,b,c){if(t(this.Kb))return a=ug(this.m,b),-1===a?c:this.m[a+1];throw Error("lookup after persistent!");};f.Jb=function(a,b){if(t(this.Kb)){if(cg(b))return this.Ib(null,Mb(b),Nb(b));if(Sd(b))return this.Ib(null,b.h?b.h(0):b.call(null,0),b.h?b.h(1):b.call(null,1));a=B(b);for(b=this;;){var c=E(a);if(t(c))a=G(a),b=uc(b,Mb(c),Nb(c));else return b}}else throw Error("conj! after persistent!");};
f.Vb=function(){if(t(this.Kb))return this.Kb=!1,new p(null,qe(this.Ob,2),this.m,null);throw Error("persistent! called twice");};f.Ib=function(a,b,c){if(t(this.Kb)){a=ug(this.m,b);if(-1===a){if(this.Ob+2<=2*Ag)return this.Ob+=2,this.m.push(b),this.m.push(c),this;a:{a=this.Ob;for(var d=this.m,e=rc(Bg),g=0;;)if(g<a)e=uc(e,d[g],d[g+1]),g+=2;else break a}return uc(e,b,c)}c!==this.m[a+1]&&(this.m[a+1]=c);return this}throw Error("assoc! after persistent!");};
f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return this.L(null,c,null);case 3:return this.L(null,c,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return this.L(null,c,null)};a.j=function(a,c,d){return this.L(null,c,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return this.L(null,a,null)};f.c=function(a,b){return this.L(null,a,b)};function Cg(){this.K=!1}
function Dg(a,b){return a===b?!0:xe(a,b)?!0:H.c(a,b)}function Eg(a,b,c){a=mb(a);a[b]=c;return a}function Fg(a,b){var c=Array(a.length-2);Ud(a,0,c,0,2*b);Ud(a,2*(b+1),c,2*b,c.length-2*b);return c}function Gg(a,b,c,d){a=a.zb(b);a.m[c]=d;return a}function Hg(a,b,c){for(var d=a.length,e=0,g=c;;)if(e<d){c=a[e];if(null!=c){var h=a[e+1];c=b.j?b.j(g,c,h):b.call(null,g,c,h)}else c=a[e+1],c=null!=c?c.dc(b,g):g;if(fd(c))return c;e+=2;g=c}else return g}function Ig(a){this.m=a;this.i=0;this.ab=this.ec=null}
Ig.prototype.advance=function(){for(var a=this.m.length;;)if(this.i<a){var b=this.m[this.i],c=this.m[this.i+1];null!=b?b=this.ec=new Yf(b,c):null!=c?(b=Ec(c),b=b.ca()?this.ab=b:!1):b=!1;this.i+=2;if(b)return!0}else return!1};Ig.prototype.ca=function(){var a=null!=this.ec;return a?a:(a=null!=this.ab)?a:this.advance()};
Ig.prototype.next=function(){if(null!=this.ec){var a=this.ec;this.ec=null;return a}if(null!=this.ab)return a=this.ab.next(),this.ab.ca()||(this.ab=null),a;if(this.advance())return this.next();throw Error("No such element");};Ig.prototype.remove=function(){return Error("Unsupported operation")};function Jg(a,b,c){this.W=a;this.X=b;this.m=c;this.I=131072;this.o=0}f=Jg.prototype;
f.zb=function(a){if(a===this.W)return this;var b=re(this.X),c=Array(0>b?4:2*(b+1));Ud(this.m,0,c,0,2*b);return new Jg(a,this.X,c)};f.bc=function(){return Kg(this.m,0,null)};f.dc=function(a,b){return Hg(this.m,a,b)};f.Ab=function(a,b,c,d){var e=1<<(b>>>a&31);if(0===(this.X&e))return d;var g=re(this.X&e-1);e=this.m[2*g];g=this.m[2*g+1];return null==e?g.Ab(a+5,b,c,d):Dg(c,e)?g:d};
f.Za=function(a,b,c,d,e,g){var h=1<<(c>>>b&31),l=re(this.X&h-1);if(0===(this.X&h)){var m=re(this.X);if(2*m<this.m.length){a=this.zb(a);b=a.m;g.K=!0;a:for(c=2*(m-l),g=2*l+(c-1),m=2*(l+1)+(c-1);;){if(0===c)break a;b[m]=b[g];--m;--c;--g}b[2*l]=d;b[2*l+1]=e;a.X|=h;return a}if(16<=m){l=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];l[c>>>b&31]=Lg.Za(a,b+5,c,d,e,g);for(e=d=0;;)if(32>d)0===
(this.X>>>d&1)?d+=1:(l[d]=null!=this.m[e]?Lg.Za(a,b+5,Pc(this.m[e]),this.m[e],this.m[e+1],g):this.m[e+1],e+=2,d+=1);else break;return new Mg(a,m+1,l)}b=Array(2*(m+4));Ud(this.m,0,b,0,2*l);b[2*l]=d;b[2*l+1]=e;Ud(this.m,2*l,b,2*(l+1),2*(m-l));g.K=!0;a=this.zb(a);a.m=b;a.X|=h;return a}m=this.m[2*l];h=this.m[2*l+1];if(null==m)return m=h.Za(a,b+5,c,d,e,g),m===h?this:Gg(this,a,2*l+1,m);if(Dg(d,m))return e===h?this:Gg(this,a,2*l+1,e);g.K=!0;g=b+5;b=Pc(m);if(b===c)e=new Ng(null,b,2,[m,h,d,e]);else{var n=
new Cg;e=Lg.Za(a,g,b,m,h,n).Za(a,g,c,d,e,n)}d=2*l;l=2*l+1;a=this.zb(a);a.m[d]=null;a.m[l]=e;return a};
f.Ya=function(a,b,c,d,e){var g=1<<(b>>>a&31),h=re(this.X&g-1);if(0===(this.X&g)){var l=re(this.X);if(16<=l){h=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];h[b>>>a&31]=Lg.Ya(a+5,b,c,d,e);for(d=c=0;;)if(32>c)0===(this.X>>>c&1)?c+=1:(h[c]=null!=this.m[d]?Lg.Ya(a+5,Pc(this.m[d]),this.m[d],this.m[d+1],e):this.m[d+1],d+=2,c+=1);else break;return new Mg(null,l+1,h)}a=Array(2*(l+1));Ud(this.m,
0,a,0,2*h);a[2*h]=c;a[2*h+1]=d;Ud(this.m,2*h,a,2*(h+1),2*(l-h));e.K=!0;return new Jg(null,this.X|g,a)}var m=this.m[2*h];g=this.m[2*h+1];if(null==m)return l=g.Ya(a+5,b,c,d,e),l===g?this:new Jg(null,this.X,Eg(this.m,2*h+1,l));if(Dg(c,m))return d===g?this:new Jg(null,this.X,Eg(this.m,2*h+1,d));e.K=!0;e=this.X;l=this.m;a+=5;var n=Pc(m);if(n===b)c=new Ng(null,n,2,[m,g,c,d]);else{var r=new Cg;c=Lg.Ya(a,n,m,g,r).Ya(a,b,c,d,r)}a=2*h;h=2*h+1;d=mb(l);d[a]=null;d[h]=c;return new Jg(null,e,d)};
f.ac=function(a,b,c,d){var e=1<<(b>>>a&31);if(0===(this.X&e))return d;var g=re(this.X&e-1);e=this.m[2*g];g=this.m[2*g+1];return null==e?g.ac(a+5,b,c,d):Dg(c,e)?new Yf(e,g):d};f.cc=function(a,b,c){var d=1<<(b>>>a&31);if(0===(this.X&d))return this;var e=re(this.X&d-1),g=this.m[2*e],h=this.m[2*e+1];return null==g?(a=h.cc(a+5,b,c),a===h?this:null!=a?new Jg(null,this.X,Eg(this.m,2*e+1,a)):this.X===d?null:new Jg(null,this.X^d,Fg(this.m,e))):Dg(c,g)?new Jg(null,this.X^d,Fg(this.m,e)):this};f.La=function(){return new Ig(this.m)};
var Lg=new Jg(null,0,[]);function Og(a){this.m=a;this.i=0;this.ab=null}Og.prototype.ca=function(){for(var a=this.m.length;;){if(null!=this.ab&&this.ab.ca())return!0;if(this.i<a){var b=this.m[this.i];this.i+=1;null!=b&&(this.ab=Ec(b))}else return!1}};Og.prototype.next=function(){if(this.ca())return this.ab.next();throw Error("No such element");};Og.prototype.remove=function(){return Error("Unsupported operation")};function Mg(a,b,c){this.W=a;this.A=b;this.m=c;this.I=131072;this.o=0}f=Mg.prototype;
f.zb=function(a){return a===this.W?this:new Mg(a,this.A,mb(this.m))};f.bc=function(){return Pg(this.m,0,null)};f.dc=function(a,b){for(var c=this.m.length,d=0;;)if(d<c){var e=this.m[d];if(null!=e){b=e.dc(a,b);if(fd(b))return b;d+=1}else d+=1}else return b};f.Ab=function(a,b,c,d){var e=this.m[b>>>a&31];return null!=e?e.Ab(a+5,b,c,d):d};
f.Za=function(a,b,c,d,e,g){var h=c>>>b&31,l=this.m[h];if(null==l)return a=Gg(this,a,h,Lg.Za(a,b+5,c,d,e,g)),a.A+=1,a;b=l.Za(a,b+5,c,d,e,g);return b===l?this:Gg(this,a,h,b)};f.Ya=function(a,b,c,d,e){var g=b>>>a&31,h=this.m[g];if(null==h)return new Mg(null,this.A+1,Eg(this.m,g,Lg.Ya(a+5,b,c,d,e)));a=h.Ya(a+5,b,c,d,e);return a===h?this:new Mg(null,this.A,Eg(this.m,g,a))};f.ac=function(a,b,c,d){var e=this.m[b>>>a&31];return null!=e?e.ac(a+5,b,c,d):d};
f.cc=function(a,b,c){var d=b>>>a&31,e=this.m[d];if(null!=e){a=e.cc(a+5,b,c);if(a===e)d=this;else if(null==a)if(8>=this.A)a:{e=this.m;a=e.length;b=Array(2*(this.A-1));c=0;for(var g=1,h=0;;)if(c<a)c!==d&&null!=e[c]?(b[g]=e[c],g+=2,h|=1<<c,c+=1):c+=1;else{d=new Jg(null,h,b);break a}}else d=new Mg(null,this.A-1,Eg(this.m,d,a));else d=new Mg(null,this.A,Eg(this.m,d,a));return d}return this};f.La=function(){return new Og(this.m)};
function Qg(a,b,c){b*=2;for(var d=0;;)if(d<b){if(Dg(c,a[d]))return d;d+=2}else return-1}function Ng(a,b,c,d){this.W=a;this.kb=b;this.A=c;this.m=d;this.I=131072;this.o=0}f=Ng.prototype;f.zb=function(a){if(a===this.W)return this;var b=Array(2*(this.A+1));Ud(this.m,0,b,0,2*this.A);return new Ng(a,this.kb,this.A,b)};f.bc=function(){return Kg(this.m,0,null)};f.dc=function(a,b){return Hg(this.m,a,b)};f.Ab=function(a,b,c,d){a=Qg(this.m,this.A,c);return 0>a?d:Dg(c,this.m[a])?this.m[a+1]:d};
f.Za=function(a,b,c,d,e,g){if(c===this.kb){b=Qg(this.m,this.A,d);if(-1===b){if(this.m.length>2*this.A)return b=2*this.A,c=2*this.A+1,a=this.zb(a),a.m[b]=d,a.m[c]=e,g.K=!0,a.A+=1,a;c=this.m.length;b=Array(c+2);Ud(this.m,0,b,0,c);b[c]=d;b[c+1]=e;g.K=!0;d=this.A+1;a===this.W?(this.m=b,this.A=d,a=this):a=new Ng(this.W,this.kb,d,b);return a}return this.m[b+1]===e?this:Gg(this,a,b+1,e)}return(new Jg(a,1<<(this.kb>>>b&31),[null,this,null,null])).Za(a,b,c,d,e,g)};
f.Ya=function(a,b,c,d,e){return b===this.kb?(a=Qg(this.m,this.A,c),-1===a?(a=2*this.A,b=Array(a+2),Ud(this.m,0,b,0,a),b[a]=c,b[a+1]=d,e.K=!0,new Ng(null,this.kb,this.A+1,b)):H.c(this.m[a+1],d)?this:new Ng(null,this.kb,this.A,Eg(this.m,a+1,d))):(new Jg(null,1<<(this.kb>>>a&31),[null,this])).Ya(a,b,c,d,e)};f.ac=function(a,b,c,d){a=Qg(this.m,this.A,c);return 0>a?d:Dg(c,this.m[a])?new Yf(this.m[a],this.m[a+1]):d};
f.cc=function(a,b,c){a=Qg(this.m,this.A,c);return-1===a?this:1===this.A?null:new Ng(null,this.kb,this.A-1,Fg(this.m,qe(a,2)))};f.La=function(){return new Ig(this.m)};function Rg(a,b,c,d,e){this.meta=a;this.bb=b;this.i=c;this.s=d;this.F=e;this.o=32374988;this.I=0}f=Rg.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){return null==this.s?Kg(this.bb,this.i+2,null):Kg(this.bb,this.i,G(this.s))};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};
f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){return null==this.s?new Yf(this.bb[this.i],this.bb[this.i+1]):E(this.s)};f.qa=function(){var a=null==this.s?Kg(this.bb,this.i+2,null):Kg(this.bb,this.i,G(this.s));return null!=a?a:Wc};f.V=function(){return this};f.T=function(a,b){return b===this.meta?this:new Rg(b,this.bb,this.i,this.s,this.F)};f.$=function(a,b){return ud(b,this)};
Rg.prototype[lb]=function(){return Yc(this)};function Kg(a,b,c){if(null==c)for(c=a.length;;)if(b<c){if(null!=a[b])return new Rg(null,a,b,null,null);var d=a[b+1];if(t(d)&&(d=d.bc(),t(d)))return new Rg(null,a,b+2,d,null);b+=2}else return null;else return new Rg(null,a,b,c,null)}function Sg(a,b,c,d,e){this.meta=a;this.bb=b;this.i=c;this.s=d;this.F=e;this.o=32374988;this.I=0}f=Sg.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.meta};f.ia=function(){return Pg(this.bb,this.i,G(this.s))};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};
f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){return E(this.s)};f.qa=function(){var a=Pg(this.bb,this.i,G(this.s));return null!=a?a:Wc};f.V=function(){return this};f.T=function(a,b){return b===this.meta?this:new Sg(b,this.bb,this.i,this.s,this.F)};f.$=function(a,b){return ud(b,this)};Sg.prototype[lb]=function(){return Yc(this)};
function Pg(a,b,c){if(null==c)for(c=a.length;;)if(b<c){var d=a[b];if(t(d)&&(d=d.bc(),t(d)))return new Sg(null,a,b+1,d,null);b+=1}else return null;else return new Sg(null,a,b,c,null)}function Tg(a,b){this.Ea=a;this.fd=b;this.Mc=!1}Tg.prototype.ca=function(){return!this.Mc||this.fd.ca()};Tg.prototype.next=function(){if(this.Mc)return this.fd.next();this.Mc=!0;return new Yf(null,this.Ea)};Tg.prototype.remove=function(){return Error("Unsupported operation")};
function Ug(a,b,c,d,e,g){this.meta=a;this.A=b;this.root=c;this.Ga=d;this.Ea=e;this.F=g;this.o=16123663;this.I=139268}f=Ug.prototype;f.Gb=function(a,b){return null==b?this.Ga?new Yf(null,this.Ea):null:null==this.root?null:this.root.ac(0,Pc(b),b,null)};f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};f.keys=function(){return Yc(xg(this))};f.entries=function(){return new sg(B(B(this)))};f.values=function(){return Yc(yg(this))};f.has=function(a){return fe(this,a)};
f.get=function(a,b){return this.L(null,a,b)};f.forEach=function(a){for(var b=B(this),c=null,d=0,e=0;;)if(e<d){var g=c.N(null,e),h=M(g,0,null);g=M(g,1,null);a.c?a.c(g,h):a.call(null,g,h);e+=1}else if(b=B(b))Td(b)?(c=wc(b),b=xc(b),h=c,d=K(c),c=h):(c=E(b),h=M(c,0,null),g=M(c,1,null),a.c?a.c(g,h):a.call(null,g,h),b=G(b),c=null,d=0),e=0;else return null};f.Z=function(a,b){return this.L(null,b,null)};f.L=function(a,b,c){return null==b?this.Ga?this.Ea:c:null==this.root?c:this.root.Ab(0,Pc(b),b,c)};
f.Hb=function(a,b,c){a=this.Ga?b.j?b.j(c,null,this.Ea):b.call(null,c,null,this.Ea):c;fd(a)?b=w(a):null!=this.root?(b=this.root.dc(b,a),b=fd(b)?w(b):b):b=a;return b};f.La=function(){var a=this.root?Ec(this.root):We();return this.Ga?new Tg(this.Ea,a):a};f.S=function(){return this.meta};f.Y=function(){return this.A};f.R=function(){var a=this.F;return null!=a?a:this.F=a=bd(this)};f.H=function(a,b){return qg(this,b)};f.Fb=function(){return new Vg(this.root,this.A,this.Ga,this.Ea)};
f.aa=function(){return Yb(Bg,this.meta)};f.pc=function(a,b){if(null==b)return this.Ga?new Ug(this.meta,this.A-1,this.root,!1,null,null):this;if(null==this.root)return this;a=this.root.cc(0,Pc(b),b);return a===this.root?this:new Ug(this.meta,this.A-1,a,this.Ga,this.Ea,null)};
f.hb=function(a,b,c){if(null==b)return this.Ga&&c===this.Ea?this:new Ug(this.meta,this.Ga?this.A:this.A+1,this.root,!0,c,null);a=new Cg;b=(null==this.root?Lg:this.root).Ya(0,Pc(b),b,c,a);return b===this.root?this:new Ug(this.meta,a.K?this.A+1:this.A,b,this.Ga,this.Ea,null)};f.V=function(){if(0<this.A){var a=null!=this.root?this.root.bc():null;return this.Ga?ud(new Yf(null,this.Ea),a):a}return null};f.T=function(a,b){return b===this.meta?this:new Ug(b,this.A,this.root,this.Ga,this.Ea,this.F)};
f.$=function(a,b){if(Sd(b))return this.hb(null,zb.c(b,0),zb.c(b,1));a=this;for(b=B(b);;){if(null==b)return a;var c=E(b);if(Sd(c))a=Ib(a,zb.c(c,0),zb.c(c,1)),b=G(b);else throw Error("conj on a map takes map entries or seqables of map entries");}};
f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return this.Z(null,c);case 3:return this.L(null,c,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return this.Z(null,c)};a.j=function(a,c,d){return this.L(null,c,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return this.Z(null,a)};f.c=function(a,b){return this.L(null,a,b)};var Bg=new Ug(null,0,null,!1,null,cd);
function Wg(a,b){for(var c=a.length,d=0,e=rc(Bg);;)if(d<c){var g=d+1;e=uc(e,a[d],b[d]);d=g}else return tc(e)}Ug.prototype[lb]=function(){return Yc(this)};function Vg(a,b,c,d){this.W={};this.root=a;this.count=b;this.Ga=c;this.Ea=d;this.o=259;this.I=56}function Xg(a,b,c){if(a.W){if(null==b)a.Ea!==c&&(a.Ea=c),a.Ga||(a.count+=1,a.Ga=!0);else{var d=new Cg;b=(null==a.root?Lg:a.root).Za(a.W,0,Pc(b),b,c,d);b!==a.root&&(a.root=b);d.K&&(a.count+=1)}return a}throw Error("assoc! after persistent!");}f=Vg.prototype;
f.Y=function(){if(this.W)return this.count;throw Error("count after persistent!");};f.Z=function(a,b){return null==b?this.Ga?this.Ea:null:null==this.root?null:this.root.Ab(0,Pc(b),b)};f.L=function(a,b,c){return null==b?this.Ga?this.Ea:c:null==this.root?c:this.root.Ab(0,Pc(b),b,c)};
f.Jb=function(a,b){a:if(this.W)if(cg(b))a=Xg(this,Mb(b),Nb(b));else if(Sd(b))a=Xg(this,b.h?b.h(0):b.call(null,0),b.h?b.h(1):b.call(null,1));else for(a=B(b),b=this;;){var c=E(a);if(t(c))a=G(a),b=Xg(b,Mb(c),Nb(c));else{a=b;break a}}else throw Error("conj! after persistent");return a};f.Vb=function(){if(this.W){this.W=null;var a=new Ug(null,this.count,this.root,this.Ga,this.Ea,null)}else throw Error("persistent! called twice");return a};f.Ib=function(a,b,c){return Xg(this,b,c)};
f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return this.Z(null,c);case 3:return this.L(null,c,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return this.Z(null,c)};a.j=function(a,c,d){return this.L(null,c,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};f.h=function(a){return this.Z(null,a)};f.c=function(a,b){return this.L(null,a,b)};
var Yg=function Yg(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Yg.l(0<c.length?new D(c.slice(0),0,null):null)};Yg.l=function(a){for(var b=B(a),c=rc(Bg);;)if(b){a=G(G(b));var d=E(b);b=E(G(b));c=uc(c,d,b);b=a}else return tc(c)};Yg.D=0;Yg.C=function(a){return this.l(B(a))};function Zg(a,b){this.O=a;this.fb=b;this.o=32374988;this.I=0}f=Zg.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};
f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.fb};f.ia=function(){var a=(null!=this.O?this.O.o&128||k===this.O.Tb||(this.O.o?0:gb(Eb,this.O)):gb(Eb,this.O))?this.O.ia(null):G(this.O);return null==a?null:new Zg(a,null)};f.R=function(){return $c(this)};
f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){return this.O.ma(null).key};f.qa=function(){var a=(null!=this.O?this.O.o&128||k===this.O.Tb||(this.O.o?0:gb(Eb,this.O)):gb(Eb,this.O))?this.O.ia(null):G(this.O);return null!=a?new Zg(a,null):Wc};f.V=function(){return this};f.T=function(a,b){return b===this.fb?this:new Zg(this.O,b)};f.$=function(a,b){return ud(b,this)};Zg.prototype[lb]=function(){return Yc(this)};
function xg(a){return(a=B(a))?new Zg(a,null):null}function $g(a,b){this.O=a;this.fb=b;this.o=32374988;this.I=0}f=$g.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();f.S=function(){return this.fb};f.ia=function(){var a=(null!=this.O?this.O.o&128||k===this.O.Tb||(this.O.o?0:gb(Eb,this.O)):gb(Eb,this.O))?this.O.ia(null):G(this.O);return null==a?null:new $g(a,null)};f.R=function(){return $c(this)};
f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};f.oa=function(a,b){return vd(b,this)};f.pa=function(a,b,c){return wd(b,c,this)};f.ma=function(){return this.O.ma(null).K};f.qa=function(){var a=(null!=this.O?this.O.o&128||k===this.O.Tb||(this.O.o?0:gb(Eb,this.O)):gb(Eb,this.O))?this.O.ia(null):G(this.O);return null!=a?new $g(a,null):Wc};f.V=function(){return this};f.T=function(a,b){return b===this.fb?this:new $g(this.O,b)};f.$=function(a,b){return ud(b,this)};$g.prototype[lb]=function(){return Yc(this)};
function yg(a){return(a=B(a))?new $g(a,null):null}var ah=function ah(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return ah.l(0<c.length?new D(c.slice(0),0,null):null)};ah.l=function(a){return t(bf(ke,a))?ie(function(a,c){return yd.c(t(a)?a:Xe,c)},a):null};ah.D=0;ah.C=function(a){return this.l(B(a))};
function bh(a,b){var c=Xe;for(b=B(b);;)if(b){var d=E(b),e=A.j(a,d,new q("cljs.core","not-found","cljs.core/not-found",-1572889185));c=Ue.c(e,new q("cljs.core","not-found","cljs.core/not-found",-1572889185))?Dd.j(c,d,e):c;b=G(b)}else return Yb(c,Jd(a))}function ch(a){this.iter=a}ch.prototype.ca=function(){return this.iter.ca()};ch.prototype.next=function(){if(this.iter.ca())return this.iter.next().key;throw Error("No such element");};ch.prototype.remove=function(){return Error("Unsupported operation")};
function dh(a,b,c){this.meta=a;this.mb=b;this.F=c;this.o=15077647;this.I=139268}f=dh.prototype;f.toString=function(){return Gc(this)};f.equiv=function(a){return this.H(null,a)};f.keys=function(){return Yc(B(this))};f.entries=function(){return new tg(B(B(this)))};f.values=function(){return Yc(B(this))};f.has=function(a){return fe(this,a)};
f.forEach=function(a){for(var b=B(this),c=null,d=0,e=0;;)if(e<d){var g=c.N(null,e),h=M(g,0,null);g=M(g,1,null);a.c?a.c(g,h):a.call(null,g,h);e+=1}else if(b=B(b))Td(b)?(c=wc(b),b=xc(b),h=c,d=K(c),c=h):(c=E(b),h=M(c,0,null),g=M(c,1,null),a.c?a.c(g,h):a.call(null,g,h),b=G(b),c=null,d=0),e=0;else return null};f.Z=function(a,b){return this.L(null,b,null)};f.L=function(a,b,c){a=Jb(this.mb,b);return t(a)?Mb(a):c};f.La=function(){return new ch(Ec(this.mb))};f.S=function(){return this.meta};f.Y=function(){return tb(this.mb)};
f.R=function(){var a=this.F;return null!=a?a:this.F=a=bd(this)};f.H=function(a,b){if(a=Od(b)){var c=K(this)===K(b);if(c)try{return je(function(){return function(a,c){return(a=fe(b,c))?a:new ed}}(c,a,this),!0,this.mb)}catch(d){if(d instanceof Error)return!1;throw d;}else return c}else return a};f.Fb=function(){return new eh(rc(this.mb))};f.aa=function(){return Yb(fh,this.meta)};f.Uc=function(a,b){return new dh(this.meta,Lb(this.mb,b),null)};f.V=function(){return xg(this.mb)};
f.T=function(a,b){return b===this.meta?this:new dh(b,this.mb,this.F)};f.$=function(a,b){return new dh(this.meta,Dd.j(this.mb,b,null),null)};f.call=function(){var a=null;a=function(a,c,d){switch(arguments.length){case 2:return this.Z(null,c);case 3:return this.L(null,c,d)}throw Error("Invalid arity: "+(arguments.length-1));};a.c=function(a,c){return this.Z(null,c)};a.j=function(a,c,d){return this.L(null,c,d)};return a}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};
f.h=function(a){return this.Z(null,a)};f.c=function(a,b){return this.L(null,a,b)};var fh=new dh(null,Xe,cd);function gh(a){for(var b=a.length,c=rc(fh),d=0;;)if(d<b)sc(c,a[d]),d+=1;else break;return tc(c)}dh.prototype[lb]=function(){return Yc(this)};function eh(a){this.ob=a;this.I=136;this.o=259}f=eh.prototype;f.Jb=function(a,b){this.ob=uc(this.ob,b,null);return this};f.Vb=function(){return new dh(null,tc(this.ob),null)};f.Y=function(){return K(this.ob)};f.Z=function(a,b){return this.L(null,b,null)};
f.L=function(a,b,c){return Hb.j(this.ob,b,Vd)===Vd?c:b};f.call=function(){function a(a,b,c){return Hb.j(this.ob,b,Vd)===Vd?c:b}function b(a,b){return Hb.j(this.ob,b,Vd)===Vd?null:b}var c=null;c=function(c,e,g){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,g)}throw Error("Invalid arity: "+(arguments.length-1));};c.c=b;c.j=a;return c}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};
f.h=function(a){return Hb.j(this.ob,a,Vd)===Vd?null:a};f.c=function(a,b){return Hb.j(this.ob,a,Vd)===Vd?b:a};function hh(a){if(Od(a))return Id(a,null);a=B(a);if(null==a)return fh;if(a instanceof D&&0===a.i)return gh(a.m);for(var b=rc(fh);;)if(null!=a){var c=G(a);b=sc(b,Cb(a));a=c}else return tc(b)}function ih(a){for(var b=zd;;)if(G(a))b=yd.c(b,E(a)),a=G(a);else return B(b)}
function Ae(a){if(null!=a&&(a.I&4096||k===a.Tc))return yc(a);if("string"===typeof a)return a;throw Error(["Doesn't support name: ",u.h(a)].join(""));}function jh(a,b){var c=rc(Xe);a=B(a);for(b=B(b);;)if(a&&b){var d=E(a),e=E(b);c=uc(c,d,e);a=G(a);b=G(b)}else return tc(c)}
var kh=function kh(a){switch(arguments.length){case 2:return kh.c(arguments[0],arguments[1]);case 3:return kh.j(arguments[0],arguments[1],arguments[2]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return kh.l(arguments[0],arguments[1],arguments[2],new D(c.slice(3),0,null))}};kh.c=function(a,b){return b};kh.j=function(a,b,c){return(a.h?a.h(b):a.call(null,b))>(a.h?a.h(c):a.call(null,c))?b:c};
kh.l=function(a,b,c,d){return pb(function(b,c){return kh.j(a,b,c)},kh.j(a,b,c),d)};kh.C=function(a){var b=E(a),c=G(a);a=E(c);var d=G(c);c=E(d);d=G(d);return this.l(b,a,c,d)};kh.D=3;function lh(a,b,c){this.start=a;this.step=b;this.count=c;this.o=82;this.I=0}f=lh.prototype;f.Y=function(){return this.count};f.ma=function(){return this.start};f.N=function(a,b){return this.start+b*this.step};f.ha=function(a,b,c){return 0<=b&&b<this.count?this.start+b*this.step:c};
f.Fc=function(){if(1>=this.count)throw Error("-drop-first of empty chunk");return new lh(this.start+this.step,this.step,this.count-1)};function mh(a,b,c){this.i=a;this.end=b;this.step=c}mh.prototype.ca=function(){return 0<this.step?this.i<this.end:this.i>this.end};mh.prototype.next=function(){var a=this.i;this.i+=this.step;return a};function oh(a,b,c,d,e,g,h){this.meta=a;this.start=b;this.end=c;this.step=d;this.ka=e;this.lc=g;this.F=h;this.o=32375006;this.I=140800}f=oh.prototype;f.toString=function(){return Gc(this)};
f.equiv=function(a){return this.H(null,a)};f.indexOf=function(){var a=null;a=function(a,c){switch(arguments.length){case 1:return J(this,a,0);case 2:return J(this,a,c)}throw Error("Invalid arity: "+arguments.length);};a.h=function(a){return J(this,a,0)};a.c=function(a,c){return J(this,a,c)};return a}();
f.lastIndexOf=function(){function a(a){return qd(this,a,K(this))}var b=null;b=function(b,d){switch(arguments.length){case 1:return a.call(this,b);case 2:return qd(this,b,d)}throw Error("Invalid arity: "+arguments.length);};b.h=a;b.c=function(a,b){return qd(this,a,b)};return b}();function ph(a){if(null==a.ka){var b=a.Y(null);32<b?(a.lc=new oh(null,a.start+32*a.step,a.end,a.step,null,null,null),a.ka=new lh(a.start,a.step,32)):a.ka=new lh(a.start,a.step,b)}}
f.N=function(a,b){if(0<=b&&b<this.Y(null))return this.start+b*this.step;if(0<=b&&this.start>this.end&&0===this.step)return this.start;throw Error("Index out of bounds");};f.ha=function(a,b,c){return 0<=b&&b<this.Y(null)?this.start+b*this.step:0<=b&&this.start>this.end&&0===this.step?this.start:c};f.La=function(){return new mh(this.start,this.end,this.step)};f.S=function(){return this.meta};
f.ia=function(){return 0<this.step?this.start+this.step<this.end?new oh(null,this.start+this.step,this.end,this.step,null,null,null):null:this.start+this.step>this.end?new oh(null,this.start+this.step,this.end,this.step,null,null,null):null};f.Y=function(){return Math.ceil((this.end-this.start)/this.step)};f.R=function(){var a=this.F;return null!=a?a:this.F=a=$c(this)};f.H=function(a,b){return td(this,b)};f.aa=function(){return Wc};f.oa=function(a,b){return hd(this,b)};
f.pa=function(a,b,c){for(a=this.start;;)if(0<this.step?a<this.end:a>this.end){c=b.c?b.c(c,a):b.call(null,c,a);if(fd(c))return w(c);a+=this.step}else return c};f.ma=function(){return this.start};f.qa=function(){var a=this.ia(null);return null==a?Wc:a};f.V=function(){return this};f.nc=function(){ph(this);return this.ka};f.Eb=function(){ph(this);return null==this.lc?Wc:this.lc};f.T=function(a,b){return b===this.meta?this:new oh(b,this.start,this.end,this.step,this.ka,this.lc,this.F)};
f.$=function(a,b){return ud(b,this)};f.Gc=function(){return B(this.Eb(null))};oh.prototype[lb]=function(){return Yc(this)};function qh(a){return 0>=a?Wc:new oh(null,0,a,1,null,null,null)}function rh(a,b){if("number"!==typeof a)throw Error("Assert failed: (number? n)");return new Be(null,function(){var c=B(b);return c?ud(E(c),rh(a,sf(a,c))):null},null,null)}function sh(a){return tc(pb(function(a,c){var b=A.j(a,c,0)+1;return uc(a,c,b)},rc(Xe),a))}
function th(){var a=Ae;return function(){function b(b,c,d){return new O(null,2,5,P,[ye.j?ye.j(b,c,d):ye.call(null,b,c,d),a.j?a.j(b,c,d):a.call(null,b,c,d)],null)}function c(b,c){return new O(null,2,5,P,[ye.c?ye.c(b,c):ye.call(null,b,c),a.c?a.c(b,c):a.call(null,b,c)],null)}function d(b){return new O(null,2,5,P,[ye.h?ye.h(b):ye.call(null,b),a.h?a.h(b):a.call(null,b)],null)}function e(){return new O(null,2,5,P,[ye.B?ye.B():ye.call(null),a.B?a.B():a.call(null)],null)}var g=null,h=function(){function b(a,
b,d,e){var g=null;if(3<arguments.length){g=0;for(var h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new D(h,0,null)}return c.call(this,a,b,d,g)}function c(b,c,d,e){return new O(null,2,5,P,[N.J(ye,b,c,d,e),N.J(a,b,c,d,e)],null)}b.D=3;b.C=function(a){var b=E(a);a=G(a);var d=E(a);a=G(a);var e=E(a);a=Vc(a);return c(b,d,e,a)};b.l=c;return b}();g=function(a,g,n,r){switch(arguments.length){case 0:return e.call(this);case 1:return d.call(this,a);case 2:return c.call(this,a,g);case 3:return b.call(this,
a,g,n);default:var l=null;if(3<arguments.length){l=0;for(var m=Array(arguments.length-3);l<m.length;)m[l]=arguments[l+3],++l;l=new D(m,0,null)}return h.l(a,g,n,l)}throw Error("Invalid arity: "+arguments.length);};g.D=3;g.C=h.C;g.B=e;g.h=d;g.c=c;g.j=b;g.l=h.l;return g}()}function uh(a){a:for(var b=a;;)if(b=B(b))b=G(b);else break a;return a}
function vh(a,b){if("string"===typeof b)return a=a.exec(b),H.c(E(a),b)?1===K(a)?E(a):bg(a):null;throw new TypeError("re-matches must match against a string.");}function wh(a,b){if("string"===typeof b)return a=a.exec(b),null==a?null:1===K(a)?E(a):bg(a);throw new TypeError("re-find must match against a string.");}
function xh(a,b,c,d,e,g,h){var l=Wa;Wa=null==Wa?null:Wa-1;try{if(null!=Wa&&0>Wa)return mc(a,"#");mc(a,c);if(0===(new q(null,"print-length","print-length",1931866356)).h(g))B(h)&&mc(a,function(){var a=(new q(null,"more-marker","more-marker",-14717935)).h(g);return t(a)?a:"..."}());else{if(B(h)){var m=E(h);b.j?b.j(m,a,g):b.call(null,m,a,g)}for(var n=G(h),r=(new q(null,"print-length","print-length",1931866356)).h(g)-1;;)if(!n||null!=r&&0===r){B(n)&&0===r&&(mc(a,d),mc(a,function(){var a=(new q(null,"more-marker",
"more-marker",-14717935)).h(g);return t(a)?a:"..."}()));break}else{mc(a,d);var v=E(n);c=a;h=g;b.j?b.j(v,c,h):b.call(null,v,c,h);var x=G(n);c=r-1;n=x;r=c}}return mc(a,e)}finally{Wa=l}}function yh(a,b){b=B(b);for(var c=null,d=0,e=0;;)if(e<d){var g=c.N(null,e);mc(a,g);e+=1}else if(b=B(b))c=b,Td(c)?(b=wc(c),d=xc(c),c=b,g=K(b),b=d,d=g):(g=E(c),mc(a,g),b=G(c),c=null,d=0),e=0;else return null}var zh={'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"};
function Ah(a){return['"',u.h(a.replace(/[\\"\b\f\n\r\t]/g,function(a){return zh[a]})),'"'].join("")}function Bh(a,b){return(a=$d(A.c(a,new q(null,"meta","meta",1499536964))))?(a=null!=b?b.o&131072||k===b.Sc?!0:!1:!1)?null!=Jd(b):a:a}
function Ch(a,b,c){if(null==a)return mc(b,"nil");Bh(c,a)&&(mc(b,"^"),Dh(Jd(a),b,c),mc(b," "));if(a.Kc)return a.Wc(b);if(null!=a?a.o&2147483648||k===a.ba||(a.o?0:gb(nc,a)):gb(nc,a))return oc(a,b,c);if(!0===a||!1===a)return mc(b,u.h(a));if("number"===typeof a)return mc(b,isNaN(a)?"##NaN":a===Number.POSITIVE_INFINITY?"##Inf":a===Number.NEGATIVE_INFINITY?"##-Inf":u.h(a));if(null!=a&&a.constructor===Object)return mc(b,"#js "),Eh(qf.c(function(b){return new Yf(null!=vh(/[A-Za-z_\*\+\?!\-'][\w\*\+\?!\-']*/,
b)?ze.h(b):b,a[b])},va(a)),b,c);if(bb(a))return xh(b,Dh,"#js ["," ","]",c,a);if(ba(a))return t((new q(null,"readably","readably",1129599760)).h(c))?mc(b,Ah(a)):mc(b,a);if(fa(a)){var d=a.name;c=t(function(){var a=null==d;return a?a:/^[\s\xa0]*$/.test(d)}())?"Function":d;return yh(b,L(["#object[",c,"","]"]))}if(a instanceof Date)return c=function(a,b){for(a=u.h(a);;)if(K(a)<b)a=["0",a].join("");else return a},yh(b,L(['#inst "',u.h(a.getUTCFullYear()),"-",c(a.getUTCMonth()+1,2),"-",c(a.getUTCDate(),
2),"T",c(a.getUTCHours(),2),":",c(a.getUTCMinutes(),2),":",c(a.getUTCSeconds(),2),".",c(a.getUTCMilliseconds(),3),"-",'00:00"']));if(a instanceof RegExp)return yh(b,L(['#"',a.source,'"']));if(t(function(){var b=null==a?null:a.constructor;return null==b?null:b.Yb}()))return yh(b,L(["#object[",a.constructor.Yb.replace(/\//g,"."),"]"]));d=function(){var b=null==a?null:a.constructor;return null==b?null:b.name}();c=t(function(){var a=null==d;return a?a:/^[\s\xa0]*$/.test(d)}())?"Object":d;return null==
a.constructor?yh(b,L(["#object[",c,"]"])):yh(b,L(["#object[",c," ",u.h(a),"]"]))}function Dh(a,b,c){var d=(new q(null,"alt-impl","alt-impl",670969595)).h(c);return t(d)?(c=Dd.j(c,new q(null,"fallback-impl","fallback-impl",-1501286995),Ch),d.j?d.j(a,b,c):d.call(null,a,b,c)):Ch(a,b,c)}
function Fh(a,b){var c=new Pa;a:{var d=new Fc(c);Dh(E(a),d,b);a=B(G(a));for(var e=null,g=0,h=0;;)if(h<g){var l=e.N(null,h);mc(d," ");Dh(l,d,b);h+=1}else if(a=B(a))e=a,Td(e)?(a=wc(e),g=xc(e),e=a,l=K(a),a=g,g=l):(l=E(e),mc(d," "),Dh(l,d,b),a=G(e),e=null,g=0),h=0;else break a}return c}function Gh(a){var b=Za();return Md(a)?"":u.h(Fh(a,b))}
function Hh(a,b,c,d,e){return xh(d,function(a,b,d){var e=Mb(a);c.j?c.j(e,b,d):c.call(null,e,b,d);mc(b," ");a=Nb(a);return c.j?c.j(a,b,d):c.call(null,a,b,d)},[u.h(a),"{"].join(""),", ","}",e,B(b))}function Eh(a,b,c){var d=Dh,e=(Qd(a),null),g=M(e,0,null);e=M(e,1,null);return t(g)?Hh(["#:",u.h(g)].join(""),e,d,b,c):Hh(null,a,d,b,c)}D.prototype.ba=k;D.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};Be.prototype.ba=k;Be.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};
Yf.prototype.ba=k;Yf.prototype.P=function(a,b,c){return xh(b,Dh,"["," ","]",c,this)};Rg.prototype.ba=k;Rg.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};vg.prototype.ba=k;vg.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};$f.prototype.ba=k;$f.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};we.prototype.ba=k;we.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};sd.prototype.ba=k;
sd.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};Ug.prototype.ba=k;Ug.prototype.P=function(a,b,c){return Eh(this,b,c)};Sg.prototype.ba=k;Sg.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};eg.prototype.ba=k;eg.prototype.P=function(a,b,c){return xh(b,Dh,"["," ","]",c,this)};dh.prototype.ba=k;dh.prototype.P=function(a,b,c){return xh(b,Dh,"#{"," ","}",c,this)};Ge.prototype.ba=k;Ge.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};mf.prototype.ba=k;
mf.prototype.P=function(a,b,c){mc(b,"#object[cljs.core.Atom ");Dh(new p(null,1,[new q(null,"val","val",128701612),this.state],null),b,c);return mc(b,"]")};$g.prototype.ba=k;$g.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};uf.prototype.ba=k;uf.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};O.prototype.ba=k;O.prototype.P=function(a,b,c){return xh(b,Dh,"["," ","]",c,this)};lg.prototype.ba=k;lg.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};
te.prototype.ba=k;te.prototype.P=function(a,b){return mc(b,"()")};mg.prototype.ba=k;mg.prototype.P=function(a,b,c){return xh(b,Dh,"#queue ["," ","]",c,B(this))};p.prototype.ba=k;p.prototype.P=function(a,b,c){return Eh(this,b,c)};oh.prototype.ba=k;oh.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};Zg.prototype.ba=k;Zg.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};Ad.prototype.ba=k;Ad.prototype.P=function(a,b,c){return xh(b,Dh,"("," ",")",c,this)};var Ih=null;
function Jh(a){null==Ih&&(Ih=nf(0));return Tc.h([u.h(a),u.h(pf.c(Ih,dd))].join(""))}function Kh(){}var Lh=function Lh(a){if(null!=a&&null!=a.rd)return a.rd(a);var c=Lh[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=Lh._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IEncodeJS.-clj-\x3ejs",a);},Mh=function Mh(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Mh.l(arguments[0],1<c.length?new D(c.slice(1),0,null):null)};
Mh.l=function(a,b){var c=null!=b&&(b.o&64||k===b.M)?N.c(Yg,b):b,d=A.j(c,new q(null,"keyword-fn","keyword-fn",-64566675),Ae),e=function(){return function(a){var b=g;return(null!=a?k===a.qd||(a.Jc?0:gb(Kh,a)):gb(Kh,a))?Lh(a):"string"===typeof a||"number"===typeof a||a instanceof q||a instanceof Sc?b.h?b.h(a):b.call(null,a):Gh(L([a]))}}(b,c,c,d),g=function(a,b,c,d){return function x(a){if(null==a)return null;if(null!=a?k===a.qd||(a.Jc?0:gb(Kh,a)):gb(Kh,a))return Lh(a);if(a instanceof q)return d.h?d.h(a):
d.call(null,a);if(a instanceof Sc)return u.h(a);if(Qd(a)){var b={};a=B(a);for(var c=null,g=0,h=0;;)if(h<g){var l=c.N(null,h),m=M(l,0,null),n=M(l,1,null);l=b;m=e(m);n=x(n);l[m]=n;h+=1}else if(a=B(a))Td(a)?(g=wc(a),a=xc(a),c=g,g=K(g)):(c=E(a),g=M(c,0,null),h=M(c,1,null),c=b,g=e(g),h=x(h),c[g]=h,a=G(a),c=null,g=0),h=0;else break;return b}if(Nd(a)){b=[];a=B(qf.c(x,a));c=null;for(h=g=0;;)if(h<g)l=c.N(null,h),b.push(l),h+=1;else if(a=B(a))c=a,Td(c)?(a=wc(c),h=xc(c),c=a,g=K(a),a=h):(a=E(c),b.push(a),a=G(c),
c=null,g=0),h=0;else break;return b}return a}}(b,c,c,d);return g(a)};Mh.D=1;Mh.C=function(a){var b=E(a);a=G(a);return this.l(b,a)};var Nh=null;function Oh(){null==Nh&&(Nh=nf(new p(null,3,[new q(null,"parents","parents",-2027538891),Xe,new q(null,"descendants","descendants",1824886031),Xe,new q(null,"ancestors","ancestors",-776045424),Xe],null)));return Nh}
function Ph(a,b,c){var d=H.c(b,c);if(d)return d;d=(new q(null,"ancestors","ancestors",-776045424)).h(a);d=d.h?d.h(b):d.call(null,b);if(!(d=fe(d,c))&&(d=Sd(c)))if(d=Sd(b))if(d=K(c)===K(b)){d=!0;for(var e=0;;)if(d&&e!==K(c))d=Ph(a,b.h?b.h(e):b.call(null,e),c.h?c.h(e):c.call(null,e)),e+=1;else return d}else return d;else return d;else return d}function Qh(a){var b=w(Oh());return Ve(A.c((new q(null,"parents","parents",-2027538891)).h(b),a))}
function Rh(a,b,c,d){pf.c(a,function(){return w(b)});pf.c(c,function(){return w(d)})}
var Sh=function Sh(a,b,c){var e=function(){var b=w(c);return b.h?b.h(a):b.call(null,a)}();e=t(t(e)?e.h?e.h(b):e.call(null,b):e)?!0:null;if(t(e))return e;e=function(){for(var e=Qh(b);;)if(0<K(e)){var h=E(e);Sh.j?Sh.j(a,h,c):Sh.call(null,a,h,c);e=Vc(e)}else return null}();if(t(e))return e;e=function(){for(var e=Qh(a);;)if(0<K(e)){var h=E(e);Sh.j?Sh.j(h,b,c):Sh.call(null,h,b,c);e=Vc(e)}else return null}();return t(e)?e:!1};function Th(a,b,c,d){c=Sh(a,b,c);return t(c)?c:Ph(d,a,b)}
var Uh=function Uh(a,b,c,d,e,g,h,l){var n=pb(function(d,g){var h=M(g,0,null);M(g,1,null);if(Ph(w(c),b,h)&&(d=null==d||Th(h,E(d),e,w(c))?g:d,!Th(E(d),h,e,w(c))))throw Error(["Multiple methods in multimethod '",u.h(a),"' match dispatch value: ",u.h(b)," -\x3e ",u.h(h)," and ",u.h(E(d)),", and neither is preferred"].join(""));return d},null,w(d)),r=function(){var a;if(a=null==n)a=w(d),a=a.h?a.h(l):a.call(null,l);return t(a)?new O(null,2,5,P,[l,a],null):n}();if(t(r)){if(H.c(w(h),w(c)))return pf.G(g,Dd,
b,E(G(r))),E(G(r));Rh(g,d,h,c);return Uh.la?Uh.la(a,b,c,d,e,g,h,l):Uh.call(null,a,b,c,d,e,g,h,l)}return null};function Vh(a,b){throw Error(["No method in multimethod '",u.h(a),"' for dispatch value: ",u.h(b)].join(""));}function Wh(){var a=Tc.c("cljs.tools.reader.impl.inspect","inspect*"),b=Xh,c=Yh,d=Zh,e=$h,g=ai,h=bi,l=ci;this.name=a;this.w=h;this.Gd=l;this.yc=b;this.Ac=c;this.Nd=d;this.zc=e;this.kc=g;this.o=4194305;this.I=4352}f=Wh.prototype;
f.call=function(){function a(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W,Q,ea){a=this;var X=N.l(a.w,b,c,d,e,L([g,h,l,m,n,v,r,x,y,z,F,C,I,T,W,Q,ea])),Y=di(this,X);t(Y)||Vh(a.name,X);return N.l(Y,b,c,d,e,L([g,h,l,m,n,v,r,x,y,z,F,C,I,T,W,Q,ea]))}function b(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W,Q){a=this;var X=a.w.Ba?a.w.Ba(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W,Q):a.w.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W,Q),Y=di(this,X);t(Y)||Vh(a.name,X);return Y.Ba?Y.Ba(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,
W,Q):Y.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W,Q)}function c(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W){a=this;var X=a.w.Aa?a.w.Aa(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W):a.w.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W),Y=di(this,X);t(Y)||Vh(a.name,X);return Y.Aa?Y.Aa(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W):Y.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T,W)}function d(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T){a=this;var Y=a.w.za?a.w.za(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T):a.w.call(null,b,c,d,
e,g,h,l,m,n,v,r,x,y,z,F,C,I,T),X=di(this,Y);t(X)||Vh(a.name,Y);return X.za?X.za(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T):X.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I,T)}function e(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I){a=this;var X=a.w.ya?a.w.ya(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I):a.w.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I),Y=di(this,X);t(Y)||Vh(a.name,X);return Y.ya?Y.ya(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I):Y.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C,I)}function g(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C){a=
this;var Y=a.w.xa?a.w.xa(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C):a.w.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C),X=di(this,Y);t(X)||Vh(a.name,Y);return X.xa?X.xa(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C):X.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F,C)}function h(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F){a=this;var Y=a.w.wa?a.w.wa(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F):a.w.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F),X=di(this,Y);t(X)||Vh(a.name,Y);return X.wa?X.wa(b,c,d,e,g,h,l,m,n,v,r,x,y,z,F):X.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z,F)}
function l(a,b,c,d,e,g,h,l,m,n,v,r,x,y,z){a=this;var F=a.w.va?a.w.va(b,c,d,e,g,h,l,m,n,v,r,x,y,z):a.w.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z),Y=di(this,F);t(Y)||Vh(a.name,F);return Y.va?Y.va(b,c,d,e,g,h,l,m,n,v,r,x,y,z):Y.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y,z)}function m(a,b,c,d,e,g,h,l,m,n,v,r,x,y){a=this;var z=a.w.ua?a.w.ua(b,c,d,e,g,h,l,m,n,v,r,x,y):a.w.call(null,b,c,d,e,g,h,l,m,n,v,r,x,y),F=di(this,z);t(F)||Vh(a.name,z);return F.ua?F.ua(b,c,d,e,g,h,l,m,n,v,r,x,y):F.call(null,b,c,d,e,g,h,l,m,n,
v,r,x,y)}function n(a,b,c,d,e,g,h,l,m,n,v,r,x){a=this;var y=a.w.ta?a.w.ta(b,c,d,e,g,h,l,m,n,v,r,x):a.w.call(null,b,c,d,e,g,h,l,m,n,v,r,x),z=di(this,y);t(z)||Vh(a.name,y);return z.ta?z.ta(b,c,d,e,g,h,l,m,n,v,r,x):z.call(null,b,c,d,e,g,h,l,m,n,v,r,x)}function r(a,b,c,d,e,g,h,l,m,n,v,r){a=this;var x=a.w.sa?a.w.sa(b,c,d,e,g,h,l,m,n,v,r):a.w.call(null,b,c,d,e,g,h,l,m,n,v,r),y=di(this,x);t(y)||Vh(a.name,x);return y.sa?y.sa(b,c,d,e,g,h,l,m,n,v,r):y.call(null,b,c,d,e,g,h,l,m,n,v,r)}function v(a,b,c,d,e,g,
h,l,m,n,v){a=this;var r=a.w.ra?a.w.ra(b,c,d,e,g,h,l,m,n,v):a.w.call(null,b,c,d,e,g,h,l,m,n,v),x=di(this,r);t(x)||Vh(a.name,r);return x.ra?x.ra(b,c,d,e,g,h,l,m,n,v):x.call(null,b,c,d,e,g,h,l,m,n,v)}function x(a,b,c,d,e,g,h,l,m,n){a=this;var v=a.w.Da?a.w.Da(b,c,d,e,g,h,l,m,n):a.w.call(null,b,c,d,e,g,h,l,m,n),r=di(this,v);t(r)||Vh(a.name,v);return r.Da?r.Da(b,c,d,e,g,h,l,m,n):r.call(null,b,c,d,e,g,h,l,m,n)}function y(a,b,c,d,e,g,h,l,m){a=this;var n=a.w.la?a.w.la(b,c,d,e,g,h,l,m):a.w.call(null,b,c,d,
e,g,h,l,m),v=di(this,n);t(v)||Vh(a.name,n);return v.la?v.la(b,c,d,e,g,h,l,m):v.call(null,b,c,d,e,g,h,l,m)}function z(a,b,c,d,e,g,h,l){a=this;var m=a.w.Ca?a.w.Ca(b,c,d,e,g,h,l):a.w.call(null,b,c,d,e,g,h,l),n=di(this,m);t(n)||Vh(a.name,m);return n.Ca?n.Ca(b,c,d,e,g,h,l):n.call(null,b,c,d,e,g,h,l)}function C(a,b,c,d,e,g,h){a=this;var l=a.w.fa?a.w.fa(b,c,d,e,g,h):a.w.call(null,b,c,d,e,g,h),m=di(this,l);t(m)||Vh(a.name,l);return m.fa?m.fa(b,c,d,e,g,h):m.call(null,b,c,d,e,g,h)}function F(a,b,c,d,e,g){a=
this;var h=a.w.J?a.w.J(b,c,d,e,g):a.w.call(null,b,c,d,e,g),l=di(this,h);t(l)||Vh(a.name,h);return l.J?l.J(b,c,d,e,g):l.call(null,b,c,d,e,g)}function I(a,b,c,d,e){a=this;var g=a.w.G?a.w.G(b,c,d,e):a.w.call(null,b,c,d,e),h=di(this,g);t(h)||Vh(a.name,g);return h.G?h.G(b,c,d,e):h.call(null,b,c,d,e)}function T(a,b,c,d){a=this;var e=a.w.j?a.w.j(b,c,d):a.w.call(null,b,c,d),g=di(this,e);t(g)||Vh(a.name,e);return g.j?g.j(b,c,d):g.call(null,b,c,d)}function W(a,b,c){a=this;var d=a.w.c?a.w.c(b,c):a.w.call(null,
b,c),e=di(this,d);t(e)||Vh(a.name,d);return e.c?e.c(b,c):e.call(null,b,c)}function ea(a,b){a=this;var c=a.w.h?a.w.h(b):a.w.call(null,b),d=di(this,c);t(d)||Vh(a.name,c);return d.h?d.h(b):d.call(null,b)}function Ha(a){a=this;var b=a.w.B?a.w.B():a.w.call(null),c=di(this,b);t(c)||Vh(a.name,b);return c.B?c.B():c.call(null)}var Q=null;Q=function(X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Yd,Wb,lc,Bc,md,Zd,ff,nh,Jk){switch(arguments.length){case 1:return Ha.call(this,X);case 2:return ea.call(this,X,Y);case 3:return W.call(this,
X,Y,qa);case 4:return T.call(this,X,Y,qa,Q);case 5:return I.call(this,X,Y,qa,Q,Aa);case 6:return F.call(this,X,Y,qa,Q,Aa,Ka);case 7:return C.call(this,X,Y,qa,Q,Aa,Ka,La);case 8:return z.call(this,X,Y,qa,Q,Aa,Ka,La,Oa);case 9:return y.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra);case 10:return x.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya);case 11:return v.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db);case 12:return r.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob);case 13:return n.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,
Bb);case 14:return m.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Yd);case 15:return l.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Yd,Wb);case 16:return h.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Yd,Wb,lc);case 17:return g.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Yd,Wb,lc,Bc);case 18:return e.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Yd,Wb,lc,Bc,md);case 19:return d.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Yd,Wb,lc,Bc,md,Zd);case 20:return c.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,
Ya,db,ob,Bb,Yd,Wb,lc,Bc,md,Zd,ff);case 21:return b.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Yd,Wb,lc,Bc,md,Zd,ff,nh);case 22:return a.call(this,X,Y,qa,Q,Aa,Ka,La,Oa,Ra,Ya,db,ob,Bb,Yd,Wb,lc,Bc,md,Zd,ff,nh,Jk)}throw Error("Invalid arity: "+(arguments.length-1));};Q.h=Ha;Q.c=ea;Q.j=W;Q.G=T;Q.J=I;Q.fa=F;Q.Ca=C;Q.la=z;Q.Da=y;Q.ra=x;Q.sa=v;Q.ta=r;Q.ua=n;Q.va=m;Q.wa=l;Q.xa=h;Q.ya=g;Q.za=e;Q.Aa=d;Q.Ba=c;Q.Hc=b;Q.sd=a;return Q}();f.apply=function(a,b){return this.call.apply(this,[this].concat(mb(b)))};
f.B=function(){var a=this.w.B?this.w.B():this.w.call(null),b=di(this,a);t(b)||Vh(this.name,a);return b.B?b.B():b.call(null)};f.h=function(a){var b=this.w.h?this.w.h(a):this.w.call(null,a),c=di(this,b);t(c)||Vh(this.name,b);return c.h?c.h(a):c.call(null,a)};f.c=function(a,b){var c=this.w.c?this.w.c(a,b):this.w.call(null,a,b),d=di(this,c);t(d)||Vh(this.name,c);return d.c?d.c(a,b):d.call(null,a,b)};
f.j=function(a,b,c){var d=this.w.j?this.w.j(a,b,c):this.w.call(null,a,b,c),e=di(this,d);t(e)||Vh(this.name,d);return e.j?e.j(a,b,c):e.call(null,a,b,c)};f.G=function(a,b,c,d){var e=this.w.G?this.w.G(a,b,c,d):this.w.call(null,a,b,c,d),g=di(this,e);t(g)||Vh(this.name,e);return g.G?g.G(a,b,c,d):g.call(null,a,b,c,d)};f.J=function(a,b,c,d,e){var g=this.w.J?this.w.J(a,b,c,d,e):this.w.call(null,a,b,c,d,e),h=di(this,g);t(h)||Vh(this.name,g);return h.J?h.J(a,b,c,d,e):h.call(null,a,b,c,d,e)};
f.fa=function(a,b,c,d,e,g){var h=this.w.fa?this.w.fa(a,b,c,d,e,g):this.w.call(null,a,b,c,d,e,g),l=di(this,h);t(l)||Vh(this.name,h);return l.fa?l.fa(a,b,c,d,e,g):l.call(null,a,b,c,d,e,g)};f.Ca=function(a,b,c,d,e,g,h){var l=this.w.Ca?this.w.Ca(a,b,c,d,e,g,h):this.w.call(null,a,b,c,d,e,g,h),m=di(this,l);t(m)||Vh(this.name,l);return m.Ca?m.Ca(a,b,c,d,e,g,h):m.call(null,a,b,c,d,e,g,h)};
f.la=function(a,b,c,d,e,g,h,l){var m=this.w.la?this.w.la(a,b,c,d,e,g,h,l):this.w.call(null,a,b,c,d,e,g,h,l),n=di(this,m);t(n)||Vh(this.name,m);return n.la?n.la(a,b,c,d,e,g,h,l):n.call(null,a,b,c,d,e,g,h,l)};f.Da=function(a,b,c,d,e,g,h,l,m){var n=this.w.Da?this.w.Da(a,b,c,d,e,g,h,l,m):this.w.call(null,a,b,c,d,e,g,h,l,m),r=di(this,n);t(r)||Vh(this.name,n);return r.Da?r.Da(a,b,c,d,e,g,h,l,m):r.call(null,a,b,c,d,e,g,h,l,m)};
f.ra=function(a,b,c,d,e,g,h,l,m,n){var r=this.w.ra?this.w.ra(a,b,c,d,e,g,h,l,m,n):this.w.call(null,a,b,c,d,e,g,h,l,m,n),v=di(this,r);t(v)||Vh(this.name,r);return v.ra?v.ra(a,b,c,d,e,g,h,l,m,n):v.call(null,a,b,c,d,e,g,h,l,m,n)};f.sa=function(a,b,c,d,e,g,h,l,m,n,r){var v=this.w.sa?this.w.sa(a,b,c,d,e,g,h,l,m,n,r):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r),x=di(this,v);t(x)||Vh(this.name,v);return x.sa?x.sa(a,b,c,d,e,g,h,l,m,n,r):x.call(null,a,b,c,d,e,g,h,l,m,n,r)};
f.ta=function(a,b,c,d,e,g,h,l,m,n,r,v){var x=this.w.ta?this.w.ta(a,b,c,d,e,g,h,l,m,n,r,v):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r,v),y=di(this,x);t(y)||Vh(this.name,x);return y.ta?y.ta(a,b,c,d,e,g,h,l,m,n,r,v):y.call(null,a,b,c,d,e,g,h,l,m,n,r,v)};f.ua=function(a,b,c,d,e,g,h,l,m,n,r,v,x){var y=this.w.ua?this.w.ua(a,b,c,d,e,g,h,l,m,n,r,v,x):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x),z=di(this,y);t(z)||Vh(this.name,y);return z.ua?z.ua(a,b,c,d,e,g,h,l,m,n,r,v,x):z.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x)};
f.va=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y){var z=this.w.va?this.w.va(a,b,c,d,e,g,h,l,m,n,r,v,x,y):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y),C=di(this,z);t(C)||Vh(this.name,z);return C.va?C.va(a,b,c,d,e,g,h,l,m,n,r,v,x,y):C.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y)};
f.wa=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z){var C=this.w.wa?this.w.wa(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z),F=di(this,C);t(F)||Vh(this.name,C);return F.wa?F.wa(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z):F.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z)};
f.xa=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C){var F=this.w.xa?this.w.xa(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C),I=di(this,F);t(I)||Vh(this.name,F);return I.xa?I.xa(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C):I.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C)};
f.ya=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F){var I=this.w.ya?this.w.ya(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F),T=di(this,I);t(T)||Vh(this.name,I);return T.ya?T.ya(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F):T.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F)};
f.za=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I){var T=this.w.za?this.w.za(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I),W=di(this,T);t(W)||Vh(this.name,T);return W.za?W.za(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I):W.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I)};
f.Aa=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T){var W=this.w.Aa?this.w.Aa(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T),ea=di(this,W);t(ea)||Vh(this.name,W);return ea.Aa?ea.Aa(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T):ea.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T)};
f.Ba=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W){var ea=this.w.Ba?this.w.Ba(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W):this.w.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W),Ha=di(this,ea);t(Ha)||Vh(this.name,ea);return Ha.Ba?Ha.Ba(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W):Ha.call(null,a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W)};
f.Hc=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W,ea){var Ha=N.l(this.w,a,b,c,d,L([e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W,ea])),Q=di(this,Ha);t(Q)||Vh(this.name,Ha);return N.l(Q,a,b,c,d,L([e,g,h,l,m,n,r,v,x,y,z,C,F,I,T,W,ea]))};function ei(a,b){var c=fi;pf.G(c.Ac,Dd,a,b);Rh(c.zc,c.Ac,c.kc,c.yc)}function di(a,b){H.c(w(a.kc),w(a.yc))||Rh(a.zc,a.Ac,a.kc,a.yc);var c=w(a.zc);c=c.h?c.h(b):c.call(null,b);return t(c)?c:Uh(a.name,b,a.yc,a.Ac,a.Nd,a.zc,a.kc,a.Gd)}f.qc=function(){return yc(this.name)};f.rc=function(){return zc(this.name)};
f.R=function(){return ha(this)};function gi(a){this.jc=a;this.F=null;this.o=2153775104;this.I=2048}f=gi.prototype;f.toString=function(){return this.jc};f.equiv=function(a){return this.H(null,a)};f.H=function(a,b){return b instanceof gi&&this.jc===b.jc};f.P=function(a,b){return mc(b,['#uuid "',u.h(this.jc),'"'].join(""))};f.R=function(){null==this.F&&(this.F=Pc(this.jc));return this.F};
function hi(a,b,c){var d=Error(a);this.message=a;this.data=b;this.Pc=c;this.name=d.name;this.description=d.description;this.number=d.number;this.fileName=d.fileName;this.lineNumber=d.lineNumber;this.columnNumber=d.columnNumber;this.stack=d.stack;return this}hi.prototype.__proto__=Error.prototype;hi.prototype.ba=k;
hi.prototype.P=function(a,b,c){mc(b,"#error {:message ");Dh(this.message,b,c);t(this.data)&&(mc(b,", :data "),Dh(this.data,b,c));t(this.Pc)&&(mc(b,", :cause "),Dh(this.Pc,b,c));return mc(b,"}")};hi.prototype.toString=function(){return Gc(this)};function ii(a,b){return new hi(a,b,null)}if("undefined"===typeof Qa||"undefined"===typeof Sa||"undefined"===typeof ji)var ji=null;"undefined"!==typeof console&&$a();
if("undefined"===typeof Qa||"undefined"===typeof Sa||"undefined"===typeof ki)var ki=function(){throw Error("cljs.core/*eval* not bound");};var li=new q(null,"cm-options","cm-options",-1418884096),mi=new q(null,"transform-style","transform-style",-1887177696),ni=new q(null,"y","y",-1757859776),oi=new q(null,"border-image","border-image",-230471616),pi=new q(null,"above-left","above-left",-1593975744),qi=new q(null,"on-key-down-capture","on-key-down-capture",-1395197888),ri=new q(null,"mm","mm",-1652850560),si=new q(null,"border-image-slice","border-image-slice",-4957056),ti=new q(null,"role","role",-736691072),ui=new q("replete.events",
"initialize-db","replete.events/initialize-db",697826432),vi=new q(null,"above-center","above-center",1960103104),wi=new q(null,"fr","fr",1577713888),xi=new Sc(null,"localTimeParser","localTimeParser",-1738135328,null),yi=new q(null,"args","args",1315556576),zi=new q(null,"rel","rel",1378823488),Ai=new q(null,"border-style","border-style",-485574304),R=new q(null,"description","description",-1428560544),Bi=new q(null,"text-anchor","text-anchor",585613696),Ci=new q(null,"large","large",-196820544),
Di=new q(null,"on-composition-end","on-composition-end",581757376),Ei=new q(null,"on-drop-capture","on-drop-capture",1615153632),Fi=new q(null,"line-height","line-height",1870784992),Gi=new q(null,"divisor","divisor",-25029120),Hi=new q(null,"unnamed","unnamed",-26044928),Ii=new q(null,"on-drag-exit","on-drag-exit",2762272),Ji=new Sc(null,"uuid","uuid",-504564192,null),Ki=new q(null,"text-rendering","text-rendering",872518208),Li=new q(null,"on-suspend","on-suspend",-740218304),Mi=new q(null,"min-width",
"min-width",1926193728),Ni=new q(null,"current-form","current-form",1889534560),Oi=new q(null,"font-style","font-style",-773672352),Pi=new q(null,"spread-method","spread-method",-1720392096),Qi=new q(null,"block-size","block-size",-1062272384),Ri=new q(null,"splitter-size","splitter-size",245247616),Si=new q(null,"date-element-parser","date-element-parser",2072167040),Ti=new q(null,"auto-complete","auto-complete",244958848),Ui=new q(null,"reversed","reversed",-286659968),Vi=new q(null,"inline-size",
"inline-size",-2060171616),Wi=new q(null,"add-event","add-event",938429088),Xi=new q(null,"animation-delay","animation-delay",-488570176),Yi=new q(null,"on-can-play-capture","on-can-play-capture",-754836736),Zi=new q(null,"restore-item","restore-item",-522170560),$i=new q(null,"hour-minute","hour-minute",-1164421312),aj=new q(null,"open","open",-1763596448),bj=new q(null,"vmin","vmin",446546816),cj=new q(null,"focusable","focusable",1031236480),dj=new q(null,"ex-kind","ex-kind",1581199296),ej=new q(null,
"baseline","baseline",1151033280),fj=new q(null,"transition-delay","transition-delay",-235557887),gj=new q(null,"mask","mask",-585748447),hj=new q(null,"yield","yield",177875009),ij=new q(null,"image-rendering","image-rendering",770251905),jj=new q(null,"tab-index","tab-index",895755393),kj=new q(null,"stroke-dasharray","stroke-dasharray",-942933855),lj=new q(null,"image-orientation","image-orientation",614962369),mj=new q(null,"strikethrough-thickness","strikethrough-thickness",2087500993),nj=new q(null,
"async","async",1050769601),oj=new q(null,"mask-size","mask-size",-1707013919),pj=new q(null,"accumulate","accumulate",-887744287),qj=new q(null,"lineWrapping","lineWrapping",1248501985),rj=new q(null,"border-top-style","border-top-style",-668961567),sj=new q(null,"box-decoration-break","box-decoration-break",-566185727),tj=new q(null,"on-input-capture","on-input-capture",2039664929),uj=new q(null,"x-height","x-height",1735436609),vj=new q(null,"popover-color","popover-color",-2019049119),wj=new q(null,
"attribute-name","attribute-name",463128929),xj=new q(null,"on-play-capture","on-play-capture",1664522657),yj=new q(null,"exponent","exponent",2083463617),zj=new q(null,"mask-type","mask-type",-1876682271),Aj=new q(null,"on-key-press-capture","on-key-press-capture",1439709729),Bj=new q(null,"on-rate-change-capture","on-rate-change-capture",1461353025),Cj=new q(null,"bbox","bbox",678077025),Dj=new q(null,"color-rendering","color-rendering",-891830687),Ej=new q(null,"box-sizing","box-sizing",-1956090239),
Fj=new q(null,"font-variant-numeric","font-variant-numeric",-749791),Gj=new q(null,"reader-error","reader-error",1610253121),Hj=new q(null,"paused","paused",-1710376127),Ij=new q(null,"min","min",444991522),Jj=new q(null,"mask-units","mask-units",1670452290),Kj=new q(null,"fill-rule","fill-rule",-1824841598),Lj=new q(null,"on-set","on-set",-140953470),Mj=new q(null,"down","down",1565245570),Nj=new q(null,"on-blur-capture","on-blur-capture",2031809666),Oj=new q(null,"xlink-role","xlink-role",2044836002),
Pj=new q(null,"font-stretch","font-stretch",-1432788830),Qj=new q(null,"gradient-transform","gradient-transform",-1737815870),Rj=new q(null,"text-decoration-style","text-decoration-style",1254269122),Sj=new q(null,"-webkit-flex-basis","-webkit-flex-basis",1359112386),Tj=new q(null,"mask-composite","mask-composite",128478402),Uj=new q(null,"radio-group","radio-group",1791520002),Vj=new q(null,"format","format",-1306924766),Wj=new q(null,"hanging","hanging",1618688322),Xj=new q(null,"children","children",
-940561982),Yj=new q(null,"t-time","t-time",-42016318),Zj=new Sc(null,"timeParser","timeParser",1585048034,null),ak=new q(null,"border-block-end","border-block-end",-2082909662),bk=new q(null,"align-items","align-items",-267946462),ck=new q(null,"align","align",1964212802),dk=new q(null,"key-bindings","key-bindings",-1464217982),ek=new q(null,"regular","regular",-1153375582),fk=new q(null,"basic-ordinal-date","basic-ordinal-date",243220162),gk=new q(null,"sizes","sizes",-273528126),hk=new q(null,
"inherit","inherit",-1840815422),ik=new q(null,"left-center","left-center",374119202),jk=new q(null,"rx","rx",1627208482),kk=new q(null,"date","date",-1463434462),lk=new q(null,"hour","hour",-555989214),mk=new q(null,"content-style-type","content-style-type",238503778),nk=new q(null,"padding-inline-end","padding-inline-end",-647416958),ok=new q(null,"r","r",-471384190),pk=new q(null,"object-fit","object-fit",-429593694),qk=new q(null,"text-overflow","text-overflow",-1022366814),rk=new q(null,"on-touch-cancel",
"on-touch-cancel",1125389250),sk=new q(null,"position-offset","position-offset",1257061411),tk=new q(null,"will-change","will-change",-152752061),uk=new q(null,"on-split-change","on-split-change",-1635241917),vk=new q(null,"on-key-press","on-key-press",-399563677),wk=new q(null,"timezone","timezone",1831928099),xk=new q(null,"outline-offset","outline-offset",1155254595),yk=new q(null,"max-length","max-length",-254826109),zk=new q(null,"cljsLegacyRender","cljsLegacyRender",-1527295613),Ak=new q(null,
"on-composition-start","on-composition-start",-1518620253),Bk=new q(null,"vector-effect","vector-effect",-616736349),Ck=new q(null,"right-below","right-below",586981827),Dk=new q(null,"align-content","align-content",-990200349),Ek=new q(null,"bk-color","bk-color",2004848163),Fk=new q(null,"stroke","stroke",1741823555),Gk=new q(null,"arrow-length","arrow-length",934916707),Hk=new q(null,"stop-color","stop-color",316173955),Ik=new q(null,"stitch-tiles","stitch-tiles",1351704227),Kk=new q(null,"time-no-ms",
"time-no-ms",870271683),Lk=new q(null,"grid-column-end","grid-column-end",592662211),Mk=new q(null,"weekyear-week-day","weekyear-week-day",-740233533),Nk=new q(null,"overrides","overrides",1738628867),Ok=new q(null,"horizontal","horizontal",2062109475),Pk=new q(null,"pt","pt",556460867),Qk=new q(null,"idle","idle",-2007156861),Rk=new q(null,"on-load-capture","on-load-capture",166061955),Sk=new q(null,"box-shadow","box-shadow",1600206755),Tk=new q(null,"on-mouse-enter","on-mouse-enter",-1664921661),
Uk=new q(null,"clip","clip",830998499),Vk=new q(null,"wrap","wrap",851669987),Wk=new q(null,"padding-block-start","padding-block-start",1054404612),Xk=new q(null,"glyph-orientation-horizontal","glyph-orientation-horizontal",436217892),Yk=new q(null,"on-emptied","on-emptied",757015652),Zk=new q(null,"max-height","max-height",-612563804),$k=new q(null,"cm-opts","cm-opts",-794223420),al=new q(null,"offset-block-end","offset-block-end",1207635172),bl=new q(null,"week-date-time","week-date-time",540228836),
cl=new q(null,"isolation","isolation",-1230029596),dl=new q(null,"border-right","border-right",-668932860),el=new q(null,"date-hour-minute-second-fraction","date-hour-minute-second-fraction",1937143076),fl=new q(null,"elevation","elevation",-1609348796),gl=new q(null,"marker-width","marker-width",-1086737020),hl=new q(null,"restart","restart",-1779883612),il=new q(null,"_margin","_margin",1508241828),jl=new q(null,"on-drag-over-capture","on-drag-over-capture",552548804),ll=new q(null,"text-transform",
"text-transform",1685000676),ml=new q(null,"intercept","intercept",-2141938204),nl=new q(null,"namespaced-map","namespaced-map",1235665380),ol=new q(null,"transform","transform",1381301764),pl=new q(null,"group","group",582596132),ql=new q(null,"border-inline-end-style","border-inline-end-style",60342820),rl=new q(null,"target-x","target-x",-1562024412),sl=new q(null,"border-bottom-style","border-bottom-style",925668932),tl=new q(null,"meta","meta",1499536964),ul=new q(null,"grid-template","grid-template",
-268181948),vl=new q(null,"selected","selected",574897764),wl=new q("replete.subs","clear-input-form","replete.subs/clear-input-form",-1064857980),xl=new q(null,"animation","animation",-1248293244),yl=new q(null,"dx","dx",-381796732),zl=new q(null,"basic-date-time","basic-date-time",1525413604),Al=new q(null,"date-time","date-time",177938180),Bl=new q(null,"basic-time-no-ms","basic-time-no-ms",-1720654076),Cl=new q(null,"relative-path","relative-path",1848635172),Dl=new q(null,"column-count","column-count",
1235131236),El=new q(null,"-webkit-align-content","-webkit-align-content",246986596),Fl=new q(null,"required-extensions","required-extensions",1193231204),Gl=new q(null,"on-seeked-capture","on-seeked-capture",-1414283356),Hl=new q(null,"on-double-click-capture","on-double-click-capture",-28858331),Il=new q(null,"color","color",1011675173),Jl=new q(null,"list-style-position","list-style-position",-335344571),Kl=new q(null,"margin-inline-end","margin-inline-end",-1696808891),Ll=new q(null,"preserve-aspect-ratio",
"preserve-aspect-ratio",-1746347963),Ml=new q(null,"-webkit-align-self","-webkit-align-self",-34524059),Nl=new q(null,"date-parser","date-parser",-981534587),Ol=new q(null,"on-scroll","on-scroll",1590848677),Pl=new Sc(null,"blockable","blockable",-28395259,null),Ql=new q(null,"text-align","text-align",1786091845),Rl=new q(null,"vertical-align","vertical-align",651007333),Sl=new q(null,"on-can-play-through-capture","on-can-play-through-capture",350920037),Tl=new q(null,"dir","dir",1734754661),Ul=new q(null,
"ref-x","ref-x",155306341),Vl=new q(null,"basic-week-date","basic-week-date",1775847845),Wl=new q(null,"tab-size","tab-size",-1265790523),Xl=new q(null,"min-length","min-length",-325792315),Yl=new q(null,"min-height","min-height",398480837),Zl=new q(null,"font-language-override","font-language-override",-1059219899),$l=new q(null,"backdrop-opacity","backdrop-opacity",1467395653),am=new q(null,"on-composition-update","on-composition-update",-337521083),bm=new q(null,"page-break-inside","page-break-inside",
-1878278555),cm=new q(null,"ruby-merge","ruby-merge",1832161925),dm=new q(null,"grid-auto-position","grid-auto-position",-1160742267),em=new q(null,"key","key",-1516042587),fm=new q(null,"pattern-transform","pattern-transform",1169361573),gm=new q("eval","form","eval/form",-1627220315),hm=new q(null,"muted","muted",1275109029),im=new q(null,"on-abort","on-abort",-1364844795),jm=new q(null,"fsm-state","fsm-state",1656310533),km=new q(null,"windows","windows",2068861701),lm=new q(null,"border-left-width",
"border-left-width",2037218085),mm=new q(null,"amplitude","amplitude",-1387734203),nm=new q(null,"validated-args","validated-args",278814533),om=new q(null,"seamless","seamless",-1120344251),pm=new q(null,"left-offset","left-offset",-331155643),qm=new q(null,"on-pause-capture","on-pause-capture",-92370043),rm=new q(null,"placeholder","placeholder",-104873083),sm=new q(null,"-ms-user-select","-ms-user-select",953709445),tm=new q(null,"bottom","bottom",-1550509018),um=new q(null,"disabled","disabled",
-1529784218),vm=new q("replete.events","history-next","replete.events/history-next",-1773984442),wm=new q(null,"reader-exception","reader-exception",-1938323098),xm=new Sc(null,"dateOptionalTimeParser","dateOptionalTimeParser",1783230854,null),ym=new q(null,"_width","_width",-75982426),zm=new q("replete.events","eval-result","replete.events/eval-result",-1560562202),Am=new q(null,"line-break","line-break",908969510),Bm=new q(null,"outline-style","outline-style",227043878),Cm=new q(null,"mask-repeat",
"mask-repeat",939485734),Dm=new q(null,"is","is",369128998),Em=new q(null,"x-channel-selector","x-channel-selector",-1025939898),Fm=new q(null,"smaller","smaller",-1619801498),Gm=new q(null,"eval-codemirror","eval-codemirror",-34079130),Hm=new q(null,"white-space","white-space",-707351930),Im=new q(null,"text-emphasis-position","text-emphasis-position",-100647290),Jm=new q(null,"basic-t-time-no-ms","basic-t-time-no-ms",-424650106),Km=new q(null,"eval-result","eval-result",937286342),Lm=new q(null,
"local-time","local-time",-1873195290),Mm=new q(null,"font-size","font-size",-1847940346),Nm=new q(null,"macosx","macosx",-1369181402),Om=new q(null,"on-rate-change","on-rate-change",1741929286),Pm=new q(null,"\x3c-","\x3c-",760412998),Qm=new q("replete.events","eval-codemirror","replete.events/eval-codemirror",1530280838),Rm=new q(null,"alt","alt",-3214426),Sm=new q(null,"_on-split-change","_on-split-change",1230437286),Tm=new q(null,"cell-padding","cell-padding",978029542),Um=new q(null,"scroll-snap-type",
"scroll-snap-type",-850828249),Vm=new q(null,"transition","transition",765692007),Wm=new q(null,"offset","offset",296498311),Xm=new q(null,"date-time-no-ms","date-time-no-ms",1655953671),Ym=new q(null,"speed","speed",1257663751),Zm=new q(null,"stemv","stemv",-157426393),$m=new q(null,"scale","scale",-230427353),an=new q(null,"year-month-day","year-month-day",-415594169),bn=new q(null,"clojure","clojure",438975815),cn=new q(null,"animation-direction","animation-direction",-362912441),dn=new q(null,
"button","button",1456579943),en=new q(null,"kerning","kerning",702175623),fn=new q(null,"top","top",-1856271961),gn=new q(null,"xlink-title","xlink-title",811720103),hn=new q(null,"clip-path-units","clip-path-units",1978916263),jn=new q(null,"level3","level3",1192475079),kn=new q(null,"db","db",993250759),ln=new q(null,"on-loaded-data","on-loaded-data",1855185351),mn=new q(null,"fx-handler","fx-handler",-549783097),nn=new q(null,"sub","sub",-2093760025),on=new q(null,"font-variant","font-variant",
1251503591),pn=new q(null,"writing-mode","writing-mode",-1707110905),qn=new q(null,"r-border","r-border",610773511),rn=new q(null,"font-weight","font-weight",2085804583),sn=new q(null,"frame-border","frame-border",-1868748185),tn=new q(null,"offset-inline-end","offset-inline-end",1318051431),un=new q(null,"date-opt-time","date-opt-time",-1507102105),vn=new q("re-frame.std-interceptors","not-found","re-frame.std-interceptors/not-found",-1614827865),Jf=new q(null,"queue","queue",1455835879),wn=new q(null,
"displayName","displayName",-809144601),xn=new q(null,"on-composition-end-capture","on-composition-end-capture",-1471972633),yn=new q(null,"-webkit-flex-grow","-webkit-flex-grow",949294887),zn=new q(null,"content-editable","content-editable",636764967),An=new q(null,"rfc822","rfc822",-404628697),Bn=new q(null,"on-mouse-out","on-mouse-out",643448647),Cn=new q(null,"result-gap","result-gap",1343464295),Dn=new q(null,"validator","validator",-1966190681),En=new q(null,"repeat-dur","repeat-dur",-366990361),
Fn=new q(null,"coords","coords",-599429112),Gn=new q(null,"method","method",55703592),Hn=new q(null,"table-values","table-values",-1257377720),In=new q(null,"justify","justify",-722524056),Jn=new q(null,"content","content",15833224),Kn=new q(null,"margin-width","margin-width",-1252353816),ci=new q(null,"default","default",-1987822328),Ln=new q(null,"max-block-size","max-block-size",-1751985816),Mn=new q(null,"on-focus","on-focus",-13737624),Nn=new q(null,"u1","u1",-1841624632),On=new q(null,"on-playing",
"on-playing",1378487752),Pn=new q(null,"sequential","sequential",-1082983960),Qn=new q(null,"float","float",-1732389368),Rn=new q(null,"access-key","access-key",914744840),Sn=new q(null,"border-right-style","border-right-style",-1606013368),Tn=new q(null,"border-top-right-radius","border-top-right-radius",1678770792),Un=new q(null,"grid-gap","grid-gap",1083581064),Vn=new q(null,"font-variant-ligatures","font-variant-ligatures",-181253464),Wn=new q(null,"overflow","overflow",2058931880),Xn=new q(null,
"ns","ns",441598760),Yn=new q(null,"grid","grid",402978600),Zn=new q(null,"on-stalled","on-stalled",1480279880),$n=new q(null,"on-composition-update-capture","on-composition-update-capture",432836456),ao=new q(null,"symbol","symbol",-1038572696),bo=new q(null,"warn","warn",-436710552),co=new q(null,"strong","strong",269529E3),eo=new q(null,"position-injected","position-injected",205959080),fo=new q(null,"columns","columns",1998437288),go=new q(null,"shape-outside","shape-outside",-830371896),ho=new q(null,
"popover","popover",-1809582136),io=new q(null,"marker-units","marker-units",-1919701016),jo=new q(null,"-moz-user-select","-moz-user-select",-342302744),ko=new q(null,"ideographic","ideographic",-335748120),lo=new q(null,"specular-exponent","specular-exponent",373200905),mo=new q(null,"date-hour-minute-second-ms","date-hour-minute-second-ms",-425334775),S=new q(null,"name","name",1843675177),no=new q(null,"no-clip?","no-clip?",-188884951),oo=new q(null,"padding-block-end","padding-block-end",923602025),
po=new q(null,"clip-rule","clip-rule",335492201),qo=new q(null,"on-mouse-enter-capture","on-mouse-enter-capture",-862465943),ro=new q(null,"panose1","panose1",1116592233),so=new q(null,"on-composition-start-capture","on-composition-start-capture",357266537),to=new q(null,"close-button?","close-button?",-1030817687),uo=new q(null,"required-args","required-args",1225806985),vo=new q(null,"basic-ordinal-date-time","basic-ordinal-date-time",1054564521),wo=new Sc(null,"NaN","NaN",666918153,null),xo=new q(null,
"on-mouse-down-capture","on-mouse-down-capture",1176660233),yo=new Sc(null,"timeElementParser","timeElementParser",302132553,null),zo=new q(null,"ordinal-date","ordinal-date",-77899447),Ao=new q(null,"backface-visibility","backface-visibility",-367721111),Bo=new q(null,"mix-blend-mode","mix-blend-mode",-1150163607),Co=new q(null,"on-progress-capture","on-progress-capture",-283565687),Do=new q(null,"arrow-width","arrow-width",1926673833),Eo=new q(null,"xlink-href","xlink-href",244956585),Fo=new q(null,
"hour-minute-second-fraction","hour-minute-second-fraction",-1253038551),Go=new q(null,"stroke-opacity","stroke-opacity",-1191543159),Ho=new q(null,"min-inline-size","min-inline-size",-2050841943),Io=new q(null,"horiz-origin-x","horiz-origin-x",1522984617),Jo=new q(null,"hyphens","hyphens",2113533609),Ko=new q(null,"form-action","form-action",-1436001591),Lo=new q(null,"fill","fill",883462889),Mo=new q(null,"break-inside","break-inside",310021897),No=new q(null,"border-block-end-width","border-block-end-width",
-1045470455),Oo=new q(null,"margin-left","margin-left",2015598377),Po=new q(null,"text-decoration-line","text-decoration-line",1905751849),Qo=new q(null,"surface-scale","surface-scale",1674847049),Ro=new q("replete.events","history-prev","replete.events/history-prev",76925801),So=new q(null,"value","value",305978217),To=new q(null,"left-above","left-above",1205957481),Uo=new q(null,"mask-image","mask-image",-1593213047),Vo=new q(null,"border-left-color","border-left-color",-1166146583),Wo=new q(null,
"date-hour-minute","date-hour-minute",1629918346),Xo=new q(null,"time","time",1385887882),Yo=new q(null,"level2","level2",-2044031830),Zo=new q(null,"list-style","list-style",-809622358),$o=new q(null,"-webkit-flex-flow","-webkit-flex-flow",667076810),ap=new q(null,"optimum","optimum",292484362),bp=new q(null,"-webkit-flex-wrap","-webkit-flex-wrap",-628183766),cp=new q(null,"margin-block-end","margin-block-end",-1287470806),dp=new q(null,"list-style-type","list-style-type",-1703248598),ep=new q(null,
"ref-y","ref-y",-1766645430),fp=new q(null,"maximum","maximum",573880714),gp=new q(null,"scroll-snap-coordinate","scroll-snap-coordinate",703792554),hp=new q(null,"-webkit-user-select","-webkit-user-select",-651687510),ip=new q(null,"color-profile","color-profile",1755323818),jp=new q(null,"component-did-mount","component-did-mount",-1126910518),kp=new q(null,"file","file",-1269645878),lp=new q(null,"vert-origin-y","vert-origin-y",-1770906134),mp=new q(null,"background-color","background-color",570434026),
np=new q(null,"overflow-wrap","overflow-wrap",-60289494),op=new q(null,"negative","negative",-1562068438),pp=new q(null,"hide-border?","hide-border?",1792698922),qp=new q(null,"on-progress","on-progress",1196110410),rp=new q(null,"stroke-linejoin","stroke-linejoin",-1810816406),sp=new q(null,"on-submit-capture","on-submit-capture",2089939562),tp=new q(null,"clear-input-form","clear-input-form",-2047880566),up=new q(null,"word-wrap","word-wrap",-1700975926),vp=new q(null,"on-transition-end","on-transition-end",
-1169027318),wp=new Sc(null,"js","js",-886355190,null),xp=new q(null,"readers","readers",-2118263030),yp=new q(null,"basic-week-date-time","basic-week-date-time",-502077622),zp=new q(null,"h-scroll","h-scroll",-1200000150),Ap=new q(null,"strikethrough-position","strikethrough-position",402256746),Bp=new q(null,"do-fx","do-fx",1194163050),Cp=new q(null,"href-lang","href-lang",1832618890),Dp=new q(null,"y1","y1",589123466),Ep=new q(null,"margin-top","margin-top",392161226),Fp=new q(null,"scoped","scoped",
1906888682),Gp=new q(null,"on-load","on-load",1415151594),Hp=new q(null,"-webkit-flex","-webkit-flex",-1736517621),Ip=new q(null,"flex-grow","flex-grow",1865160747),Jp=new q(null,"mode","mode",654403691),Kp=new q(null,"-webkit-justify-content","-webkit-justify-content",205818059),Lp=new q(null,"width","width",-384071477),Mp=new q(null,"px","px",281329899),Np=new q(null,"start","start",-355208981),Op=new q(null,"background","background",-863952629),Pp=new q(null,"on-ended","on-ended",428118347),Qp=
new q(null,"on-drop","on-drop",1867868491),Rp=new q(null,"auto-reverse","auto-reverse",1757163883),Sp=new q(null,"dy","dy",1719547243),Tp=new q(null,"hz","hz",-1450739349),Up=new q(null,"page-break-after","page-break-after",1723909515),Vp=new q(null,"g2","g2",-479351381),Wp=new q(null,"below-center","below-center",-2126885397),Xp=new q(null,"background-blend-mode","background-blend-mode",-1923706293),Yp=new q(null,"on-blur","on-blur",814300747),Zp=new q(null,"defer","defer",-40276405),$p=new q(null,
"rem","rem",-976484757),aq=new q(null,"points-at-y","points-at-y",-1154851221),bq=new q(null,"div-size","div-size",1661625995),cq=new q(null,"shape-rendering","shape-rendering",955846315),dq=new q(null,"em","em",707813035),eq=new q(null,"on-loaded-data-capture","on-loaded-data-capture",675534539),fq=new q(null,"show-weeks?","show-weeks?",-1563135221),gq=new q(null,"font-feature-settings","font-feature-settings",-1311751381),hq=new q(null,"num-octaves","num-octaves",-150470805),iq=new q(null,"dppx",
"dppx",1920508843),jq=new q(null,"grid-auto-rows","grid-auto-rows",-113194069),kq=new q(null,"background-attachment","background-attachment",-885303381),lq=new q(null,"flex-wrap","flex-wrap",455413707),mq=new q(null,"component-did-update","component-did-update",-1468549173),nq=new q(null,"orientation","orientation",623557579),oq=new q(null,"grid-template-rows","grid-template-rows",-372292629),pq=new q(null,"grid-row-start","grid-row-start",-1827627988),qq=new q(null,"between","between",1131099276),
rq=new q(null,"dpcm","dpcm",-1187601236),sq=new q(null,"grid-auto-flow","grid-auto-flow",-1754873684),tq=new q(null,"key-type","key-type",-1494232916),uq=new q(null,"val","val",128701612),vq=new q(null,"cursor","cursor",1011937484),wq=new q(null,"format-str","format-str",695206156),xq=new q(null,"dispatch-n","dispatch-n",-504469236),yq=new q(null,"stroke-dashoffset","stroke-dashoffset",-782320340),zq=new q(null,"vertical","vertical",718696748),Aq=new Sc(null,"inst","inst",-2008473268,null),Bq=new q(null,
"border-right-width","border-right-width",750273868),Cq=new q(null,"form-target","form-target",1549802860),Dq=new q(null,"on-wheel","on-wheel",-1971630708),Eq=new q(null,"below-left","below-left",1233934732),Fq=new q(null,"weekyear","weekyear",-74064500),U=new q(null,"type","type",1174270348),Gq=new q(null,"border-inline-start-width","border-inline-start-width",874415532),Hq=new q("replete.subs","key-bindings","replete.subs/key-bindings",-447606100),Iq=new q(null,"unix","unix",1361815212),Jq=new q(null,
"flex","flex",-1425124628),Kq=new q(null,"controls","controls",1340701452),Lq=new q(null,"vert-origin-x","vert-origin-x",1437952844),Mq=new q(null,"_size","_size",-746489012),Nq=new q(null,"on-waiting-capture","on-waiting-capture",-1085823124),Oq=new q(null,"debug","debug",-1608172596),Pq=new q(null,"border-inline-end-color","border-inline-end-color",144511980),Qq=new q(null,"manifest","manifest",-1386791956),Rq=new q(null,"on-context-menu","on-context-menu",-1330744340),Sq=new q(null,"app-name",
"app-name",-268811251),Tq=new q(null,"ruby-position","ruby-position",-1367543795),Uq=new q(null,"src","src",-1651076051),Vq=new q(null,"pc","pc",512913453),Wq=new q(null,"basic-time","basic-time",-923134899),Xq=new q(null,"on-can-play-through","on-can-play-through",-1707144051),Yq=new q(null,"xml-lang","xml-lang",697555117),Zq=new Sc(null,"localDateParser","localDateParser",477820077,null),$q=new q(null,"xlink-type","xlink-type",-144814867),ar=new q(null,"points","points",-1486596883),br=new q(null,
"h3.popover-title","h3.popover-title",126205197),cr=new q(null,"on-wheel-capture","on-wheel-capture",-950568595),dr=new q(null,"y-channel-selector","y-channel-selector",-1933215315),er=new q(null,"orient","orient",1933743565),fr=new q(null,"view-box","view-box",-1792199155),gr=new q(null,"underline-thickness","underline-thickness",1528492621),hr=new q(null,"text-orientation","text-orientation",561880685),ir=new q(null,"border-block-start-style","border-block-start-style",255834733),jr=new q(null,
"form-no-validate","form-no-validate",-1832208755),kr=new q(null,"points-at-z","points-at-z",1246841485),lr=new q(null,"b-border","b-border",-1277965683),mr=new Sc(null,"Inf","Inf",647172781,null),nr=new q(null,"source","source",-433931539),or=new q(null,"list-style-image","list-style-image",-1093077267),pr=new q(null,"on-animation-iteration","on-animation-iteration",784117517),qr=new q(null,"icon","icon",1679606541),rr=new q(null,"output","output",-1105869043),sr=new q(null,"on-drag","on-drag",-69159091),
tr=new q(null,"multiple","multiple",1244445549),ur=new q(null,"horiz-adv-x","horiz-adv-x",1555956653),vr=new q(null,"max-width","max-width",-1939924051),wr=new q(null,"preserve-alpha","preserve-alpha",-1965515795),xr=new q(null,"on-paste-capture","on-paste-capture",664699950),yr=new q(null,"scope","scope",-439358418),zr=new q(null,"border-bottom-left-radius","border-bottom-left-radius",-76446610),Ar=new q(null,"preamble-text","preamble-text",-1480702866),Br=new q(null,"componentWillUnmount","componentWillUnmount",
1573788814),Cr=new q(null,"sandbox","sandbox",-54636402),Dr=new q(null,"text-combine-upright","text-combine-upright",1934643374),Er=new q(null,"on-mouse-leave-capture","on-mouse-leave-capture",-251526962),Fr=new q(null,"string","string",-1989541586),Gr=new q(null,"ascent","ascent",-1986032338),Hr=new Sc(null,"queue","queue",-1198599890,null),Ir=new q(null,"vh","vh",79552846),Jr=new q(null,"ime-mode","ime-mode",1418620270),Kr=new q(null,"vector","vector",1902966158),Lr=new q(null,"hour-minute-second",
"hour-minute-second",-1906654770),Mr=new q(null,"all","all",892129742),Nr=new q(null,"extraKeys","extraKeys",1380834830),Or=new q(null,"on-error-capture","on-error-capture",-1613428178),Pr=new q(null,"border-image-source","border-image-source",1924962862),Qr=new q(null,"radius","radius",-2073122258),Rr=new q(null,"outline-width","outline-width",-381531602),Sr=new q(null,"resize","resize",297367086),Tr=new q(null,"illegal-argument","illegal-argument",-1845493170),Ur=new q(null,"transform-box","transform-box",
599037518),Vr=new q(null,"ordinal-date-time","ordinal-date-time",-1386753458),Wr=new q(null,"border-inline-end","border-inline-end",1529961070),Xr=new q(null,"border-block-end-style","border-block-end-style",-936122706),Yr=new q(null,"deregister-event-handler","deregister-event-handler",-1096518994),Zr=new q(null,"perspective","perspective",1459886798),$r=new q(null,"close-callback","close-callback",651188974),as=new q(null,"border-left","border-left",-1150760178),bs=new q(null,"length-adjust","length-adjust",
773679982),cs=new q(null,"border-top-left-radius","border-top-left-radius",1361811342),ds=new Sc(null,"dateParser","dateParser",-1248418930,null),es=new q(null,"word-spacing","word-spacing",-1211711602),fs=new q(null,"s","s",1705939918),gs=new q(null,"ordinal-date-time-no-ms","ordinal-date-time-no-ms",-1539005490),hs=new q(null,"on-mouse-down","on-mouse-down",1147755470),is=new q(null,"flex-shrink","flex-shrink",1481146383),js=new q(null,"animation-timing-function","animation-timing-function",-1186881521),
ks=new q(null,"spill","spill",-1725816817),ls=new q(null,"padding-right","padding-right",-1250249681),ms=new q(null,"xml-base","xml-base",1909907631),ns=new q(null,"on-click","on-click",1632826543),os=new q(null,"strable","strable",1877668047),ps=new q(null,"seed","seed",68613327),qs=new q(null,"stop-opacity","stop-opacity",-2018003729),rs=new q(null,"up","up",-269712113),ss=new q(null,"hour-minute-second-ms","hour-minute-second-ms",1209749775),ts=new q(null,"ch","ch",-554717905),us=new q(null,"border-bottom-width",
"border-bottom-width",-1417262769),vs=new q(null,"font","font",-1506159249),ws=new q(null,"size","size",1098693007),xs=new q(null,"font-variant-alternates","font-variant-alternates",2146842031),ys=new q(null,"use-map","use-map",705810863),zs=new q(null,"k","k",-2146297393),As=new q(null,"title","title",636505583),Bs=new q(null,"on-seeking","on-seeking",-1860722161),Cs=new q(null,"kernel-matrix","kernel-matrix",165302799),Ds=new q(null,"running","running",1554969103),Es=new q(null,"column-gap","column-gap",
384822863),Fs=new q(null,"allow-full-screen","allow-full-screen",-1219396017),Gs=new q(null,"level4","level4",1467985519),Hs=new q(null,"column","column",2078222095),Is=new q(null,"on-mouse-out-capture","on-mouse-out-capture",-1317872881),Js=new q(null,"border-block-start-width","border-block-start-width",989693743),Ks=new q(null,"vw","vw",1941049135),Ls=new q(null,"border-collapse","border-collapse",919100239),Ms=new q(null,"validating","validating",1866468207),Ns=new q(null,"arabic-form","arabic-form",
-246736017),Os=new q(null,"on-loaded-metadata","on-loaded-metadata",1770177391),Ps=new q(null,"deg","deg",-681556081),Qs=new q(null,"headers","headers",-835030129),Rs=new q(null,"-webkit-flex-shrink","-webkit-flex-shrink",1567519631),Ss=new q(null,"orphans","orphans",1913357231),Ts=new q(null,"loop","loop",-395552849),Us=new q(null,"glyph-ref","glyph-ref",2123396015),Vs=new q(null,"border-right-color","border-right-color",2017953775),Ws=new q(null,"center","center",-748944368),Xs=new q(null,"high",
"high",2027297808),Ys=new q(null,"enter","enter",1792452624),Zs=new q(null,"widths","widths",-1467327440),$s=new q(null,"shouldComponentUpdate","shouldComponentUpdate",1795750960),at=new q(null,"on-load-start","on-load-start",73295952),bt=new q(null,"div.popover.fade.in","div.popover.fade.in",-106226512),ct=new q(null,"background-clip","background-clip",1705503920),dt=new q(null,"on-paste","on-paste",-50859856),et=new q(null,"time-parser","time-parser",-1636511536),ft=new q(null,"flush-dom","flush-dom",
-933676816),gt=new q(null,"html-for","html-for",594503920),ht=new q(null,"background-image","background-image",-1142314704),it=new q(null,"small","small",2133478704),jt=new q(null,"style","style",-496642736),kt=new q(null,"theme","theme",-1247880880),lt=new q(null,"textarea","textarea",-650375824),mt=new q(null,"dpi","dpi",-986162832),nt=new q(null,"on-time-update-capture","on-time-update-capture",213296528),ot=new q(null,"unicode-range","unicode-range",-2014392944),pt=new q(null,"clip-path","clip-path",
-439959120),qt=new q(null,"cm","cm",540591536),rt=new q(null,"grid-column-gap","grid-column-gap",-1342199344),st=new q(null,"points-at-x","points-at-x",1619352080),tt=new q(null,"zoom-and-pan","zoom-and-pan",-599601616),ut=new q(null,"lang","lang",-1819677104),vt=new q(null,"stroke-linecap","stroke-linecap",-1201103248),wt=new q(null,"_height","_height",133867120),xt=new q(null,"src-set","src-set",1389408880),yt=new q(null,"rows","rows",850049680),zt=new q(null,"flood-opacity","flood-opacity",-479030608),
At=new q(null,"on-copy-capture","on-copy-capture",-988406096),Bt=new q(null,"on-key-up","on-key-up",884441808),Ct=new q(null,"external-resources-required","external-resources-required",-757648688),Dt=new q("replete.subs","eval-result","replete.subs/eval-result",1129723600),Et=new q(null,"div","div",1057191632),Ft=new q(null,"trim-v","trim-v",-1274938640),Gt=new q(null,"turn","turn",75759344),Ht=new q(null,"in2","in2",782506768),It=new q(null,"showing?","showing?",2094921488),Jt=new q(null,"summary",
"summary",380847952),Kt=new q(null,"ruby-align","ruby-align",-479045808),Lt=new q(null,"filter-res","filter-res",-755681424),Mt=new q(null,"date-time-parser","date-time-parser",-656147568),Nt=new q(null,"start-of-week","start-of-week",-1590603824),Ot=new q(null,"text-align-last","text-align-last",1401448400),Pt=new q(null,"_initial-split","_initial-split",2145793073),Qt=new q(null,"on-cut","on-cut",-1019124687),Rt=new q(null,"begin","begin",-319034319),St=new q(null,"dispatch","dispatch",1319337009),
Tt=new q(null,"grid-column-start","grid-column-start",718549073),Ut=new q(null,"on-animation-iteration-capture","on-animation-iteration-capture",376540273),Vt=new q(null,"enc-type","enc-type",-1746291599),Wt=new q(null,"g1","g1",1986774193),Xt=new q(null,"base-profile","base-profile",-29066063),Yt=new q(null,"clear-input","clear-input",-561724207),Zt=new q(null,"border-block-start-color","border-block-start-color",690898129),$t=new q(null,"update-fn","update-fn",711087313),au=new q(null,"lighting-color",
"lighting-color",-1324714767),bu=new q(null,"z","z",-789527183),cu=new q(null,"year","year",335913393),du=new q(null,"reagentRender","reagentRender",-358306383),eu=new q(null,"azimuth","azimuth",-165971535),fu=new q(null,"border-image-repeat","border-image-repeat",-1007131119),gu=new q(null,"arrow-gap","arrow-gap",1490206257),hu=new q(null,"alphabetic","alphabetic",1536352849),iu=new q(null,"alignment-baseline","alignment-baseline",-311060879),ju=new q(null,"t-time-no-ms","t-time-no-ms",990689905),
ku=new q(null,"on-encrypted","on-encrypted",-278636879),lu=new Sc(null,"dateElementParser","dateElementParser",984800945,null),mu=new q(null,"on-transition-end-capture","on-transition-end-capture",-318050607),nu=new q(null,"warning","warning",-1685650671),ou=new q(null,"span.bold","span.bold",636457745),pu=new q(null,"basic-week-date-time-no-ms","basic-week-date-time-no-ms",-2043113679),qu=new Sc(null,"localDateOptionalTimeParser","localDateOptionalTimeParser",435955537,null),ru=new q(null,"http-equiv",
"http-equiv",-433976463),su=new q(null,"on-volume-change","on-volume-change",84155249),tu=new q(null,"cols","cols",-1914801295),uu=new q("replete.events","clear-input","replete.events/clear-input",-844727375),vu=new q(null,"grid-row","grid-row",-1737175087),wu=new q(null,"widows","widows",1989591025),xu=new q(null,"\x3c\x3e","\x3c\x3e",1280186386),yu=new q(null,"scrolling","scrolling",349011090),zu=new q(null,"edge-mode","edge-mode",1902361778),Au=new q("replete.events","input-history","replete.events/input-history",
-313529166),Bu=new q(null,"preload","preload",1646824722),Cu=new q(null,"on-waiting","on-waiting",332105010),Du=new q(null,"dominant-baseline","dominant-baseline",609259826),Eu=new q(null,"units-per-em","units-per-em",1845580082),Fu=new q(null,"no-cache","no-cache",1588056370),Gu=new q(null,"border-width","border-width",-1512605390),Hu=new q(null,"render","render",-1408033454),Iu=new q(null,"on-drag-leave","on-drag-leave",-373180078),Ju=new q(null,"marker-start","marker-start",-56273582),Ku=new q(null,
"db-handler","db-handler",579530098),Lu=new q(null,"overline-position","overline-position",1793937810),Mu=new q(null,"filter","filter",-948537934),Nu=new q(null,"basic-date","basic-date",1566551506),Ou=new q(null,"on-animation-start","on-animation-start",923687410),Pu=new q(null,"mask-mode","mask-mode",1954608626),Qu=new q("replete.subs","current-form","replete.subs/current-form",942128658),Ru=new q(null,"event","event",301435442),Su=new q(null,"quotes","quotes",-844987790),Tu=new q(null,"on-select",
"on-select",-192407950),Uu=new q(null,"offset-block-start","offset-block-start",-188512622),Vu=new q(null,"after","after",594996914),Wu=new q(null,"on-touch-cancel-capture","on-touch-cancel-capture",282949330),Xu=new q(null,"right-center","right-center",2147253074),Yu=new q(null,"poster","poster",-1616913550),Zu=new q(null,"offset-inline-start","offset-inline-start",-1043134574),$u=new q(null,"input-history","input-history",-2110310510),av=new q(null,"danger","danger",-624338030),bv=new q(null,"success",
"success",1890645906),cv=new q(null,"text-indent","text-indent",-1987214414),dv=new q(null,"kernel-unit-length","kernel-unit-length",-176217166),ev=new q(null,"z-index","z-index",1892827090),fv=new q("replete.events","save-form","replete.events/save-form",322041842),gv=new q(null,"system-language","system-language",-520364013),hv=new q(null,"aria","aria",1737868339),iv=new q(null,"on-drag-start","on-drag-start",-47712205),jv=new q(null,"on-touch-move-capture","on-touch-move-capture",2112992339),kv=
new q(null,"reagent-render","reagent-render",-985383853),lv=new q(null,"draggable","draggable",1676206163),mv=new q(null,"margin-block-start","margin-block-start",1770237075),nv=new q(null,"glyph-name","glyph-name",-1290126189),ov=new q(null,"padding-top","padding-top",1929675955),pv=new q(null,"auto-play","auto-play",-645319501),qv=new q(null,"revert","revert",-983985933),rv=new q(null,"on-scroll-capture","on-scroll-capture",537214227),sv=new q(null,"border-left-style","border-left-style",65166675),
tv=new q(null,"line","line",212345235),uv=new q(null,"key-params","key-params",1987800467),vv=new q(null,"on-playing-capture","on-playing-capture",-1248344653),wv=new q(null,"descent","descent",1331783219),xv=new q(null,"stroke-width","stroke-width",716836435),yv=new q(null,"challenge","challenge",1302148691),zv=new q(null,"text-emphasis-style","text-emphasis-style",1293728371),Av=new q(null,"list","list",765357683),Bv=new q(null,"readOnly","readOnly",-1749118317),Cv=new q(null,"div.rc-backdrop.noselect",
"div.rc-backdrop.noselect",-530372973),Dv=new q(null,"cap-height","cap-height",1034322643),Ev=new q(null,"view-target","view-target",-2146114861),Fv=new q(null,"on-write","on-write",31519475),Gv=new q(null,"empty-cells","empty-cells",306849587),Hv=new q(null,"padding-left","padding-left",-1180879053),Iv=new q(null,"keyword","keyword",811389747),Jv=new q(null,"ex","ex",-1413771341),Kv=new q(null,"weekyear-week","weekyear-week",795291571),Lv=new q(null,"on-mouse-up-capture","on-mouse-up-capture",-1098004557),
Mv=new q(null,"key-times","key-times",478549971),Nv=new q(null,"status","status",-1997798413),Ov=new q(null,"result","result",1415092211),Pv=new q(null,"scroll","scroll",971553779),Qv=new q(null,"larger","larger",1304935444),Rv=new q(null,"on-animation-start-capture","on-animation-start-capture",560396340),Sv=new q(null,"not-found","not-found",-629079980),Tv=new q(null,"from","from",1815293044),Uv=new q(null,"font-variant-caps","font-variant-caps",-1493584780),Vv=new q(null,"l-border","l-border",
383143028),Wv=new q(null,"text-decoration-color","text-decoration-color",853200020),Xv=new q(null,"on-animation-end-capture","on-animation-end-capture",-951923532),Yv=new q(null,"node-id","node-id",779482292),Zv=new q(null,"u2","u2",1850032340),$v=new q(null,"src-lang","src-lang",254495956),aw=new q(null,"hidden","hidden",-312506092),bw=new q(null,"max","max",61366548),cw=new q(null,"word-break","word-break",-407281356),dw=new q(null,"border-top-width","border-top-width",1612782932),ew=new q(null,
"background-origin","background-origin",79411540),fw=new q(null,"column-width","column-width",405119380),gw=new q(null,"min-block-size","min-block-size",2039624084),hw=new q(null,"local-date","local-date",1829761428),iw=new q(null,"media-group","media-group",1155749300),jw=new q(null,"border-spacing","border-spacing",-1602200108),kw=new q(null,"opacity","opacity",397153780),lw=new q(null,"col","col",-1959363084),mw=new q(null,"on-double-click","on-double-click",1434856980),nw=new q(null,"basic-ordinal-date-time-no-ms",
"basic-ordinal-date-time-no-ms",-395135436),ow=new q(null,"cx","cx",1272694324),pw=new q(null,"label","label",1718410804),qw=new q(null,"id","id",-1388402092),rw=new q(null,"div.chosen-search","div.chosen-search",-210987404),sw=new q(null,"accept-charset","accept-charset",-1667839372),tw=new q(null,"std-deviation","std-deviation",-891200908),uw=new q(null,"on-key-up-capture","on-key-up-capture",798383732),vw=new q(null,"page-break-before","page-break-before",-944104780),ww=new q(null,"values","values",
372645556),xw=new q(null,"class","class",-2030961996),yw=new q(null,"dur","dur",1464522452),zw=new q(null,"on-stalled-capture","on-stalled-capture",1710011124),Aw=new q(null,"effects","effects",-282369292),Bw=new q(null,"arg-names","arg-names",1632831252),Cw=new q(null,"text-length","text-length",1833660212),Dw=new q(null,"on-abort-capture","on-abort-capture",-179468428),Ew=new q(null,"autofocus","autofocus",-712814732),Fw=new q(null,"wmode","wmode",661021556),Gw=new q(null,"no-validate","no-validate",
72997812),Hw=new q(null,"k3","k3",1937862580),Iw=new q(null,"unknown-os","unknown-os",-2005955628),Jw=new q(null,"resource","resource",251898836),Kw=new q(null,"cy","cy",755331060),Lw=new q(null,"underline-position","underline-position",2105325589),Mw=new q(null,"on-can-play","on-can-play",1481578549),Nw=new q(null,"on-drag-capture","on-drag-capture",1336556597),Ow=new q("replete.events","mark-up-history","replete.events/mark-up-history",1325591605),Pw=new q(null,"opts","opts",155075701),Qw=new q(null,
"nil","nil",99600501),Rw=new q(null,"kind","kind",-717265803),Sw=new q(null,"year-month","year-month",735283381),Tw=new q(null,"k4","k4",-899960619),Uw=new q(null,"char-set","char-set",-155556619),Vw=new q(null,"minimum","minimum",-1621006059),Ww=new q(null,"padding","padding",1660304693),Xw=new q(null,"baseline-shift","baseline-shift",-2068063947),Yw=new q(null,"off","off",606440789),Zw=new q(null,"content-script-type","content-script-type",-764886699),$w=new q(null,"xml-space","xml-space",1409379733),
ax=new q(null,"font-kerning","font-kerning",-638989899),bx=new q(null,"auto-run","auto-run",1958400437),cx=new q(null,"history-index","history-index",-394704427),dx=new q(null,"checked","checked",-50955819),ex=new q(null,"grid-area","grid-area",-1829717451),fx=new q(null,"border-inline-start","border-inline-start",957988437),gx=new q(null,"border-top-color","border-top-color",-804629899),hx=new q(null,"border-image-outset","border-image-outset",-335977867),ix=new q(null,"v-mathematical","v-mathematical",
-639453547),jx=new q(null,"context-menu","context-menu",-1002713451),kx=new q(null,"on-drag-enter","on-drag-enter",-1692112235),lx=new q(null,"slope","slope",-1227938123),mx=new Sc(null,"/","/",-1371932971,null),nx=new q(null,"right-above","right-above",832458485),ox=new q(null,"font-variant-position","font-variant-position",783614741),px=new q(null,"mask-position","mask-position",-342553835),qx=new q(null,"mark-up-history","mark-up-history",-1272569067),rx=new q(null,"top-offset","top-offset",1235816245),
sx=new q(null,"run-queue","run-queue",-1701798027),tx=new q(null,"color-interpolation-filters","color-interpolation-filters",-519168139),ux=new q(null,"tooltip-position","tooltip-position",936197013),vx=new q(null,"key-points","key-points",-1704741963),wx=new q(null,"div.popover-content","div.popover-content",1045719989),xx=new q(null,"justify-content","justify-content",-1990475787),yx=new q(null,"on-mouse-move","on-mouse-move",-1386320874),zx=new q(null,"component-will-unmount","component-will-unmount",
-2058314698),Ax=new q(null,"shape","shape",1190694006),Bx=new q(null,"cross-origin","cross-origin",-2100195210),Cx=new q(null,"svg","svg",856789142),Dx=new q(null,"start-offset","start-offset",1295473814),Ex=new q(null,"gap","gap",80255254),Fx=new q(null,"max-inline-size","max-inline-size",1870424342),Gx=new q(null,"info","info",-317069002),Hx=new q(null,"t-border","t-border",1110748502),Ix=new q(null,"transition-timing-function","transition-timing-function",-549540522),Jx=new q(null,"code","code",
1586293142),Kx=new q(null,"col-span","col-span",-232603210),Lx=new q(null,"overflow-x","overflow-x",-26547754),Mx=new q(null,"stack","stack",-793405930),Nx=new q(null,"selectable-fn","selectable-fn",-1997365738),Ox=new q(null,"additive","additive",-1654411690),Px=new q(null,"on-mouse-move-capture","on-mouse-move-capture",-528714122),Qx=new q(null,"on-copy","on-copy",-227435882),Rx=new q(null,"on-volume-change-capture","on-volume-change-capture",1886298774),Sx=new q(null,"on-drag-enter-capture","on-drag-enter-capture",
955704982),Tx=new q(null,"hover-color","hover-color",663962326),Ux=new q(null,"outline","outline",793464534),Vx=new q("replete.events","async-eval","replete.events/async-eval",1939234518),Wx=new Sc(null,"dateTimeParser","dateTimeParser",-1493718282,null),Xx=new q(null,"file-path","file-path",-2005501162),Yx=new q(null,"animation-duration","animation-duration",-1261077706),Zx=new q(null,"initial","initial",1854648214),$x=new q(null,"border-block-start","border-block-start",1160398742),ay=new q(null,
"text-underline-position","text-underline-position",-1234733162),by=new q(null,"border-inline-start-style","border-inline-start-style",1730804630),cy=new q(null,"animation-play-state","animation-play-state",655922102),dy=new q(null,"operator","operator",-1860875338),ey=new q(null,"transform-origin","transform-origin",-586167370),fy=new q(null,"on-context-menu-capture","on-context-menu-capture",2060544023),gy=new q(null,"local-date-opt-time","local-date-opt-time",1178432599),hy=new q(null,"xlink-arcrole",
"xlink-arcrole",-759567177),iy=new q(null,"auto-focus","auto-focus",1250006231),jy=new q(null,"on-touch-move","on-touch-move",1587118423),ky=new q(null,"left-below","left-below",1290111351),ly=new q(null,"on-touch-end-capture","on-touch-end-capture",-635667049),my=new q(null,"src-doc","src-doc",-543683145),ny=new q(null,"object-position","object-position",-598884937),oy=new q(null,"marks","marks",-1844991497),py=new q(null,"display-name","display-name",694513143),qy=new q(null,"perspective-origin",
"perspective-origin",-1049394665),ry=new q(null,"low","low",-1601362409),sy=new q(null,"right","right",-452581833),ty=new q(null,"scheduled","scheduled",553898551),uy=new q(null,"on-drag-start-capture","on-drag-start-capture",-198934889),vy=new q(null,"text-shadow","text-shadow",116733623),wy=new q(null,"on-animation-end","on-animation-end",-1927132329),xy=new q(null,"week-date","week-date",-1176745129),yy=new Sc(null,"-Inf","-Inf",-2123243689,null),zy=new q(null,"border-color","border-color",-2059162761),
Ay=new q(null,"text-decoration","text-decoration",1836813207),By=new q(null,"transition-property","transition-property",2036650935),Cy=new q(null,"path-length","path-length",651940791),Dy=new q(null,"on-submit","on-submit",1227871159),Ey=new q(null,"rotate","rotate",152705015),Fy=new q(null,"diffuse-constant","diffuse-constant",-1427039241),Gy=new q(null,"shape-margin","shape-margin",358865911),Hy=new q(null,"display","display",242065432),Iy=new q(null,"image-resolution","image-resolution",-1933945832),
Jy=new q(null,"on-touch-start-capture","on-touch-start-capture",126030904),Ky=new q(null,"position","position",-2011731912),Ly=new q(null,"changes","changes",1492088),My=new q(null,"on-click-capture","on-click-capture",-1777989448),Ny=new q(null,"mathematical","mathematical",-944855880),Oy=new q(null,"on-cut-capture","on-cut-capture",1724168408),Py=new q(null,"order","order",-1254677256),Qy=new q(null,"on-dispose","on-dispose",2105306360),Ry=new q(null,"grid-template-areas","grid-template-areas",
-1162938120),Sy=new q(null,"vmax","vmax",-1435213544),Ty=new q(null,"d","d",1972142424),V=new q(null,"validate-fn","validate-fn",1430169944),Uy=new q(null,"text-emphasis-color","text-emphasis-color",-1426881160),Vy=new q(null,"action","action",-811238024),Wy=new q(null,"on-mouse-up","on-mouse-up",-1340533320),Xy=new q(null,"target-y","target-y",266215864),Yy=new q(null,"form-gap","form-gap",514237880),Zy=new q(null,"cell-spacing","cell-spacing",769666488),$y=new q(null,"on-mouse-leave","on-mouse-leave",
-1864319528),az=new q(null,"pause","pause",-2095325672),bz=new q(null,"spell-check","spell-check",-2060352968),cz=new q(null,"error","error",-978969032),dz=new q(null,"by","by",30600856),ez=new q(null,"origin","origin",1037372088),fz=new q(null,"br","br",934104792),gz=new q(null,"on","on",173873944),hz=new q(null,"class-name","class-name",945142584),iz=new q(null,"shape-image-threshold","shape-image-threshold",-1978694824),jz=new q(null,"componentFunction","componentFunction",825866104),kz=new q(null,
"fy","fy",550788984),lz=new q(null,"on-drag-over","on-drag-over",-93410408),mz=new q(null,"on-mouse-over","on-mouse-over",-858472552),nz=new q("replete.subs","input-history","replete.subs/input-history",1250913176),oz=new q(null,"stroke-miterlimit","stroke-miterlimit",1151270808),pz=new q(null,"border-inline-end-width","border-inline-end-width",1208892376),qz=new q(null,"exception","exception",-335277064),rz=new q(null,"key-splines","key-splines",-1981996040),sz=new q(null,"column-fill","column-fill",
1132872696),tz=new q(null,"-webkit-order","-webkit-order",-1474851815),uz=new q(null,"on-emptied-capture","on-emptied-capture",-1997072263),Hf=new q(null,"coeffects","coeffects",497912985),vz=new q(null,"letter-spacing","letter-spacing",-948993767),wz=new q(null,"x","x",2099068185),xz=new q(null,"on-duration-change","on-duration-change",815271225),yz=new q(null,"pattern-content-units","pattern-content-units",-776686279),zz=new q(null,"child","child",623967545),Az=new q(null,"change-fn","change-fn",
1566440825),Bz=new q(null,"vert-adv-y","vert-adv-y",-641097319),Cz=new q(null,"column-span","column-span",1302376857),Dz=new q(null,"x1","x1",-1863922247),Ez=new q(null,"xlink-show","xlink-show",-816120391),Fz=new q(null,"form","form",-1624062471),Gz=new q(null,"date-hour","date-hour",-344234471),Hz=new q(null,"os","os",795021913),Iz=new q(null,"tag","tag",-1290361223),Jz=new q(null,"on-seeking-capture","on-seeking-capture",-1395183943),Kz=new q(null,"capture","capture",-677031143),Lz=new q(null,
"anchor","anchor",1549638489),Mz=new q(null,"background-repeat","background-repeat",-387201191),Nz=new q(null,"input","input",556931961),Oz=new q(null,"padding-bottom","padding-bottom",-1899795591),Pz=new q(null,"integrity","integrity",-562947111),Qz=new q(null,"break-before","break-before",-1036311591),Rz=new q(null,"on-encrypted-capture","on-encrypted-capture",-1535382567),Sz=new q(null,"target","target",253001721),Tz=new q(null,"on-error","on-error",1728533530),Uz=new q(null,"on-duration-change-capture",
"on-duration-change-capture",-905092998),Vz=new q(null,"flood-color","flood-color",1622703322),Wz=new q(null,"_splitter-size","_splitter-size",-2092162822),Xz=new q(null,"rendering-intent","rendering-intent",-45468422),Yz=new q(null,"read-only","read-only",-191706886),Zz=new q(null,"v-hanging","v-hanging",-956218086),$z=new q(null,"allow-reorder","allow-reorder",-472942310),aA=new q(null,"unicode-bidi","unicode-bidi",310629754),bA=new q(null,"set","set",304602554),cA=new q(null,"linux","linux",-238042662),
dA=new q(null,"above","above",-1286866470),eA=new q(null,"margin-inline-start","margin-inline-start",320232954),fA=new q(null,"align-self","align-self",1475936794),gA=new q(null,"margin-right","margin-right",809689658),hA=new q(null,"accentheight","accentheight",718345882),iA=new q(null,"end","end",-268185958),jA=new q(null,"grid-row-end","grid-row-end",-128277830),kA=new q(null,"not-implemented","not-implemented",1918806714),lA=new q(null,"on-input","on-input",-267523366),mA=new q(null,"background-position",
"background-position",1112702746),nA=new q("replete.subs","restore-item","replete.subs/restore-item",1022890810),oA=new q(null,"scroll-behavior","scroll-behavior",1300031290),pA=new q(null,"unicode","unicode",-542572710),qA=new q(null,"bias","bias",-315297926),rA=new q(null,"table-layout","table-layout",-1260034150),sA=new q(null,"version","version",425292698),tA=new q(null,"groupEnd","groupEnd",-337721382),uA=new q(null,"y2","y2",-718691301),vA=new q(null,"atom","atom",-397043653),wA=new q(null,
"on-pause","on-pause",1839279163),xA=new q(null,"border-inline-start-color","border-inline-start-color",392047707),yA=new q(null,"panel-1","panel-1",998274139),zA=new q(null,"form-method","form-method",1197598843),AA=new q(null,"popover-border-color","popover-border-color",2142810267),BA=new q(null,"grid-row-gap","grid-row-gap",-2068663141),CA=new q(null,"trigger","trigger",103466139),DA=new q(null,"on-time-update","on-time-update",-1701460805),EA=new q(null,"on-change","on-change",-732046149),FA=
new q(null,"eof","eof",-489063237),GA=new q(null,"on-touch-start","on-touch-start",447239419),HA=new q(null,"primitive-units","primitive-units",179991803),IA=new q(null,"grid-template-columns","grid-template-columns",-594112133),JA=new q(null,"autobind","autobind",-570650245),KA=new q(null,"hierarchy","hierarchy",-1053470341),LA=new q(null,"allow-transparency","allow-transparency",-912588389),MA=new q(null,"calc-mode","calc-mode",1979119003),NA=new q(null,"border","border",1444987323),OA=new q(null,
"cofx","cofx",2013202907),PA=new q(null,"required-features","required-features",-1798960645),QA=new q(null,"attribute-type","attribute-type",1937706491),RA=new q(null,"panel-2","panel-2",244198907),SA=new q(null,"column-rule-width","column-rule-width",-305318373),TA=new q(null,"border-bottom-color","border-bottom-color",-208763333),UA=new q(null,"on-key-down","on-key-down",-1374733765),VA=new q(null,"body","body",-2049205669),WA=new q(null,"marker-mid","marker-mid",-505338277),XA=new q(null,"border-top",
"border-top",-158897573),YA=new q(null,"disabled?","disabled?",-1523234181),ZA=new q(null,"on-play","on-play",-188934501),$A=new q(null,"v-ideographic","v-ideographic",-1846578533),aB=new q(null,"column-rule-color","column-rule-color",525397723),bB=new q(null,"resume","resume",-118572261),cB=new q(null,"overflow-y","overflow-y",-1436589285),dB=new q(null,"border-radius","border-radius",419594011),eB=new q(null,"mask-clip","mask-clip",-1874001061),fB=new q(null,"nonce","nonce",564330331),gB=new q(null,
"time-element-parser","time-element-parser",-2042883205),hB=new q(null,"ms","ms",-1152709733),iB=new q(null,"marker-height","marker-height",631099323),jB=new q(null,"on-suspend-capture","on-suspend-capture",726683611),kB=new q(null,"pointer-events","pointer-events",-1053858853),lB=new q(null,"flex-basis","flex-basis",983188475),mB=new q(null,"caption-side","caption-side",500795420),nB=new q(null,"-webkit-align-items","-webkit-align-items",1515523100),oB=new q(null,"fx","fx",-1237829572),pB=new q(null,
"on-cancel","on-cancel",-2071892932),qB=new q(null,"margin-height","margin-height",-711398340),rB=new q(null,"font-synthesis","font-synthesis",-2125674372),sB=new q(null,"date-hour-minute-second","date-hour-minute-second",-1565419364),tB=new q(null,"polyline","polyline",-1731551044),uB=new q(null,"touch-action","touch-action",-128660292),vB=new q(null,"local","local",-1497766724),wB=new q(null,"stretch","stretch",-1888837380),xB=new q(null,"break-after","break-after",-1075423972),yB=new q(null,"before",
"before",-1633692388),zB=new q(null,"week-date-time-no-ms","week-date-time-no-ms",-1226853060),AB=new q(null,"font-size-adjust","font-size-adjust",-104156772),BB=new q(null,"rad","rad",-833983012),CB=new q(null,"download","download",-300081668),DB=new q(null,"cite","cite",1909439996),EB=new q(null,"k1","k1",952658428),FB=new q(null,"on-mouse-over-capture","on-mouse-over-capture",-19370468),GB=new q(null,"transition-duration","transition-duration",85784092),HB=new q(null,"border-bottom-right-radius",
"border-bottom-right-radius",414899772),IB=new q(null,"k2","k2",1429301820),JB=new q(null,"v-scroll","v-scroll",-1842185668),KB=new q(null,"khz","khz",507119228),LB=new q(null,"on-ended-capture","on-ended-capture",-800024932),MB=new q(null,"counter-increment","counter-increment",-181725540),NB=new q(null,"below-right","below-right",1598040732),OB=new q(null,"text-emphasis","text-emphasis",-1264768324),PB=new q(null,"auto","auto",-566279492),QB=new q(null,"base-frequency","base-frequency",694845148),
RB=new q(null,"input-mode","input-mode",1777008412),SB=new q(null,"step","step",1288888124),TB=new q(null,"font-variant-east-asian","font-variant-east-asian",-992331876),UB=new q(null,"log","log",-1595516004),VB=new q(null,"scroll-snap-destination","scroll-snap-destination",157820989),WB=new q(null,"decelerate","decelerate",1942059197),XB=new q(null,"media","media",-1066138403),YB=new q(null,"on-change-capture","on-change-capture",-862104355),ZB=new q(null,"glyph-orientation-vertical","glyph-orientation-vertical",
1701745981),$B=new q(null,"margin-bottom","margin-bottom",388334941),aC=new q("re-frame.std-interceptors","untrimmed-event","re-frame.std-interceptors/untrimmed-event",-840935075),bC=new q(null,"outline-color","outline-color",-804747875),cC=new q(null,"below","below",-926774883),dC=new q(null,"on-focus-capture","on-focus-capture",1657084317),eC=new q(null,"x2","x2",-1362513475),fC=new q(null,"level1","level1",813811133),gC=new q(null,"character","character",380652989),hC=new q(null,"color-interpolation",
"color-interpolation",-1276247587),iC=new q(null,"animation-iteration-count","animation-iteration-count",-1410888227),jC=new q(null,"map","map",1371690461),kC=new q(null,"on-loaded-metadata-capture","on-loaded-metadata-capture",227905021),lC=new q(null,"on-seeked","on-seeked",-1704740355),mC=new q(null,"background-size","background-size",-1248630243),nC=new q(null,"finish-run","finish-run",753148477),oC=new q(null,"basic-date-time-no-ms","basic-date-time-no-ms",-899402179),pC=new q(null,"visibility",
"visibility",1338380893),qC=new q(null,"ry","ry",-334598563),rC=new q(null,"filter-units","filter-units",185161373),sC=new q(null,"grad","grad",1125187229),tC=new q(null,"componentWillMount","componentWillMount",-285327619),uC=new q(null,"i","i",-1386841315),vC=new q(null,"gradient-units","gradient-units",-1502403779),wC=new q(null,"limiting-cone-angle","limiting-cone-angle",1429669757),xC=new q(null,"column-rule","column-rule",121487261),yC=new q(null,"enable-background","enable-background",-858721379),
zC=new q(null,"on-touch-end","on-touch-end",1515667389),AC=new q(null,"animation-fill-mode","animation-fill-mode",1637181373),BC=new q(null,"direction","direction",-633359395),CC=new q(null,"href","href",-793805698),DC=new q(null,"profile","profile",-545963874),EC=new q(null,"fill-opacity","fill-opacity",-537571170),FC=new q(null,"tooltip","tooltip",-1809677058),GC=new q(null,"on-load-start-capture","on-load-start-capture",-2090509058),Z=new q(null,"required","required",1807647006),HC=new q(null,
"user-select","user-select",-346451650),IC=new q(null,"none","none",1333468478),JC=new q(null,"unset","unset",-513298114),KC=new q(null,"column-rule-style","column-rule-style",547990910),LC=new q(null,"animation-name","animation-name",-302195330),MC=new q(null,"v-alphabetic","v-alphabetic",-552236578),NC=new q(null,"specular-constant","specular-constant",-360693250),OC=new q(null,"above-right","above-right",791010942),PC=new q(null,"mysql","mysql",-1431590210),QC=new q(null,"pattern-units","pattern-units",
-1273751842),RC=new q(null,"grid-column","grid-column",-1086912770),SC=new q(null,"dispatch-later","dispatch-later",291951390),TC=new q(null,"font-family","font-family",-667419874),UC=new q(null,"grid-auto-columns","grid-auto-columns",-1346990274),VC=new q(null,"on-drag-exit-capture","on-drag-exit-capture",1830296414),WC=new q(null,"xlink-actuate","xlink-actuate",1131107166),XC=new q(null,"showing-injected?","showing-injected?",-105733250),YC=new q(null,"flex-direction","flex-direction",364609438),
ZC=new q(null,"message","message",-406056002),$C=new q(null,"-webkit-flex-direction","-webkit-flex-direction",1024372702),aD=new q(null,"form-enc-type","form-enc-type",-1649098754),bD=new q(null,"height","height",1025178622),cD=new q(null,"spacing","spacing",204422175),dD=new q(null,"border-bottom","border-bottom",2110948415),eD=new q(null,"marker-end","marker-end",341488703),fD=new q(null,"on-drag-end-capture","on-drag-end-capture",36069439),gD=new q("eval","result","eval/result",1420716095),hD=
new q(null,"initial-split","initial-split",2072601727),iD=new q(null,"around","around",-265975553),jD=new q(null,"basic-t-time","basic-t-time",191791391),kD=new q(null,"mask-content-units","mask-content-units",-1147421409),lD=new q(null,"in","in",-1531184865),mD=new q(null,"clear","clear",1877104959),nD=new q(null,"left","left",-399115937),oD=new q(null,"mask-origin","mask-origin",-1021931137),pD=new q(null,"repeat-count","repeat-count",-274354817),qD=new q(null,"pattern","pattern",242135423),rD=
new q(null,"overline-thickness","overline-thickness",-1687103105),sD=new q(null,"padding-inline-start","padding-inline-start",1837266335),tD=new q(null,"row-span","row-span",-365554241),uD=new q(null,"default-year","default-year",1658037695),vD=new q(null,"preamble-markup","preamble-markup",1557120511),wD=new q(null,"on-select-capture","on-select-capture",2093373951),xD=new q(null,"accept","accept",1874130431),yD=new q(null,"counter-reset","counter-reset",1170260511),zD=new q("replete.subs","os",
"replete.subs/os",1944768095),AD=new q(null,"span","span",1394872991),BD=new q(null,"show-today?","show-today?",513056415),CD=new q("replete.events","eval","replete.events/eval",999958207),DD=new q(null,"on-drag-leave-capture","on-drag-leave-capture",-1751732545),ED=new q(null,"to","to",192099007),FD=new q(null,"paint-order","paint-order",1313558207),GD=new q(null,"on-drag-end","on-drag-end",520272671),HD=new q(null,"flex-flow","flex-flow",544537375),ID=new q(null,"border-image-width","border-image-width",
-478445793),JD=new q(null,"margin","margin",-995903681),KD=new q(null,"data","data",-232669377),LD=new q(null,"model","model",331153215),MD=new q(null,"stemh","stemh",1705215871),ND=new q(null,"border-block-end-color","border-block-end-color",1571299231),OD=new Sc(null,"f","f",43394975,null),PD=new q(null,"tooltip-style?","tooltip-style?",1188162527),QD=new q(null,"attr","attr",-604132353);var RD={};var SD={},TD="undefined"!==typeof console;if("undefined"===typeof RD||"undefined"===typeof SD||"undefined"===typeof UD)var UD=nf(null);
if("undefined"===typeof RD||"undefined"===typeof SD||"undefined"===typeof VD)var VD=function(){var a={};a.warn=function(){return function(){function a(a){var b=null;if(0<arguments.length){b=0;for(var d=Array(arguments.length-0);b<d.length;)d[b]=arguments[b+0],++b;b=new D(d,0,null)}return c.call(this,b)}function c(a){return pf.l(UD,Ff,new O(null,1,5,P,[bo],null),yd,L([N.c(u,a)]))}a.D=0;a.C=function(a){a=B(a);return c(a)};a.l=c;return a}()}(a);a.error=function(){return function(){function a(a){var b=
null;if(0<arguments.length){b=0;for(var d=Array(arguments.length-0);b<d.length;)d[b]=arguments[b+0],++b;b=new D(d,0,null)}return c.call(this,b)}function c(a){return pf.l(UD,Ff,new O(null,1,5,P,[cz],null),yd,L([N.c(u,a)]))}a.D=0;a.C=function(a){a=B(a);return c(a)};a.l=c;return a}()}(a);return a}();function WD(a,b,c){var d=t(b.ignoreCase)?"gi":"g";d=t(b.multiline)?[d,"m"].join(""):d;return a.replace(new RegExp(b.source,t(b.Je)?[d,"u"].join(""):d),c)}
function XD(a){return function(){function b(a){var b=null;if(0<arguments.length){b=0;for(var d=Array(arguments.length-0);b<d.length;)d[b]=arguments[b+0],++b;b=new D(d,0,null)}return c.call(this,b)}function c(b){b=tf(b);if(H.c(K(b),1))return b=E(b),a.h?a.h(b):a.call(null,b);b=bg(b);return a.h?a.h(b):a.call(null,b)}b.D=0;b.C=function(a){a=B(a);return c(a)};b.l=c;return b}()}
function YD(a,b,c){if("string"===typeof b)return a.replace(new RegExp(String(b).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08"),"g"),c);if(b instanceof RegExp)return"string"===typeof c?WD(a,b,c):WD(a,b,XD(c));throw["Invalid match arg: ",u.h(b)].join("");}function ZD(a){var b=new Pa;for(a=B(a);;)if(null!=a)b.append(u.h(E(a))),a=G(a),null!=a&&b.append(" ");else return b.toString()}
function $D(a,b){a="/(?:)/"===u.h(b)?yd.c(bg(ud("",qf.c(u,B(a)))),""):bg(u.h(a).split(b));if(1<K(a))a:for(;;)if(""===Kd(a))a=null==a?null:Rb(a);else break a;return a};var aE={},bE=new dh(null,new p(null,2,["aria",null,"data",null],null),null);function cE(a){return 2>K(a)?a.toUpperCase():[u.h(a.substring(0,1).toUpperCase()),u.h(a.substring(1))].join("")}function dE(a){if("string"===typeof a)return a;a=Ae(a);var b=$D(a,/-/),c=B(b);b=E(c);c=G(c);return t(bE.h?bE.h(b):bE.call(null,b))?a:N.j(u,b,qf.c(cE,c))}
function eE(a){var b=function(){var b=function(){var b=Gd(a);return b?(b=a.displayName,t(b)?b:a.name):b}();if(t(b))return b;b=function(){var b=null!=a?a.I&4096||k===a.Tc?!0:!1:!1;return b?Ae(a):b}();if(t(b))return b;b=Jd(a);return Qd(b)?S.h(b):null}();return YD(u.h(b),"$",".")}var fE=!1;var gE={};if("undefined"===typeof RD||"undefined"===typeof aE||"undefined"===typeof gE||"undefined"===typeof hE)var hE=0;function iE(a){return setTimeout(a,16)}var jE="undefined"===typeof window||null==window.document?iE:function(){var a=window,b=a.requestAnimationFrame;if(t(b))return b;b=a.webkitRequestAnimationFrame;if(t(b))return b;b=a.mozRequestAnimationFrame;if(t(b))return b;a=a.msRequestAnimationFrame;return t(a)?a:iE}();function kE(a,b){return a.cljsMountOrder-b.cljsMountOrder}
if("undefined"===typeof RD||"undefined"===typeof aE||"undefined"===typeof gE||"undefined"===typeof lE)var lE=function(){return null};function mE(){this.Bc=!1}function nE(a,b){var c=a[b];if(null==c)return null;a[b]=null;a=c.length;for(b=0;;)if(b<a){var d=c[b];d.B?d.B():d.call(null);b+=1}else return null}
function oE(a){if(a.Bc)return null;a.Bc=!0;a=function(a){return function(){a.Bc=!1;nE(a,"beforeFlush");lE();var b=a.componentQueue;if(null!=b){a.componentQueue=null;b.sort(kE);for(var d=b.length,e=0;;)if(e<d){var g=b[e];!0===g.cljsIsDirty&&g.forceUpdate();e+=1}else break}return nE(a,"afterRender")}}(a);return jE.h?jE.h(a):jE.call(null,a)}mE.prototype.enqueue=function(a,b){if(!t(b))throw Error("Assert failed: Enqueued function must not be nil\nf");null==this[a]&&(this[a]=[]);this[a].push(b);return oE(this)};
function pE(a){return qE.enqueue("afterRender",a)}if("undefined"===typeof RD||"undefined"===typeof aE||"undefined"===typeof gE||"undefined"===typeof qE){var qE;qE=new mE}function rE(a){if(t(a.cljsIsDirty))return null;a.cljsIsDirty=!0;return qE.enqueue("componentQueue",a)};function sE(a,b){a=N.j(kh,a,b);return ud(a,zf(function(a){return function(b){return a===b}}(a),b))}function tE(a,b){return K(a)<K(b)?pb(yd,b,a):pb(yd,a,b)}var uE=function uE(a){switch(arguments.length){case 1:return uE.h(arguments[0]);case 2:return uE.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return uE.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};uE.h=function(a){return a};
uE.c=function(a,b){for(;;)if(K(b)<K(a)){var c=a;a=b;b=c}else return pb(function(a,b){return function(a,c){return fe(b,c)?a:Ld.c(a,c)}}(a,b),a,a)};uE.l=function(a,b,c){a=sE(function(a){return-K(a)},yd.l(c,b,L([a])));return pb(uE,E(a),Vc(a))};uE.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};uE.D=2;
var vE=function vE(a){switch(arguments.length){case 1:return vE.h(arguments[0]);case 2:return vE.c(arguments[0],arguments[1]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return vE.l(arguments[0],arguments[1],new D(c.slice(2),0,null))}};vE.h=function(a){return a};vE.c=function(a,b){return K(a)<K(b)?pb(function(a,d){return fe(b,d)?Ld.c(a,d):a},a,a):pb(Ld,a,b)};vE.l=function(a,b,c){return pb(vE,a,yd.c(c,b))};
vE.C=function(a){var b=E(a),c=G(a);a=E(c);c=G(c);return this.l(b,a,c)};vE.D=2;function wE(a,b){return K(a)>=K(b)&&af(function(b){return fe(a,b)},b)};var xE={},yE;if("undefined"===typeof RD||"undefined"===typeof xE||"undefined"===typeof zE)var zE=!1;if("undefined"===typeof RD||"undefined"===typeof xE||"undefined"===typeof AE)var AE=0;if("undefined"===typeof RD||"undefined"===typeof xE||"undefined"===typeof BE)var BE=nf(0);function CE(a,b){var c=yE;yE=a;try{return b.B?b.B():b.call(null)}finally{yE=c}}
function DE(a,b){b.captured=null;b.He=AE+=1;a=CE(b,a);var c=b.captured;b.rb=!1;a:{var d=b.Cb;var e=null==c?0:c.length,g=e===(null==d?0:d.length);if(g)for(g=0;;){var h=g===e;if(h){d=h;break a}if(c[g]===d[g])g+=1;else{d=!1;break a}}else d=g}if(!d)a:{d=hh(c);e=hh(b.Cb);b.Cb=c;c=B(vE.c(d,e));g=null;for(var l=h=0;;)if(l<h){var m=g.N(null,l);pc(m,b,EE);l+=1}else if(c=B(c))g=c,Td(g)?(c=wc(g),l=xc(g),g=c,h=K(c),c=l):(c=E(g),pc(c,b,EE),c=G(g),g=null,h=0),l=0;else break;d=B(vE.c(e,d));e=null;for(h=g=0;;)if(h<
g)c=e.N(null,h),qc(c,b),h+=1;else if(d=B(d))e=d,Td(e)?(d=wc(e),g=xc(e),e=d,c=K(d),d=g,g=c):(c=E(e),qc(c,b),d=G(e),e=null,g=0),h=0;else break a}return a}function FE(a){var b=yE;if(null!=b){var c=b.captured;null==c?b.captured=[a]:c.push(a)}}function GE(a,b){zE&&pf.j(BE,me,K(b)-K(a));return b}function HE(a,b,c){var d=a.na;a.na=GE(d,Dd.j(d,b,c));return a.Nc=null}function IE(a,b){var c=a.na;a.na=GE(c,Fd.c(c,b));return a.Nc=null}
function JE(a,b,c){var d=a.Nc;d=null==d?a.Nc=je(function(){return function(a,b,c){a.push(b);a.push(c);return a}}(d),[],a.na):d;for(var e=d.length,g=0;;)if(g<e){var h=d[g],l=d[g+1];l.G?l.G(h,a,b,c):l.call(null,h,a,b,c);g=2+g}else break}function KE(a,b,c,d){mc(b,["#\x3c",u.h(d)," "].join(""));a:{d=yE;yE=null;try{var e=w(a);break a}finally{yE=d}e=void 0}Dh(e,b,c);return mc(b,"\x3e")}if("undefined"===typeof RD||"undefined"===typeof xE||"undefined"===typeof LE)var LE=null;
function ME(){for(;;){var a=LE;if(null==a)return null;LE=null;for(var b=a.length,c=0;;)if(c<b){var d=a[c];d.rb&&null!=d.Cb&&NE(d,!0);c+=1}else break}}lE=ME;function OE(){}function PE(a,b,c,d){this.state=a;this.meta=b;this.Bb=c;this.na=d;this.o=2154201088;this.I=114690}f=PE.prototype;f.gc=k;f.P=function(a,b,c){return KE(this,b,c,"Atom:")};f.S=function(){return this.meta};f.R=function(){return ha(this)};f.H=function(a,b){return this===b};
f.Ia=function(a,b){if(null!=this.Bb&&!t(this.Bb.h?this.Bb.h(b):this.Bb.call(null,b)))throw Error("Assert failed: Validator rejected reference state\n(validator new-value)");a=this.state;this.state=b;null!=this.na&&JE(this,a,b);return b};f.sc=function(a,b){return this.Ia(null,b.h?b.h(this.state):b.call(null,this.state))};f.tc=function(a,b,c){return this.Ia(null,b.c?b.c(this.state,c):b.call(null,this.state,c))};
f.uc=function(a,b,c,d){return this.Ia(null,b.j?b.j(this.state,c,d):b.call(null,this.state,c,d))};f.vc=function(a,b,c,d,e){return this.Ia(null,N.J(b,this.state,c,d,e))};f.wc=function(a,b){JE(this,a,b)};f.Wb=function(a,b,c){return HE(this,b,c)};f.Xb=function(a,b){return IE(this,b)};f.T=function(a,b){return new PE(this.state,b,this.Bb,this.na)};f.jb=function(){FE(this);return this.state};
var QE=function QE(a){switch(arguments.length){case 1:return QE.h(arguments[0]);default:for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return QE.l(arguments[0],new D(c.slice(1),0,null))}};QE.h=function(a){return new PE(a,null,null,null)};QE.l=function(a,b){var c=null!=b&&(b.o&64||k===b.M)?N.c(Yg,b):b;b=A.c(c,tl);c=A.c(c,Dn);return new PE(a,b,c,null)};QE.C=function(a){var b=E(a);a=G(a);return this.l(b,a)};QE.D=1;
function RE(a,b,c,d){var e=b.reagReactionCache,g=null==e?Xe:e,h=g.c?g.c(c,null):g.call(null,c,null);if(null!=h)return w(h);if(null==yE)return a.B?a.B():a.call(null);var l=function(){var l=function(){return function(){zE&&pf.c(BE,ne);var a=Fd.c(b.reagReactionCache,c);b.reagReactionCache=a;null!=d&&(d.fc=null);return null}}(a,Qy,e,g,h);return SE.j?SE.j(a,Qy,l):SE.call(null,a,Qy,l)}(),m=w(l);b.reagReactionCache=Dd.j(g,c,l);zE&&pf.c(BE,dd);null!=d&&(d.fc=l);return m}
function TE(a,b,c){this.Ma=a;this.Sb=b;this.fc=c;this.o=2153807872;this.I=0}f=TE.prototype;f.gc=k;f.jb=function(){var a=this,b=a.fc;return null==b?RE(function(){return function(){return N.c(a.Ma,a.Sb)}}(b,this),a.Ma,a.Sb,this):w(b)};f.H=function(a,b){return b instanceof TE&&H.c(this.Ma,b.Ma)&&H.c(this.Sb,b.Sb)};f.R=function(){return Pc(new O(null,2,5,P,[this.Ma,this.Sb],null))};f.P=function(a,b,c){return KE(this,b,c,"Track:")};
function UE(a,b,c,d,e){this.ea=a;this.path=b;this.fc=c;this.state=d;this.na=e;this.o=2153807872;this.I=114690}function VE(a){var b=yE;yE=null;try{return a.jb(null)}finally{yE=b}}function WE(a,b,c){b!==c&&(a.state=c,null!=a.na&&JE(a,b,c))}f=UE.prototype;f.gc=k;f.P=function(a,b,c){return KE(this,b,c,["Cursor: ",u.h(this.path)].join(""))};f.R=function(){return Pc(new O(null,2,5,P,[this.ea,this.path],null))};f.H=function(a,b){return b instanceof UE&&H.c(this.path,b.path)&&H.c(this.ea,b.ea)};
f.Ia=function(a,b){WE(this,this.state,b);(null!=this.ea?this.ea.o&32768||k===this.ea.oc||(this.ea.o?0:gb(Ub,this.ea)):gb(Ub,this.ea))?H.c(this.path,zd)?of(this.ea,b):pf.G(this.ea,Ef,this.path,b):this.ea.c?this.ea.c(this.path,b):this.ea.call(null,this.path,b);return b};f.sc=function(a,b){var c=this;return c.Ia(null,function(){var a=VE(c);return b.h?b.h(a):b.call(null,a)}())};f.tc=function(a,b,c){var d=this;return d.Ia(null,function(){var a=VE(d);return b.c?b.c(a,c):b.call(null,a,c)}())};
f.uc=function(a,b,c,d){var e=this;return e.Ia(null,function(){var a=VE(e);return b.j?b.j(a,c,d):b.call(null,a,c,d)}())};f.vc=function(a,b,c,d,e){return this.Ia(null,N.J(b,VE(this),c,d,e))};f.wc=function(a,b){JE(this,a,b)};f.Wb=function(a,b,c){return HE(this,b,c)};f.Xb=function(a,b){return IE(this,b)};
f.jb=function(){var a=this,b=this,c=a.state,d=function(){var d=a.fc;return null==d?(d=(null!=a.ea?a.ea.o&32768||k===a.ea.oc||(a.ea.o?0:gb(Ub,a.ea)):gb(Ub,a.ea))?function(){return function(){var b=w(a.ea);return pb(A,b,a.path)}}(d,c,b):function(){return function(){return a.ea.h?a.ea.h(a.path):a.ea.call(null,a.path)}}(d,c,b),RE(d,a.ea,a.path,b)):w(d)}();WE(b,c,d);return d};
var XE=function XE(a){if(null!=a&&null!=a.Lc)return a.Lc(a);var c=XE[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=XE._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IDisposable.dispose!",a);},YE=function YE(a,b){if(null!=a&&null!=a.ed)return a.ed(a,b);var d=YE[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=YE._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("IDisposable.add-on-dispose!",a);};
function EE(a,b,c,d){c===d||a.rb?a=null:null==a.gb?(a.rb=!0,null==LE&&(LE=[],!1===qE.Bc&&oE(qE)),a=LE.push(a)):a=!0===a.gb?NE(a,!1):a.gb.h?a.gb.h(a):a.gb.call(null,a);return a}function ZE(a,b,c,d,e,g,h,l){this.Ma=a;this.state=b;this.rb=c;this.Zc=d;this.Cb=e;this.na=g;this.gb=h;this.Dc=l;this.o=2153807872;this.I=114690}function $E(a){var b=yE;yE=null;try{return a.jb(null)}finally{yE=b}}
function NE(a,b){var c=a.state;if(t(b)){b=a.Ma;try{a.Dc=null;var d=DE(b,a)}catch(e){d=e,a.state=d,a.Dc=d,d=a.rb=!1}}else d=DE(a.Ma,a);a.Zc||(a.state=d,null==a.na||H.c(c,d)||JE(a,c,d));return d}function aF(a,b){var c=null!=b&&(b.o&64||k===b.M)?N.c(Yg,b):b;b=A.c(c,bx);var d=A.c(c,Lj),e=A.c(c,Qy);c=A.c(c,Fu);null!=b&&(a.gb=b);null!=d&&(a.bd=d);null!=e&&(a.$c=e);null!=c&&(a.Zc=c)}f=ZE.prototype;f.gc=k;f.P=function(a,b,c){return KE(this,b,c,["Reaction ",u.h(Pc(this)),":"].join(""))};f.R=function(){return ha(this)};
f.H=function(a,b){return this===b};f.Lc=function(){var a=this.state,b=this.Cb;this.gb=this.state=this.Cb=null;this.rb=!0;b=B(hh(b));for(var c=null,d=0,e=0;;)if(e<d){var g=c.N(null,e);qc(g,this);e+=1}else if(b=B(b))c=b,Td(c)?(b=wc(c),e=xc(c),c=b,d=K(b),b=e):(b=E(c),qc(b,this),b=G(c),c=null,d=0),e=0;else break;null!=this.$c&&this.$c(a);a=this.ad;if(null==a)return null;b=a.length;for(c=0;;)if(c<b)d=a[c],d.h?d.h(this):d.call(null,this),c+=1;else return null};
f.ed=function(a,b){a=this.ad;return null==a?this.ad=[b]:a.push(b)};f.Ia=function(a,b){if(!Gd(this.bd))throw Error("Assert failed: Reaction is read only; on-set is not allowed\n(fn? (.-on-set a))");a=this.state;this.state=b;this.bd(a,b);JE(this,a,b);return b};f.sc=function(a,b){var c=this;return c.Ia(null,function(){var a=$E(c);return b.h?b.h(a):b.call(null,a)}())};f.tc=function(a,b,c){var d=this;return d.Ia(null,function(){var a=$E(d);return b.c?b.c(a,c):b.call(null,a,c)}())};
f.uc=function(a,b,c,d){var e=this;return e.Ia(null,function(){var a=$E(e);return b.j?b.j(a,c,d):b.call(null,a,c,d)}())};f.vc=function(a,b,c,d,e){return this.Ia(null,N.J(b,$E(this),c,d,e))};f.wc=function(a,b){JE(this,a,b)};f.Wb=function(a,b,c){return HE(this,b,c)};f.Xb=function(a,b){a=Md(this.na);IE(this,b);return!a&&Md(this.na)&&null==this.gb?this.Lc(null):null};
f.jb=function(){var a=this.Dc;if(null!=a)throw a;(a=null==yE)&&ME();a&&null==this.gb?this.rb&&(a=this.state,this.state=this.Ma.B?this.Ma.B():this.Ma.call(null),null==this.na||H.c(a,this.state)||JE(this,a,this.state)):(FE(this),this.rb&&NE(this,!1));return this.state};
function SE(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;c=arguments[0];b=1<b.length?new D(b.slice(1),0,null):null;var e=null!=b&&(b.o&64||k===b.M)?N.c(Yg,b):b;b=A.c(e,bx);d=A.c(e,Lj);e=A.c(e,Qy);c=new ZE(c,null,!0,!1,null,null,null,null);aF(c,new p(null,3,[bx,b,Lj,d,Qy,e],null));return c}var bF=SE(null);
function cF(a,b){var c=dF,d=bF,e=DE(a,d);null!=d.Cb&&(bF=SE(null),aF(d,c),d.Ma=a,d.gb=function(){return function(){return rE.h?rE.h(b):rE.call(null,b)}}(d,e),b.cljsRatom=d);return e}function eF(a){var b={};a=CE(b,a);return new O(null,2,5,P,[a,null!=b.captured],null)};var fF={},gF,hF=aa.createReactClass;function iF(a){for(var b=va(a),c=b.length,d=Xe,e=0;;)if(e<c){var g=b[e];d=Dd.j(d,ze.h(g),a[g]);e+=1}else return d}function jF(a,b){var c=b.argv;return null==c?new O(null,2,5,P,[a.constructor,iF(b)],null):c}function kF(a){var b;if(b=Gd(a))a=null==a?null:a.prototype,b=null!=(null==a?null:a.reagentRender);return b}function lF(a){var b;if(b=Gd(a))a=null==a?null:a.prototype,b=null!=(null==a?null:a.render);return b}
if("undefined"===typeof RD||"undefined"===typeof aE||"undefined"===typeof fF||"undefined"===typeof mF)var mF=null;
function nF(a){for(;;){var b=a.reagentRender;if(ee(b))var c=null;else throw Error(["Assert failed: ",["Expected something callable, not ",Gh(L([b]))].join(""),"\n(clojure.core/ifn? f)"].join(""));var d=!0===a.cljsLegacyRender?b.call(a,a):function(){var c=jF(a,a.props);switch(K(c)){case 1:return b.call(a);case 2:return b.call(a,pd(c,1));case 3:return b.call(a,pd(c,1),pd(c,2));case 4:return b.call(a,pd(c,1),pd(c,2),pd(c,3));case 5:return b.call(a,pd(c,1),pd(c,2),pd(c,3),pd(c,4));default:return b.apply(a,
nb(c).slice(1))}}();if(Sd(d))return mF.h?mF.h(d):mF.call(null,d);if(ee(d))c=kF(d)?function(a,b,c,d){return function(){function a(a){var c=null;if(0<arguments.length){c=0;for(var d=Array(arguments.length-0);c<d.length;)d[c]=arguments[c+0],++c;c=new D(d,0,null)}return b.call(this,c)}function b(a){a=N.j(dg,d,a);return mF.h?mF.h(a):mF.call(null,a)}a.D=0;a.C=function(a){a=B(a);return b(a)};a.l=b;return a}()}(a,b,c,d):d,a.reagentRender=c;else return d}}
var dF=new p(null,1,[Fu,!0],null),pF=new p(null,1,[Hu,function(){var a=this.cljsRatom;this.cljsIsDirty=!1;return null==a?cF(function(a,c){return function(){a:{var a=gF;gF=c;try{var b=[!1];try{var g=nF(c);b[0]=!0;var h=g;break a}finally{t(b[0])||t(TD)&&(t(!1)?VD:console).error(["Error rendering component",u.h(oF.B?oF.B():oF.call(null))].join(""))}}finally{gF=a}h=void 0}return h}}(a,this),this):NE(a,!1)}],null);
function qF(a,b){var c=a instanceof q?a.U:null;switch(c){case "getDefaultProps":throw Error("getDefaultProps not supported");case "getInitialState":return function(){return function(){var a=this.cljsState;a=null!=a?a:this.cljsState=QE.h(null);return of(a,b.call(this,this))}}(a,c);case "componentWillReceiveProps":return function(){return function(a){return b.call(this,this,jF(this,a))}}(a,c);case "shouldComponentUpdate":return function(){return function(a){var c=fE;if(c)return c;c=this.props.argv;
var d=a.argv,h=null==c||null==d;if(null==b){if(h)return h;try{return Ue.c(c,d)}catch(l){return a=l,t(TD)&&(t(!1)?VD:console).warn(["Warning: Exception thrown while comparing argv's in shouldComponentUpdate: ",u.h(c)," ",u.h(d)," ",u.h(a)].join("")),!1}}else return h?b.call(this,this,jF(this,this.props),jF(this,a)):b.call(this,this,c,d)}}(a,c);case "componentWillUpdate":return function(){return function(a){return b.call(this,this,jF(this,a))}}(a,c);case "componentDidUpdate":return function(){return function(a){return b.call(this,
this,jF(this,a))}}(a,c);case "componentWillMount":return function(){return function(){this.cljsMountOrder=hE+=1;return null==b?null:b.call(this,this)}}(a,c);case "componentDidMount":return function(){return function(){return b.call(this,this)}}(a,c);case "componentWillUnmount":return function(){return function(){var a=this.cljsRatom;null!=a&&XE(a);this.cljsIsDirty=!1;return null==b?null:b.call(this,this)}}(a,c);case "componentDidCatch":return function(){return function(a,c){return b.call(this,this,
a,c)}}(a,c);default:return null}}function rF(a,b){a=qF(a,b);if(t(t(a)?b:a)&&!ee(b))throw Error(["Assert failed: ",["Expected something callable, not ",Gh(L([b]))].join(""),"\n(clojure.core/ifn? f)"].join(""));return t(a)?a:b}var sF=new p(null,3,[$s,null,tC,null,Br,null],null),tF=function(a){return function(b){return function(c){var d=A.c(w(b),c);if(null!=d)return d;d=a.h?a.h(c):a.call(null,c);pf.G(b,Dd,c,d);return d}}(nf(Xe))}(dE);
function uF(a){return je(function(a,c,d){return Dd.j(a,ze.h(tF.h?tF.h(c):tF.call(null,c)),d)},Xe,a)}
function vF(a){var b=bh(a,new O(null,3,5,P,[Hu,du,jz],null)),c=E(yg(b));if(!(0<K(b)))throw Error("Assert failed: Missing reagent-render\n(pos? (count renders))");if(1!==K(b))throw Error("Assert failed: Too many render functions supplied\n(\x3d\x3d 1 (count renders))");if(!ee(c))throw Error(["Assert failed: ",["Expected something callable, not ",Gh(L([c]))].join(""),"\n(clojure.core/ifn? render-fun)"].join(""));var d=function(){var b=du.h(a);return t(b)?b:jz.h(a)}();b=null==d;var e=t(d)?d:Hu.h(a),
g=u.h(function(){var b=wn.h(a);return t(b)?b:eE(e)}());a:switch(g){case "":c=u.h(Jh("reagent"));break a;default:c=g}d=je(function(){return function(a,b,c){return Dd.j(a,b,rF(b,c))}}(d,b,e,g,c),Xe,a);return Dd.l(d,wn,c,L([JA,!1,zk,b,du,e,Hu,Hu.h(pF)]))}function wF(a){return je(function(a,c,d){a[Ae(c)]=d;return a},{},a)}function xF(a){if(!Qd(a))throw Error("Assert failed: (map? body)");a=wF(vF(ah.l(L([sF,uF(a)]))));return hF.h?hF.h(a):hF.call(null,a)}
var yF=function yF(a){var c=function(){var c=null==a?null:a.type;return null==c?null:c.displayName}(),d=null==a?null:a["return"];c=[function(){var a=null==d?null:yF.h?yF.h(d):yF.call(null,d);return null==a?null:[u.h(a)," \x3e "].join("")}(),u.h(c)].join("");return Md(c)?null:c},zF=function zF(a){var c=function(){var c=null==a?null:a._reactInternalFiber;return t(c)?c:null==a?null:a.se}();if(t(c))return yF(c);var d=function(){var c=null==a?null:a._reactInternalInstance;if(t(c))return c;c=null==a?null:
a.te;return t(c)?c:a}(),e=function(){var a=null==d?null:d._currentElement;return t(a)?a:null==d?null:d.qe}();c=function(){var a=null==e?null:e.type;return null==a?null:a.displayName}();var g=function(){var a=null==e?null:e._owner;return t(a)?a:null==e?null:e.re}();c=[function(){var a=null==g?null:zF.h?zF.h(g):zF.call(null,g);return null==a?null:[u.h(a)," \x3e "].join("")}(),u.h(c)].join("");return Md(c)?null:c};
function oF(){var a=gF;var b=zF(a);t(b)?a=b:(a=null==a?null:a.constructor,a=null==a?null:eE(a));return Md(a)?"":[" (in ",u.h(a),")"].join("")}
function AF(a){if(!ee(a))throw Error(["Assert failed: ",["Expected something callable, not ",Gh(L([a]))].join(""),"\n(clojure.core/ifn? f)"].join(""));lF(a)&&!kF(a)&&t(TD)&&(t(!1)?VD:console).warn(["Warning: Using native React classes directly in Hiccup forms is not supported. Use create-element or adapt-react-class instead: ",u.h(function(){var b=eE(a);return Md(b)?a:b}()),oF()].join(""));if(kF(a))return a.cljsReactClass=a;var b=Jd(a);b=Dd.j(b,kv,a);b=xF(b);return a.cljsReactClass=b};function BF(a,b,c){if(se(c)){var d=N.c(ve,qf.c(a,c));return b.h?b.h(d):b.call(null,d)}return cg(c)?(d=new Yf(function(){var b=Mb(c);return a.h?a.h(b):a.call(null,b)}(),function(){var b=Nb(c);return a.h?a.h(b):a.call(null,b)}()),b.h?b.h(d):b.call(null,d)):Xd(c)?(d=uh(qf.c(a,c)),b.h?b.h(d):b.call(null,d)):Rd(c)?(d=pb(function(b,c){return yd.c(b,a.h?a.h(c):a.call(null,c))},c,c),b.h?b.h(d):b.call(null,d)):Nd(c)?(d=jf.c(Bd(c),qf.c(a,c)),b.h?b.h(d):b.call(null,d)):b.h?b.h(c):b.call(null,c)}
var CF=function CF(a,b){return BF(gf.c(CF,a),ke,a.h?a.h(b):a.call(null,b))};var DF={},EF=aa.React,FF=/([^\s\.#]+)(?:#([^\s\.#]+))?(?:\.([^\s#]+))?/;function GF(a){return a instanceof q||a instanceof Sc}function HF(a){return GF(a)||"string"===typeof a}var IF={"class":"className","for":"htmlFor",charset:"charSet"};function JF(a,b){return a.hasOwnProperty(b)?a[b]:null}function KF(a,b,c){if(GF(b)){var d=JF(IF,Ae(b));b=null==d?IF[Ae(b)]=dE(b):d}a[b]=LF.h?LF.h(c):LF.call(null,c);return a}
function LF(a){return"object"!==da(a)?a:GF(a)?Ae(a):Qd(a)?je(KF,{},a):Nd(a)?Mh(a):ee(a)?function(){function b(a){var b=null;if(0<arguments.length){b=0;for(var d=Array(arguments.length-0);b<d.length;)d[b]=arguments[b+0],++b;b=new D(d,0,null)}return c.call(this,b)}function c(b){return N.c(a,b)}b.D=0;b.C=function(a){a=B(a);return c(a)};b.l=c;return b}():Mh(a)}var MF={};function NF(a,b,c){if(GF(b)){var d=JF(MF,Ae(b));b=null==d?MF[Ae(b)]=dE(b):d}a[b]=LF(c);return a}
function OF(a){return"object"!==da(a)?a:GF(a)?Ae(a):Qd(a)?je(NF,{},a):Nd(a)?Mh(a):ee(a)?function(){function b(a){var b=null;if(0<arguments.length){b=0;for(var d=Array(arguments.length-0);b<d.length;)d[b]=arguments[b+0],++b;b=new D(d,0,null)}return c.call(this,b)}function c(b){return N.c(a,b)}b.D=0;b.C=function(a){a=B(a);return c(a)};b.l=c;return b}():Mh(a)}function PF(a,b){a=null==a?{}:a;a.key=b;return a}
function QF(a,b){var c=b.id,d=b["class"];b=null!=c&&null==qw.h(a)?Dd.j(a,qw,c):a;return t(d)?Dd.j(b,xw,function(){var b=xw.h(a);return null==b?d:[u.h(d)," ",u.h(GF(b)?Ae(b):b)].join("")}()):b}function RF(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,xw);return Nd(c)?Dd.j(b,xw,ZD(lf(function(){return function(a){return t(a)?GF(a)?Ae(a):a:null}}(a,b,b,c),c))):b}if("undefined"===typeof RD||"undefined"===typeof aE||"undefined"===typeof DF||"undefined"===typeof SF)var SF=null;
var TF=new dh(null,new p(null,6,["url",null,"tel",null,"text",null,"textarea",null,"password",null,"search",null],null),null);
function UF(a,b,c,d){var e=Xe,g=null!=e&&(e.o&64||k===e.M)?N.c(Yg,e):e,h=A.c(g,Fv);if(a===document.activeElement&&fe(TF,a.type)&&"string"===typeof b&&"string"===typeof c){var l=a.value;if(Ue.c(l,c))return pE(function(){return function(){return VF.h?VF.h(d):VF.call(null,d)}}(l,e,g,h));c=K(l)-a.selectionStart;c=K(b)-c;d.cljsDOMValue=b;a.value=b;Gd(h)&&(h.h?h.h(b):h.call(null,b));a.selectionStart=c;return a.selectionEnd=c}d.cljsDOMValue=b;a.value=b;return Gd(h)?h.h?h.h(b):h.call(null,b):null}
function VF(a){if(t(a.cljsInputLive)){a.cljsInputDirty=!1;var b=a.cljsRenderedValue,c=a.cljsDOMValue,d=SF.h?SF.h(a):SF.call(null,a);return Ue.c(b,c)?UF(d,b,c,a):null}return null}function WF(a,b,c){a.cljsDOMValue=c.target.value;t(a.cljsInputDirty)||(a.cljsInputDirty=!0,pE(function(){return VF(a)}));return b.h?b.h(c):b.call(null,c)}
function XF(a){var b=gF;if(t(function(){var b=null!=a;return b?(b=a.hasOwnProperty("onChange"),t(b)?a.hasOwnProperty("value"):b):b}())){if(!t(SF))throw Error("Assert failed: reagent.dom needs to be loaded for controlled input to work\nfind-dom-node");var c=a.value,d=null==c?"":c,e=a.onChange;t(b.cljsInputLive)||(b.cljsInputLive=!0,b.cljsDOMValue=d);b.cljsRenderedValue=d;delete a.value;a.defaultValue=d;a.onChange=function(a,c,d,e){return function(a){return WF(b,e,a)}}(a,c,d,e)}}
var YF=null,$F=new p(null,4,[py,"ReagentInput",mq,VF,zx,function(a){return a.cljsInputLive=null},kv,function(a,b,c,d){XF(c);return ZF.G?ZF.G(a,b,c,d):ZF.call(null,a,b,c,d)}],null);function aG(a){if(Qd(a))try{var b=A.c(a,em)}catch(c){b=null}else b=null;return b}function bG(a){var b=aG(Jd(a));return null==b?aG(M(a,1,null)):b}var cG={};
function dG(a,b,c){var d=a.name,e=M(b,c,null),g=null==e||Qd(e);e=QF(RF(g?e:null),a);a=t(a.custom)?OF(e):LF(e);c+=g?1:0;a:switch(d){case "input":case "textarea":g=!0;break a;default:g=!1}if(g)return g=P,null==YF&&(YF=xF($F)),b=Id(new O(null,5,5,g,[YF,b,d,a,c],null),Jd(b)),eG.h?eG.h(b):eG.call(null,b);g=aG(Jd(b));a=null==g?a:PF(a,g);return ZF.G?ZF.G(b,d,a,c):ZF.call(null,b,d,a,c)}
function fG(a){return u.h(CF(function(a){if(Gd(a)){var b=eE(a);switch(b){case "":return a;default:return Tc.h(b)}}else return a},a))}function gG(a,b){return[u.h(N.c(u,b)),": ",fG(a),"\n",oF()].join("")}
function hG(a){for(;;){if(!(0<K(a)))throw Error(["Assert failed: ",gG(a,L(["Hiccup form should not be empty"])),"\n(pos? (count v))"].join(""));var b=M(a,0,null);if(!HF(b)&&!ee(b))throw Error(["Assert failed: ",gG(a,L(["Invalid Hiccup form"])),"\n(valid-tag? tag)"].join(""));if(xe(xu,b)){b=M(a,1,null);var c=null==b||Qd(b);b=LF(c?b:null);c=1+(c?1:0);var d=bG(a);null!=d&&PF(b,d);return ZF.G?ZF.G(a,EF.Fragment,b,c):ZF.call(null,a,EF.Fragment,b,c)}if(HF(b))switch(b=Ae(b),c=b.indexOf("\x3e"),c){case -1:c=
b;b=JF(cG,c);if(null==b){b=c;var e=G(vh(FF,Ae(c)));d=M(e,0,null);var g=M(e,1,null);e=M(e,2,null);e=null==e?null:YD(e,/\./," ");if(!t(d))throw Error(["Assert failed: ",["Invalid tag: '",u.h(c),"'",oF()].join(""),"\ntag"].join(""));c={name:d,id:g,"class":e,custom:Ue.c(-1,d.indexOf("-"))};b=cG[b]=c}return dG(b,a,1);case 0:c=M(a,1,null);if(!H.c("\x3e",b))throw Error(["Assert failed: ",gG(a,L(["Invalid Hiccup tag"])),'\n(\x3d "\x3e" n)'].join(""));return dG({name:c},a,2);default:a=Id(new O(null,2,5,P,
[b.substring(0,c),Dd.j(Id(a,null),0,b.substring(c+1))],null),Jd(a))}else return c=b.cljsReactClass,b=null==c?AF(b):c,c={argv:a},a=bG(a),null!=a&&(c.key=a),EF.createElement.c?EF.createElement.c(b,c):EF.createElement.call(null,b,c)}}function eG(a){return"object"!==da(a)?a:Sd(a)?hG(a):Xd(a)?iG.h?iG.h(a):iG.call(null,a):GF(a)?Ae(a):(null!=a?a.o&2147483648||k===a.ba||(a.o?0:gb(nc,a)):gb(nc,a))?Gh(L([a])):a}mF=eG;
function iG(a){var b={},c=eF(function(b){return function(){for(var c=nb(a),d=c.length,e=0;;)if(e<d){var m=c[e];Sd(m)&&null==bG(m)&&(b["no-key"]=!0);c[e]=eG(m);e+=1}else break;return c}}(b)),d=M(c,0,null);c=M(c,1,null);t(c)&&t(TD)&&(t(!1)?VD:console).warn(["Warning: ",gG(a,L(["Reactive deref not supported in lazy seq, ","it should be wrapped in doall"]))].join(""));t(b["no-key"])&&t(TD)&&(t(!1)?VD:console).warn(["Warning: ",gG(a,L(["Every element in a seq should have a unique :key"]))].join(""));return d}
function ZF(a,b,c,d){var e=K(a)-d;switch(e){case 0:return EF.createElement.c?EF.createElement.c(b,c):EF.createElement.call(null,b,c);case 1:return a=eG(M(a,d,null)),EF.createElement.j?EF.createElement.j(b,c,a):EF.createElement.call(null,b,c,a);default:return EF.createElement.apply(null,je(function(){return function(a,b,c){b>=d&&a.push(eG(c));return a}}(e),[b,c],a))}};var jG={},kG=aa.ReactDOM;if("undefined"===typeof RD||"undefined"===typeof jG||"undefined"===typeof lG)var lG=null;if("undefined"===typeof RD||"undefined"===typeof jG||"undefined"===typeof mG)var mG=nf(Xe);
function nG(a,b){var c=fE;fE=!0;try{var d=a.B?a.B():a.call(null),e=function(){return function(){var c=fE;fE=!1;try{return pf.G(mG,Dd,b,new O(null,2,5,P,[a,b],null)),nE(qE,"afterRender"),null}finally{fE=c}}}(d,b,c,!0);return kG.render.j?kG.render.j(d,b,e):kG.render.call(null,d,b,e)}finally{fE=c}}function oG(a,b){return nG(a,b)}function pG(){var a=new O(null,1,5,P,[qG],null),b=document.getElementById("app");ME();return nG(function(){return eG(Gd(a)?a.B?a.B():a.call(null):a)},b)}
function rG(a){return kG.findDOMNode.h?kG.findDOMNode.h(a):kG.findDOMNode.call(null,a)}SF=rG;ca("reagent.core.force_update_all",function(){ME();ME();for(var a=B(yg(w(mG))),b=null,c=0,d=0;;)if(d<c){var e=b.N(null,d);N.c(oG,e);d+=1}else if(a=B(a))b=a,Td(b)?(a=wc(b),d=xc(b),b=a,c=K(a),a=d):(a=E(b),N.c(oG,a),a=G(b),b=null,c=0),d=0;else break;return nE(qE,"afterRender")});
function sG(a){if(null==a.reagentRender)throw Error(["Assert failed: ",["Expected a reagent component, not ",Gh(L([a]))].join(""),"\n(comp/reagent-component? this)"].join(""));a=a.props;var b=a.argv;null==b?a=iF(a):(a=M(b,1,null),a=Qd(a)?a:null);return a}function tG(a){return QE.h(a)}function uG(a){return pE(a)};var vG={},wG=Wg("cljs/tools/reader/impl/errors.cljs cljs/core.cljs cljs/analyzer.cljc cljs/spec/alpha.cljs cljs/spec/gen/alpha.cljc cljs/reader.cljs cljs/repl.cljs clojure/test/check.cljc cljs/pprint.cljs clojure/data.clj cljs/js.clj clojure/zip.clj cljs/analyzer/macros.clj clojure/string.clj clojure/test/check/random.clj cljs/tools/reader/reader_types.clj cljs/nodejs.cljs clojure/set.cljs cljs/pprint.cljc cljs/env.cljc clojure/test/check/random.cljs clojure/test/check/generators.cljc clojure/data.cljs cljs/env/macros.clj clojure/core/reducers.cljs cljs/tools/reader/reader_types.cljs cljs/analyzer/api.cljc cljs/spec/test/alpha.cljc cljs/core.js cljs/spec/test/alpha.cljs clojure/zip.cljs cljs/tools/reader/impl/utils.cljs clojure/test/check/properties.cljc clojure/reflect.clj cljs/test.cljs cljs/spec/gen/alpha.cljs cljs/core.cljc clojure/test/check/clojure_test.cljc cljs/tools/reader/impl/inspect.cljs cljs/tools/reader/impl/commons.cljs clojure/walk.clj cljs/repl.cljc clojure/string.cljs cljs/tagged_literals.cljc cljs/test.cljc clojure/core/reducers.clj cljs/js.cljs clojure/set.clj clojure/walk.cljs cljs/tools/reader.cljs clojure/reflect.cljs cljs/reader.clj cljs/spec/alpha.cljc".split(" "),
[new p(null,3,[Cl,"cljs/tools/reader/impl/errors.cljs",Xn,"cljs.tools.reader.impl.errors",nr,';;   Copyright (c) Russ Olsen, Nicola Mometto, Rich Hickey \x26 contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.tools.reader.impl.errors\n  (:require [cljs.tools.reader.reader-types :as types]\n            [clojure.string :as s]\n            [cljs.tools.reader.impl.inspect :as i]))\n\n(defn- ex-details\n  [rdr ex-type]\n  (let [details {:type :reader-exception\n                 :ex-kind ex-type}]\n    (if (types/indexing-reader? rdr)\n      (assoc\n       details\n       :file (types/get-file-name rdr)\n       :line (types/get-line-number rdr)\n       :col (types/get-column-number rdr))\n      details)))\n\n(defn- throw-ex\n  "Throw an ex-info error."\n  [rdr ex-type \x26 msg]\n  (let [details (ex-details rdr ex-type)\n        file (:file details)\n        line (:line details)\n        col (:col details)\n        msg1 (if file (str file " "))\n        msg2 (if line (str "[line " line ", col " col "]"))\n        msg3 (if (or msg1 msg2) " ")\n        full-msg (apply str msg1 msg2 msg3 msg)]\n    (throw (ex-info full-msg details))))\n\n(defn reader-error\n  "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided"\n  [rdr \x26 msgs]\n  (throw-ex rdr :reader-error (apply str msgs)))\n\n(defn illegal-arg-error\n  "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided"\n  [rdr \x26 msgs]\n  (throw-ex rdr :illegal-argument (apply str msgs)))\n\n(defn eof-error\n  "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided"\n  [rdr \x26 msgs]\n  (throw-ex rdr :eof (apply str msgs)))\n\n(defn throw-eof-delimited\n  ([rdr kind column line] (throw-eof-delimited rdr kind line column nil))\n  ([rdr kind line column n]\n   (eof-error\n    rdr\n    "Unexpected EOF while reading "\n    (if n\n      (str "item " n " of "))\n    (name kind)\n    (if line\n      (str ", starting at line " line " and column " column))\n    ".")))\n\n(defn throw-odd-map [rdr line col elements]\n  (reader-error\n   rdr\n   "The map literal starting with "\n   (i/inspect (first elements))\n   (if line (str " on line " line " column " col))\n   " contains "\n   (count elements)\n   " form(s). Map literals must contain an even number of forms."))\n\n(defn throw-invalid-number [rdr token]\n  (reader-error\n   rdr\n   "Invalid number: "\n   token\n   "."))\n\n(defn throw-invalid-unicode-literal [rdr token]\n  (throw\n   (illegal-arg-error\n    rdr\n    "Invalid unicode literal: \\\\"\n    token\n    ".")))\n\n(defn throw-invalid-unicode-escape [rdr ch]\n  (reader-error\n   rdr\n   "Invalid unicode escape: \\\\u"\n   ch\n   "."))\n\n(defn throw-invalid [rdr kind token]\n  (reader-error rdr "Invalid " (name kind) ": " token "."))\n\n(defn throw-eof-at-start [rdr kind]\n  (eof-error rdr "Unexpected EOF while reading start of " (name kind) "."))\n\n(defn throw-bad-char [rdr kind ch]\n  (reader-error rdr "Invalid character: " ch " found while reading " (name kind) "."))\n\n(defn throw-eof-at-dispatch [rdr]\n  (eof-error rdr "Unexpected EOF while reading dispatch character."))\n\n(defn throw-bad-dispatch [rdr ch]\n  (reader-error rdr "No dispatch macro for " ch "."))\n\n(defn throw-unmatch-delimiter [rdr ch]\n  (reader-error rdr "Unmatched delimiter " ch "."))\n\n(defn throw-eof-reading [rdr kind \x26 start]\n  (let [init (case kind :regex "#\\"" :string \\")]\n    (eof-error rdr "Unexpected EOF reading " (name kind) " starting " (apply str init start) ".")))\n\n(defn throw-no-dispatch [rdr ch]\n  (throw-bad-dispatch rdr ch))\n\n(defn throw-invalid-unicode-char[rdr token]\n  (reader-error\n   rdr\n   "Invalid unicode character \\\\"\n   token\n   "."))\n\n(defn throw-invalid-unicode-digit-in-token[rdr ch token]\n  (illegal-arg-error\n   rdr\n   "Invalid digit "\n   ch\n   " in unicode character \\\\"\n   token\n   "."))\n\n(defn throw-invalid-unicode-digit[rdr ch]\n  (illegal-arg-error\n   rdr\n   "Invalid digit "\n   ch\n   " in unicode character."))\n\n(defn throw-invalid-unicode-len[rdr actual expected]\n  (illegal-arg-error\n   rdr\n   "Invalid unicode literal. Unicode literals should be "\n   expected\n   "characters long.  "\n   "value suppled is "\n   actual\n   "characters long."))\n\n(defn throw-invalid-character-literal[rdr token]\n  (reader-error rdr "Invalid character literal \\\\u" token "."))\n\n(defn throw-invalid-octal-len[rdr token]\n  (reader-error\n   rdr\n   "Invalid octal escape sequence in a character literal:"\n   token\n   ". Octal escape sequences must be 3 or fewer digits."))\n\n(defn throw-bad-octal-number [rdr]\n  (reader-error rdr "Octal escape sequence must be in range [0, 377]."))\n\n(defn throw-unsupported-character[rdr token]\n  (reader-error\n   rdr\n   "Unsupported character: "\n   token\n   "."))\n\n(defn throw-eof-in-character [rdr]\n  (eof-error\n   rdr\n   "Unexpected EOF while reading character."))\n\n(defn throw-bad-escape-char [rdr ch]\n  (reader-error rdr "Unsupported escape character: \\\\" ch "."))\n\n(defn throw-single-colon [rdr]\n  (reader-error rdr "A single colon is not a valid keyword."))\n\n(defn throw-bad-metadata [rdr x]\n  (reader-error\n   rdr\n   "Metadata cannot be "\n   (i/inspect x)\n   ". Metadata must be a Symbol, Keyword, String or Map."))\n\n(defn throw-bad-metadata-target [rdr target]\n  (reader-error\n   rdr\n   "Metadata can not be applied to "\n   (i/inspect target)\n   ". "\n   "Metadata can only be applied to IMetas."))\n\n(defn throw-feature-not-keyword [rdr feature]\n  (reader-error\n   rdr\n   "Feature cannot be "\n   (i/inspect feature)\n   " Features must be keywords."))\n\n(defn throw-ns-map-no-map [rdr ns-name]\n  (reader-error rdr "Namespaced map with namespace " ns-name " does not specify a map."))\n\n(defn throw-bad-ns [rdr ns-name]\n  (reader-error rdr "Invalid value used as namespace in namespaced map: " ns-name "."))\n\n(defn throw-bad-reader-tag [rdr tag]\n  (reader-error\n   rdr\n   "Invalid reader tag: "\n   (i/inspect tag)\n   ". Reader tags must be symbols."))\n\n(defn throw-unknown-reader-tag [rdr tag]\n  (reader-error\n   rdr\n   "No reader function for tag "\n   (i/inspect tag)\n   "."))\n\n(defn- duplicate-keys-error [msg coll]\n  (letfn [(duplicates [seq]\n            (for [[id freq] (frequencies seq)\n                  :when (\x3e freq 1)]\n              id))]\n    (let [dups (duplicates coll)]\n      (apply str msg\n             (when (\x3e (count dups) 1) "s")\n             ": " (interpose ", " dups)))))\n\n(defn throw-dup-keys [rdr kind ks]\n  (reader-error\n   rdr\n   (duplicate-keys-error\n    (str (s/capitalize (name kind)) " literal contains duplicate key")\n    ks)))\n\n(defn throw-eof-error [rdr line]\n  (if line\n    (eof-error rdr "EOF while reading, starting at line " line ".")\n    (eof-error rdr "EOF while reading.")))\n'],
null),new p(null,3,[Cl,"cljs/core.cljs",Xn,"cljs.core",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.core\n  (:require goog.math.Long\n            goog.math.Integer\n            [goog.string :as gstring]\n            [goog.object :as gobject]\n            [goog.array :as garray]\n            [goog.Uri])\n  (:import [goog.string StringBuffer]))\n\n;; next line is auto-generated by the build-script - Do not edit!\n(def *clojurescript-version* "1.10.520")\n\n;; Setting of these Vars is in ClojureScript code is associated with intrinsics\n;; that affect compilation state, but otherwise turn into no-ops in the emitted\n;; JavaScript.\n\n;; The scope of *unchecked-if* is controlled by balanced pairs of set! calls.\n(def *unchecked-if* false)\n;; The scope of *unchecked-arrays* is file-scope: In JVM ClojureScript its side-\n;; effect is to set same-named analyzer dynamic Var, which is unset via binding\n;; scopes. In self-hosted it is cleared via cljs.js/post-file-side-effects.\n(def *unchecked-arrays* false)\n;; The scope of *warn-on-infer* is file-scope: Its side effect is to set the\n;; cljs.analyzer/*cljs-warnings* dynamic Var, which is unset via binding scopes.\n(def *warn-on-infer* false)\n\n(set! *unchecked-arrays* true)\n\n(defonce PROTOCOL_SENTINEL #js {})\n\n(def MODULE_URIS nil) ;; set by compiler\n(def MODULE_INFOS nil) ;; set by compiler\n\n(goog-define\n  ^{:dynamic true\n    :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \\"nodejs\\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option."}\n  *target* "default")\n\n(def\n  ^{:dynamic true\n    :doc "Var bound to the current namespace. Only used for bootstrapping."\n    :jsdoc ["@type {*}"]}\n  *ns* nil)\n\n(def\n  ^{:dynamic true\n    :jsdoc ["@type {*}"]}\n  *out* nil)\n\n(def\n  ^{:dynamic true}\n  *assert* true)\n\n(defonce\n  ^{:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed." :dynamic true}\n  *print-fn* nil)\n\n(defn ^{:doc "Arranges to have tap functions executed via the supplied f, a\n  function of no arguments. Returns true if successful, false otherwise." :dynamic true}\n  *exec-tap-fn*\n  [f]\n  (and\n   (exists? js/setTimeout)\n   (js/setTimeout f 0)\n   true))\n\n(defonce\n  ^{:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed." :dynamic true}\n  *print-err-fn* nil)\n\n(defn set-print-fn!\n  "Set *print-fn* to f."\n  [f] (set! *print-fn* f))\n\n(defn set-print-err-fn!\n  "Set *print-err-fn* to f."\n  [f] (set! *print-err-fn* f))\n\n(def\n  ^{:dynamic true\n    :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}\n  *flush-on-newline* true)\n\n(def\n  ^{:dynamic true\n    :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}\n  *print-newline* true)\n\n(def\n  ^{:dynamic true\n    :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}\n  *print-readably* true)\n\n(def\n  ^{:dynamic true\n    :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}\n  *print-meta* false)\n\n(def\n  ^{:dynamic true\n    :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}\n  *print-dup* false)\n\n(def\n  ^{:dynamic true\n    :doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}\n  *print-namespace-maps* false)\n\n(def\n  ^{:dynamic true\n    :doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  \'...\' to represent the remaining items. The root binding is nil\n  indicating no limit."\n    :jsdoc ["@type {null|number}"]}\n  *print-length* nil)\n\n(def\n  ^{:dynamic true\n    :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints \'#\' to represent it. The root binding\n  is nil indicating no limit."\n    :jsdoc ["@type {null|number}"]}\n  *print-level* nil)\n\n(def\n  ^{:dynamic true\n    :doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}\n  *print-fn-bodies* false)\n\n(defonce\n  ^{:dynamic true\n    :jsdoc ["@type {*}"]}\n  *loaded-libs* nil)\n\n(defn- pr-opts []\n  {:flush-on-newline *flush-on-newline*\n   :readably *print-readably*\n   :meta *print-meta*\n   :dup *print-dup*\n   :print-length *print-length*})\n\n(declare into-array)\n\n(defn enable-console-print!\n  "Set *print-fn* to console.log"\n  []\n  (set! *print-newline* false)\n  (set-print-fn!\n    (fn []\n      (let [xs (js-arguments)]\n        (.apply (.-log js/console) js/console (garray/clone xs)))))\n  (set-print-err-fn!\n    (fn []\n      (let [xs (js-arguments)]\n        (.apply (.-error js/console) js/console (garray/clone xs)))))\n  nil)\n\n(def\n  ^{:doc "bound in a repl thread to the most recent value printed"}\n  *1)\n\n(def\n  ^{:doc "bound in a repl thread to the second most recent value printed"}\n  *2)\n\n(def\n  ^{:doc "bound in a repl thread to the third most recent value printed"}\n  *3)\n\n(def\n  ^{:doc "bound in a repl thread to the most recent exception caught by the repl"}\n  *e)\n\n(defn truth_\n  "Internal - do not use!"\n  [x]\n  (cljs.core/truth_ x))\n\n(def not-native nil)\n\n(declare instance? Keyword)\n\n(defn ^boolean identical?\n  "Tests if 2 arguments are the same object"\n  [x y]\n  (cljs.core/identical? x y))\n\n(defn ^boolean nil?\n  "Returns true if x is nil, false otherwise."\n  [x]\n  (coercive-\x3d x nil))\n\n(defn ^boolean array?\n  "Returns true if x is a JavaScript array."\n  [x]\n  (if (identical? *target* "nodejs")\n    (.isArray js/Array x)\n    (instance? js/Array x)))\n\n(defn ^boolean number?\n  "Returns true if x is a JavaScript number."\n  [x]\n  (cljs.core/number? x))\n\n(defn not\n  "Returns true if x is logical false, false otherwise."\n  [x]\n  (cond\n    (nil? x) true\n    (false? x) true\n    :else false))\n\n(defn ^boolean some?\n  "Returns true if x is not nil, false otherwise."\n  [x] (not (nil? x)))\n\n(defn object?\n  "Returns true if x\'s constructor is Object"\n  [x]\n  (if-not (nil? x)\n    (identical? (.-constructor x) js/Object)\n    false))\n\n(defn ^boolean string?\n  "Returns true if x is a JavaScript string."\n  [x]\n  (goog/isString x))\n\n(defn char?\n  "Returns true if x is a JavaScript string of length one."\n  [x]\n  (and (string? x) (\x3d\x3d 1 (.-length x))))\n\n(defn any?\n  "Returns true if given any argument."\n  [x] true)\n\n(set! *unchecked-if* true)\n(defn native-satisfies?\n  "Internal - do not use!"\n  [p x]\n  (let [x (if (nil? x) nil x)]\n    (cond\n     (unchecked-get p (goog/typeOf x)) true\n     (unchecked-get p "_") true\n     :else false)))\n(set! *unchecked-if* false)\n\n(defn is_proto_\n  [x]\n  (identical? (.-prototype (.-constructor x)) x))\n\n(def\n  ^{:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}\n  *main-cli-fn* nil)\n\n(def\n  ^{:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}\n  *command-line-args* nil)\n\n(defn type\n  "Return x\'s constructor."\n  [x]\n  (when-not (nil? x)\n    (.-constructor x)))\n\n(defn missing-protocol [proto obj]\n  (let [ty (type obj)\n        ty (if (and ty (.-cljs$lang$type ty))\n             (.-cljs$lang$ctorStr ty)\n             (goog/typeOf obj))]\n   (js/Error.\n     (.join (array "No protocol method " proto\n                   " defined for type " ty ": " obj) ""))))\n\n(defn type-\x3estr [ty]\n  (if-let [s (.-cljs$lang$ctorStr ty)]\n    s\n    (str ty)))\n\n;; INTERNAL - do not use, only for Node.js\n(defn load-file [file]\n  (when-not js/COMPILED\n    (cljs.core/load-file* file)))\n\n(if (and (exists? js/Symbol)\n         (identical? (goog/typeOf js/Symbol) "function"))\n  (def ITER_SYMBOL (.-iterator js/Symbol))\n  (def ITER_SYMBOL "@@iterator"))\n\n(def ^{:jsdoc ["@enum {string}"]}\n  CHAR_MAP\n  #js {"-"    "_"\n       ":"    "_COLON_"\n       "+"    "_PLUS_"\n       "\x3e"    "_GT_"\n       "\x3c"    "_LT_"\n       "\x3d"    "_EQ_"\n       "~"    "_TILDE_"\n       "!"    "_BANG_"\n       "@"    "_CIRCA_"\n       "#"    "_SHARP_"\n       "\'"    "_SINGLEQUOTE_"\n       "\\\\\\"" "_DOUBLEQUOTE_"\n       "%"    "_PERCENT_"\n       "^"    "_CARET_"\n       "\x26"    "_AMPERSAND_"\n       "*"    "_STAR_"\n       "|"    "_BAR_"\n       "{"    "_LBRACE_"\n       "}"    "_RBRACE_"\n       "["    "_LBRACK_"\n       "]"    "_RBRACK_"\n       "/"    "_SLASH_"\n       "\\\\\\\\" "_BSLASH_"\n       "?"    "_QMARK_"})\n\n(def ^{:jsdoc ["@enum {string}"]}\n  DEMUNGE_MAP\n  #js {"_"             "-"\n       "_COLON_"       ":"\n       "_PLUS_"        "+"\n       "_GT_"          "\x3e"\n       "_LT_"          "\x3c"\n       "_EQ_"          "\x3d"\n       "_TILDE_"       "~"\n       "_BANG_"        "!"\n       "_CIRCA_"       "@"\n       "_SHARP_"       "#"\n       "_SINGLEQUOTE_" "\'"\n       "_DOUBLEQUOTE_" "\\\\\\""\n       "_PERCENT_"     "%"\n       "_CARET_"       "^"\n       "_AMPERSAND_"   "\x26"\n       "_STAR_"        "*"\n       "_BAR_"         "|"\n       "_LBRACE_"      "{"\n       "_RBRACE_"      "}"\n       "_LBRACK_"      "["\n       "_RBRACK_"      "]"\n       "_SLASH_"       "/"\n       "_BSLASH_"      "\\\\\\\\"\n       "_QMARK_"       "?"})\n\n(def DEMUNGE_PATTERN nil)\n\n(defn system-time\n  "Returns highest resolution time offered by host in milliseconds."\n  []\n  (cond\n    (and (exists? js/performance)\n         (not (nil? (. js/performance -now))))\n    (.now js/performance)\n\n    (and (exists? js/process)\n         (not (nil? (. js/process -hrtime))))\n    (let [t (.hrtime js/process)]\n      (/ (+ (* (aget t 0) 1e9) (aget t 1)) 1e6))\n\n    :else (.getTime (js/Date.))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; arrays ;;;;;;;;;;;;;;;;\n\n(declare apply)\n\n(defn ^array make-array\n  "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments."\n  ([size]\n     (js/Array. size))\n  ([type size]\n     (make-array size))\n  ([type size \x26 more-sizes]\n    (let [dims more-sizes\n          dimarray (make-array size)]\n      (dotimes [i (alength dimarray)]\n        (aset dimarray i (apply make-array nil dims)))\n      dimarray)))\n\n(defn aclone\n  "Returns a javascript array, cloned from the passed in array"\n  [arr]\n  (let [len (alength arr)\n        new-arr (make-array len)]\n    (dotimes [i len]\n      (aset new-arr i (aget arr i)))\n    new-arr))\n\n(defn ^array array\n  "Creates a new javascript array.\n@param {...*} var_args" ;;array is a special case, don\'t emulate this doc string\n  [var-args]            ;; [\x26 items]\n  (let [a (js/Array. (alength (cljs.core/js-arguments)))]\n    (loop [i 0]\n      (if (\x3c i (alength a))\n        (do\n          (aset a i (aget (cljs.core/js-arguments) i))\n          (recur (inc i)))\n        a))))\n\n(defn- maybe-warn\n  [e]\n  (when *print-err-fn*\n    (*print-err-fn* e)))\n\n(defn- checked-aget\n  ([array idx]\n   (when-assert\n     (try\n       (assert (or (array? array) (goog/isArrayLike array)))\n       (assert (number? idx))\n       (assert (not (neg? idx)))\n       (assert (\x3c idx (alength array)))\n       (catch :default e\n         (maybe-warn e))))\n   (unchecked-get array idx))\n  ([array idx \x26 idxs]\n   (apply checked-aget (checked-aget array idx) idxs)))\n\n(defn- checked-aset\n  ([array idx val]\n   (when-assert\n     (try\n       (assert (or (array? array) (goog/isArrayLike array)))\n       (assert (number? idx))\n       (assert (not (neg? idx)))\n       (assert (\x3c idx (alength array)))\n       (catch :default e\n         (maybe-warn e))))\n   (unchecked-set array idx val))\n  ([array idx idx2 \x26 idxv]\n   (apply checked-aset (checked-aget array idx) idx2 idxv)))\n\n(defn- checked-aget\'\n  ([array idx]\n   {:pre [(or (array? array) (goog/isArrayLike array))\n          (number? idx) (not (neg? idx)) (\x3c idx (alength array))]}\n   (unchecked-get array idx))\n  ([array idx \x26 idxs]\n   (apply checked-aget\' (checked-aget\' array idx) idxs)))\n\n(defn- checked-aset\'\n  ([array idx val]\n   {:pre [(or (array? array) (goog/isArrayLike array))\n          (number? idx) (not (neg? idx)) (\x3c idx (alength array))]}\n   (unchecked-set array idx val))\n  ([array idx idx2 \x26 idxv]\n   (apply checked-aset\' (checked-aget\' array idx) idx2 idxv)))\n\n(defn aget\n  "Returns the value at the index/indices. Works on JavaScript arrays."\n  ([array idx]\n     (cljs.core/aget array idx))\n  ([array idx \x26 idxs]\n     (apply aget (aget array idx) idxs)))\n\n(defn aset\n  "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val."\n  ([array idx val]\n    (cljs.core/aset array idx val))\n  ([array idx idx2 \x26 idxv]\n    (apply aset (aget array idx) idx2 idxv)))\n\n(defn ^number alength\n  "Returns the length of the array. Works on arrays of all types."\n  [array]\n  (cljs.core/alength array))\n\n(declare reduce)\n\n(defn ^array into-array\n  "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure."\n  ([aseq]\n     (into-array nil aseq))\n  ([type aseq]\n     (reduce (fn [a x] (.push a x) a) (array) aseq)))\n\n(defn js-invoke\n  "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name."\n  [obj s \x26 args]\n  (.apply (unchecked-get obj s) obj (into-array args)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;; core protocols ;;;;;;;;;;;;;\n\n(defprotocol Fn\n  "Marker protocol")\n\n(defprotocol IFn\n  "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) \x3d\x3e 2"\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q r]\n    [this a b c d e f g h i j k l m n o p q r s]\n    [this a b c d e f g h i j k l m n o p q r s t]\n    [this a b c d e f g h i j k l m n o p q r s t rest]))\n\n(defprotocol ICloneable\n  "Protocol for cloning a value."\n  (^clj -clone [value]\n    "Creates a clone of value."))\n\n(defprotocol ICounted\n  "Protocol for adding the ability to count a collection in constant time."\n  (^number -count [coll]\n    "Calculates the count of coll in constant time. Used by cljs.core/count."))\n\n(defprotocol IEmptyableCollection\n  "Protocol for creating an empty collection."\n  (-empty [coll]\n    "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty."))\n\n(defprotocol ICollection\n  "Protocol for adding to a collection."\n  (^clj -conj [coll o]\n    "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) \x3d\x3e [1 2 3 4 5]\n     (conj \'(2 3 4 5) 1) \x3d\x3e \'(1 2 3 4 5)"))\n\n#_(defprotocol IOrdinal\n    (-index [coll]))\n\n(defprotocol IIndexed\n  "Protocol for collections to provide indexed-based access to their items."\n  (-nth [coll n] [coll n not-found]\n    "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."))\n\n(defprotocol ASeq\n  "Marker protocol indicating an array sequence.")\n\n(defprotocol ISeq\n  "Protocol for collections to provide access to their items as sequences."\n  (-first [coll]\n    "Returns the first item in the collection coll. Used by cljs.core/first.")\n  (^clj -rest [coll]\n    "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) \x3d\x3e ()\n     (rest nil) \x3d\x3e ()"))\n\n(defprotocol INext\n  "Protocol for accessing the next items of a collection."\n  (^clj-or-nil -next [coll]\n    "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) \x3d\x3e nil\n     (next nil) \x3d\x3e nil"))\n\n(defprotocol ILookup\n  "Protocol for looking up a value in a data structure."\n  (-lookup [o k] [o k not-found]\n    "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."))\n\n(defprotocol IAssociative\n  "Protocol for adding associativity to collections."\n  (^boolean -contains-key? [coll k]\n    "Returns true if k is a key in coll.")\n  #_(-entry-at [coll k])\n  (^clj -assoc [coll k v]\n    "Returns a new collection of coll with a mapping from key k to\n     value v added to it."))\n\n(defprotocol IFind\n  "Protocol for implementing entry finding in collections."\n  (-find [coll k] "Returns the map entry for key, or nil if key not present."))\n\n(defprotocol IMap\n  "Protocol for adding mapping functionality to collections."\n  #_(-assoc-ex [coll k v])\n  (^clj -dissoc [coll k]\n    "Returns a new collection of coll without the mapping for key k."))\n\n(defprotocol IMapEntry\n  "Protocol for examining a map entry."\n  (-key [coll]\n    "Returns the key of the map entry.")\n  (-val [coll]\n    "Returns the value of the map entry."))\n\n(defprotocol ISet\n  "Protocol for adding set functionality to a collection."\n  (^clj -disjoin [coll v]\n    "Returns a new collection of coll that does not contain v."))\n\n(defprotocol IStack\n  "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."\n  (-peek [coll]\n    "Returns the item from the top of the stack. Is used by cljs.core/peek.")\n  (^clj -pop [coll]\n    "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."))\n\n(defprotocol IVector\n  "Protocol for adding vector functionality to collections."\n  (^clj -assoc-n [coll n val]\n    "Returns a new vector with value val added at position n."))\n\n(defprotocol IDeref\n  "Protocol for adding dereference functionality to a reference."\n  (-deref [o]\n    "Returns the value of the reference o."))\n\n(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))\n\n(defprotocol IMeta\n  "Protocol for accessing the metadata of an object."\n  (^clj-or-nil -meta [o]\n    "Returns the metadata of object o."))\n\n(defprotocol IWithMeta\n  "Protocol for adding metadata to an object."\n  (^clj -with-meta [o meta]\n    "Returns a new object with value of o and metadata meta added to it."))\n\n(defprotocol IReduce\n  "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."\n  (-reduce [coll f] [coll f start]\n    "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."))\n\n(defprotocol IKVReduce\n  "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."\n  (-kv-reduce [coll f init]\n    "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."))\n\n(defprotocol IEquiv\n  "Protocol for adding value comparison functionality to a type."\n  (^boolean -equiv [o other]\n    "Returns true if o and other are equal, false otherwise."))\n\n(defprotocol IHash\n  "Protocol for adding hashing functionality to a type."\n  (-hash [o]\n    "Returns the hash code of o."))\n\n(defprotocol ISeqable\n  "Protocol for adding the ability to a type to be transformed into a sequence."\n  (^clj-or-nil -seq [o]\n    "Returns a seq of o, or nil if o is empty."))\n\n(defprotocol ISequential\n  "Marker interface indicating a persistent collection of sequential items")\n\n(defprotocol IList\n  "Marker interface indicating a persistent list")\n\n(defprotocol IRecord\n  "Marker interface indicating a record object")\n\n(defprotocol IReversible\n  "Protocol for reversing a seq."\n  (^clj -rseq [coll]\n    "Returns a seq of the items in coll in reversed order."))\n\n(defprotocol ISorted\n  "Protocol for a collection which can represent their items\n  in a sorted manner. "\n  (^clj -sorted-seq [coll ascending?]\n    "Returns a sorted seq from coll in either ascending or descending order.")\n  (^clj -sorted-seq-from [coll k ascending?]\n    "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are \x3e or \x3e\x3d\n     than k. If ascending is false, the result should contain all items which\n     are \x3c or \x3c\x3d than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) \x3d\x3e (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) \x3d\x3e (3 2 1)")\n  (-entry-key [coll entry]\n    "Returns the key for entry.")\n  (-comparator [coll]\n    "Returns the comparator for coll."))\n\n(defprotocol IWriter\n  "Protocol for writing. Currently only implemented by StringBufferWriter."\n  (-write [writer s]\n    "Writes s with writer and returns the result.")\n  (-flush [writer]\n    "Flush writer."))\n\n(defprotocol IPrintWithWriter\n  "The old IPrintable protocol\'s implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."\n  (-pr-writer [o writer opts]))\n\n(defprotocol IPending\n  "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq."\n  (^boolean -realized? [x]\n    "Returns true if a value for x has been produced, false otherwise."))\n\n(defprotocol IWatchable\n  "Protocol for types that can be watched. Currently only implemented by Atom."\n  (-notify-watches [this oldval newval]\n    "Calls all watchers with this, oldval and newval.")\n  (-add-watch [this key f]\n    "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.")\n  (-remove-watch [this key]\n    "Removes watcher that corresponds to key from this."))\n\n(defprotocol IEditableCollection\n  "Protocol for collections which can transformed to transients."\n  (^clj -as-transient [coll]\n    "Returns a new, transient version of the collection, in constant time."))\n\n(defprotocol ITransientCollection\n  "Protocol for adding basic functionality to transient collections."\n  (^clj -conj! [tcoll val]\n    "Adds value val to tcoll and returns tcoll.")\n  (^clj -persistent! [tcoll]\n    "Creates a persistent data structure from tcoll and returns it."))\n\n(defprotocol ITransientAssociative\n  "Protocol for adding associativity to transient collections."\n  (^clj -assoc! [tcoll key val]\n    "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."))\n\n(defprotocol ITransientMap\n  "Protocol for adding mapping functionality to transient collections."\n  (^clj -dissoc! [tcoll key]\n    "Returns a new transient collection of tcoll without the mapping for key."))\n\n(defprotocol ITransientVector\n  "Protocol for adding vector functionality to transient collections."\n  (^clj -assoc-n! [tcoll n val]\n    "Returns tcoll with value val added at position n.")\n  (^clj -pop! [tcoll]\n    "Returns tcoll with the last item removed from it."))\n\n(defprotocol ITransientSet\n  "Protocol for adding set functionality to a transient collection."\n  (^clj -disjoin! [tcoll v]\n    "Returns tcoll without v."))\n\n(defprotocol IComparable\n  "Protocol for values that can be compared."\n  (^number -compare [x y]\n    "Returns a negative number, zero, or a positive number when x is logically\n     \'less than\', \'equal to\', or \'greater than\' y."))\n\n(defprotocol IChunk\n  "Protocol for accessing the items of a chunk."\n  (-drop-first [coll]\n    "Return a new chunk of coll with the first item removed."))\n\n(defprotocol IChunkedSeq\n  "Protocol for accessing a collection as sequential chunks."\n  (-chunked-first [coll]\n    "Returns the first chunk in coll.")\n  (-chunked-rest [coll]\n    "Return a new collection of coll with the first chunk removed."))\n\n(defprotocol IChunkedNext\n  "Protocol for accessing the chunks of a collection."\n  (-chunked-next [coll]\n    "Returns a new collection of coll without the first chunk."))\n\n(defprotocol INamed\n  "Protocol for adding a name."\n  (^string -name [x]\n    "Returns the name String of x.")\n  ( ^{:tag #{string clj-nil}}-namespace [x]\n    "Returns the namespace String of x."))\n\n(defprotocol IAtom\n  "Marker protocol indicating an atom.")\n\n(defprotocol IReset\n  "Protocol for adding resetting functionality."\n  (-reset! [o new-value]\n    "Sets the value of o to new-value."))\n\n(defprotocol ISwap\n  "Protocol for adding swapping functionality."\n  (-swap! [o f] [o f a] [o f a b] [o f a b xs]\n    "Swaps the value of o to be (apply f current-value-of-atom args)."))\n\n(defprotocol IVolatile\n  "Protocol for adding volatile functionality."\n  (-vreset! [o new-value]\n    "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."))\n\n(defprotocol IIterable\n  "Protocol for iterating over a collection."\n  (-iterator [coll]\n    "Returns an iterator for coll."))\n\n;; Printing support\n\n(deftype StringBufferWriter [sb]\n  IWriter\n  (-write [_ s] (.append sb s))\n  (-flush [_] nil))\n\n(defn pr-str*\n  "Support so that collections can implement toString without\n   loading all the printing machinery."\n  [^not-native obj]\n  (let [sb (StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (-pr-writer obj writer (pr-opts))\n    (-flush writer)\n    (str sb)))\n\n;;;;;;;;;;;;;;;;;;; Murmur3 ;;;;;;;;;;;;;;;\n\n;;http://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/java/lang/Integer.java\n(defn ^number int-rotate-left [x n]\n  (bit-or\n    (bit-shift-left x n)\n    (unsigned-bit-shift-right x (- n))))\n\n;; http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n(if (and (exists? Math/imul)\n         (not (zero? (Math/imul 0xffffffff 5))))\n  (defn ^number imul [a b] (Math/imul a b))\n  (defn ^number imul [a b]\n    (let [ah (bit-and (unsigned-bit-shift-right a 16) 0xffff)\n          al (bit-and a 0xffff)\n          bh (bit-and (unsigned-bit-shift-right b 16) 0xffff)\n          bl (bit-and b 0xffff)]\n      (bit-or\n        (+ (* al bl)\n           (unsigned-bit-shift-right\n             (bit-shift-left (+ (* ah bl) (* al bh)) 16) 0)) 0))))\n\n;; http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp\n(def m3-seed 0)\n(def m3-C1 (int 0xcc9e2d51))\n(def m3-C2 (int 0x1b873593))\n\n(defn ^number m3-mix-K1 [k1]\n  (-\x3e (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))\n\n(defn ^number m3-mix-H1 [h1 k1]\n  (int (-\x3e (int h1) (bit-xor (int k1)) (int-rotate-left 13) (imul 5) (+ (int 0xe6546b64)))))\n\n(defn ^number m3-fmix [h1 len]\n  (as-\x3e (int h1) h1\n    (bit-xor h1 len)\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))\n    (imul h1 (int 0x85ebca6b))\n    (bit-xor h1 (unsigned-bit-shift-right h1 13))\n    (imul h1 (int 0xc2b2ae35))\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))))\n\n(defn ^number m3-hash-int [in]\n  (if (zero? in)\n    in\n    (let [k1 (m3-mix-K1 in)\n          h1 (m3-mix-H1 m3-seed k1)]\n      (m3-fmix h1 4))))\n\n(defn ^number m3-hash-unencoded-chars [in]\n  (let [h1 (loop [i 1 h1 m3-seed]\n             (if (\x3c i (.-length in))\n               (recur (+ i 2)\n                 (m3-mix-H1 h1\n                   (m3-mix-K1\n                     (bit-or (.charCodeAt in (dec i))\n                       (bit-shift-left (.charCodeAt in i) 16)))))\n               h1))\n        h1 (if (\x3d\x3d (bit-and (.-length in) 1) 1)\n             (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (.-length in)))))\n             h1)]\n    (m3-fmix h1 (imul 2 (.-length in)))))\n\n;;;;;;;;;;;;;;;;;;; symbols ;;;;;;;;;;;;;;;\n\n(declare list Symbol \x3d compare)\n\n;; Simple caching of string hashcode\n(def string-hash-cache (js-obj))\n(def string-hash-cache-count 0)\n\n;;http://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/java/lang/String.java\n(defn hash-string* [s]\n  (if-not (nil? s)\n    (let [len (.-length s)]\n      (if (pos? len)\n        (loop [i 0 hash 0]\n          (if (\x3c i len)\n            (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n            hash))\n        0))\n    0))\n\n(defn add-to-string-hash-cache [k]\n  (let [h (hash-string* k)]\n    (gobject/set string-hash-cache k h)\n    (set! string-hash-cache-count (inc string-hash-cache-count))\n    h))\n\n(defn hash-string [k]\n  (when (\x3e string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (if (nil? k)\n    0\n    (let [h (unchecked-get string-hash-cache k)]\n      (if (number? h)\n        h\n        (add-to-string-hash-cache k)))))\n\n(defn hash\n  "Returns the hash code of its argument. Note this is the hash code\n   consistent with \x3d."\n  [o]\n  (cond\n    (implements? IHash o)\n    (bit-xor (-hash o) 0)\n\n    (number? o)\n    (if (js/isFinite o)\n      (js-mod (Math/floor o) 2147483647)\n      (case o\n        ##Inf\n        2146435072\n        ##-Inf\n        -1048576\n        2146959360))\n\n    ;; note: mirrors Clojure\'s behavior on the JVM, where the hashCode is\n    ;; 1231 for true and 1237 for false\n    ;; http://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html#hashCode%28%29\n    (true? o) 1231\n\n    (false? o) 1237\n\n    (string? o)\n    (m3-hash-int (hash-string o))\n\n    (instance? js/Date o)\n    (bit-xor (.valueOf o) 0)\n\n    (nil? o) 0\n\n    :else\n    (bit-xor (-hash o) 0)))\n\n(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed\n    (+ hash 0x9e3779b9\n      (bit-shift-left seed 6)\n      (bit-shift-right seed 2))))\n\n(defn ^boolean instance?\n  "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"\n  [c x]\n  (cljs.core/instance? c x))\n\n(defn ^boolean symbol?\n  "Return true if x is a Symbol"\n  [x]\n  (instance? Symbol x))\n\n(defn- hash-symbol [sym]\n  (hash-combine\n    (m3-hash-unencoded-chars (.-name sym))\n    (hash-string (.-ns sym))))\n\n(defn- compare-symbols [a b]\n  (cond\n   (identical? (.-str a) (.-str b)) 0\n   (and (not (.-ns a)) (.-ns b)) -1\n   (.-ns a) (if-not (.-ns b)\n              1\n              (let [nsc (garray/defaultCompare (.-ns a) (.-ns b))]\n                (if (\x3d\x3d 0 nsc)\n                  (garray/defaultCompare (.-name a) (.-name b))\n                  nsc)))\n   :default (garray/defaultCompare (.-name a) (.-name b))))\n\n(declare get)\n\n(deftype Symbol [ns name str ^:mutable _hash _meta]\n  Object\n  (toString [_] str)\n  (equiv [this other] (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Symbol other)\n      (identical? str (.-str other))\n      false))\n\n  IFn\n  (-invoke [sym coll]\n    (get coll sym))\n  (-invoke [sym coll not-found]\n    (get coll sym not-found))\n\n  IMeta\n  (-meta [_] _meta)\n\n  IWithMeta\n  (-with-meta [_ new-meta] (Symbol. ns name str _hash new-meta))\n\n  IHash\n  (-hash [sym]\n    (caching-hash sym hash-symbol _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer str)))\n\n(defn var?\n  "Returns true if v is of type cljs.core.Var"\n  [v]\n  (instance? cljs.core.Var v))\n\n(defn symbol\n  "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars."\n  ([name]\n   (cond (symbol? name) name\n         (string? name) (let [idx (.indexOf name "/")]\n                          (if (\x3c idx 1)\n                            (symbol nil name)\n                            (symbol (.substring name 0 idx)\n                                    (.substring name (inc idx) (. name -length)))))\n         (var? name) (.-sym name)\n         (keyword? name) (recur (.-fqn name))\n         :else (throw (new js/Error "no conversion to symbol"))))\n  ([ns name]\n   (let [sym-str (if-not (nil? ns)\n                   (str ns "/" name)\n                   name)]\n     (Symbol. ns name sym-str nil nil))))\n\n(deftype Var [val sym _meta]\n  Object\n  (isMacro [_]\n    (. (val) -cljs$lang$macro))\n  (toString [_]\n    (str "#\'" sym))\n  IDeref\n  (-deref [_] (val))\n  IMeta\n  (-meta [_] _meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (Var. val sym new-meta))\n  IEquiv\n  (-equiv [this other]\n    (if (instance? Var other)\n      (\x3d (.-sym this) (.-sym other))\n      false))\n  IHash\n  (-hash [_]\n    (hash-symbol sym))\n  Fn\n  IFn\n  (-invoke [_]\n    ((val)))\n  (-invoke [_ a]\n    ((val) a))\n  (-invoke [_ a b]\n    ((val) a b))\n  (-invoke [_ a b c]\n    ((val) a b c))\n  (-invoke [_ a b c d]\n    ((val) a b c d))\n  (-invoke [_ a b c d e]\n    ((val) a b c d e))\n  (-invoke [_ a b c d e f]\n    ((val) a b c d e f))\n  (-invoke [_ a b c d e f g]\n    ((val) a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    ((val) a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    ((val) a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    ((val) a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    ((val) a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    ((val) a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    ((val) a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    ((val) a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    ((val) a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    ((val) a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    ((val) a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    ((val) a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    ((val) a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    ((val) a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply (val) a b c d e f g h i j k l m n o p q r s t rest)))\n\n;;;;;;;;;;;;;;;;;;; fundamentals ;;;;;;;;;;;;;;;\n\n(declare array-seq prim-seq IndexedSeq)\n\n(defn iterable?\n  "Return true if x implements IIterable protocol."\n  [x]\n  (satisfies? IIterable x))\n\n(defn clone\n  "Clone the supplied value which must implement ICloneable."\n  [value]\n  (-clone value))\n\n(defn cloneable?\n  "Return true if x implements ICloneable protocol."\n  [value]\n  (satisfies? ICloneable value))\n\n(defn ^seq seq\n  "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? ISeqable coll)\n      (-seq coll)\n\n      (array? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0 nil))\n\n      (string? coll)\n      (when-not (zero? (.-length coll))\n        (IndexedSeq. coll 0 nil))\n\n      (native-satisfies? ISeqable coll)\n      (-seq coll)\n\n      :else (throw (js/Error. (str coll " is not ISeqable"))))))\n\n(defn first\n  "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-first coll)\n      (let [s (seq coll)]\n        (when-not (nil? s)\n          (-first s))))))\n\n(defn ^seq rest\n  "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."\n  [coll]\n  (if-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-rest coll)\n      (let [s (seq coll)]\n        (if s\n          (-rest ^not-native s)\n          ())))\n    ()))\n\n(defn ^seq next\n  "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? INext coll)\n      (-next coll)\n      (seq (rest coll)))))\n\n(defn ^boolean \x3d\n  "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure\'s immutable data\n  structures define -equiv (and thus \x3d) as a value, not an identity,\n  comparison."\n  ([x] true)\n  ([x y]\n    (if (nil? x)\n      (nil? y)\n      (or (identical? x y)\n        ^boolean (-equiv x y))))\n  ([x y \x26 more]\n     (if (\x3d x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (\x3d y (first more)))\n       false)))\n\n;; EXPERIMENTAL: subject to change\n(deftype ES6Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))\n\n(defn es6-iterator\n  "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."\n  [coll]\n  (ES6Iterator. (seq coll)))\n\n(declare es6-iterator-seq)\n\n(deftype ES6IteratorSeq [value iter ^:mutable _rest]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] value)\n  (-rest [_]\n    (when (nil? _rest)\n      (set! _rest (es6-iterator-seq iter)))\n    _rest))\n\n(defn es6-iterator-seq\n  "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."\n  [iter]\n  (let [v (.next iter)]\n    (if (.-done v)\n      ()\n      (ES6IteratorSeq. (.-value v) iter nil))))\n\n;;;;;;;;;;;;;;;;;;; Murmur3 Helpers ;;;;;;;;;;;;;;;;\n\n(defn ^number mix-collection-hash\n  "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with \x3d, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."\n  [hash-basis count]\n  (let [h1 m3-seed\n        k1 (m3-mix-K1 hash-basis)\n        h1 (m3-mix-H1 h1 k1)]\n    (m3-fmix h1 count)))\n\n(defn ^number hash-ordered-coll\n  "Returns the hash code, consistent with \x3d, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."\n  [coll]\n  (loop [n 0 hash-code 1 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n        (next coll))\n      (mix-collection-hash hash-code n))))\n\n(def ^:private empty-ordered-hash\n  (mix-collection-hash 1 0))\n\n(defn ^number hash-unordered-coll\n  "Returns the hash code, consistent with \x3d, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."\n  [coll]\n  (loop [n 0 hash-code 0 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ hash-code (hash (first coll))) 0) (next coll))\n      (mix-collection-hash hash-code n))))\n\n(def ^:private empty-unordered-hash\n  (mix-collection-hash 0 0))\n\n;;;;;;;;;;;;;;;;;;; protocols on primitives ;;;;;;;;\n(declare hash-map list equiv-sequential)\n\n(extend-type nil\n  ICounted\n  (-count [_] 0))\n\n;; TODO: we should remove this and handle date equality checking\n;; by some other means, probably by adding a new primitive type\n;; case to the hash table lookup - David\n\n(extend-type js/Date\n  IEquiv\n  (-equiv [o other]\n    (and (instance? js/Date other)\n         (\x3d\x3d (.valueOf o) (.valueOf other))))\n\n  IComparable\n  (-compare [this other]\n    (if (instance? js/Date other)\n      (garray/defaultCompare (.valueOf this) (.valueOf other))\n      (throw (js/Error. (str "Cannot compare " this " to " other))))))\n\n(defprotocol Inst\n  (inst-ms* [inst]))\n\n(extend-protocol Inst\n  js/Date\n  (inst-ms* [inst] (.getTime inst)))\n\n(defn inst-ms\n  "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT"\n  [inst]\n  (inst-ms* inst))\n\n(defn inst?\n  "Return true if x satisfies Inst"\n  [x]\n  (satisfies? Inst x))\n\n(extend-type number\n  IEquiv\n  (-equiv [x o] (identical? x o)))\n\n(declare with-meta)\n\n(extend-type function\n  Fn\n  IMeta\n  (-meta [_] nil))\n\n(extend-type default\n  IHash\n  (-hash [o]\n    (goog/getUid o)))\n\n;;this is primitive because \x26 emits call to array-seq\n(defn inc\n  "Returns a number one greater than num."\n  [x] (cljs.core/+ x 1))\n\n(declare deref)\n\n(deftype Reduced [val]\n  IDeref\n  (-deref [o] val))\n\n(defn reduced\n  "Wraps x in a way such that a reduce will terminate with the value x"\n  [x]\n  (Reduced. x))\n\n(defn reduced?\n  "Returns true if x is the result of a call to reduced"\n  [r]\n  (instance? Reduced r))\n\n(defn ensure-reduced\n  "If x is already reduced?, returns it, else returns (reduced x)"\n  [x]\n  (if (reduced? x) x (reduced x)))\n\n(defn unreduced\n  "If x is reduced?, returns (deref x), else returns x"\n  [x]\n  (if (reduced? x) (deref x) x))\n\n;; generic to all refs\n;; (but currently hard-coded to atom!)\n(defn deref\n  "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?."\n  [o]\n  (-deref o))\n\n(defn- ci-reduce\n  "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization"\n  ([cicoll f]\n     (let [cnt (-count cicoll)]\n       (if (zero? cnt)\n         (f)\n         (loop [val (-nth cicoll 0), n 1]\n           (if (\x3c n cnt)\n             (let [nval (f val (-nth cicoll n))]\n               (if (reduced? nval)\n                 @nval\n                 (recur nval (inc n))))\n             val)))))\n  ([cicoll f val]\n     (let [cnt (-count cicoll)]\n       (loop [val val, n 0]\n         (if (\x3c n cnt)\n           (let [nval (f val (-nth cicoll n))]\n             (if (reduced? nval)\n               @nval\n               (recur nval (inc n))))\n           val))))\n  ([cicoll f val idx]\n     (let [cnt (-count cicoll)]\n       (loop [val val, n idx]\n         (if (\x3c n cnt)\n           (let [nval (f val (-nth cicoll n))]\n             (if (reduced? nval)\n               @nval\n               (recur nval (inc n))))\n           val)))))\n\n(defn- array-reduce\n  ([arr f]\n     (let [cnt (alength arr)]\n       (if (zero? (alength arr))\n         (f)\n         (loop [val (aget arr 0), n 1]\n           (if (\x3c n cnt)\n             (let [nval (f val (aget arr n))]\n               (if (reduced? nval)\n                 @nval\n                 (recur nval (inc n))))\n             val)))))\n  ([arr f val]\n     (let [cnt (alength arr)]\n       (loop [val val, n 0]\n         (if (\x3c n cnt)\n           (let [nval (f val (aget arr n))]\n             (if (reduced? nval)\n               @nval\n               (recur nval (inc n))))\n           val))))\n  ([arr f val idx]\n     (let [cnt (alength arr)]\n       (loop [val val, n idx]\n         (if (\x3c n cnt)\n           (let [nval (f val (aget arr n))]\n             (if (reduced? nval)\n               @nval\n               (recur nval (inc n))))\n           val)))))\n\n(declare hash-coll cons drop count nth RSeq List)\n\n(defn counted?\n  "Returns true if coll implements count in constant time"\n  [x] (satisfies? ICounted x))\n\n(defn indexed?\n  "Returns true if coll implements nth in constant time"\n  [x] (satisfies? IIndexed x))\n\n(defn- -indexOf\n  ([coll x]\n   (-indexOf coll x 0))\n  ([coll x start]\n   (let [len (count coll)]\n     (if (\x3e\x3d start len)\n       -1\n       (loop [idx (cond\n                    (pos? start) start\n                    (neg? start) (max 0 (+ start len))\n                    :else start)]\n         (if (\x3c idx len)\n           (if (\x3d (nth coll idx) x)\n             idx\n             (recur (inc idx)))\n           -1))))))\n\n(defn- -lastIndexOf\n  ([coll x]\n   (-lastIndexOf coll x (count coll)))\n  ([coll x start]\n   (let [len (count coll)]\n    (if (zero? len)\n      -1\n      (loop [idx (cond\n                   (pos? start) (min (dec len) start)\n                   (neg? start) (+ len start)\n                   :else start)]\n        (if (\x3e\x3d idx 0)\n          (if (\x3d (nth coll idx) x)\n            idx\n            (recur (dec idx)))\n          -1))))))\n\n(deftype IndexedSeqIterator [arr ^:mutable i]\n  Object\n  (hasNext [_]\n    (\x3c i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret)))\n\n(deftype IndexedSeq [arr i meta]\n  Object\n  (toString [coll]\n   (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (IndexedSeq. arr i meta))\n\n  ISeqable\n  (-seq [this]\n    (when (\x3c i (alength arr))\n      this))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (IndexedSeq. arr i new-meta)))\n\n  ASeq\n  ISeq\n  (-first [_] (aget arr i))\n  (-rest [_] (if (\x3c (inc i) (alength arr))\n               (IndexedSeq. arr (inc i) nil)\n               (list)))\n\n  INext\n  (-next [_] (if (\x3c (inc i) (alength arr))\n               (IndexedSeq. arr (inc i) nil)\n               nil))\n\n  ICounted\n  (-count [_]\n    (max 0 (- (alength arr) i)))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (if (and (\x3c\x3d 0 i) (\x3c i (alength arr)))\n        (aget arr i)\n        (throw (js/Error. "Index out of bounds")))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (and (\x3c\x3d 0 i) (\x3c i (alength arr)))\n        (aget arr i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IIterable\n  (-iterator [coll]\n    (IndexedSeqIterator. arr i))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr i) (inc i)))\n  (-reduce [coll f start]\n    (array-reduce arr f start i))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReversible\n  (-rseq [coll]\n    (let [c (-count coll)]\n      (if (pos? c)\n        (RSeq. coll (dec c) nil)))))\n\n(es6-iterable IndexedSeq)\n\n(defn prim-seq\n  "Create seq from a primitive JavaScript Array-like."\n  ([prim]\n     (prim-seq prim 0))\n  ([prim i]\n     (when (\x3c i (alength prim))\n       (IndexedSeq. prim i nil))))\n\n(defn array-seq\n  "Create a seq from a JavaScript array."\n  ([array]\n     (prim-seq array 0))\n  ([array i]\n     (prim-seq array i)))\n\n(declare with-meta seq-reduce)\n\n(deftype RSeq [ci i meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (RSeq. ci i meta))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (RSeq. ci i new-meta)))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeq\n  (-first [coll]\n    (-nth ci i))\n  (-rest [coll]\n    (if (pos? i)\n      (RSeq. ci (dec i) nil)\n      ()))\n  \n  INext\n  (-next [coll]\n    (when (pos? i)\n      (RSeq. ci (dec i) nil)))\n\n  ICounted\n  (-count [coll] (inc i))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReduce\n  (-reduce [col f] (seq-reduce f col))\n  (-reduce [col f start] (seq-reduce f start col)))\n\n(es6-iterable RSeq)\n\n(defn second\n  "Same as (first (next x))"\n  [coll]\n  (first (next coll)))\n\n(defn ffirst\n  "Same as (first (first x))"\n  [coll]\n  (first (first coll)))\n\n(defn nfirst\n  "Same as (next (first x))"\n  [coll]\n  (next (first coll)))\n\n(defn fnext\n  "Same as (first (next x))"\n  [coll]\n  (first (next coll)))\n\n(defn nnext\n  "Same as (next (next x))"\n  [coll]\n  (next (next coll)))\n\n(defn last\n  "Return the last item in coll, in linear time"\n  [s]\n  (let [sn (next s)]\n    (if-not (nil? sn)\n      (recur sn)\n      (first s))))\n\n(extend-type default\n  IEquiv\n  (-equiv [x o] (identical? x o)))\n\n(defn conj\n  "conj[oin]. Returns a new collection with the xs\n  \'added\'. (conj nil item) returns (item).  The \'addition\' may\n  happen at different \'places\' depending on the concrete type."\n  ([] [])\n  ([coll] coll)\n  ([coll x]\n    (if-not (nil? coll)\n      (-conj coll x)\n      (list x)))\n  ([coll x \x26 xs]\n    (if xs\n      (recur (conj coll x) (first xs) (next xs))\n      (conj coll x))))\n\n(defn empty\n  "Returns an empty collection of the same category as coll, or nil"\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? IEmptyableCollection coll)\n      (-empty coll)\n\n      (satisfies? IEmptyableCollection coll)\n      (-empty coll)\n\n      :else nil)))\n\n(defn- accumulating-seq-count [coll]\n  (loop [s (seq coll) acc 0]\n    (if (counted? s) ; assumes nil is counted, which it currently is\n      (+ acc (-count s))\n      (recur (next s) (inc acc)))))\n\n(defn count\n  "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"\n  [coll]\n  (if-not (nil? coll)\n    (cond\n      (implements? ICounted coll)\n      (-count coll)\n\n      (array? coll)\n      (alength coll)\n    \n      (string? coll)\n      ^number (.-length coll)\n\n      (implements? ISeqable coll)\n      (accumulating-seq-count coll)\n\n      :else (-count coll))\n    0))\n\n(defn- linear-traversal-nth\n  ([coll n]\n     (cond\n       (nil? coll)     (throw (js/Error. "Index out of bounds"))\n       (zero? n)       (if (seq coll)\n                         (first coll)\n                         (throw (js/Error. "Index out of bounds")))\n       (indexed? coll) (-nth coll n)\n       (seq coll)      (recur (next coll) (dec n))\n       :else           (throw (js/Error. "Index out of bounds"))))\n  ([coll n not-found]\n     (cond\n       (nil? coll)     not-found\n       (zero? n)       (if (seq coll)\n                         (first coll)\n                         not-found)\n       (indexed? coll) (-nth coll n not-found)\n       (seq coll)      (recur (next coll) (dec n) not-found)\n       :else           not-found)))\n\n(defn nth\n  "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences."\n  ([coll n]\n    (cond\n      (not (number? n))\n      (throw (js/Error. "Index argument to nth must be a number"))\n\n      (nil? coll)\n      coll\n\n      (implements? IIndexed coll)\n      (-nth coll n)\n\n      (array? coll)\n      (if (and (\x3c -1 n (.-length coll)))\n        (aget coll (int n))\n        (throw (js/Error. "Index out of bounds")))\n\n      (string? coll)\n      (if (and (\x3c -1 n (.-length coll)))\n        (.charAt coll (int n))\n        (throw (js/Error. "Index out of bounds")))\n\n      (or (implements? ISeq coll)\n          (implements? ISequential coll))\n      (if (neg? n)\n        (throw (js/Error. "Index out of bounds"))\n        (linear-traversal-nth coll n))\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      :else\n      (throw (js/Error. (str "nth not supported on this type "\n                          (type-\x3estr (type coll)))))))\n  ([coll n not-found]\n    (cond\n      (not (number? n))\n      (throw (js/Error. "Index argument to nth must be a number."))\n\n      (nil? coll)\n      not-found\n\n      (implements? IIndexed coll)\n      (-nth coll n not-found)\n\n      (array? coll)\n      (if (and (\x3c -1 n (.-length coll)))\n        (aget coll (int n))\n        not-found)\n\n      (string? coll)\n      (if (and (\x3c -1 n (.-length coll)))\n        (.charAt coll (int n))\n        not-found)\n\n      (or (implements? ISeq coll)\n          (implements? ISequential coll))\n      (if (neg? n)\n        not-found\n        (linear-traversal-nth coll n not-found))\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n not-found)\n\n      :else\n      (throw (js/Error. (str "nth not supported on this type "\n                          (type-\x3estr (type coll))))))))\n\n(defn nthrest\n  "Returns the nth rest of coll, coll when n is 0."\n  [coll n]\n    (loop [n n xs coll]\n      (if-let [xs (and (pos? n) (seq xs))]\n        (recur (dec n) (rest xs))\n        xs)))\n\n(defn get\n  "Returns the value mapped to key, not-found or nil if key not present."\n  ([o k]\n    (when-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup o k)\n\n        (array? o)\n        (when (and (some? k) (\x3c k (.-length o)))\n          (aget o (int k)))\n\n        (string? o)\n        (when (and (some? k) (\x3c k (.-length o)))\n          (.charAt o (int k)))\n\n        (native-satisfies? ILookup o)\n        (-lookup o k)\n\n        :else nil)))\n  ([o k not-found]\n    (if-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup o k not-found)\n\n        (array? o)\n        (if (and (some? k) (\x3c -1 k (.-length o)))\n          (aget o (int k))\n          not-found)\n\n        (string? o)\n        (if (and (some? k) (\x3c -1 k (.-length o)))\n          (.charAt o (int k))\n          not-found)\n\n        (native-satisfies? ILookup o)\n        (-lookup o k not-found)\n\n        :else not-found)\n      not-found)))\n\n(declare PersistentHashMap PersistentArrayMap MapEntry)\n\n(defn assoc\n  "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index."\n  ([coll k v]\n    (if-not (nil? coll)\n      (-assoc coll k v)\n      (array-map k v)))\n  ([coll k v \x26 kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))\n\n(defn dissoc\n  "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s)."\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-dissoc coll k)))\n  ([coll k \x26 ks]\n    (when-not (nil? coll)\n      (let [ret (dissoc coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))\n\n(defn fn?\n  "Return true if f is a JavaScript function or satisfies the Fn protocol."\n  [f]\n  (or ^boolean (goog/isFunction f) (satisfies? Fn f)))\n\n(deftype MetaFn [afn meta]\n  IMeta\n  (-meta [_] meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (MetaFn. afn new-meta))\n  Fn\n  IFn\n  (-invoke [_]\n    (afn))\n  (-invoke [_ a]\n    (afn a))\n  (-invoke [_ a b]\n    (afn a b))\n  (-invoke [_ a b c]\n    (afn a b c))\n  (-invoke [_ a b c d]\n    (afn a b c d))\n  (-invoke [_ a b c d e]\n    (afn a b c d e))\n  (-invoke [_ a b c d e f]\n    (afn a b c d e f))\n  (-invoke [_ a b c d e f g]\n    (afn a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    (afn a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    (afn a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    (afn a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    (afn a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    (afn a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    (afn a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    (afn a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    (afn a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    (afn a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    (afn a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    (afn a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    (afn a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    (afn a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply afn a b c d e f g h i j k l m n o p q r s t rest)))\n\n(defn with-meta\n  "Returns an object of the same type and value as obj, with\n  map m as its metadata."\n  [o meta]\n  (if ^boolean (goog/isFunction o)\n    (MetaFn. o meta)\n    (when-not (nil? o)\n      (-with-meta o meta))))\n\n(defn meta\n  "Returns the metadata of obj, returns nil if there is no metadata."\n  [o]\n  (when (and (not (nil? o))\n             (satisfies? IMeta o))\n    (-meta o)))\n\n(defn peek\n  "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."\n  [coll]\n  (when-not (nil? coll)\n    (-peek coll)))\n\n(defn pop\n  "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."\n  [coll]\n  (when-not (nil? coll)\n    (-pop coll)))\n\n(defn disj\n  "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s)."\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-disjoin coll k)))\n  ([coll k \x26 ks]\n    (when-not (nil? coll)\n      (let [ret (disj coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))\n\n(defn empty?\n  "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"\n  [coll] (or (nil? coll)\n             (not (seq coll))))\n\n(defn coll?\n  "Returns true if x satisfies ICollection"\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))\n\n(defn set?\n  "Returns true if x satisfies ISet"\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))\n\n(defn associative?\n "Returns true if coll implements IAssociative"\n  [x] (satisfies? IAssociative x))\n\n(defn ifind?\n "Returns true if coll implements IFind"\n  [x] (satisfies? IFind x))\n\n(defn sequential?\n  "Returns true if coll satisfies ISequential"\n  [x] (satisfies? ISequential x))\n\n(defn sorted?\n  "Returns true if coll satisfies ISorted"\n  [x] (satisfies? ISorted x))\n\n(defn reduceable?\n  "Returns true if coll satisfies IReduce"\n  [x] (satisfies? IReduce x))\n\n(defn map?\n  "Return true if x satisfies IMap"\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))\n\n(defn record?\n  "Return true if x satisfies IRecord"\n  [x]\n  (satisfies? IRecord x))\n\n(defn vector?\n  "Return true if x satisfies IVector"\n  [x] (satisfies? IVector x))\n\n(declare ChunkedCons ChunkedSeq)\n\n(defn chunked-seq?\n  "Return true if x is satisfies IChunkedSeq."\n  [x] (implements? IChunkedSeq x))\n\n;;;;;;;;;;;;;;;;;;;; js primitives ;;;;;;;;;;;;\n(defn js-obj\n  "Create JavaSript object from an even number arguments representing\n  interleaved keys and values."\n  ([]\n     (cljs.core/js-obj))\n  ([\x26 keyvals]\n     (apply gobject/create keyvals)))\n\n(defn js-keys\n  "Return the JavaScript keys for an object."\n  [obj]\n  (gobject/getKeys obj))\n\n(defn js-delete\n  "Delete a property from a JavaScript object.\n  Returns true upon success, false otherwise."\n  [obj key]\n  (cljs.core/js-delete obj key))\n\n(defn- array-copy\n  ([from i to j len]\n    (loop [i i j j len len]\n       (if (zero? len)\n         to\n         (do (aset to j (aget from i))\n             (recur (inc i) (inc j) (dec len)))))))\n\n(defn- array-copy-downward\n  ([from i to j len]\n     (loop [i (+ i (dec len)) j (+ j (dec len)) len len]\n       (if (zero? len)\n         to\n         (do (aset to j (aget from i))\n             (recur (dec i) (dec j) (dec len)))))))\n\n;;;;;;;;;;;;;;;; preds ;;;;;;;;;;;;;;;;;;\n\n(def ^:private lookup-sentinel (js-obj))\n\n(defn ^boolean false?\n  "Returns true if x is the value false, false otherwise."\n  [x] (cljs.core/false? x))\n\n(defn ^boolean true?\n  "Returns true if x is the value true, false otherwise."\n  [x] (cljs.core/true? x))\n\n(defn boolean?\n  "Return true if x is a Boolean"\n  [x] (or (cljs.core/true? x) (cljs.core/false? x)))\n\n(defn ^boolean undefined?\n  "Returns true if x identical to the JavaScript undefined value."\n  [x]\n  (cljs.core/undefined? x))\n\n(defn seq?\n  "Return true if s satisfies ISeq"\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))\n\n(defn seqable?\n  "Return true if the seq function is supported for s"\n  [s]\n  (or\n   (nil? s)\n   (satisfies? ISeqable s)\n   (array? s)\n   (string? s)))\n\n(defn boolean\n  "Coerce to boolean"\n  [x]\n  (cond\n    (nil? x) false\n    (false? x) false\n    :else true))\n\n(defn ifn?\n  "Returns true if f returns true for fn? or satisfies IFn."\n  [f]\n  (or (fn? f) (satisfies? IFn f)))\n\n(defn integer?\n  "Returns true if n is a JavaScript number with no decimal part."\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (\x3d\x3d (js/parseFloat n) (js/parseInt n 10))))\n\n(defn int?\n  "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long."\n  [x]\n  (or (integer? x)\n      (instance? goog.math.Integer x)\n      (instance? goog.math.Long x)))\n\n(defn pos-int?\n  "Return true if x satisfies int? and is positive."\n  [x]\n  (cond\n    (integer? x) (pos? x)\n\n    (instance? goog.math.Integer x)\n    (and (not (.isNegative x))\n         (not (.isZero x)))\n\n    (instance? goog.math.Long x)\n    (and (not (.isNegative x))\n         (not (.isZero x)))\n\n    :else false))\n\n(defn ^boolean neg-int?\n  "Return true if x satisfies int? and is negative."\n  [x]\n  (cond\n    (integer? x) (neg? x)\n\n    (instance? goog.math.Integer x)\n    (.isNegative x)\n\n    (instance? goog.math.Long x)\n    (.isNegative x)\n\n    :else false))\n\n(defn nat-int?\n  "Return true if x satisfies int? and is a natural integer value."\n  [x]\n  (cond\n    (integer? x)\n    (not (neg? x))\n\n    (instance? goog.math.Integer x)\n    (not (.isNegative x))\n\n    (instance? goog.math.Long x)\n    (not (.isNegative x))\n\n    :else false))\n\n(defn float?\n  "Returns true for JavaScript numbers, false otherwise."\n  [x]\n  (number? x))\n\n(defn double?\n  "Returns true for JavaScript numbers, false otherwise."\n  [x]\n  (number? x))\n\n(defn infinite?\n  "Returns true for Infinity and -Infinity values."\n  [x]\n  (or (identical? x js/Number.POSITIVE_INFINITY)\n      (identical? x js/Number.NEGATIVE_INFINITY)))\n\n(defn contains?\n  "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. \'contains?\' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also \'some\'."\n  [coll v]\n  (if (identical? (get coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))\n\n(defn find\n  "Returns the map entry for key, or nil if key not present."\n  [coll k]\n  (if (ifind? coll)\n    (-find coll k)\n    (when (and (not (nil? coll))\n            (associative? coll)\n            (contains? coll k))\n      (MapEntry. k (get coll k) nil))))\n\n(defn ^boolean distinct?\n  "Returns true if no two of the arguments are \x3d"\n  ([x] true)\n  ([x y] (not (\x3d x y)))\n  ([x y \x26 more]\n     (if (not (\x3d x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Seq fns ;;;;;;;;;;;;;;;;\n\n(defn ^number compare\n  "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically \'less than\', \'equal to\', or \'greater than\'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."\n  [x y]\n  (cond\n   (identical? x y) 0\n\n   (nil? x) -1\n\n   (nil? y) 1\n\n   (number? x) (if (number? y)\n                 (garray/defaultCompare x y)\n                 (throw (js/Error. (str "Cannot compare " x " to " y))))\n\n   (satisfies? IComparable x)\n   (-compare x y)\n\n   :else\n   (if (and (or (string? x) (array? x) (true? x) (false? x))\n            (identical? (type x) (type y)))\n     (garray/defaultCompare x y)\n     (throw (js/Error. (str "Cannot compare " x " to " y))))))\n\n(defn ^:private compare-indexed\n  "Compare indexed collection."\n  ([xs ys]\n     (let [xl (count xs)\n           yl (count ys)]\n       (cond\n        (\x3c xl yl) -1\n        (\x3e xl yl) 1\n        (\x3d\x3d xl 0) 0\n        :else (compare-indexed xs ys xl 0))))\n  ([xs ys len n]\n     (let [d (compare (nth xs n) (nth ys n))]\n       (if (and (zero? d) (\x3c (+ n 1) len))\n         (recur xs ys len (inc n))\n         d))))\n\n(defn ^:private fn-\x3ecomparator\n  "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."\n  [f]\n  (if (\x3d f compare)\n    compare\n    (fn [x y]\n      (let [r (f x y)]\n        (if (number? r)\n          r\n          (if r\n            -1\n            (if (f y x) 1 0)))))))\n\n(declare to-array)\n\n(defn sort\n  "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare."\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure\'s stable sort, though docs don\'t promise it\n       (garray/stableSort a (fn-\x3ecomparator comp))\n       (seq a))\n     ())))\n\n(defn sort-by\n  "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare."\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn-\x3ecomparator comp) (keyfn x) (keyfn y))) coll)))\n\n; simple reduce based on seqs, used as default\n(defn- seq-reduce\n  ([f coll]\n    (if-let [s (seq coll)]\n      (reduce f (first s) (next s))\n      (f)))\n  ([f val coll]\n    (loop [val val, coll (seq coll)]\n      (if coll\n        (let [nval (f val (first coll))]\n          (if (reduced? nval)\n            @nval\n            (recur nval (next coll))))\n        val))))\n\n(declare vec)\n\n(defn shuffle\n  "Return a random permutation of coll"\n  [coll]\n  (let [a (to-array coll)]\n    (garray/shuffle a)\n    (vec a)))\n\n(defn- iter-reduce\n  ([coll f]\n   (let [iter (-iterator coll)]\n     (if (.hasNext iter)\n       (let [init (.next iter)]\n         (loop [acc init]\n           (if ^boolean (.hasNext iter)\n             (let [nacc (f acc (.next iter))]\n               (if (reduced? nacc)\n                 @nacc\n                 (recur nacc)))\n             acc)))\n       (f))))\n  ([coll f init]\n   (let [iter (-iterator coll)]\n     (loop [acc init]\n       (if ^boolean (.hasNext iter)\n         (let [nacc (f acc (.next iter))]\n           (if (reduced? nacc)\n             @nacc\n             (recur nacc)))\n         acc)))))\n\n(defn reduce\n  "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called."\n  ([f coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce coll f)\n\n       (array? coll)\n       (array-reduce coll f)\n\n       (string? coll)\n       (array-reduce coll f)\n\n       (native-satisfies? IReduce coll)\n       (-reduce coll f)\n\n       (iterable? coll)\n       (iter-reduce coll f)\n\n       :else\n       (seq-reduce f coll)))\n  ([f val coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce coll f val)\n\n       (array? coll)\n       (array-reduce coll f val)\n      \n       (string? coll)\n       (array-reduce coll f val)\n\n       (native-satisfies? IReduce coll)\n       (-reduce coll f val)\n\n       (iterable? coll)\n       (iter-reduce coll f val)\n\n       :else\n       (seq-reduce f val coll))))\n\n(defn reduce-kv\n  "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."\n  ([f init coll]\n    (if-not (nil? coll)\n      (-kv-reduce coll f init)\n      init)))\n\n(defn identity\n  "Returns its argument."\n  [x] x)\n\n(defn completing\n  "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument."\n  ([f] (completing f identity))\n  ([f cf]\n    (fn\n      ([] (f))\n      ([x] (cf x))\n      ([x y] (f x y)))))\n\n(defn transduce\n  "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with \'completing\'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items."\n  ([xform f coll] (transduce xform f (f) coll))\n  ([xform f init coll]\n     (let [f (xform f)\n           ret (reduce f init coll)]\n       (f ret))))\n\n;;; Math - variadic forms will not work until the following implemented:\n;;; first, next, reduce\n\n(defn ^number +\n  "Returns the sum of nums. (+) returns 0."\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y \x26 more]\n    (reduce + (cljs.core/+ x y) more)))\n\n(defn ^number -\n  "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y \x26 more] (reduce - (cljs.core/- x y) more)))\n\n(defn ^number *\n  "Returns the product of nums. (*) returns 1."\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y \x26 more] (reduce * (cljs.core/* x y) more)))\n\n(declare divide)\n\n(defn ^number /\n  "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."\n  ([x] (/ 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y \x26 more] (reduce / (/ x y) more)))\n\n(defn ^boolean \x3c\n  "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false."\n  ([x] true)\n  ([x y] (cljs.core/\x3c x y))\n  ([x y \x26 more]\n     (if (cljs.core/\x3c x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/\x3c y (first more)))\n       false)))\n\n(defn ^boolean \x3c\x3d\n  "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false."\n  ([x] true)\n  ([x y] (cljs.core/\x3c\x3d x y))\n  ([x y \x26 more]\n   (if (cljs.core/\x3c\x3d x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/\x3c\x3d y (first more)))\n     false)))\n\n(defn ^boolean \x3e\n  "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false."\n  ([x] true)\n  ([x y] (cljs.core/\x3e x y))\n  ([x y \x26 more]\n   (if (cljs.core/\x3e x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/\x3e y (first more)))\n     false)))\n\n(defn ^boolean \x3e\x3d\n  "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false."\n  ([x] true)\n  ([x y] (cljs.core/\x3e\x3d x y))\n  ([x y \x26 more]\n   (if (cljs.core/\x3e\x3d x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/\x3e\x3d y (first more)))\n     false)))\n\n(defn dec\n  "Returns a number one less than num."\n  [x] (- x 1))\n\n(defn ^number max\n  "Returns the greatest of the nums."\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y \x26 more]\n   (reduce max (cljs.core/max x y) more)))\n\n(defn ^number min\n  "Returns the least of the nums."\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y \x26 more]\n   (reduce min (cljs.core/min x y) more)))\n\n(defn ^number byte [x] x)\n\n(defn char\n  "Coerce to char"\n  [x]\n  (cond\n    (number? x) (.fromCharCode js/String x)\n    (and (string? x) (\x3d\x3d (.-length x) 1)) x\n    :else (throw (js/Error. "Argument to char must be a character or number"))))\n\n(defn ^number short [x] x)\n(defn ^number float [x] x)\n(defn ^number double [x] x)\n\n(defn ^number unchecked-byte [x] x)\n(defn ^number unchecked-char [x] x)\n(defn ^number unchecked-short [x] x)\n(defn ^number unchecked-float [x] x)\n(defn ^number unchecked-double [x] x)\n\n(defn ^number unchecked-add\n  "Returns the sum of nums. (+) returns 0."\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add x y))\n  ([x y \x26 more] (reduce unchecked-add (cljs.core/unchecked-add x y) more)))\n\n(defn ^number unchecked-add-int\n  "Returns the sum of nums. (+) returns 0."\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add-int x y))\n  ([x y \x26 more] (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))\n\n(defn unchecked-dec\n  "Returns a number one less than x, an int."\n  [x]\n  (cljs.core/unchecked-dec x))\n\n(defn unchecked-dec-int\n  "Returns a number one less than x, an int."\n  [x]\n  (cljs.core/unchecked-dec-int x))\n\n(defn ^number unchecked-divide-int\n  "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."\n  ([x] (unchecked-divide-int 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y \x26 more] (reduce unchecked-divide-int (unchecked-divide-int x y) more)))\n\n(defn unchecked-inc [x]\n  (cljs.core/unchecked-inc x))\n\n(defn unchecked-inc-int [x]\n  (cljs.core/unchecked-inc-int x))\n\n(defn ^number unchecked-multiply\n  "Returns the product of nums. (*) returns 1."\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply x y))\n  ([x y \x26 more] (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))\n\n(defn ^number unchecked-multiply-int\n  "Returns the product of nums. (*) returns 1."\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply-int x y))\n  ([x y \x26 more] (reduce unchecked-multiply-int (cljs.core/unchecked-multiply-int x y) more)))\n\n(defn unchecked-negate [x]\n  (cljs.core/unchecked-negate x))\n\n(defn unchecked-negate-int [x]\n  (cljs.core/unchecked-negate-int x))\n\n(declare mod)\n\n(defn unchecked-remainder-int [x n]\n  (cljs.core/unchecked-remainder-int x n))\n\n(defn ^number unchecked-subtract\n  "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y \x26 more] (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))\n\n(defn ^number unchecked-subtract-int\n  "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y \x26 more] (reduce unchecked-subtract-int (cljs.core/unchecked-subtract-int x y) more)))\n\n(defn- ^number fix [q]\n  (if (\x3e\x3d q 0)\n    (Math/floor q)\n    (Math/ceil q)))\n\n(defn int\n  "Coerce to int by stripping decimal places."\n  [x]\n  (bit-or x 0))\n\n(defn unchecked-int\n  "Coerce to int by stripping decimal places."\n  [x]\n  (fix x))\n\n(defn long\n  "Coerce to long by stripping decimal places. Identical to `int\'."\n  [x]\n  (fix x))\n\n(defn unchecked-long\n  "Coerce to long by stripping decimal places. Identical to `int\'."\n  [x]\n  (fix x))\n\n(defn booleans [x] x)\n(defn bytes [x] x)\n(defn chars [x] x)\n(defn shorts [x] x)\n(defn ints [x] x)\n(defn floats [x] x)\n(defn doubles [x] x)\n(defn longs [x] x)\n\n(defn js-mod\n  "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"\n  [n d]\n  (cljs.core/js-mod n d))\n\n(defn mod\n  "Modulus of num and div. Truncates toward negative infinity."\n  [n d]\n  (js-mod (+ (js-mod n d) d) d))\n\n(defn quot\n  "quot[ient] of dividing numerator by denominator."\n  [n d]\n  (let [rem (js-mod n d)]\n    (fix (/ (- n rem) d))))\n\n(defn rem\n  "remainder of dividing numerator by denominator."\n  [n d]\n  (let [q (quot n d)]\n    (- n (* d q))))\n\n(defn bit-xor\n  "Bitwise exclusive or"\n  ([x y] (cljs.core/bit-xor x y))\n  ([x y \x26 more]\n     (reduce bit-xor (cljs.core/bit-xor x y) more)))\n\n(defn bit-and\n  "Bitwise and"\n  ([x y] (cljs.core/bit-and x y))\n  ([x y \x26 more]\n     (reduce bit-and (cljs.core/bit-and x y) more)))\n\n(defn bit-or\n  "Bitwise or"\n  ([x y] (cljs.core/bit-or x y))\n  ([x y \x26 more]\n     (reduce bit-or (cljs.core/bit-or x y) more)))\n\n(defn bit-and-not\n  "Bitwise and with complement"\n  ([x y] (cljs.core/bit-and-not x y))\n  ([x y \x26 more]\n     (reduce bit-and-not (cljs.core/bit-and-not x y) more)))\n\n(defn bit-clear\n  "Clear bit at index n"\n  [x n]\n  (cljs.core/bit-clear x n))\n\n(defn bit-flip\n  "Flip bit at index n"\n  [x n]\n  (cljs.core/bit-flip x n))\n\n(defn bit-not\n  "Bitwise complement"\n  [x] (cljs.core/bit-not x))\n\n(defn bit-set\n  "Set bit at index n"\n  [x n]\n  (cljs.core/bit-set x n))\n\n(defn ^boolean bit-test\n  "Test bit at index n"\n  [x n]\n  (cljs.core/bit-test x n))\n\n(defn bit-shift-left\n  "Bitwise shift left"\n  [x n] (cljs.core/bit-shift-left x n))\n\n(defn bit-shift-right\n  "Bitwise shift right"\n  [x n] (cljs.core/bit-shift-right x n))\n\n(defn bit-shift-right-zero-fill\n  "DEPRECATED: Bitwise shift right with zero fill"\n  [x n] (cljs.core/bit-shift-right-zero-fill x n))\n\n(defn unsigned-bit-shift-right\n  "Bitwise shift right with zero fill"\n  [x n] (cljs.core/unsigned-bit-shift-right x n))\n\n(defn bit-count\n  "Counts the number of bits set in n"\n  [v]\n  (let [v (- v (bit-and (bit-shift-right v 1) 0x55555555))\n        v (+ (bit-and v 0x33333333) (bit-and (bit-shift-right v 2) 0x33333333))]\n    (bit-shift-right (* (bit-and (+ v (bit-shift-right v 4)) 0xF0F0F0F) 0x1010101) 24)))\n\n(defn ^boolean \x3d\x3d\n  "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined."\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y \x26 more]\n   (if (\x3d\x3d x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (\x3d\x3d y (first more)))\n     false)))\n\n(defn ^boolean pos?\n  "Returns true if num is greater than zero, else false"\n  [x] (cljs.core/pos? x))\n\n(defn ^boolean zero?\n  "Returns true if num is zero, else false"\n  [x]\n  (cljs.core/zero? x))\n\n(defn ^boolean neg?\n  "Returns true if num is less than zero, else false"\n  [x] (cljs.core/neg? x))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; protocols for host types ;;;;;;\n\n(defn nthnext\n  "Returns the nth next of coll, (seq coll) when n is 0."\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;; basics ;;;;;;;;;;;;;;;;;;\n\n(defn str\n  "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."\n  ([] "")\n  ([x] (if (nil? x)\n         ""\n         (.join #js [x] "")))\n  ([x \x26 ys]\n    (loop [sb (StringBuffer. (str x)) more ys]\n      (if more\n        (recur (. sb  (append (str (first more)))) (next more))\n        (.toString sb)))))\n\n(defn subs\n  "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive."\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))\n\n(declare map name)\n\n(defn- equiv-sequential\n  "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."\n  [x y]\n  (boolean\n    (when (sequential? y)\n      (if (and (counted? x) (counted? y)\n               (not (\x3d\x3d (count x) (count y))))\n        false\n        (loop [xs (seq x) ys (seq y)]\n          (cond (nil? xs) (nil? ys)\n            (nil? ys) false\n            (\x3d (first xs) (first ys)) (recur (next xs) (next ys))\n            :else false))))))\n\n(defn- hash-coll [coll]\n  (if (seq coll)\n    (loop [res (hash (first coll)) s (next coll)]\n      (if (nil? s)\n        res\n        (recur (hash-combine res (hash (first s))) (next s))))\n    0))\n\n(declare key val)\n\n(defn- hash-imap [m]\n  ;; a la clojure.lang.APersistentMap\n  (loop [h 0 s (seq m)]\n    (if s\n      (let [e (first s)]\n        (recur (js-mod (+ h (bit-xor (hash (key e)) (hash (val e))))\n                    4503599627370496)\n               (next s)))\n      h)))\n\n(defn- hash-iset [s]\n  ;; a la clojure.lang.APersistentSet\n  (loop [h 0 s (seq s)]\n    (if s\n      (let [e (first s)]\n        (recur (js-mod (+ h (hash e)) 4503599627370496)\n               (next s)))\n      h)))\n\n(declare name chunk-first chunk-rest)\n\n(defn- extend-object!\n  "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript\'s implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."\n  [obj fn-map]\n  (doseq [[key-name f] fn-map]\n    (let [str-name (name key-name)]\n      (gobject/set obj str-name f)))\n  obj)\n\n;;;;;;;;;;;;;;;; cons ;;;;;;;;;;;;;;;;\n(deftype List [meta first rest count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x count))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IList\n\n  ICloneable\n  (-clone [_] (List. meta first rest count __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (List. new-meta first rest count __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll]\n    (if (\x3d\x3d count 1)\n      ()\n      rest))\n\n  INext\n  (-next [coll]\n    (if (\x3d\x3d count 1)\n      nil\n      rest))\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(defn list?\n  "Returns true if x implements IList"\n  [x]\n  (satisfies? IList x))\n\n(es6-iterable List)\n\n(deftype EmptyList [meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IList\n\n  ICloneable\n  (-clone [_] (EmptyList. meta))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (EmptyList. new-meta)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] ())\n\n  INext\n  (-next [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] (throw (js/Error. "Can\'t pop empty list")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1 nil))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (or (list? other)\n            (sequential? other))\n      (nil? (seq other))\n      false))\n\n  IHash\n  (-hash [coll] empty-ordered-hash)\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(set! (.-EMPTY List) (EmptyList. nil))\n\n(es6-iterable EmptyList)\n\n(defn reversible?\n  "Returns true if coll satisfies? IReversible."\n  [coll]\n  (satisfies? IReversible coll))\n\n(defn ^seq rseq\n  "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"\n  [rev]\n  (-rseq rev))\n\n(defn reverse\n  "Returns a seq of the items in coll in reverse order. Not lazy."\n  [coll]\n  (if (reversible? coll)\n    (or (rseq coll) ())\n    (reduce conj () coll)))\n\n(defn list\n  "Creates a new list containing the items."\n  [\x26 xs]\n  (let [arr (if (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n              (.-arr xs)\n              (let [arr (array)]\n                (loop [^not-native xs xs]\n                  (if-not (nil? xs)\n                    (do\n                      (.push arr (-first xs))\n                      (recur (-next xs)))\n                    arr))))]\n    (loop [i (alength arr) r ()]\n      (if (\x3e i 0)\n        (recur (dec i) (-conj r (aget arr (dec i))))\n        r))))\n\n(deftype Cons [meta first rest ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IList\n\n  ICloneable\n  (-clone [_] (Cons. meta first rest __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Cons. new-meta first rest __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  INext\n  (-next [coll]\n    (if (nil? rest) nil (seq rest)))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll nil))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n  \n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable Cons)\n\n(defn cons\n  "Returns a new seq where x is the first element and coll is the rest."\n  [x coll]\n  (cond\n    (nil? coll)             (List. nil x nil 1 nil)\n    (implements? ISeq coll) (Cons. nil x coll nil)\n    :default                (Cons. nil x (seq coll) nil)))\n\n(defn hash-keyword [k]\n  (int (+ (hash-symbol k) 0x9e3779b9)))\n\n(defn- compare-keywords [a b]\n  (cond\n   (identical? (.-fqn a) (.-fqn b)) 0\n   (and (not (.-ns a)) (.-ns b)) -1\n   (.-ns a) (if-not (.-ns b)\n              1\n              (let [nsc (garray/defaultCompare (.-ns a) (.-ns b))]\n                (if (\x3d\x3d 0 nsc)\n                  (garray/defaultCompare (.-name a) (.-name b))\n                  nsc)))\n   :default (garray/defaultCompare (.-name a) (.-name b))))\n\n(deftype Keyword [ns name fqn ^:mutable _hash]\n  Object\n  (toString [_] (str ":" fqn))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Keyword other)\n      (identical? fqn (.-fqn other))\n      false))\n  IFn\n  (-invoke [kw coll]\n    (get coll kw))\n  (-invoke [kw coll not-found]\n    (get coll kw not-found))\n\n  IHash\n  (-hash [this]\n    (caching-hash this hash-keyword _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer (str ":" fqn))))\n\n(defn keyword?\n  "Return true if x is a Keyword"\n  [x]\n  (instance? Keyword x))\n\n(defn keyword-identical?\n  "Efficient test to determine that two keywords are identical."\n  [x y]\n  (if (identical? x y)\n    true\n    (if (and (keyword? x) (keyword? y))\n      (identical? (.-fqn x) (.-fqn y))\n      false)))\n\n(defn symbol-identical?\n  "Efficient test to determine that two symbols are identical."\n  [x y]\n  (if (identical? x y)\n    true\n    (if (and (symbol? x) (symbol? y))\n      (identical? (.-str x) (.-str y))\n      false)))\n\n(defn namespace\n  "Returns the namespace String of a symbol or keyword, or nil if not present."\n  [x]\n  (if (implements? INamed x)\n    (-namespace x)\n    (throw (js/Error. (str "Doesn\'t support namespace: " x)))))\n\n(defn ident?\n  "Return true if x is a symbol or keyword"\n  [x] (or (keyword? x) (symbol? x)))\n\n(defn simple-ident?\n  "Return true if x is a symbol or keyword without a namespace"\n  [x] (and (ident? x) (nil? (namespace x))))\n\n(defn qualified-ident?\n  "Return true if x is a symbol or keyword with a namespace"\n  [x] (boolean (and (ident? x) (namespace x) true)))\n\n(defn simple-symbol?\n  "Return true if x is a symbol without a namespace"\n  [x] (and (symbol? x) (nil? (namespace x))))\n\n(defn qualified-symbol?\n  "Return true if x is a symbol with a namespace"\n  [x] (boolean (and (symbol? x) (namespace x) true)))\n\n(defn simple-keyword?\n  "Return true if x is a keyword without a namespace"\n  [x] (and (keyword? x) (nil? (namespace x))))\n\n(defn qualified-keyword?\n  "Return true if x is a keyword with a namespace"\n  [x] (boolean (and (keyword? x) (namespace x) true)))\n\n(defn keyword\n  "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically."\n  ([name] (cond\n            (keyword? name) name\n            (symbol? name) (Keyword.\n                             (cljs.core/namespace name)\n                             (cljs.core/name name) (.-str name) nil)\n            (string? name) (let [parts (.split name "/")]\n                             (if (\x3d\x3d (alength parts) 2)\n                               (Keyword. (aget parts 0) (aget parts 1) name nil)\n                               (Keyword. nil (aget parts 0) name nil)))))\n  ([ns name]\n   (let [ns   (cond\n                (keyword? ns) (cljs.core/name ns)\n                (symbol? ns)  (cljs.core/name ns)\n                :else ns)\n         name (cond\n                (keyword? name) (cljs.core/name name)\n                (symbol? name) (cljs.core/name name)\n                :else name)]\n     (Keyword. ns name (str (when ns (str ns "/")) name) nil))))\n\n\n(deftype LazySeq [meta ^:mutable fn ^:mutable s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (sval [coll]\n    (if (nil? fn)\n      s\n      (do\n        (set! s (fn))\n        (set! fn nil)\n        s)))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IPending\n  (-realized? [coll]\n    (not fn))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (LazySeq. new-meta #(-seq coll) nil __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (first s)))\n  (-rest [coll]\n    (-seq coll)\n    (if-not (nil? s)\n      (rest s)\n      ()))\n\n  INext\n  (-next [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (next s)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (.sval coll)\n    (when-not (nil? s)\n      (loop [ls s]\n        (if (instance? LazySeq ls)\n          (recur (.sval ls))\n          (do (set! s ls)\n            (seq s))))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable LazySeq)\n\n(declare ArrayChunk)\n\n(deftype ChunkBuffer [^:mutable buf ^:mutable end]\n  Object\n  (add [_ o]\n    (aset buf end o)\n    (set! end (inc end)))\n\n  (chunk [_]\n    (let [ret (ArrayChunk. buf 0 end)]\n      (set! buf nil)\n      ret))\n\n  ICounted\n  (-count [_] end))\n\n(defn chunk-buffer [capacity]\n  (ChunkBuffer. (make-array capacity) 0))\n\n(deftype ArrayChunk [arr off end]\n  ICounted\n  (-count [_] (- end off))\n\n  IIndexed\n  (-nth [coll i]\n    (aget arr (+ off i)))\n  (-nth [coll i not-found]\n    (if (and (\x3e\x3d i 0) (\x3c i (- end off)))\n      (aget arr (+ off i))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (\x3d\x3d off end)\n      (throw (js/Error. "-drop-first of empty chunk"))\n      (ArrayChunk. arr (inc off) end)))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr off) (inc off)))\n  (-reduce [coll f start]\n    (array-reduce arr f start off)))\n\n(defn array-chunk\n  ([arr]\n     (ArrayChunk. arr 0 (alength arr)))\n  ([arr off]\n     (ArrayChunk. arr off (alength arr)))\n  ([arr off end]\n     (ArrayChunk. arr off end)))\n\n(deftype ChunkedCons [chunk more meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (ChunkedCons. chunk more new-meta __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ASeq\n  ISeq\n  (-first [coll] (-nth chunk 0))\n  (-rest [coll]\n    (if (\x3e (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more nil nil)\n      (if (nil? more)\n        ()\n        more)))\n\n  INext\n  (-next [coll]\n    (if (\x3e (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more nil nil)\n      (when-not (nil? more)\n        (-seq more))))\n\n  IChunkedSeq\n  (-chunked-first [coll] chunk)\n  (-chunked-rest [coll]\n    (if (nil? more)\n      ()\n      more))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (if (nil? more)\n      nil\n      more))\n\n  ICollection\n  (-conj [this o]\n    (cons o this))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash)))\n\n(es6-iterable ChunkedCons)\n\n(defn chunk-cons [chunk rest]\n  (if (zero? (-count chunk))\n    rest\n    (ChunkedCons. chunk rest nil nil)))\n\n(defn chunk-append [b x]\n  (.add b x))\n\n(defn chunk [b]\n  (.chunk b))\n\n(defn chunk-first [s]\n  (-chunked-first s))\n\n(defn chunk-rest [s]\n  (-chunked-rest s))\n\n(defn chunk-next [s]\n  (if (implements? IChunkedNext s)\n    (-chunked-next s)\n    (seq (-chunked-rest s))))\n\n;;;;;;;;;;;;;;;;\n\n(defn to-array\n  "Returns an array containing the contents of coll."\n  [coll]\n  (let [ary (array)]\n    (loop [s (seq coll)]\n      (if-not (nil? s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))\n\n(defn to-array-2d\n  "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."\n  [coll]\n    (let [ret (make-array (count coll))]\n      (loop [i 0 xs (seq coll)]\n        (when-not (nil? xs)\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))\n\n(defn int-array\n  "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure."\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (int-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (\x3c i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))\n\n(defn long-array\n  "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure."\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (long-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (\x3c i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))\n\n(defn double-array\n  "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure."\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (double-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (\x3c i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))\n\n(defn object-array\n  "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure."\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (object-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (\x3c i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))\n\n(defn bounded-count\n  "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq"\n  {:added "1.9"}\n  [n coll]\n  (if (counted? coll)\n    (count coll)\n    (loop [i 0 s (seq coll)]\n      (if (and (not (nil? s)) (\x3c i n))\n        (recur (inc i) (next s))\n        i))))\n\n(defn spread\n  [arglist]\n  (when-not (nil? arglist)\n    (let [n (next arglist)]\n      (if (nil? n)\n        (seq (first arglist))\n        (cons (first arglist)\n              (spread n))))))\n\n(defn concat\n  "Returns a lazy seq representing the concatenation of the elements in the supplied colls."\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y \x26 zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))\n\n(defn list*\n  "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence."\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d \x26 more]\n     (cons a (cons b (cons c (cons d (spread more)))))))\n\n\n;;; Transients\n\n(defn transient\n  "Returns a new, transient version of the collection, in constant time."\n  [coll]\n  (-as-transient coll))\n\n(defn persistent!\n  "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."\n  [tcoll]\n  (-persistent! tcoll))\n\n(defn conj!\n  "Adds val to the transient collection, and return tcoll. The \'addition\'\n  may happen at different \'places\' depending on the concrete type."\n  ([] (transient []))\n  ([tcoll] tcoll)\n  ([tcoll val]\n    (-conj! tcoll val))\n  ([tcoll val \x26 vals]\n    (let [ntcoll (-conj! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))\n\n(defn assoc!\n  "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be \x3c\x3d (count vector). Returns coll."\n  ([tcoll key val]\n    (-assoc! tcoll key val))\n  ([tcoll key val \x26 kvs]\n    (let [ntcoll (-assoc! tcoll key val)]\n      (if kvs\n        (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n        ntcoll))))\n\n(defn dissoc!\n  "Returns a transient map that doesn\'t contain a mapping for key(s)."\n  ([tcoll key]\n    (-dissoc! tcoll key))\n  ([tcoll key \x26 ks]\n    (let [ntcoll (-dissoc! tcoll key)]\n      (if ks\n        (recur ntcoll (first ks) (next ks))\n        ntcoll))))\n\n(defn pop!\n  "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll"\n  [tcoll]\n  (-pop! tcoll))\n\n(defn disj!\n  "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s)."\n  ([tcoll val]\n    (-disjoin! tcoll val))\n  ([tcoll val \x26 vals]\n    (let [ntcoll (-disjoin! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; apply ;;;;;;;;;;;;;;;;\n\n;; see core.clj\n(gen-apply-to)\n\n(set! *unchecked-if* true)\n\n(defn- ^seq next*\n  "Internal. DO NOT USE! Next without the nil? check."\n  [coll]\n  (if (implements? INext coll)\n    (-next ^not-native coll)\n    (seq (rest coll))))\n\n(defn- apply-to-simple\n  "Internal. DO NOT USE!\n  Assumes args was already called with seq beforehand!"\n  ([f ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$0 f)\n       (.cljs$core$IFn$_invoke$arity$0 f)\n       (.call f f))\n     (apply-to-simple f (-first args) (next* args))))\n  ([f a0 ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$1 f)\n       (.cljs$core$IFn$_invoke$arity$1 f a0)\n       (.call f f a0))\n     (apply-to-simple f a0 (-first args) (next* args))))\n  ([f a0 a1 ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$2 f)\n       (.cljs$core$IFn$_invoke$arity$2 f a0 a1)\n       (.call f f a0 a1))\n     (apply-to-simple f a0 a1 (-first args) (next* args))))\n  ([f a0 a1 a2 ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$3 f)\n       (.cljs$core$IFn$_invoke$arity$3 f a0 a1 a2)\n       (.call f f a0 a1 a2))\n     (apply-to-simple f a0 a1 a2 (-first args) (next* args))))\n  ([f a0 a1 a2 a3 ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$4 f)\n       (.cljs$core$IFn$_invoke$arity$4 f a0 a1 a2 a3)\n       (.call f f a0 a1 a2 a3))\n     (gen-apply-to-simple f 4 args))))\n\n(defn apply\n  "Applies fn f to the argument list formed by prepending intervening arguments to args."\n  ([f args]\n   (if (.-cljs$lang$applyTo f)\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (bounded-count (inc fixed-arity) args)]\n       (if (\x3c\x3d bc fixed-arity)\n         (apply-to f bc args)\n         (.cljs$lang$applyTo f args)))\n     (apply-to-simple f (seq args))))\n  ([f x args]\n   (if (.-cljs$lang$applyTo f)\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (inc (bounded-count fixed-arity args))]\n       (if (\x3c\x3d bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f x (seq args))))\n  ([f x y args]\n   (if (.-cljs$lang$applyTo f)\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (+ 2 (bounded-count (dec fixed-arity) args))]\n       (if (\x3c\x3d bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f x y (seq args))))\n  ([f x y z args]\n   (if (.-cljs$lang$applyTo f)\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (+ 3 (bounded-count (- fixed-arity 2) args))]\n       (if (\x3c\x3d bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f x y z (seq args))))\n  ([f a b c d \x26 args]\n   (if (.-cljs$lang$applyTo f)\n     (let [spread-args (spread args)\n           arglist (cons a (cons b (cons c (cons d spread-args))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (+ 4 (bounded-count (- fixed-arity 3) spread-args))]\n       (if (\x3c\x3d bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f a b c d (spread args)))))\n\n(set! *unchecked-if* false)\n\n(defn vary-meta\n "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata."\n  ([obj f]\n   (with-meta obj (f (meta obj))))\n  ([obj f a]\n   (with-meta obj (f (meta obj) a)))\n  ([obj f a b]\n   (with-meta obj (f (meta obj) a b)))\n  ([obj f a b c]\n   (with-meta obj (f (meta obj) a b c)))\n  ([obj f a b c d]\n   (with-meta obj (f (meta obj) a b c d)))\n  ([obj f a b c d \x26 args]\n   (with-meta obj (apply f (meta obj) a b c d args))))\n\n(defn ^boolean not\x3d\n  "Same as (not (\x3d obj1 obj2))"\n  ([x] false)\n  ([x y] (not (\x3d x y)))\n  ([x y \x26 more]\n   (not (apply \x3d x y more))))\n\n(defn not-empty\n  "If coll is empty, returns nil, else coll"\n  [coll] (when (seq coll) coll))\n\n(defn nil-iter []\n  (reify\n    Object\n    (hasNext [_] false)\n    (next [_] (js/Error. "No such element"))\n    (remove [_] (js/Error. "Unsupported operation"))))\n\n(deftype StringIter [s ^:mutable i]\n  Object\n  (hasNext [_] (\x3c i (.-length s)))\n  (next [_]\n    (let [ret (.charAt s i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. "Unsupported operation")))\n\n(defn string-iter [x]\n  (StringIter. x 0))\n\n(deftype ArrayIter [arr ^:mutable i]\n  Object\n  (hasNext [_] (\x3c i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. "Unsupported operation")))\n\n(defn array-iter [x]\n  (ArrayIter. x 0))\n\n(def INIT #js {})\n(def START #js {})\n\n(deftype SeqIter [^:mutable _seq ^:mutable _next]\n  Object\n  (hasNext [_]\n    (if (identical? _seq INIT)\n      (do\n        (set! _seq START)\n        (set! _next (seq _next)))\n      (if (identical? _seq _next)\n        (set! _next (next _seq))))\n    (not (nil? _next)))\n  (next [this]\n    (if-not ^boolean (.hasNext this)\n      (throw (js/Error. "No such element"))\n      (do\n        (set! _seq _next)\n        (first _next))))\n  (remove [_] (js/Error. "Unsupported operation")))\n\n(defn seq-iter [coll]\n  (SeqIter. INIT coll))\n\n(defn iter [coll]\n  (cond\n    (iterable? coll) (-iterator coll)\n    (nil? coll) (nil-iter)\n    (string? coll) (string-iter coll)\n    (array? coll) (array-iter coll)\n    (seqable? coll) (seq-iter coll)\n    :else (throw (js/Error. (str "Cannot create iterator from " coll)))))\n\n(deftype Many [vals]\n  Object\n  (add [this o]\n    (.push vals o)\n    this)\n  (remove [this]\n    (.shift vals))\n  (isEmpty [this]\n    (zero? (.-length vals)))\n  (toString [this]\n    (str "Many: " vals)))\n\n(def ^:private NONE #js {})\n\n(deftype Single [^:mutable val]\n  Object\n  (add [this o]\n    (if (identical? val NONE)\n      (do\n        (set! val o)\n        this)\n      (Many. #js [val o])))\n  (remove [this]\n    (if (identical? val NONE)\n      (throw (js/Error. (str "Removing object from empty buffer")))\n      (let [ret val]\n        (set! val NONE)\n        ret)))\n  (isEmpty [this]\n    (identical? val NONE))\n  (toString [this]\n    (str "Single: " val)))\n\n(deftype Empty []\n  Object\n  (add [this o]\n    (Single. o))\n  (remove [this]\n    (throw (js/Error. (str "Removing object from empty buffer"))))\n  (isEmpty [this]\n    true)\n  (toString [this]\n    "Empty"))\n\n(def ^:private EMPTY (Empty.))\n\n(deftype MultiIterator [iters]\n  Object\n  (hasNext [_]\n    (loop [iters (seq iters)]\n      (if-not (nil? iters)\n        (let [iter (first iters)]\n          (if-not ^boolean (.hasNext iter)\n            false\n            (recur (next iters))))\n        true)))\n  (next [_]\n    (let [nexts (array)]\n      (dotimes [i (alength iters)]\n        (aset nexts i (.next (aget iters i))))\n      (prim-seq nexts 0))))\n\n(defn- chunkIteratorSeq [iter]\n  (lazy-seq\n    (when ^boolean (.hasNext iter)\n      (let [arr (array)]\n        (loop [n 0]\n          (if (and (.hasNext iter) (\x3c n 32))\n            (do\n              (aset arr n (.next iter))\n              (recur (inc n)))\n            (chunk-cons (array-chunk arr 0 n) (chunkIteratorSeq iter))))))))\n\n(deftype TransformerIterator [^:mutable buffer ^:mutable _next ^:mutable completed ^:mutable xf sourceIter multi]\n  Object\n  (step [this]\n    (if-not (identical? _next NONE)\n      true\n      (loop []\n        (if (identical? _next NONE)\n          (if ^boolean (.isEmpty buffer)\n            (if ^boolean completed\n              false\n              (if ^boolean (.hasNext sourceIter)\n                (let [iter (if ^boolean multi\n                             (apply xf (cons nil (.next sourceIter)))\n                             (xf nil (.next sourceIter)))]\n                  (when (reduced? iter)\n                    (xf nil)\n                    (set! completed true))\n                  (recur))\n                (do\n                  (xf nil)\n                  (set! completed true)\n                  (recur))))\n            (do\n              (set! _next (.remove buffer))\n              (recur)))\n          true))))\n  (hasNext [this]\n    (.step this))\n  (next [this]\n    (if ^boolean (.hasNext this)\n      (let [ret _next]\n        (set! _next NONE)\n        ret)\n      (throw (js/Error. "No such element"))))\n  (remove [_]\n    (js/Error. "Unsupported operation")))\n\n(es6-iterable TransformerIterator)\n\n(defn transformer-iterator\n  [xform sourceIter multi]\n  (let [iterator (TransformerIterator. EMPTY NONE false nil sourceIter multi)]\n    (set! (.-xf iterator)\n      (xform (fn\n               ([] nil)\n               ([acc] acc)\n               ([acc o]\n                (set! (.-buffer iterator) (.add (.-buffer iterator) o))\n                acc))))\n    iterator))\n\n(set! (.-create TransformerIterator)\n  (fn [xform source]\n    (transformer-iterator xform source false)))\n\n(set! (.-createMulti TransformerIterator)\n  (fn [xform sources]\n    (transformer-iterator xform (MultiIterator. (to-array sources)) true)))\n\n(defn sequence\n  "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments"\n  ([coll]\n     (if (seq? coll)\n       coll\n       (or (seq coll) ())))\n  ([xform coll]\n   (or (chunkIteratorSeq\n         (.create TransformerIterator xform (iter coll)))\n       ()))\n  ([xform coll \x26 colls]\n   (or (chunkIteratorSeq\n         (.createMulti TransformerIterator xform (map iter (cons coll colls))))\n       ())))\n\n(defn every?\n  "Returns true if (pred x) is logical true for every x in coll, else\n  false."\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))\n\n(defn not-every?\n  "Returns false if (pred x) is logical true for every x in\n  coll, else true."\n  [pred coll] (not (every? pred coll)))\n\n(defn some\n  "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"\n  [pred coll]\n  (when-let [s (seq coll)]\n    (or (pred (first s)) (recur pred (next s)))))\n\n(defn not-any?\n  "Returns false if (pred x) is logical true for any x in coll,\n  else true."\n  [pred coll] (not (some pred coll)))\n\n(defn even?\n  "Returns true if n is even, throws an exception if n is not an integer"\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str "Argument must be an integer: " n)))))\n\n(defn odd?\n  "Returns true if n is odd, throws an exception if n is not an integer"\n  [n] (not (even? n)))\n\n(defn complement\n  "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y \x26 zs] (not (apply f x y zs)))))\n\n(defn constantly\n  "Returns a function that takes any number of arguments and returns x."\n  [x] (fn [\x26 args] x))\n\n(defn comp\n  "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc."\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z \x26 args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z \x26 args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 \x26 fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [\x26 args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))\n\n(defn partial\n  "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args."\n  ([f] f)\n  ([f arg1]\n   (fn\n     ([] (f arg1))\n     ([x] (f arg1 x))\n     ([x y] (f arg1 x y))\n     ([x y z] (f arg1 x y z))\n     ([x y z \x26 args] (apply f arg1 x y z args))))\n  ([f arg1 arg2]\n   (fn\n     ([] (f arg1 arg2))\n     ([x] (f arg1 arg2 x))\n     ([x y] (f arg1 arg2 x y))\n     ([x y z] (f arg1 arg2 x y z))\n     ([x y z \x26 args] (apply f arg1 arg2 x y z args))))\n  ([f arg1 arg2 arg3]\n   (fn\n     ([] (f arg1 arg2 arg3))\n     ([x] (f arg1 arg2 arg3 x))\n     ([x y] (f arg1 arg2 arg3 x y))\n     ([x y z] (f arg1 arg2 arg3 x y z))\n     ([x y z \x26 args] (apply f arg1 arg2 arg3 x y z args))))\n  ([f arg1 arg2 arg3 \x26 more]\n   (fn [\x26 args] (apply f arg1 arg2 arg3 (concat more args)))))\n\n(defn fnil\n  "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched."\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c \x26 ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c \x26 ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c \x26 ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))\n\n(declare volatile!)\n\n(defn map-indexed\n  "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided."\n  ([f]\n    (fn [rf]\n      (let [i (volatile! -1)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (rf result (f (vswap! i inc) input)))))))\n  ([f coll]\n    (letfn [(mapi [idx coll]\n              (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (chunk-append b (f (+ idx i) (-nth c i))))\n                      (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                    (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n      (mapi 0 coll))))\n\n(defn keep\n  "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided."\n  ([f]\n   (fn [rf]\n     (fn\n       ([] (rf))\n       ([result] (rf result))\n       ([result input]\n          (let [v (f input)]\n            (if (nil? v)\n              result\n              (rf result v)))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (-nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Atom\n\n(deftype Atom [state meta validator watches]\n  Object\n  (equiv [this other]\n    (-equiv this other))\n\n  IAtom\n\n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f))\n    this)\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog/getUid this)))\n\n(defn atom\n  "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change."\n  ([x] (Atom. x nil nil nil))\n  ([x \x26 {:keys [meta validator]}] (Atom. x meta validator nil)))\n\n(declare pr-str)\n\n(defn reset!\n  "Sets the value of atom to newval without regard for the\n  current value. Returns new-value."\n  [a new-value]\n  (if (instance? Atom a)\n    (let [validate (.-validator a)]\n      (when-not (nil? validate)\n        (when-not (validate new-value)\n          (throw (js/Error. "Validator rejected reference state"))))\n      (let [old-value (.-state a)]\n        (set! (.-state a) new-value)\n        (when-not (nil? (.-watches a))\n          (-notify-watches a old-value new-value))\n        new-value))\n    (-reset! a new-value)))\n\n(defn reset-vals!\n  "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset."\n  {:added "1.9"}\n  [a new-value]\n  (let [validate (.-validator a)]\n    (when-not (nil? validate)\n      (when-not (validate new-value)\n        (throw (js/Error. "Validator rejected reference state"))))\n    (let [old-value (.-state a)]\n      (set! (.-state a) new-value)\n      (when-not (nil? (.-watches a))\n        (-notify-watches a old-value new-value))\n      [old-value new-value])))\n\n(defn swap!\n  "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in."\n  ([a f]\n   (if (instance? Atom a)\n     (reset! a (f (.-state a)))\n     (-swap! a f)))\n  ([a f x]\n   (if (instance? Atom a)\n     (reset! a (f (.-state a) x))\n     (-swap! a f x)))\n  ([a f x y]\n   (if (instance? Atom a)\n     (reset! a (f (.-state a) x y))\n     (-swap! a f x y)))\n  ([a f x y \x26 more]\n   (if (instance? Atom a)\n     (reset! a (apply f (.-state a) x y more))\n     (-swap! a f x y more))))\n\n(defn swap-vals!\n  "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap."\n  {:added "1.9"}\n  ([a f]\n   (reset-vals! a (f (.-state a))))\n  ([a f x]\n   (reset-vals! a (f (.-state a) x)))\n  ([a f x y]\n   (reset-vals! a (f (.-state a) x y)))\n  ([a f x y \x26 more]\n   (reset-vals! a (apply f (.-state a) x y more))))\n\n(defn compare-and-set!\n  "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."\n  [^not-native a oldval newval]\n  (if (\x3d (-deref a) oldval)\n    (do (reset! a newval) true)\n    false))\n\n(defn set-validator!\n  "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."\n  [iref val]\n  (when (and (some? val)\n             (not (val (-deref iref))))\n    (throw (js/Error. "Validator rejected reference state")))\n  (set! (.-validator iref) val))\n\n(defn get-validator\n  "Gets the validator-fn for a var/ref/agent/atom."\n  [iref]\n  (.-validator iref))\n\n(deftype Volatile [^:mutable state]\n  IVolatile\n  (-vreset! [_ new-state]\n    (set! state new-state))\n\n  IDeref\n  (-deref [_] state))\n\n(defn volatile!\n  "Creates and returns a Volatile with an initial value of val."\n  [val]\n  (Volatile. val))\n\n(defn volatile?\n  "Returns true if x is a volatile."\n  [x] (instance? Volatile x))\n\n(defn vreset!\n  "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."\n  [vol newval]  (-vreset! vol newval))\n\n(defn keep-indexed\n  "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided."\n  ([f]\n   (fn [rf]\n     (let [ia (volatile! -1)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [i (vswap! ia inc)\n                  v (f i input)]\n              (if (nil? v)\n                result\n                (rf result v))))))))\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (-nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))\n\n(defn every-pred\n  "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates."\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z \x26 args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z \x26 args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z \x26 args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 \x26 ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z \x26 args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))\n\n(defn some-fn\n  "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates."\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z \x26 args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z \x26 args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z \x26 args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 \x26 ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z \x26 args] (or (spn x y z)\n                             (some #(some % args) ps)))))))\n\n(defn map\n  "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided."\n  ([f]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (rf result (f input)))\n        ([result input \x26 inputs]\n           (rf result (apply f input inputs))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (-nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 \x26 colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))\n\n(defn take\n  "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided."\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na\n                    nn (vswap! na dec)\n                    result (if (pos? n)\n                             (rf result input)\n                             result)]\n                (if (not (pos? nn))\n                  (ensure-reduced result)\n                  result)))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (lazy-seq\n       (when (pos? n)\n         (when-let [s (seq coll)]\n           (cons (first s) (take (dec n) (rest s))))))))\n\n(defn drop\n  "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided."\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na]\n                (vswap! na dec)\n                (if (pos? n)\n                  result\n                  (rf result input))))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (let [step (fn [n coll]\n                  (let [s (seq coll)]\n                    (if (and (pos? n) s)\n                      (recur (dec n) (rest s))\n                      s)))]\n       (lazy-seq (step n coll)))))\n\n(defn drop-last\n  "Return a lazy sequence of all but the last n (default 1) items in coll"\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))\n\n(defn take-last\n  "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))\n\n(defn drop-while\n  "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided."\n  ([pred]\n     (fn [rf]\n       (let [da (volatile! true)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [drop? @da]\n                (if (and drop? (pred input))\n                  result\n                  (do\n                    (vreset! da nil)\n                    (rf result input)))))))))\n  ([pred coll]\n     (let [step (fn [pred coll]\n                  (let [s (seq coll)]\n                    (if (and s (pred (first s)))\n                      (recur pred (rest s))\n                      s)))]\n       (lazy-seq (step pred coll)))))\n\n(deftype Cycle [meta all prev ^:mutable current ^:mutable _next]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (currentval [coll]\n    (when-not ^seq current\n      (if-let [c (next prev)]\n        (set! current c)\n        (set! current all)))\n    current)\n\n  IPending\n  (-realized? [coll]\n    (some? current))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Cycle. new-meta all prev current _next)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (first (.currentval coll)))\n  (-rest [coll]\n    (when (nil? _next)\n      (set! _next (Cycle. nil all (.currentval coll) nil nil)))\n    _next)\n\n  INext\n  (-next [coll]\n    (-rest coll))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeqable\n  (-seq [coll] coll)\n\n  IReduce\n  (-reduce [coll f]\n    (loop [s (.currentval coll) ret (first s)]\n      (let [s   (or (next s) all)\n            ret (f ret (first s))]\n        (if (reduced? ret)\n          @ret\n          (recur s ret)))))\n  (-reduce [coll f start]\n    (loop [s (.currentval coll) ret start]\n      (let [ret (f ret (first s))]\n        (if (reduced? ret)\n          @ret\n          (recur (or (next s) all) ret))))))\n\n(defn cycle\n  "Returns a lazy (infinite!) sequence of repetitions of the items in coll."\n  [coll] (if-let [vals (seq coll)]\n           (Cycle. nil vals nil vals nil)\n           (.-EMPTY List)))\n\n(defn split-at\n  "Returns a vector of [(take n coll) (drop n coll)]"\n  [n coll]\n  [(take n coll) (drop n coll)])\n\n(deftype Repeat [meta count val ^:mutable next ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x count))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IPending\n  (-realized? [coll] false)\n  \n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Repeat. new-meta count val next nil)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    val)\n  (-rest [coll]\n    (if (nil? next)\n      (if (\x3e count 1)\n        (do\n          (set! next (Repeat. nil (dec count) val nil nil))\n          next)\n        (if (\x3d\x3d -1 count)\n          coll\n          ()))\n      next))\n\n  INext\n  (-next [coll]\n    (if (nil? next)\n      (if (\x3e count 1)\n        (do\n          (set! next (Repeat. nil (dec count) val nil nil))\n          next)\n        (if (\x3d\x3d -1 count)\n          coll\n          nil))\n      next))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISequential\n  ISeqable\n  (-seq [coll] coll)\n  \n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IReduce\n  (-reduce [coll f]\n    (if (\x3d\x3d count -1)\n      (loop [ret (f val val)]\n        (if (reduced? ret)\n          @ret\n          (recur (f ret val))))\n      (loop [i 1 ret val]\n        (if (\x3c i count)\n          (let [ret (f ret val)]\n            (if (reduced? ret)\n              @ret\n              (recur (inc i) ret)))\n          ret))))\n  (-reduce [coll f start]\n    (if (\x3d\x3d count -1)\n      (loop [ret (f start val)]\n        (if (reduced? ret)\n          @ret\n          (recur (f ret val))))\n      (loop [i 0 ret start]\n        (if (\x3c i count)\n          (let [ret (f ret val)]\n            (if (reduced? ret)\n              @ret\n              (recur (inc i) ret)))\n          ret)))))\n\n(defn repeat\n  "Returns a lazy (infinite!, or length n if supplied) sequence of xs."\n  ([x] (Repeat. nil -1 x nil nil))\n  ([n x] (if (pos? n)\n           (Repeat. nil n x nil nil)\n           (.-EMPTY List))))\n\n(defn replicate\n  "DEPRECATED: Use \'repeat\' instead.\n  Returns a lazy seq of n xs."\n  [n x] (take n (repeat x)))\n\n(defn repeatedly\n  "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it"\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))\n\n(def ^:private UNREALIZED-SEED #js {})\n\n(deftype Iterate [meta f prev-seed ^:mutable seed ^:mutable next]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IPending\n  (-realized? [coll]\n    (not (identical? seed UNREALIZED-SEED)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Iterate. new-meta f prev-seed seed next)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (when (identical? UNREALIZED-SEED seed)\n      (set! seed (f prev-seed)))\n    seed)\n  (-rest [coll]\n    (when (nil? next)\n      (set! next (Iterate. nil f (-first coll) UNREALIZED-SEED nil)))\n    next)\n\n  INext\n  (-next [coll]\n    (-rest coll))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeqable\n  (-seq [coll] coll)\n\n  IReduce\n  (-reduce [coll rf]\n    (let [first (-first coll)\n          v     (f first)]\n      (loop [ret (rf first v) v v]\n        (if (reduced? ret)\n          @ret\n          (let [v (f v)]\n            (recur (rf ret v) v))))))\n  (-reduce [coll rf start]\n    (let [v (-first coll)]\n      (loop [ret (rf start v) v v]\n        (if (reduced? ret)\n          @ret\n          (let [v (f v)]\n            (recur (rf ret v) v)))))))\n\n(defn iterate\n  "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"\n  {:added "1.0"}\n  [f x] (Iterate. nil f nil x nil))\n\n(defn interleave\n  "Returns a lazy seq of the first item in each coll, then the second etc."\n  ([] ())\n  ([c1] (lazy-seq c1))\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 \x26 colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))\n\n(defn interpose\n  "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided."\n  ([sep]\n    (fn [rf]\n      (let [started (volatile! false)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if @started\n              (let [sepr (rf result sep)]\n                (if (reduced? sepr)\n                  sepr\n                  (rf sepr input)))\n              (do\n                (vreset! started true)\n                (rf result input))))))))\n  ([sep coll] (drop 1 (interleave (repeat sep) coll))))\n\n\n\n(defn- flatten1\n  "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"\n  [colls]\n  (let [cat (fn cat [coll colls]\n              (lazy-seq\n                (if-let [coll (seq coll)]\n                  (cons (first coll) (cat (rest coll) colls))\n                  (when (seq colls)\n                    (cat (first colls) (rest colls))))))]\n    (cat nil colls)))\n\n(declare cat)\n\n(defn mapcat\n  "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"\n  {:added "1.0"\n   :static true}\n  ([f] (comp (map f) cat))\n  ([f \x26 colls]\n     (apply concat (apply map f colls))))\n\n(defn filter\n  "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."\n  ([pred]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (if (pred input)\n             (rf result input)\n             result)))))\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (when (pred (-nth c i))\n                (chunk-append b (-nth c i))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))\n\n(defn remove\n  "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."\n  ([pred] (filter (complement pred)))\n  ([pred coll]\n     (filter (complement pred) coll)))\n\n(defn tree-seq\n  "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree."\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))\n\n(defn flatten\n  "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))\n\n(defn into\n  "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied."\n  ([] [])\n  ([to] to)\n  ([to from]\n     (if-not (nil? to)\n       (if (implements? IEditableCollection to)\n         (-with-meta (persistent! (reduce -conj! (transient to) from)) (meta to))\n         (reduce -conj to from))\n       (reduce conj () from)))\n  ([to xform from]\n     (if (implements? IEditableCollection to)\n       (-with-meta (persistent! (transduce xform conj! (transient to) from)) (meta to))\n       (transduce xform conj to from))))\n\n(defn mapv\n  "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments."\n  ([f coll]\n     (-\x3e (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 \x26 colls]\n     (into [] (apply map f c1 c2 c3 colls))))\n\n(defn filterv\n  "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects."\n  [pred coll]\n  (-\x3e (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))\n\n(defn partition\n  "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items."\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (\x3d\x3d n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (\x3d\x3d n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))\n\n(defn get-in\n  "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."\n  {:added "1.2"\n   :static true}\n  ([m ks]\n     (reduce get m ks))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if-not (nil? ks)\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))\n\n(defn assoc-in\n  "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."\n  [m [k \x26 ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))\n\n(defn update-in\n  "\'Updates\' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created."\n  ([m [k \x26 ks] f]\n   (if ks\n     (assoc m k (update-in (get m k) ks f))\n     (assoc m k (f (get m k)))))\n  ([m [k \x26 ks] f a]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a))\n     (assoc m k (f (get m k) a))))\n  ([m [k \x26 ks] f a b]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b))\n     (assoc m k (f (get m k) a b))))\n  ([m [k \x26 ks] f a b c]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b c))\n     (assoc m k (f (get m k) a b c))))\n  ([m [k \x26 ks] f a b c \x26 args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f a b c args))\n     (assoc m k (apply f (get m k) a b c args)))))\n\n(defn update\n  "\'Updates\' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value."\n  ([m k f]\n   (assoc m k (f (get m k))))\n  ([m k f x]\n   (assoc m k (f (get m k) x)))\n  ([m k f x y]\n   (assoc m k (f (get m k) x y)))\n  ([m k f x y z]\n   (assoc m k (f (get m k) x y z)))\n  ([m k f x y z \x26 more]\n   (assoc m k (apply f (get m k) x y z more))))\n\n;;; PersistentVector\n\n(deftype VectorNode [edit arr])\n\n(defn- pv-fresh-node [edit]\n  (VectorNode. edit (make-array 32)))\n\n(defn- pv-aget [node idx]\n  (aget (.-arr node) idx))\n\n(defn- pv-aset [node idx val]\n  (aset (.-arr node) idx val))\n\n(defn- pv-clone-node [node]\n  (VectorNode. (.-edit node) (aclone (.-arr node))))\n\n(defn- tail-off [pv]\n  (let [cnt (.-cnt pv)]\n    (if (\x3c cnt 32)\n      0\n      (bit-shift-left (bit-shift-right-zero-fill (dec cnt) 5) 5))))\n\n(defn- new-path [edit level node]\n  (loop [ll level\n         ret node]\n    (if (zero? ll)\n      ret\n      (let [embed ret\n            r (pv-fresh-node edit)\n            _ (pv-aset r 0 embed)]\n        (recur (- ll 5) r)))))\n\n(defn- push-tail [pv level parent tailnode]\n  (let [ret (pv-clone-node parent)\n        subidx (bit-and (bit-shift-right-zero-fill (dec (.-cnt pv)) level) 0x01f)]\n    (if (\x3d\x3d 5 level)\n      (do\n        (pv-aset ret subidx tailnode)\n        ret)\n      (let [child (pv-aget parent subidx)]\n        (if-not (nil? child)\n          (let [node-to-insert (push-tail pv (- level 5) child tailnode)]\n            (pv-aset ret subidx node-to-insert)\n            ret)\n          (let [node-to-insert (new-path nil (- level 5) tailnode)]\n            (pv-aset ret subidx node-to-insert)\n            ret))))))\n\n(defn- vector-index-out-of-bounds [i cnt]\n  (throw (js/Error. (str "No item " i " in vector of length " cnt))))\n\n(defn- first-array-for-longvec [pv]\n  ;; invariants: (count pv) \x3e 32.\n  (loop [node (.-root pv)\n         level (.-shift pv)]\n    (if (pos? level)\n      (recur (pv-aget node 0) (- level 5))\n      (.-arr node))))\n\n(defn- unchecked-array-for [pv i]\n  ;; invariant: i is a valid index of pv (use array-for if unknown).\n  (if (\x3e\x3d i (tail-off pv))\n      (.-tail pv)\n      (loop [node (.-root pv)\n             level (.-shift pv)]\n        (if (pos? level)\n          (recur (pv-aget node (bit-and (bit-shift-right-zero-fill i level) 0x01f))\n                 (- level 5))\n          (.-arr node)))))\n\n(defn- array-for [pv i]\n  (if (and (\x3c\x3d 0 i) (\x3c i (.-cnt pv)))\n    (unchecked-array-for pv i)\n    (vector-index-out-of-bounds i (.-cnt pv))))\n\n(defn- do-assoc [pv level node i val]\n  (let [ret (pv-clone-node node)]\n    (if (zero? level)\n      (do\n        (pv-aset ret (bit-and i 0x01f) val)\n        ret)\n      (let [subidx (bit-and (bit-shift-right-zero-fill i level) 0x01f)]\n        (pv-aset ret subidx (do-assoc pv (- level 5) (pv-aget node subidx) i val))\n        ret))))\n\n(defn- pop-tail [pv level node]\n  (let [subidx (bit-and (bit-shift-right-zero-fill (- (.-cnt pv) 2) level) 0x01f)]\n    (cond\n     (\x3e level 5) (let [new-child (pop-tail pv (- level 5) (pv-aget node subidx))]\n                   (if (and (nil? new-child) (zero? subidx))\n                     nil\n                     (let [ret (pv-clone-node node)]\n                       (pv-aset ret subidx new-child)\n                       ret)))\n     (zero? subidx) nil\n     :else (let [ret (pv-clone-node node)]\n             (pv-aset ret subidx nil)\n             ret))))\n\n(deftype RangedIterator [^:mutable i ^:mutable base ^:mutable arr v start end]\n  Object\n  (hasNext [this]\n    (\x3c i end))\n  (next [this]\n    (when (\x3d\x3d (- i base) 32)\n      (set! arr (unchecked-array-for v i))\n      (set! base (+ base 32)))\n    (let [ret (aget arr (bit-and i 0x01f))]\n      (set! i (inc i))\n      ret)))\n\n(defn ranged-iterator [v start end]\n  (let [i start]\n    (RangedIterator. i (- i (js-mod i 32))\n      (when (\x3c start (count v))\n        (unchecked-array-for v i))\n      v start end)))\n\n(defn- pv-reduce\n  ([pv f start end]\n   (if (\x3c start end)\n     (pv-reduce pv f (nth pv start) (inc start) end)\n     (f)))\n  ([pv f init start end]\n   (loop [acc init i start arr (unchecked-array-for pv start)]\n     (if (\x3c i end)\n       (let [j (bit-and i 0x01f)\n             arr (if (zero? j) (unchecked-array-for pv i) arr)\n             nacc (f acc (aget arr j))]\n         (if (reduced? nacc)\n           @nacc\n           (recur nacc (inc i) arr)))\n       acc))))\n\n(declare tv-editable-root tv-editable-tail TransientVector deref\n         pr-sequential-writer pr-writer chunked-seq)\n\n(defprotocol APersistentVector\n  "Marker protocol")\n\n(deftype PersistentVector [meta cnt shift root tail ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (PersistentVector. meta cnt shift root tail __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentVector. new-meta cnt shift root tail __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (\x3e cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. "Can\'t pop empty vector"))\n     (\x3d\x3d 1 cnt) (-with-meta (.-EMPTY PersistentVector) meta)\n     (\x3c 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (.slice tail 0 -1) nil)\n      :else (let [new-tail (unchecked-array-for coll (- cnt 2))\n                  nr (pop-tail coll shift root)\n                  new-root (if (nil? nr) (.-EMPTY-NODE PersistentVector) nr)\n                  cnt-1 (dec cnt)]\n              (if (and (\x3c 5 shift) (nil? (pv-aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (pv-aget new-root 0) new-tail nil)\n                (PersistentVector. meta cnt-1 shift new-root new-tail nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (\x3c (- cnt (tail-off coll)) 32)\n      (let [len (alength tail)\n            new-tail (make-array (inc len))]\n        (dotimes [i len]\n          (aset new-tail i (aget tail i)))\n        (aset new-tail len o)\n        (PersistentVector. meta (inc cnt) shift root new-tail nil))\n      (let [root-overflow? (\x3e (bit-shift-right-zero-fill cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (pv-fresh-node nil)]\n                           (pv-aset n-r 0 root)\n                           (pv-aset n-r 1 (new-path nil shift (VectorNode. nil tail)))\n                           n-r)\n                       (push-tail coll shift root (VectorNode. nil tail)))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o) nil))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (instance? PersistentVector other)\n      (if (\x3d\x3d cnt (count other))\n        (let [me-iter  (-iterator coll)\n              you-iter (-iterator other)]\n          (loop []\n            (if ^boolean (.hasNext me-iter)\n              (let [x (.next me-iter)\n                    y (.next you-iter)]\n                (if (\x3d x y)\n                  (recur)\n                  false))\n              true)))\n        false)\n      (equiv-sequential coll other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (cond\n      (zero? cnt) nil\n      (\x3c\x3d cnt 32) (IndexedSeq. tail 0 nil)\n      :else (chunked-seq coll (first-array-for-longvec coll) 0 0)))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (\x3c\x3d 0 n) (\x3c n cnt))\n      (aget (unchecked-array-for coll n) (bit-and n 0x01f))\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (number? k)\n      (-assoc-n coll k v)\n      (throw (js/Error. "Vector\'s key for assoc must be a number."))))\n  (-contains-key? [coll k]\n    (if (integer? k)\n      (and (\x3c\x3d 0 k) (\x3c k cnt))\n      false))\n\n  IFind\n  (-find [coll n]\n    (when (and (\x3c\x3d 0 n) (\x3c n cnt))\n      (MapEntry. n (aget (unchecked-array-for coll n) (bit-and n 0x01f)) nil)))\n\n  APersistentVector\n  IVector\n  (-assoc-n [coll n val]\n    (cond\n       (and (\x3c\x3d 0 n) (\x3c n cnt))\n       (if (\x3c\x3d (tail-off coll) n)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and n 0x01f) val)\n           (PersistentVector. meta cnt shift root new-tail nil))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root n val) tail nil))\n       (\x3d\x3d n cnt) (-conj coll val)\n       :else (throw (js/Error. (str "Index " n " out of bounds  [0," cnt "]")))))\n\n  IReduce\n  (-reduce [v f]\n    (pv-reduce v f 0 cnt))\n  (-reduce [v f init]\n    (loop [i 0 init init]\n      (if (\x3c i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (\x3c j len)\n                       (let [init (f init (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IKVReduce\n  (-kv-reduce [v f init]\n    (loop [i 0 init init]\n      (if (\x3c i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (\x3c j len)\n                       (let [init (f init (+ j i) (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientVector. cnt shift (tv-editable-root root) (tv-editable-tail tail)))\n\n  IReversible\n  (-rseq [coll]\n    (when (pos? cnt)\n      (RSeq. coll (dec cnt) nil)))\n\n  IIterable\n  (-iterator [this]\n    (ranged-iterator this 0 cnt)))\n\n(set! (.-EMPTY-NODE PersistentVector) (VectorNode. nil (make-array 32)))\n\n(set! (.-EMPTY PersistentVector)\n  (PersistentVector. nil 0 5 (.-EMPTY-NODE PersistentVector) (array) empty-ordered-hash))\n\n(set! (.-fromArray PersistentVector)\n  (fn [xs ^boolean no-clone]\n    (let [l (alength xs)\n          xs (if no-clone xs (aclone xs))]\n      (if (\x3c l 32)\n        (PersistentVector. nil l 5 (.-EMPTY-NODE PersistentVector) xs nil)\n        (let [node (.slice xs 0 32)\n              v (PersistentVector. nil 32 5 (.-EMPTY-NODE PersistentVector) node nil)]\n          (loop [i 32 out (-as-transient v)]\n            (if (\x3c i l)\n              (recur (inc i) (conj! out (aget xs i)))\n              (persistent! out))))))))\n\n(es6-iterable PersistentVector)\n\n(declare map-entry?)\n\n(defn vec\n  "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."\n  [coll]\n  (cond\n    (map-entry? coll)\n    [(key coll) (val coll)]\n\n    (vector? coll)\n    (with-meta coll nil)\n\n    (array? coll)\n    (.fromArray PersistentVector coll true)\n\n    :else\n    (-persistent!\n      (reduce -conj!\n        (-as-transient (.-EMPTY PersistentVector))\n        coll))))\n\n(defn vector\n  "Creates a new vector containing the args."\n  [\x26 args]\n  (if (and (instance? IndexedSeq args) (zero? (.-i args)))\n    (.fromArray PersistentVector (.-arr args) true)\n    (vec args)))\n\n(declare subvec)\n\n(deftype ChunkedSeq [vec node i off meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (chunked-seq vec node i off new-meta)))\n  IMeta\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n  (-rest [coll]\n    (if (\x3c (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (\x3c (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    ())\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n  (-chunked-rest [coll]\n    (let [end (+ i (alength node))]\n      (if (\x3c end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0)\n        ())))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [end (+ i (alength node))]\n      (when (\x3c end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f]\n    (pv-reduce vec f (+ i off) (count vec)))\n\n  (-reduce [coll f start]\n    (pv-reduce vec f start (+ i off) (count vec))))\n\n(es6-iterable ChunkedSeq)\n\n(defn chunked-seq\n  ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n  ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (ChunkedSeq. vec node i off meta nil)))\n\n(declare build-subvec)\n\n(deftype Subvec [meta v start end ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (Subvec. meta v start end __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (build-subvec new-meta v start end __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (\x3d\x3d start end)\n      (throw (js/Error. "Can\'t pop empty vector"))\n      (build-subvec meta v start (dec end) nil)))\n\n  ICollection\n  (-conj [coll o]\n    (build-subvec meta (-assoc-n v end o) start (inc end) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (\x3d\x3d i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  IReversible\n  (-rseq [coll]\n    (if-not (\x3d\x3d start end)\n      (RSeq. coll (dec (- end start)) nil)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (if (or (neg? n) (\x3c\x3d end (+ start n)))\n      (vector-index-out-of-bounds n (- end start))\n      (-nth v (+ start n))))\n  (-nth [coll n not-found]\n    (if (or (neg? n) (\x3c\x3d end (+ start n)))\n      not-found\n      (-nth v (+ start n) not-found)))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (if (number? key)\n      (-assoc-n coll key val)\n      (throw (js/Error. "Subvec\'s key for assoc must be a number."))))\n\n  IFind\n  (-find [coll n]\n    (when-not (neg? n)\n      (let [idx (+ start n)]\n        (when (\x3c idx end)\n          (MapEntry. n (-lookup v idx) nil)))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (let [v-pos (+ start n)]\n      (if (or (neg? n) (\x3c\x3d (inc end) v-pos))\n        (throw (js/Error. (str "Index " n " out of bounds [0," (-count coll) "]")))\n        (build-subvec meta (assoc v v-pos val) start (max end (inc v-pos)) nil))))\n\n  IReduce\n  (-reduce [coll f]\n    (if (implements? APersistentVector v)\n      (pv-reduce v f start end)\n      (ci-reduce coll f)))\n  (-reduce [coll f init]\n    (if (implements? APersistentVector v)\n      (pv-reduce v f init start end)\n      (ci-reduce coll f init)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (loop [i start j 0 init init]\n      (if (\x3c i end)\n        (let [init (f init j (-nth v i))]\n          (if (reduced? init)\n            @init\n            (recur (inc i) (inc j) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found))\n\n  IIterable\n  (-iterator [coll]\n    (if (implements? APersistentVector v)\n      (ranged-iterator v start end)\n      (seq-iter coll))))\n\n(es6-iterable Subvec)\n\n(defn- build-subvec [meta v start end __hash]\n  (if (instance? Subvec v)\n    (recur meta (.-v v) (+ (.-start v) start) (+ (.-start v) end) __hash)\n    (do\n      (when-not (vector? v)\n        (throw (js/Error. "v must satisfy IVector")))\n      (let [c (count v)]\n        (when (or (neg? start)\n                  (neg? end)\n                  (\x3e start c)\n                  (\x3e end c))\n          (throw (js/Error. "Index out of bounds"))))\n      (Subvec. meta v start end __hash))))\n\n(defn subvec\n  "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done."\n  ([v start]\n   (subvec v start (count v)))\n  ([v start end]\n   (assert (and (not (nil? start)) (not (nil? end))))\n   (build-subvec nil v (int start) (int end) nil)))\n\n(defn- tv-ensure-editable [edit node]\n  (if (identical? edit (.-edit node))\n    node\n    (VectorNode. edit (aclone (.-arr node)))))\n\n(defn- tv-editable-root [node]\n  (VectorNode. (js-obj) (aclone (.-arr node))))\n\n(defn- tv-editable-tail [tl]\n  (let [ret (make-array 32)]\n    (array-copy tl 0 ret 0 (alength tl))\n    ret))\n\n(defn- tv-push-tail [tv level parent tail-node]\n  (let [ret    (tv-ensure-editable (.. tv -root -edit) parent)\n        subidx (bit-and (bit-shift-right-zero-fill (dec (.-cnt tv)) level) 0x01f)]\n    (pv-aset ret subidx\n             (if (\x3d\x3d level 5)\n               tail-node\n               (let [child (pv-aget ret subidx)]\n                 (if-not (nil? child)\n                   (tv-push-tail tv (- level 5) child tail-node)\n                   (new-path (.. tv -root -edit) (- level 5) tail-node)))))\n    ret))\n\n(defn- tv-pop-tail [tv level node]\n  (let [node   (tv-ensure-editable (.. tv -root -edit) node)\n        subidx (bit-and (bit-shift-right-zero-fill (- (.-cnt tv) 2) level) 0x01f)]\n    (cond\n      (\x3e level 5) (let [new-child (tv-pop-tail\n                                   tv (- level 5) (pv-aget node subidx))]\n                    (if (and (nil? new-child) (zero? subidx))\n                      nil\n                      (do (pv-aset node subidx new-child)\n                          node)))\n      (zero? subidx) nil\n      :else (do (pv-aset node subidx nil)\n                node))))\n\n(defn- unchecked-editable-array-for [tv i]\n  ;; invariant: i is a valid index of tv.\n  (if (\x3e\x3d i (tail-off tv))\n    (.-tail tv)\n    (let [root (.-root tv)]\n      (loop [node  root\n             level (.-shift tv)]\n        (if (pos? level)\n          (recur (tv-ensure-editable\n                   (.-edit root)\n                   (pv-aget node\n                            (bit-and (bit-shift-right-zero-fill i level)\n                                     0x01f)))\n                 (- level 5))\n          (.-arr node))))))\n\n(deftype TransientVector [^:mutable cnt\n                          ^:mutable shift\n                          ^:mutable root\n                          ^:mutable tail]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if ^boolean (.-edit root)\n      (if (\x3c (- cnt (tail-off tcoll)) 32)\n        (do (aset tail (bit-and cnt 0x01f) o)\n            (set! cnt (inc cnt))\n            tcoll)\n        (let [tail-node (VectorNode. (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (if (\x3e (bit-shift-right-zero-fill cnt 5)\n                 (bit-shift-left 1 shift))\n            (let [new-root-array (make-array 32)\n                  new-shift      (+ shift 5)]\n              (aset new-root-array 0 root)\n              (aset new-root-array 1 (new-path (.-edit root) shift tail-node))\n              (set! root  (VectorNode. (.-edit root) new-root-array))\n              (set! shift new-shift)\n              (set! cnt   (inc cnt))\n              tcoll)\n            (let [new-root (tv-push-tail tcoll shift root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              tcoll))))\n      (throw (js/Error. "conj! after persistent!"))))\n\n  (-persistent! [tcoll]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [len (- cnt (tail-off tcoll))\n                trimmed-tail (make-array len)]\n            (array-copy tail 0 trimmed-tail 0 len)\n            (PersistentVector. nil cnt shift root trimmed-tail nil)))\n      (throw (js/Error. "persistent! called twice"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if (number? key)\n      (-assoc-n! tcoll key val)\n      (throw (js/Error. "TransientVector\'s key for assoc! must be a number."))))\n\n  ITransientVector\n  (-assoc-n! [tcoll n val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (\x3c\x3d 0 n) (\x3c n cnt))\n        (if (\x3c\x3d (tail-off tcoll) n)\n          (do (aset tail (bit-and n 0x01f) val)\n              tcoll)\n          (let [new-root\n                ((fn go [level node]\n                   (let [node (tv-ensure-editable (.-edit root) node)]\n                     (if (zero? level)\n                       (do (pv-aset node (bit-and n 0x01f) val)\n                           node)\n                       (let [subidx (bit-and (bit-shift-right-zero-fill n level)\n                                             0x01f)]\n                         (pv-aset node subidx\n                                  (go (- level 5) (pv-aget node subidx)))\n                         node))))\n                 shift root)]\n            (set! root new-root)\n            tcoll))\n        (\x3d\x3d n cnt) (-conj! tcoll val)\n        :else\n        (throw\n         (js/Error.\n          (str "Index " n " out of bounds for TransientVector of length" cnt))))\n      (throw (js/Error. "assoc! after persistent!"))))\n\n  (-pop! [tcoll]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt) (throw (js/Error. "Can\'t pop empty vector"))\n        (\x3d\x3d 1 cnt)                       (do (set! cnt 0) tcoll)\n        (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)\n        :else\n        (let [new-tail (unchecked-editable-array-for tcoll (- cnt 2))\n              new-root (let [nr (tv-pop-tail tcoll shift root)]\n                         (if-not (nil? nr)\n                           nr\n                           (VectorNode. (.-edit root) (make-array 32))))]\n          (if (and (\x3c 5 shift) (nil? (pv-aget new-root 1)))\n            (let [new-root (tv-ensure-editable (.-edit root) (pv-aget new-root 0))]\n              (set! root  new-root)\n              (set! shift (- shift 5))\n              (set! cnt   (dec cnt))\n              (set! tail  new-tail)\n              tcoll)\n            (do (set! root new-root)\n                (set! cnt  (dec cnt))\n                (set! tail new-tail)\n                tcoll))))\n      (throw (js/Error. "pop! after persistent!"))))\n\n  ICounted\n  (-count [coll]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. "count after persistent!"))))\n\n  IIndexed\n  (-nth [coll n]\n    (if ^boolean (.-edit root)\n      (aget (array-for coll n) (bit-and n 0x01f))\n      (throw (js/Error. "nth after persistent!"))))\n\n  (-nth [coll n not-found]\n    (if (and (\x3c\x3d 0 n) (\x3c n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))\n\n;;; PersistentQueue ;;;\n\n(deftype PersistentQueueIter [^:mutable fseq riter]\n  Object\n  (hasNext [_]\n    (or (and (some? fseq) (seq fseq)) (and (some? riter) (.hasNext riter))))\n  (next [_]\n    (cond\n      (some? fseq)\n      (let [ret (first fseq)]\n        (set! fseq (next fseq))\n        ret)\n      (and (some? riter) ^boolean (.hasNext riter))\n      (.next riter)\n      :else (throw (js/Error. "No such element"))))\n  (remove [_] (js/Error. "Unsupported operation")))\n\n(deftype PersistentQueueSeq [meta front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentQueueSeq. new-meta front rear __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  INext\n  (-next [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (when (some? rear)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))\n\n(es6-iterable PersistentQueueSeq)\n\n(deftype PersistentQueue [meta count front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [coll] (PersistentQueue. meta count front rear __hash))\n\n  IIterable\n  (-iterator [coll]\n    (PersistentQueueIter. front (-iterator rear)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentQueue. new-meta count front rear __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear nil)\n        (PersistentQueue. meta (dec count) (seq rear) [] nil))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o) nil)\n      (PersistentQueue. meta (inc count) (conj front o) [] nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentQueue) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear) nil))))\n\n  ICounted\n  (-count [coll] count))\n\n(set! (.-EMPTY PersistentQueue) (PersistentQueue. nil 0 nil [] empty-ordered-hash))\n\n(es6-iterable PersistentQueue)\n\n(deftype NeverEquiv []\n  Object\n  (equiv [this other]\n    (-equiv this other))\n  IEquiv\n  (-equiv [o other] false))\n\n(def ^:private never-equiv (NeverEquiv.))\n\n(defn equiv-map\n  "Test map equivalence. Returns true if x equals y, otherwise returns false."\n  [x y]\n  (boolean\n    (when (and (map? y) (not (record? y)))\n      ; assume all maps are counted\n      (when (\x3d\x3d (count x) (count y))\n        (if (satisfies? IKVReduce x)\n          (reduce-kv\n            (fn [_ k v]\n              (if (\x3d (get y k never-equiv) v)\n                true\n                (reduced false)))\n            true x)\n          (every?\n            (fn [xkv]\n              (\x3d (get y (first xkv) never-equiv) (second xkv)))\n            x))))))\n\n\n(defn- scan-array [incr k array]\n  (let [len (alength array)]\n    (loop [i 0]\n      (when (\x3c i len)\n        (if (identical? k (aget array i))\n          i\n          (recur (+ i incr)))))))\n\n; The keys field is an array of all keys of this map, in no particular\n; order. Any string, keyword, or symbol key is used as a property name\n; to store the value in strobj.  If a key is assoc\'ed when that same\n; key already exists in strobj, the old value is overwritten. If a\n; non-string key is assoc\'ed, return a HashMap object instead.\n\n(defn- obj-map-compare-keys [a b]\n  (let [a (hash a)\n        b (hash b)]\n    (cond\n     (\x3c a b) -1\n     (\x3e a b) 1\n     :else 0)))\n\n(defn- obj-map-\x3ehash-map [m k v]\n  (let [ks  (.-keys m)\n        len (alength ks)\n        so  (.-strobj m)\n        mm  (meta m)]\n    (loop [i   0\n           out (transient (.-EMPTY PersistentHashMap))]\n      (if (\x3c i len)\n        (let [k (aget ks i)]\n          (recur (inc i) (assoc! out k (gobject/get so k))))\n        (-with-meta (persistent! (assoc! out k v)) mm)))))\n\n;;; ObjMap - DEPRECATED\n\n(defn- obj-clone [obj ks]\n  (let [new-obj (js-obj)\n        l (alength ks)]\n    (loop [i 0]\n      (when (\x3c i l)\n        (let [k (aget ks i)]\n          (gobject/set new-obj k (gobject/get obj k))\n          (recur (inc i)))))\n    new-obj))\n\n(deftype ObjMap [meta keys strobj update-count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (ObjMap. new-meta keys strobj update-count __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY ObjMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (alength keys))\n      (map #(vector % (unchecked-get strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (alength keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (unchecked-get strobj k)\n      not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if ^boolean (goog/isString k)\n        (if (or (\x3e update-count (.-HASHMAP_THRESHOLD ObjMap))\n                (\x3e\x3d (alength keys) (.-HASHMAP_THRESHOLD ObjMap)))\n          (obj-map-\x3ehash-map coll k v)\n          (if-not (nil? (scan-array 1 k keys))\n            (let [new-strobj (obj-clone strobj keys)]\n              (gobject/set new-strobj k v)\n              (ObjMap. meta keys new-strobj (inc update-count) nil)) ; overwrite\n            (let [new-strobj (obj-clone strobj keys) ; append\n                  new-keys (aclone keys)]\n              (gobject/set new-strobj k v)\n              (.push new-keys k)\n              (ObjMap. meta new-keys new-strobj (inc update-count) nil))))\n        ;; non-string key. game over.\n        (obj-map-\x3ehash-map coll k v)))\n  (-contains-key? [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      true\n      false))\n\n  IFind\n  (-find [coll k]\n    (when (and ^boolean (goog/isString k)\n            (not (nil? (scan-array 1 k keys))))\n      (MapEntry. k (unchecked-get strobj k) nil)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength keys)]\n      (loop [keys (.sort keys obj-map-compare-keys)\n             init init]\n        (if (seq keys)\n          (let [k (first keys)\n                init (f init k (unchecked-get strobj k))]\n            (if (reduced? init)\n              @init\n              (recur (rest keys) init)))\n          init))))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (let [new-keys (aclone keys)\n            new-strobj (obj-clone strobj keys)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (transient (into (hash-map) coll))))\n\n(set! (.-EMPTY ObjMap) (ObjMap. nil (array) (js-obj) 0 empty-unordered-hash))\n\n(set! (.-HASHMAP_THRESHOLD ObjMap) 8)\n\n(set! (.-fromObject ObjMap) (fn [ks obj] (ObjMap. nil ks obj 0 nil)))\n\n;; Record Iterator\n(deftype RecordIter [^:mutable i record base-count fields ext-map-iter]\n  Object\n  (hasNext [_]\n    (or (\x3c i base-count) (.hasNext ext-map-iter)))\n  (next [_]\n    (if (\x3c i base-count)\n      (let [k (nth fields i)]\n        (set! i (inc i))\n        (MapEntry. k (-lookup record k) nil))\n      (.next ext-map-iter)))\n  (remove [_] (js/Error. "Unsupported operation")))\n\n;; EXPERIMENTAL: subject to change\n(deftype ES6EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))\n\n(defn es6-entries-iterator [coll]\n  (ES6EntriesIterator. (seq coll)))\n\n;; EXPERIMENTAL: subject to change\n(deftype ES6SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))\n\n(defn es6-set-entries-iterator [coll]\n  (ES6SetEntriesIterator. (seq coll)))\n\n;;; PersistentArrayMap\n\n(defn- array-index-of-nil? [arr]\n  (let [len (alength arr)]\n    (loop [i 0]\n      (cond\n        (\x3c\x3d len i) -1\n        (nil? (aget arr i)) i\n        :else (recur (+ i 2))))))\n\n(defn- array-index-of-keyword? [arr k]\n  (let [len  (alength arr)\n        kstr (.-fqn k)]\n    (loop [i 0]\n      (cond\n        (\x3c\x3d len i) -1\n        (and (keyword? (aget arr i))\n             (identical? kstr (.-fqn (aget arr i)))) i\n        :else (recur (+ i 2))))))\n\n(defn- array-index-of-symbol? [arr k]\n  (let [len  (alength arr)\n        kstr (.-str k)]\n    (loop [i 0]\n      (cond\n        (\x3c\x3d len i) -1\n        (and (symbol? (aget arr i))\n             (identical? kstr (.-str (aget arr i)))) i\n        :else (recur (+ i 2))))))\n\n(defn- array-index-of-identical? [arr k]\n  (let [len (alength arr)]\n    (loop [i 0]\n      (cond\n        (\x3c\x3d len i) -1\n        (identical? k (aget arr i)) i\n        :else (recur (+ i 2))))))\n\n(defn- array-index-of-equiv? [arr k]\n  (let [len (alength arr)]\n    (loop [i 0]\n      (cond\n        (\x3c\x3d len i) -1\n        (\x3d k (aget arr i)) i\n        :else (recur (+ i 2))))))\n\n(defn array-index-of [arr k]\n  (cond\n    (keyword? k) (array-index-of-keyword? arr k)\n\n    (or ^boolean (goog/isString k) (number? k))\n    (array-index-of-identical? arr k)\n\n    (symbol? k) (array-index-of-symbol? arr k)\n\n    (nil? k)\n    (array-index-of-nil? arr)\n\n    :else (array-index-of-equiv? arr k)))\n\n(defn- array-map-index-of [m k]\n  (array-index-of (.-arr m) k))\n\n(defn- array-extend-kv [arr k v]\n  (let [l (alength arr)\n        narr (make-array (+ l 2))]\n    (loop [i 0]\n      (when (\x3c i l)\n        (aset narr i (aget arr i))\n        (recur (inc i))))\n    (aset narr l k)\n    (aset narr (inc l) v)\n    narr))\n\n(defn- array-map-extend-kv [m k v]\n  (array-extend-kv (.-arr m) k v))\n\n(declare TransientArrayMap)\n\n(deftype MapEntry [key val ^:mutable __hash]\n  Object\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] nil)\n\n  ISequential\n  ISeqable\n  (-seq [node] (IndexedSeq. #js [key val] 0 nil))\n\n  IReversible\n  (-rseq [node] (IndexedSeq. #js [val key] 0 nil))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (\x3d\x3d n 0) key\n          (\x3d\x3d n 1) val\n          :else    (throw (js/Error. "Index out of bounds"))))\n\n  (-nth [node n not-found]\n    (cond (\x3d\x3d n 0) key\n          (\x3d\x3d n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n  (-contains-key? [node k]\n    (or (\x3d\x3d k 0) (\x3d\x3d k 1)))\n\n  IFind\n  (-find [node k]\n    (case k\n      0 (MapEntry. 0 key nil)\n      1 (MapEntry. 1 val nil)\n      nil))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-nth node k))\n\n  (-invoke [node k not-found]\n    (-nth node k not-found)))\n\n(defn map-entry?\n  "Returns true if x satisfies IMapEntry"\n  [x]\n  (implements? IMapEntry x))\n\n(deftype PersistentArrayMapSeq [arr i _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta _meta)\n      coll\n      (PersistentArrayMapSeq. arr i new-meta)))\n\n  ICounted\n  (-count [coll]\n    (/ (- (alength arr) i) 2))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (MapEntry. (aget arr i) (aget arr (inc i)) nil))\n\n  (-rest [coll]\n    (if (\x3c i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) nil)\n      ()))\n\n  INext\n  (-next [coll]\n    (when (\x3c i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) nil)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable PersistentArrayMapSeq)\n\n(defn persistent-array-map-seq [arr i _meta]\n  (when (\x3c\x3d i (- (alength arr) 2))\n    (PersistentArrayMapSeq. arr i _meta)))\n\n(declare keys vals)\n\n(deftype PersistentArrayMapIterator [arr ^:mutable i cnt]\n  Object\n  (hasNext [_]\n    (\x3c i cnt))\n  (next [_]\n    (let [ret (MapEntry. (aget arr i) (aget arr (inc i)) nil)]\n      (set! i (+ i 2))\n      ret)))\n\n(deftype PersistentArrayMap [meta cnt arr ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentArrayMap. meta cnt arr __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentArrayMap. new-meta cnt arr __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. "conj on a map takes map entries or seqables of map entries"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentArrayMap) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (if (and (map? other) (not (record? other)))\n      (let [alen (alength arr)\n            ^not-native other other]\n        (if (\x3d\x3d cnt (-count other))\n          (loop [i 0]\n            (if (\x3c i alen)\n              (let [v (-lookup other (aget arr i) lookup-sentinel)]\n                (if-not (identical? v lookup-sentinel)\n                  (if (\x3d (aget arr (inc i)) v)\n                    (recur (+ i 2))\n                    false)\n                  false))\n              true))\n          false))\n      false))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  IIterable\n  (-iterator [this]\n    (PersistentArrayMapIterator. arr 0 (* cnt 2)))\n\n  ISeqable\n  (-seq [coll]\n    (persistent-array-map-seq arr 0 nil))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [idx (array-map-index-of coll k)]\n      (if (\x3d\x3d idx -1)\n        not-found\n        (aget arr (inc idx)))))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [idx (array-map-index-of coll k)]\n      (cond\n        (\x3d\x3d idx -1)\n        (if (\x3c cnt (.-HASHMAP-THRESHOLD PersistentArrayMap))\n          (let [arr (array-map-extend-kv coll k v)]\n            (PersistentArrayMap. meta (inc cnt) arr nil))\n          (-\x3e (into (.-EMPTY PersistentHashMap) coll)\n            (-assoc k v)\n            (-with-meta meta)))\n\n        (identical? v (aget arr (inc idx)))\n        coll\n\n        :else\n        (let [arr (doto (aclone arr)\n                    (aset (inc idx) v))]\n          (PersistentArrayMap. meta cnt arr nil)))))\n\n  (-contains-key? [coll k]\n    (not (\x3d\x3d (array-map-index-of coll k) -1)))\n\n  IFind\n  (-find [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (when-not (\x3d\x3d idx -1)\n        (MapEntry. (aget arr idx) (aget arr (inc idx)) nil))))\n\n  IMap\n  (-dissoc [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (if (\x3e\x3d idx 0)\n        (let [len     (alength arr)\n              new-len (- len 2)]\n          (if (zero? new-len)\n            (-empty coll)\n            (let [new-arr (make-array new-len)]\n              (loop [s 0 d 0]\n                (cond\n                  (\x3e\x3d s len) (PersistentArrayMap. meta (dec cnt) new-arr nil)\n                  (\x3d k (aget arr s)) (recur (+ s 2) d)\n                  :else (do (aset new-arr d (aget arr s))\n                            (aset new-arr (inc d) (aget arr (inc s)))\n                            (recur (+ s 2) (+ d 2))))))))\n        coll)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength arr)]\n      (loop [i 0 init init]\n        (if (\x3c i len)\n          (let [init (f init (aget arr i) (aget arr (inc i)))]\n            (if (reduced? init)\n              @init\n              (recur (+ i 2) init)))\n          init))))\n  \n  IReduce\n  (-reduce [coll f]\n    (iter-reduce coll f))\n  (-reduce [coll f start]\n    (iter-reduce coll f start))\n  \n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientArrayMap. (js-obj) (alength arr) (aclone arr))))\n\n(set! (.-EMPTY PersistentArrayMap) (PersistentArrayMap. nil 0 (array) empty-unordered-hash))\n\n(set! (.-HASHMAP-THRESHOLD PersistentArrayMap) 8)\n\n(set! (.-fromArray PersistentArrayMap)\n  (fn [arr ^boolean no-clone ^boolean no-check]\n    (as-\x3e (if no-clone arr (aclone arr)) arr\n      (if no-check\n        arr\n        (let [ret (array)]\n          (loop [i 0]\n            (when (\x3c i (alength arr))\n              (let [k (aget arr i)\n                    v (aget arr (inc i))\n                    idx (array-index-of ret k)]\n                (when (\x3d\x3d idx -1)\n                  (.push ret k)\n                  (.push ret v)))\n              (recur (+ i 2))))\n          ret))\n      (let [cnt (/ (alength arr) 2)]\n        (PersistentArrayMap. nil cnt arr nil)))))\n\n(set! (.-createWithCheck PersistentArrayMap)\n  (fn [arr]\n    (let [ret (array)]\n      (loop [i 0]\n        (when (\x3c i (alength arr))\n          (let [k (aget arr i)\n                v (aget arr (inc i))\n                idx (array-index-of ret k)]\n            (if (\x3d\x3d idx -1)\n              (doto ret (.push k) (.push v))\n              (throw (js/Error. (str "Duplicate key: " k)))))\n          (recur (+ i 2))))\n      (let [cnt (/ (alength arr) 2)]\n        (PersistentArrayMap. nil cnt arr nil)))))\n\n(set! (.-createAsIfByAssoc PersistentArrayMap)\n  (fn [arr]\n    (let [ret (array)]\n      (loop [i 0]\n        (when (\x3c i (alength arr))\n          (let [k (aget arr i)\n                v (aget arr (inc i))\n                idx (array-index-of ret k)]\n            (if (\x3d\x3d idx -1)\n              (doto ret (.push k) (.push v))\n              (aset ret (inc idx) v)))\n          (recur (+ i 2))))\n      (PersistentArrayMap. nil (/ (alength ret) 2) ret nil))))\n\n(es6-iterable PersistentArrayMap)\n\n(declare array-\x3etransient-hash-map)\n\n(deftype TransientArrayMap [^:mutable editable?\n                            ^:mutable len\n                            arr]\n  ICounted\n  (-count [tcoll]\n    (if editable?\n      (quot len 2)\n      (throw (js/Error. "count after persistent!"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (-lookup tcoll k nil))\n\n  (-lookup [tcoll k not-found]\n    (if editable?\n      (let [idx (array-map-index-of tcoll k)]\n        (if (\x3d\x3d idx -1)\n          not-found\n          (aget arr (inc idx))))\n      (throw (js/Error. "lookup after persistent!"))))\n\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if editable?\n      (cond\n        (map-entry? o)\n        (-assoc! tcoll (key o) (val o))\n\n        (vector? o)\n        (-assoc! tcoll (o 0) (o 1))\n\n        :else\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (-assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. "conj! after persistent!"))))\n\n  (-persistent! [tcoll]\n    (if editable?\n      (do (set! editable? false)\n          (PersistentArrayMap. nil (quot len 2) arr nil))\n      (throw (js/Error. "persistent! called twice"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (if (\x3d\x3d idx -1)\n          (if (\x3c\x3d (+ len 2) (* 2 (.-HASHMAP-THRESHOLD PersistentArrayMap)))\n            (do (set! len (+ len 2))\n                (.push arr key)\n                (.push arr val)\n                tcoll)\n            (assoc! (array-\x3etransient-hash-map len arr) key val))\n          (if (identical? val (aget arr (inc idx)))\n            tcoll\n            (do (aset arr (inc idx) val)\n                tcoll))))\n      (throw (js/Error. "assoc! after persistent!"))))\n\n  ITransientMap\n  (-dissoc! [tcoll key]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (when (\x3e\x3d idx 0)\n          (aset arr idx (aget arr (- len 2)))\n          (aset arr (inc idx) (aget arr (dec len)))\n          (doto arr .pop .pop)\n          (set! len (- len 2)))\n        tcoll)\n      (throw (js/Error. "dissoc! after persistent!"))))\n  \n  IFn\n  (-invoke [tcoll key]\n    (-lookup tcoll key nil))\n  (-invoke [tcoll key not-found]\n    (-lookup tcoll key not-found)))\n\n(declare TransientHashMap)\n\n(defn- array-\x3etransient-hash-map [len arr]\n  (loop [out (transient (.-EMPTY PersistentHashMap))\n         i   0]\n    (if (\x3c i len)\n      (recur (assoc! out (aget arr i) (aget arr (inc i))) (+ i 2))\n      out)))\n\n;;; PersistentHashMap\n\n(deftype Box [^:mutable val])\n\n(declare create-inode-seq create-array-node-seq reset! create-node atom deref)\n\n(defn key-test [key other]\n  (cond\n    (identical? key other) true\n    (keyword-identical? key other) true\n    :else (\x3d key other)))\n\n(defn- mask [hash shift]\n  (bit-and (bit-shift-right-zero-fill hash shift) 0x01f))\n\n(defn- clone-and-set\n  ([arr i a]\n     (doto (aclone arr)\n       (aset i a)))\n  ([arr i a j b]\n     (doto (aclone arr)\n       (aset i a)\n       (aset j b))))\n\n(defn- remove-pair [arr i]\n  (let [new-arr (make-array (- (alength arr) 2))]\n    (array-copy arr 0 new-arr 0 (* 2 i))\n    (array-copy arr (* 2 (inc i)) new-arr (* 2 i) (- (alength new-arr) (* 2 i)))\n    new-arr))\n\n(defn- bitmap-indexed-node-index [bitmap bit]\n  (bit-count (bit-and bitmap (dec bit))))\n\n(defn- bitpos [hash shift]\n  (bit-shift-left 1 (mask hash shift)))\n\n(defn- edit-and-set\n  ([inode edit i a]\n     (let [editable (.ensure-editable inode edit)]\n       (aset (.-arr editable) i a)\n       editable))\n  ([inode edit i a j b]\n     (let [editable (.ensure-editable inode edit)]\n       (aset (.-arr editable) i a)\n       (aset (.-arr editable) j b)\n       editable)))\n\n(defn- inode-kv-reduce [arr f init]\n  (let [len (alength arr)]\n    (loop [i 0 init init]\n      (if (\x3c i len)\n        (let [init (let [k (aget arr i)]\n                     (if-not (nil? k)\n                       (f init k (aget arr (inc i)))\n                       (let [node (aget arr (inc i))]\n                         (if-not (nil? node)\n                           (.kv-reduce node f init)\n                           init))))]\n          (if (reduced? init)\n            init\n            (recur (+ i 2) init)))\n        init))))\n\n(declare ArrayNode)\n\n (deftype NodeIterator [arr ^:mutable i ^:mutable next-entry ^:mutable next-iter]\n  Object\n  (advance [this]\n    (let [len (alength arr)]\n      (loop []\n        (if (\x3c i len)\n          (let [key (aget arr i)\n                node-or-val (aget arr (inc i))\n                ^boolean found\n                (cond (some? key)\n                      (set! next-entry (MapEntry. key node-or-val nil))\n                      (some? node-or-val)\n                      (let [new-iter (-iterator node-or-val)]\n                        (if ^boolean (.hasNext new-iter)\n                          (set! next-iter new-iter)\n                          false))\n                      :else false)]\n            (set! i (+ i 2))\n            (if found true (recur)))\n          false))))\n  (hasNext [this]\n    (or (some? next-entry) (some? next-iter) (.advance this)))\n  (next [this]\n    (cond\n      (some? next-entry)\n      (let [ret next-entry]\n        (set! next-entry nil)\n        ret)\n      (some? next-iter)\n      (let [ret (.next next-iter)]\n        (when-not ^boolean (.hasNext next-iter)\n          (set! next-iter nil))\n        ret)\n      ^boolean (.advance this)\n      (.next this)\n      :else (throw (js/Error. "No such element"))))\n  (remove [_] (js/Error. "Unsupported operation")))\n\n(deftype BitmapIndexedNode [edit ^:mutable bitmap ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (if (\x3e\x3d n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (\x3c i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc (.-EMPTY BitmapIndexedNode)\n                                              (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. nil (inc n) nodes))\n            (let [new-arr (make-array (* 2 (inc n)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (BitmapIndexedNode. nil (bit-or bitmap bit) new-arr))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc val-or-node (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) val)))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (BitmapIndexedNode. nil bitmap\n                                        (clone-and-set arr (* 2 idx) nil (inc (* 2 idx))\n                                                       (create-node (+ shift 5) key-or-nil val-or-node hash key val)))))))))\n\n  (inode-without [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without val-or-node (+ shift 5) hash key)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))\n                        (\x3d\x3d bitmap bit) nil\n                        :else (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))))\n                (key-test key key-or-nil)\n                (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))\n                :else inode)))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)  (.inode-lookup val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil) val-or-node\n                :else not-found)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil) (.inode-find val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil)          (MapEntry. key-or-nil val-or-node nil)\n                :else not-found)))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [n       (bit-count bitmap)\n            new-arr (make-array (if (neg? n) 4 (* 2 (inc n))))]\n        (array-copy arr 0 new-arr 0 (* 2 n))\n        (BitmapIndexedNode. e bitmap new-arr))))\n\n  (edit-and-remove-pair [inode e bit i]\n    (if (\x3d\x3d bitmap bit)\n      nil\n      (let [editable (.ensure-editable inode e)\n            earr     (.-arr editable)\n            len      (alength earr)]\n        (set! (.-bitmap editable) (bit-xor bit (.-bitmap editable)))\n        (array-copy earr (* 2 (inc i))\n                    earr (* 2 i)\n                    (- len (* 2 (inc i))))\n        (aset earr (- len 2) nil)\n        (aset earr (dec len) nil)\n        editable)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (cond\n            (\x3c (* 2 n) (alength arr))\n            (let [editable (.ensure-editable inode edit)\n                  earr     (.-arr editable)]\n              (set! (.-val added-leaf?) true)\n              (array-copy-downward earr (* 2 idx)\n                                   earr (* 2 (inc idx))\n                                   (* 2 (- n idx)))\n              (aset earr (* 2 idx) key)\n              (aset earr (inc (* 2 idx)) val)\n              (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n              editable)\n\n            (\x3e\x3d n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (\x3c i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc! (.-EMPTY BitmapIndexedNode)\n                                               edit (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. edit (inc n) nodes))\n\n            :else\n            (let [new-arr (make-array (* 2 (+ n 4)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (let [editable (.ensure-editable inode edit)]\n                (set! (.-arr editable) new-arr)\n                (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n                editable))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc! val-or-node edit (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (edit-and-set inode edit (inc (* 2 idx)) n)))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (edit-and-set inode edit (inc (* 2 idx)) val))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (edit-and-set inode edit (* 2 idx) nil (inc (* 2 idx))\n                                  (create-node edit (+ shift 5) key-or-nil val-or-node hash key val))))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without! val-or-node edit (+ shift 5) hash key removed-leaf?)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (edit-and-set inode edit (inc (* 2 idx)) n)\n                        (\x3d\x3d bitmap bit) nil\n                        :else (.edit-and-remove-pair inode edit bit idx)))\n                (key-test key key-or-nil)\n                (do (set! (.-val removed-leaf?) true)\n                    (.edit-and-remove-pair inode edit bit idx))\n                :else inode)))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init))\n\n  IIterable\n  (-iterator [coll]\n    (NodeIterator. arr 0 nil nil)))\n\n(set! (.-EMPTY BitmapIndexedNode) (BitmapIndexedNode. nil 0 (make-array 0)))\n\n(defn- pack-array-node [array-node edit idx]\n  (let [arr     (.-arr array-node)\n        len     (alength arr)\n        new-arr (make-array (* 2 (dec (.-cnt array-node))))]\n    (loop [i 0 j 1 bitmap 0]\n      (if (\x3c i len)\n        (if (and (not (\x3d\x3d i idx))\n                 (not (nil? (aget arr i))))\n          (do (aset new-arr j (aget arr i))\n              (recur (inc i) (+ j 2) (bit-or bitmap (bit-shift-left 1 i))))\n          (recur (inc i) j bitmap))\n        (BitmapIndexedNode. edit bitmap new-arr)))))\n\n(deftype ArrayNodeIterator [arr ^:mutable i ^:mutable next-iter]\n  Object\n  (hasNext [this]\n    (let [len (alength arr)]\n      (loop []\n        (if-not (and  (some? next-iter) ^boolean (.hasNext next-iter))\n          (if (\x3c i len)\n            (let [node (aget arr i)]\n              (set! i (inc i))\n              (when (some? node)\n                (set! next-iter (-iterator node)))\n              (recur))\n            false)\n          true))))\n  (next [this]\n    (if ^boolean (.hasNext this)\n      (.next next-iter)\n      (throw (js/Error. "No such element"))))\n  (remove [_] (js/Error. "Unsupported operation")))\n\n(deftype ArrayNode [edit ^:mutable cnt ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (ArrayNode. nil (inc cnt) (clone-and-set arr idx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?)))\n        (let [n (.inode-assoc node (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (ArrayNode. nil cnt (clone-and-set arr idx n)))))))\n\n  (inode-without [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (let [n (.inode-without node (+ shift 5) hash key)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (\x3c\x3d cnt 8)\n              (pack-array-node inode nil idx)\n              (ArrayNode. nil (dec cnt) (clone-and-set arr idx n)))\n\n            :else\n            (ArrayNode. nil cnt (clone-and-set arr idx n))))\n        inode)))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-lookup node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-find node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-seq [inode]\n    (create-array-node-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (ArrayNode. e cnt (aclone arr))))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (let [editable (edit-and-set inode edit idx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))]\n          (set! (.-cnt editable) (inc (.-cnt editable)))\n          editable)\n        (let [n (.inode-assoc! node edit (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (edit-and-set inode edit idx n))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        inode\n        (let [n (.inode-without! node edit (+ shift 5) hash key removed-leaf?)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (\x3c\x3d cnt 8)\n              (pack-array-node inode edit idx)\n              (let [editable (edit-and-set inode edit idx n)]\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))\n\n            :else\n            (edit-and-set inode edit idx n))))))\n\n  (kv-reduce [inode f init]\n    (let [len (alength arr)]           ; actually 32\n      (loop [i 0 init init]\n        (if (\x3c i len)\n          (let [node (aget arr i)]\n            (if-not (nil? node)\n              (let [init (.kv-reduce node f init)]\n                (if (reduced? init)\n                  init\n                  (recur (inc i) init)))\n              (recur (inc i) init)))\n          init))))\n\n IIterable\n (-iterator [coll]\n    (ArrayNodeIterator. arr 0 nil)))\n\n(defn- hash-collision-node-find-index [arr cnt key]\n  (let [lim (* 2 cnt)]\n    (loop [i 0]\n      (if (\x3c i lim)\n        (if (key-test key (aget arr i))\n          i\n          (recur (+ i 2)))\n        -1))))\n\n(deftype HashCollisionNode [edit\n                            ^:mutable collision-hash\n                            ^:mutable cnt\n                            ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (if (\x3d\x3d hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (\x3d\x3d idx -1)\n          (let [len     (* 2 cnt)\n                new-arr (make-array (+ len 2))]\n            (array-copy arr 0 new-arr 0 len)\n            (aset new-arr len key)\n            (aset new-arr (inc len) val)\n            (set! (.-val added-leaf?) true)\n            (HashCollisionNode. nil collision-hash (inc cnt) new-arr))\n          (if (\x3d (aget arr (inc idx)) val)\n            inode\n            (HashCollisionNode. nil collision-hash cnt (clone-and-set arr (inc idx) val)))))\n      (.inode-assoc (BitmapIndexedNode. nil (bitpos collision-hash shift) (array nil inode))\n                    shift hash key val added-leaf?)))\n\n  (inode-without [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (\x3d\x3d idx -1) inode\n            (\x3d\x3d cnt 1)  nil\n            :else (HashCollisionNode. nil collision-hash (dec cnt) (remove-pair arr (quot idx 2))))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (\x3c idx 0)              not-found\n            (key-test key (aget arr idx)) (aget arr (inc idx))\n            :else                  not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (\x3c idx 0)              not-found\n            (key-test key (aget arr idx)) (MapEntry. (aget arr idx) (aget arr (inc idx)) nil)\n            :else                  not-found)))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [new-arr (make-array (* 2 (inc cnt)))]\n        (array-copy arr 0 new-arr 0 (* 2 cnt))\n        (HashCollisionNode. e collision-hash cnt new-arr))))\n\n  (ensure-editable-array [inode e count array]\n    (if (identical? e edit)\n      (do (set! arr array)\n          (set! cnt count)\n          inode)\n      (HashCollisionNode. edit collision-hash count array)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (if (\x3d\x3d hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (\x3d\x3d idx -1)\n          (if (\x3e (alength arr) (* 2 cnt))\n            (let [editable (edit-and-set inode edit (* 2 cnt) key (inc (* 2 cnt)) val)]\n              (set! (.-val added-leaf?) true)\n              (set! (.-cnt editable) (inc (.-cnt editable)))\n              editable)\n            (let [len     (alength arr)\n                  new-arr (make-array (+ len 2))]\n              (array-copy arr 0 new-arr 0 len)\n              (aset new-arr len key)\n              (aset new-arr (inc len) val)\n              (set! (.-val added-leaf?) true)\n              (.ensure-editable-array inode edit (inc cnt) new-arr)))\n          (if (identical? (aget arr (inc idx)) val)\n            inode\n            (edit-and-set inode edit (inc idx) val))))\n      (.inode-assoc! (BitmapIndexedNode. edit (bitpos collision-hash shift) (array nil inode nil nil))\n                     edit shift hash key val added-leaf?)))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (if (\x3d\x3d idx -1)\n        inode\n        (do (set! (.-val removed-leaf?) true)\n            (if (\x3d\x3d cnt 1)\n              nil\n              (let [editable (.ensure-editable inode edit)\n                    earr     (.-arr editable)]\n                (aset earr idx (aget earr (- (* 2 cnt) 2)))\n                (aset earr (inc idx) (aget earr (dec (* 2 cnt))))\n                (aset earr (dec (* 2 cnt)) nil)\n                (aset earr (- (* 2 cnt) 2) nil)\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init))\n\n  IIterable\n  (-iterator [coll]\n    (NodeIterator. arr 0 nil nil)))\n\n(defn- create-node\n  ([shift key1 val1 key2hash key2 val2]\n     (let [key1hash (hash key1)]\n       (if (\x3d\x3d key1hash key2hash)\n         (HashCollisionNode. nil key1hash 2 (array key1 val1 key2 val2))\n         (let [added-leaf? (Box. false)]\n           (-\x3e (.-EMPTY BitmapIndexedNode)\n               (.inode-assoc shift key1hash key1 val1 added-leaf?)\n               (.inode-assoc shift key2hash key2 val2 added-leaf?))))))\n  ([edit shift key1 val1 key2hash key2 val2]\n     (let [key1hash (hash key1)]\n       (if (\x3d\x3d key1hash key2hash)\n         (HashCollisionNode. nil key1hash 2 (array key1 val1 key2 val2))\n         (let [added-leaf? (Box. false)]\n           (-\x3e (.-EMPTY BitmapIndexedNode)\n               (.inode-assoc! edit shift key1hash key1 val1 added-leaf?)\n               (.inode-assoc! edit shift key2hash key2 val2 added-leaf?)))))))\n\n(deftype NodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (NodeSeq. new-meta nodes i s __hash)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeq\n  (-first [coll]\n    (if (nil? s)\n      (MapEntry. (aget nodes i) (aget nodes (inc i)) nil)\n      (first s)))\n\n  (-rest [coll]\n    (let [ret (if (nil? s)\n                (create-inode-seq nodes (+ i 2) nil)\n                (create-inode-seq nodes i (next s)))]\n      (if-not (nil? ret) ret ())))\n\n  INext\n  (-next [coll]\n    (if (nil? s)\n      (create-inode-seq nodes (+ i 2) nil)\n      (create-inode-seq nodes i (next s))))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable NodeSeq)\n\n(defn- create-inode-seq\n  ([nodes]\n     (create-inode-seq nodes 0 nil))\n  ([nodes i s]\n     (if (nil? s)\n       (let [len (alength nodes)]\n         (loop [j i]\n           (if (\x3c j len)\n             (if-not (nil? (aget nodes j))\n               (NodeSeq. nil nodes j nil nil)\n               (if-let [node (aget nodes (inc j))]\n                 (if-let [node-seq (.inode-seq node)]\n                   (NodeSeq. nil nodes (+ j 2) node-seq nil)\n                   (recur (+ j 2)))\n                 (recur (+ j 2)))))))\n       (NodeSeq. nil nodes i s nil))))\n\n(deftype ArrayNodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (ArrayNodeSeq. new-meta nodes i s __hash)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeq\n  (-first [coll] (first s))\n  (-rest  [coll]\n    (let [ret (create-array-node-seq nodes i (next s))]\n      (if-not (nil? ret) ret ())))\n\n  INext\n  (-next [coll]\n    (create-array-node-seq nodes i (next s)))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable ArrayNodeSeq)\n\n(defn- create-array-node-seq\n  ([nodes] (create-array-node-seq nodes 0 nil))\n  ([nodes i s]\n     (if (nil? s)\n       (let [len (alength nodes)]\n         (loop [j i]\n           (if (\x3c j len)\n             (if-let [nj (aget nodes j)]\n               (if-let [ns (.inode-seq nj)]\n                 (ArrayNodeSeq. nil nodes (inc j) ns nil)\n                 (recur (inc j)))\n               (recur (inc j))))))\n       (ArrayNodeSeq. nil nodes i s nil))))\n\n(deftype HashMapIter [nil-val root-iter ^:mutable seen]\n  Object\n  (hasNext [_]\n    (or (not ^boolean seen) ^boolean (.hasNext root-iter)))\n  (next [_]\n    (if-not ^boolean seen\n      (do\n        (set! seen true)\n        (MapEntry. nil nil-val nil))\n      (.next root-iter)))\n  (remove [_] (js/Error. "Unsupported operation")))\n\n(deftype PersistentHashMap [meta cnt root ^boolean has-nil? nil-val ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IIterable\n  (-iterator [coll]\n    (let [root-iter (if ^boolean root (-iterator root) (nil-iter))]\n      (if has-nil?\n        (HashMapIter. nil-val root-iter false)\n        root-iter)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentHashMap. new-meta cnt root has-nil? nil-val __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. "conj on a map takes map entries or seqables of map entries"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentHashMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [s (if-not (nil? root) (.inode-seq root))]\n        (if has-nil?\n          (cons (MapEntry. nil nil-val nil) s)\n          s))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond (nil? k)    (if has-nil?\n                        nil-val\n                        not-found)\n          (nil? root) not-found\n          :else       (.inode-lookup root 0 (hash k) k not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (nil? k)\n      (if (and has-nil? (identical? v nil-val))\n        coll\n        (PersistentHashMap. meta (if has-nil? cnt (inc cnt)) root true v nil))\n      (let [added-leaf? (Box. false)\n            new-root    (-\x3e (if (nil? root)\n                              (.-EMPTY BitmapIndexedNode)\n                              root)\n                            (.inode-assoc 0 (hash k) k v added-leaf?))]\n        (if (identical? new-root root)\n          coll\n          (PersistentHashMap. meta (if ^boolean (.-val added-leaf?) (inc cnt) cnt) new-root has-nil? nil-val nil)))))\n\n  (-contains-key? [coll k]\n    (cond (nil? k)    has-nil?\n          (nil? root) false\n          :else       (not (identical? (.inode-lookup root 0 (hash k) k lookup-sentinel)\n                                       lookup-sentinel))))\n\n  IFind\n  (-find [coll k]\n    (cond\n      (nil? k) (when has-nil? (MapEntry. nil nil-val nil))\n      (nil? root) nil\n      :else (.inode-find root 0 (hash k) k nil)))\n\n  IMap\n  (-dissoc [coll k]\n    (cond (nil? k)    (if has-nil?\n                        (PersistentHashMap. meta (dec cnt) root false nil nil)\n                        coll)\n          (nil? root) coll\n          :else\n          (let [new-root (.inode-without root 0 (hash k) k)]\n            (if (identical? new-root root)\n              coll\n              (PersistentHashMap. meta (dec cnt) new-root has-nil? nil-val nil)))))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [init (if has-nil? (f init nil nil-val) init)]\n      (cond\n        (reduced? init)          @init\n        (not (nil? root)) (unreduced (.kv-reduce root f init))\n        :else                    init)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientHashMap. (js-obj) root cnt has-nil? nil-val)))\n\n(set! (.-EMPTY PersistentHashMap) (PersistentHashMap. nil 0 nil false nil empty-unordered-hash))\n\n(set! (.-fromArray PersistentHashMap)\n  (fn [arr ^boolean no-clone]\n    (let [arr (if no-clone arr (aclone arr))\n          len (alength arr)]\n      (loop [i 0 ret (transient (.-EMPTY PersistentHashMap))]\n        (if (\x3c i len)\n          (recur (+ i 2)\n            (-assoc! ret (aget arr i) (aget arr (inc i))))\n          (-persistent! ret))))))\n\n(set! (.-fromArrays PersistentHashMap)\n  (fn [ks vs]\n    (let [len (alength ks)]\n      (loop [i 0 ^not-native out (transient (.-EMPTY PersistentHashMap))]\n        (if (\x3c i len)\n          (recur (inc i) (-assoc! out (aget ks i) (aget vs i)))\n          (persistent! out))))))\n\n(set! (.-createWithCheck PersistentHashMap)\n  (fn [arr]\n    (let [len (alength arr)\n          ret (transient (.-EMPTY PersistentHashMap))]\n      (loop [i 0]\n        (when (\x3c i len)\n          (-assoc! ret (aget arr i) (aget arr (inc i)))\n          (if (not\x3d (-count ret) (inc (/ i 2)))\n            (throw (js/Error. (str "Duplicate key: " (aget arr i))))\n            (recur (+ i 2)))))\n      (-persistent! ret))))\n\n(es6-iterable PersistentHashMap)\n\n(deftype TransientHashMap [^:mutable ^boolean edit\n                           ^:mutable root\n                           ^:mutable count\n                           ^:mutable ^boolean has-nil?\n                           ^:mutable nil-val]\n  Object\n  (conj! [tcoll o]\n    (if edit\n      (cond\n        (map-entry? o)\n        (.assoc! tcoll (key o) (val o))\n\n        (vector? o)\n        (.assoc! tcoll (o 0) (o 1))\n\n        :else\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (.assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. "conj! after persistent"))))\n\n  (assoc! [tcoll k v]\n    (if edit\n      (if (nil? k)\n        (do (if (identical? nil-val v)\n              nil\n              (set! nil-val v))\n            (if has-nil?\n              nil\n              (do (set! count (inc count))\n                  (set! has-nil? true)))\n            tcoll)\n        (let [added-leaf? (Box. false)\n              node        (-\x3e (if (nil? root)\n                                (.-EMPTY BitmapIndexedNode)\n                                root)\n                              (.inode-assoc! edit 0 (hash k) k v added-leaf?))]\n          (if (identical? node root)\n            nil\n            (set! root node))\n          (if ^boolean (.-val added-leaf?)\n            (set! count (inc count)))\n          tcoll))\n      (throw (js/Error. "assoc! after persistent!"))))\n\n  (without! [tcoll k]\n    (if edit\n      (if (nil? k)\n        (if has-nil?\n          (do (set! has-nil? false)\n              (set! nil-val nil)\n              (set! count (dec count))\n              tcoll)\n          tcoll)\n        (if (nil? root)\n          tcoll\n          (let [removed-leaf? (Box. false)\n                node (.inode-without! root edit 0 (hash k) k removed-leaf?)]\n            (if (identical? node root)\n              nil\n              (set! root node))\n            (if ^boolean (.-val removed-leaf?)\n              (set! count (dec count)))\n            tcoll)))\n      (throw (js/Error. "dissoc! after persistent!"))))\n\n  (persistent! [tcoll]\n    (if edit\n      (do (set! edit nil)\n          (PersistentHashMap. nil count root has-nil? nil-val nil))\n      (throw (js/Error. "persistent! called twice"))))\n\n  ICounted\n  (-count [coll]\n    (if edit\n      count\n      (throw (js/Error. "count after persistent!"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (if (nil? k)\n      (if has-nil?\n        nil-val)\n      (if (nil? root)\n        nil\n        (.inode-lookup root 0 (hash k) k))))\n\n  (-lookup [tcoll k not-found]\n    (if (nil? k)\n      (if has-nil?\n        nil-val\n        not-found)\n      (if (nil? root)\n        not-found\n        (.inode-lookup root 0 (hash k) k not-found))))\n\n  ITransientCollection\n  (-conj! [tcoll val] (.conj! tcoll val))\n\n  (-persistent! [tcoll] (.persistent! tcoll))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (.assoc! tcoll key val))\n\n  ITransientMap\n  (-dissoc! [tcoll key] (.without! tcoll key))\n\n  IFn\n  (-invoke [tcoll key]\n    (-lookup tcoll key))\n  (-invoke [tcoll key not-found]\n    (-lookup tcoll key not-found)))\n\n;;; PersistentTreeMap\n\n(defn- tree-map-seq-push [node stack ^boolean ascending?]\n  (loop [t node stack stack]\n    (if-not (nil? t)\n      (recur (if ascending? (.-left t) (.-right t))\n             (conj stack t))\n      stack)))\n\n(deftype PersistentTreeMapSeq [meta stack ^boolean ascending? cnt ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ISeqable\n  (-seq [this] this)\n\n  ISequential\n  ISeq\n  (-first [this] (peek stack))\n  (-rest [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (if-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil)\n        ())))\n  INext\n  (-next [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (when-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil))))\n\n  ICounted\n  (-count [coll]\n    (if (neg? cnt)\n      (inc (count (next coll)))\n      cnt))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentTreeMapSeq. new-meta stack ascending? cnt __hash)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable PersistentTreeMapSeq)\n\n(defn- create-tree-map-seq [tree ascending? cnt]\n  (PersistentTreeMapSeq. nil (tree-map-seq-push tree nil ascending?) ascending? cnt nil))\n\n(declare RedNode BlackNode)\n\n(defn- balance-left [key val ins right]\n  (if (instance? RedNode ins)\n    (cond\n      (instance? RedNode (.-left ins))\n      (RedNode. (.-key ins) (.-val ins)\n              (.blacken (.-left ins))\n              (BlackNode. key val (.-right ins) right nil)\n              nil)\n\n      (instance? RedNode (.-right ins))\n      (RedNode. (.. ins -right -key) (.. ins -right -val)\n                (BlackNode. (.-key ins) (.-val ins)\n                            (.-left ins)\n                            (.. ins -right -left)\n                            nil)\n                (BlackNode. key val\n                            (.. ins -right -right)\n                            right\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. key val ins right nil))\n    (BlackNode. key val ins right nil)))\n\n(defn- balance-right [key val left ins]\n  (if (instance? RedNode ins)\n    (cond\n      (instance? RedNode (.-right ins))\n      (RedNode. (.-key ins) (.-val ins)\n                (BlackNode. key val left (.-left ins) nil)\n                (.blacken (.-right ins))\n                nil)\n\n      (instance? RedNode (.-left ins))\n      (RedNode. (.. ins -left -key) (.. ins -left -val)\n                (BlackNode. key val left (.. ins -left -left) nil)\n                (BlackNode. (.-key ins) (.-val ins)\n                            (.. ins -left -right)\n                            (.-right ins)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. key val left ins nil))\n    (BlackNode. key val left ins nil)))\n\n(defn- balance-left-del [key val del right]\n  (cond\n    (instance? RedNode del)\n    (RedNode. key val (.blacken del) right nil)\n\n    (instance? BlackNode right)\n    (balance-right key val del (.redden right))\n\n    (and (instance? RedNode right) (instance? BlackNode (.-left right)))\n    (RedNode. (.. right -left -key) (.. right -left -val)\n              (BlackNode. key val del (.. right -left -left) nil)\n              (balance-right (.-key right) (.-val right)\n                             (.. right -left -right)\n                             (.redden (.-right right)))\n              nil)\n\n    :else\n    (throw (js/Error. "red-black tree invariant violation"))))\n\n(defn- balance-right-del [key val left del]\n  (cond\n    (instance? RedNode del)\n    (RedNode. key val left (.blacken del) nil)\n\n    (instance? BlackNode left)\n    (balance-left key val (.redden left) del)\n\n    (and (instance? RedNode left) (instance? BlackNode (.-right left)))\n    (RedNode. (.. left -right -key) (.. left -right -val)\n              (balance-left (.-key left) (.-val left)\n                            (.redden (.-left left))\n                            (.. left -right -left))\n              (BlackNode. key val (.. left -right -right) del nil)\n              nil)\n\n    :else\n    (throw (js/Error. "red-black tree invariant violation"))))\n\n(defn- tree-map-kv-reduce [node f init]\n  (let [init (if-not (nil? (.-left node))\n               (tree-map-kv-reduce (.-left node) f init)\n               init)]\n    (if (reduced? init)\n      init\n      (let [init (f init (.-key node) (.-val node))]\n        (if (reduced? init)\n          init\n          (if-not (nil? (.-right node))\n            (tree-map-kv-reduce (.-right node) f init)\n            init))))))\n\n(deftype BlackNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (.balance-left ins node))\n\n  (add-right [node ins]\n    (.balance-right ins node))\n\n  (remove-left [node del]\n    (balance-left-del key val del right))\n\n  (remove-right [node del]\n    (balance-right-del key val left del))\n\n  (blacken [node] node)\n\n  (redden [node] (RedNode. key val left right nil))\n\n  (balance-left [node parent]\n    (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil))\n\n  (balance-right [node parent]\n    (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil))\n\n  (replace [node key val left right]\n    (BlackNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (-with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] nil)\n\n  ISequential\n  ISeqable\n  (-seq [node] (IndexedSeq. #js [key val] 0 nil))\n\n  IReversible\n  (-rseq [node] (IndexedSeq. #js [val key] 0 nil))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (\x3d\x3d n 0) key\n          (\x3d\x3d n 1) val\n          :else    (throw (js/Error. "Index out of bounds"))))\n\n  (-nth [node n not-found]\n    (cond (\x3d\x3d n 0) key\n          (\x3d\x3d n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n  (-contains-key? [node k]\n    (or (\x3d\x3d k 0) (\x3d\x3d k 1)))\n\n  IFind\n  (-find [node k]\n    (case k\n      0 (MapEntry. 0 key nil)\n      1 (MapEntry. 1 val nil)\n      nil))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-nth node k))\n\n  (-invoke [node k not-found]\n    (-nth node k not-found)))\n\n(es6-iterable BlackNode)\n\n(deftype RedNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (RedNode. key val ins right nil))\n\n  (add-right [node ins]\n    (RedNode. key val left ins nil))\n\n  (remove-left [node del]\n    (RedNode. key val del right nil))\n\n  (remove-right [node del]\n    (RedNode. key val left del nil))\n\n  (blacken [node]\n    (BlackNode. key val left right nil))\n\n  (redden [node]\n    (throw (js/Error. "red-black tree invariant violation")))\n\n  (balance-left [node parent]\n    (cond\n      (instance? RedNode left)\n      (RedNode. key val\n                (.blacken left)\n                (BlackNode. (.-key parent) (.-val parent) right (.-right parent) nil)\n                nil)\n\n      (instance? RedNode right)\n      (RedNode. (.-key right) (.-val right)\n                (BlackNode. key val left (.-left right) nil)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-right right)\n                            (.-right parent)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil)))\n\n  (balance-right [node parent]\n    (cond\n      (instance? RedNode right)\n      (RedNode. key val\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            left\n                            nil)\n                (.blacken right)\n                nil)\n\n      (instance? RedNode left)\n      (RedNode. (.-key left) (.-val left)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            (.-left left)\n                            nil)\n                (BlackNode. key val (.-right left) right nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil)))\n\n  (replace [node key val left right]\n    (RedNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (-with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] nil)\n\n  ISequential\n  ISeqable\n  (-seq [node] (IndexedSeq. #js [key val] 0 nil))\n\n  IReversible\n  (-rseq [node] (IndexedSeq. #js [val key] 0 nil))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (\x3d\x3d n 0) key\n          (\x3d\x3d n 1) val\n          :else    (throw (js/Error. "Index out of bounds"))))\n\n  (-nth [node n not-found]\n    (cond (\x3d\x3d n 0) key\n          (\x3d\x3d n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n  (-contains-key? [node k]\n    (or (\x3d\x3d k 0) (\x3d\x3d k 1)))\n\n  IFind\n  (-find [node k]\n    (case k\n      0 (MapEntry. 0 key nil)\n      1 (MapEntry. 1 val nil)\n      nil))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-nth node k))\n\n  (-invoke [node k not-found]\n    (-nth node k not-found)))\n\n(es6-iterable RedNode)\n\n(defn- tree-map-add [comp tree k v found]\n  (if (nil? tree)\n    (RedNode. k v nil nil nil)\n    (let [c (comp k (.-key tree))]\n      (cond\n        (zero? c)\n        (do (aset found 0 tree)\n            nil)\n\n        (neg? c)\n        (let [ins (tree-map-add comp (.-left tree) k v found)]\n          (if-not (nil? ins)\n            (.add-left tree ins)))\n\n        :else\n        (let [ins (tree-map-add comp (.-right tree) k v found)]\n          (if-not (nil? ins)\n            (.add-right tree ins)))))))\n\n(defn- tree-map-append [left right]\n  (cond\n    (nil? left)\n    right\n\n    (nil? right)\n    left\n\n    (instance? RedNode left)\n    (if (instance? RedNode right)\n      (let [app (tree-map-append (.-right left) (.-left right))]\n        (if (instance? RedNode app)\n          (RedNode. (.-key app) (.-val app)\n                    (RedNode. (.-key left) (.-val left)\n                              (.-left left)\n                              (.-left app)\n                              nil)\n                    (RedNode. (.-key right) (.-val right)\n                              (.-right app)\n                              (.-right right)\n                              nil)\n                    nil)\n          (RedNode. (.-key left) (.-val left)\n                    (.-left left)\n                    (RedNode. (.-key right) (.-val right) app (.-right right) nil)\n                    nil)))\n      (RedNode. (.-key left) (.-val left)\n                (.-left left)\n                (tree-map-append (.-right left) right)\n                nil))\n\n    (instance? RedNode right)\n    (RedNode. (.-key right) (.-val right)\n              (tree-map-append left (.-left right))\n              (.-right right)\n              nil)\n\n    :else\n    (let [app (tree-map-append (.-right left) (.-left right))]\n      (if (instance? RedNode app)\n        (RedNode. (.-key app) (.-val app)\n                  (BlackNode. (.-key left) (.-val left)\n                              (.-left left)\n                              (.-left app)\n                              nil)\n                  (BlackNode. (.-key right) (.-val right)\n                              (.-right app)\n                              (.-right right)\n                              nil)\n                  nil)\n        (balance-left-del (.-key left) (.-val left)\n                          (.-left left)\n                          (BlackNode. (.-key right) (.-val right)\n                                      app\n                                      (.-right right)\n                                      nil))))))\n\n(defn- tree-map-remove [comp tree k found]\n  (if-not (nil? tree)\n    (let [c (comp k (.-key tree))]\n      (cond\n        (zero? c)\n        (do (aset found 0 tree)\n            (tree-map-append (.-left tree) (.-right tree)))\n\n        (neg? c)\n        (let [del (tree-map-remove comp (.-left tree) k found)]\n          (if (or (not (nil? del)) (not (nil? (aget found 0))))\n            (if (instance? BlackNode (.-left tree))\n              (balance-left-del (.-key tree) (.-val tree) del (.-right tree))\n              (RedNode. (.-key tree) (.-val tree) del (.-right tree) nil))))\n\n        :else\n        (let [del (tree-map-remove comp (.-right tree) k found)]\n          (if (or (not (nil? del)) (not (nil? (aget found 0))))\n            (if (instance? BlackNode (.-right tree))\n              (balance-right-del (.-key tree) (.-val tree) (.-left tree) del)\n              (RedNode. (.-key tree) (.-val tree) (.-left tree) del nil))))))))\n\n(defn- tree-map-replace [comp tree k v]\n  (let [tk (.-key tree)\n        c  (comp k tk)]\n    (cond (zero? c) (.replace tree tk v (.-left tree) (.-right tree))\n          (neg? c)  (.replace tree tk (.-val tree) (tree-map-replace comp (.-left tree) k v) (.-right tree))\n          :else     (.replace tree tk (.-val tree) (.-left tree) (tree-map-replace comp (.-right tree) k v)))))\n\n(declare key)\n\n(deftype PersistentTreeMap [comp tree cnt meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  (entry-at [coll k]\n    (loop [t tree]\n      (if-not (nil? t)\n        (let [c (comp k (.-key t))]\n          (cond (zero? c) t\n                (neg? c)  (recur (.-left t))\n                :else     (recur (.-right t)))))))\n\n  ICloneable\n  (-clone [_] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentTreeMap. comp tree cnt new-meta __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. "conj on a map takes map entries or seqables of map entries"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeMap. comp nil 0 meta 0))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (if-not (nil? tree)\n      (unreduced (tree-map-kv-reduce tree f init))\n      init))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  ISeqable\n  (-seq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree true cnt)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree false cnt)))\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [n (.entry-at coll k)]\n      (if-not (nil? n)\n        (.-val n)\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [found (array nil)\n          t     (tree-map-add comp tree k v found)]\n      (if (nil? t)\n        (let [found-node (nth found 0)]\n          (if (\x3d v (.-val found-node))\n            coll\n            (PersistentTreeMap. comp (tree-map-replace comp tree k v) cnt meta nil)))\n        (PersistentTreeMap. comp (.blacken t) (inc cnt) meta nil))))\n\n  (-contains-key? [coll k]\n    (not (nil? (.entry-at coll k))))\n\n  IFind\n  (-find [coll k]\n    (.entry-at coll k))\n\n  IMap\n  (-dissoc [coll k]\n    (let [found (array nil)\n          t     (tree-map-remove comp tree k found)]\n      (if (nil? t)\n        (if (nil? (nth found 0))\n          coll\n          (PersistentTreeMap. comp nil 0 meta nil))\n        (PersistentTreeMap. comp (.blacken t) (dec cnt) meta nil))))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (if (pos? cnt)\n      (create-tree-map-seq tree ascending? cnt)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (if (pos? cnt)\n      (loop [stack nil t tree]\n        (if-not (nil? t)\n          (let [c (comp k (.-key t))]\n            (cond\n              (zero? c)  (PersistentTreeMapSeq. nil (conj stack t) ascending? -1 nil)\n              ascending? (if (neg? c)\n                           (recur (conj stack t) (.-left t))\n                           (recur stack          (.-right t)))\n              :else      (if (pos? c)\n                           (recur (conj stack t) (.-right t))\n                           (recur stack          (.-left t)))))\n          (when-not (nil? stack)\n            (PersistentTreeMapSeq. nil stack ascending? -1 nil))))))\n\n  (-entry-key [coll entry] (key entry))\n\n  (-comparator [coll] comp))\n\n(set! (.-EMPTY PersistentTreeMap) (PersistentTreeMap. compare nil 0 nil empty-unordered-hash))\n\n(es6-iterable PersistentTreeMap)\n\n(defn hash-map\n  "keyval \x3d\x3e key val\n  Returns a new hash map with supplied mappings."\n  [\x26 keyvals]\n  (loop [in (seq keyvals), out (transient (.-EMPTY PersistentHashMap))]\n    (if in\n      (recur (nnext in) (assoc! out (first in) (second in)))\n      (persistent! out))))\n\n(defn array-map\n  "keyval \x3d\x3e key val\n  Returns a new array map with supplied mappings."\n  [\x26 keyvals]\n  (let [arr (if (and (instance? IndexedSeq keyvals) (zero? (.-i keyvals)))\n              (.-arr keyvals)\n              (into-array keyvals))]\n    (.createAsIfByAssoc PersistentArrayMap arr)))\n\n(defn obj-map\n  "keyval \x3d\x3e key val\n  Returns a new object map with supplied mappings."\n  [\x26 keyvals]\n  (let [ks  (array)\n        obj (js-obj)]\n    (loop [kvs (seq keyvals)]\n      (if kvs\n        (do (.push ks (first kvs))\n            (gobject/set obj (first kvs) (second kvs))\n            (recur (nnext kvs)))\n        (.fromObject ObjMap ks obj)))))\n\n(defn sorted-map\n  "keyval \x3d\x3e key val\n  Returns a new sorted map with supplied mappings."\n  ([\x26 keyvals]\n     (loop [in (seq keyvals) out (.-EMPTY PersistentTreeMap)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))\n\n(defn sorted-map-by\n  "keyval \x3d\x3e key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator."\n  ([comparator \x26 keyvals]\n     (loop [in (seq keyvals)\n            out (PersistentTreeMap. (fn-\x3ecomparator comparator) nil 0 nil 0)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))\n\n(deftype KeySeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta _meta)\n      coll\n      (KeySeq. mseq new-meta)))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n  \n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-key me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (KeySeq. nseq nil)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (KeySeq. nseq nil))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable KeySeq)\n\n(defn keys\n  "Returns a sequence of the map\'s keys, in the same order as (seq map)."\n  [map]\n  (when-let [mseq (seq map)]\n    (KeySeq. mseq nil)))\n\n(defn key\n  "Returns the key of the map entry."\n  [map-entry]\n  (-key map-entry))\n\n(deftype ValSeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta _meta)\n      coll\n      (ValSeq. mseq new-meta)))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-val me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (ValSeq. nseq nil)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (ValSeq. nseq nil))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable ValSeq)\n\n(defn vals\n  "Returns a sequence of the map\'s values, in the same order as (seq map)."\n  [map]\n  (when-let [mseq (seq map)]\n    (ValSeq. mseq nil)))\n\n(defn val\n  "Returns the value in the map entry."\n  [map-entry]\n  (-val map-entry))\n\n(defn merge\n  "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result."\n  [\x26 maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))\n\n(defn merge-with\n  "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter)."\n  [f \x26 maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (key e) v (val e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))\n\n(defn select-keys\n  "Returns a map containing only those entries in map whose key is in keys"\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not\x3d entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        (-with-meta ret (meta map)))))\n\n;;; PersistentHashSet\n\n(declare TransientHashSet)\n\n(deftype HashSetIter [iter]\n  Object\n  (hasNext [_]\n    (.hasNext iter))\n  (next [_]\n    (if ^boolean (.hasNext iter)\n      (.-key (.next iter))\n      (throw (js/Error. "No such element"))))\n  (remove [_] (js/Error. "Unsupported operation")))\n\n(deftype PersistentHashSet [meta hash-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashSet. meta hash-map __hash))\n\n  IIterable\n  (-iterator [coll]\n    (HashSetIter. (-iterator hash-map)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentHashSet. new-meta hash-map __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentHashSet. meta (assoc hash-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentHashSet) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (\x3d\x3d (count coll) (count other))\n     ^boolean\n     (try\n       (reduce-kv\n         #(or (contains? other %2) (reduced false))\n         true hash-map)\n       (catch js/Error ex\n         false))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (-count hash-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if-let [entry (-find hash-map v)]\n      (key entry)\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentHashSet. meta (-dissoc hash-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll] (TransientHashSet. (-as-transient hash-map))))\n\n(set! (.-EMPTY PersistentHashSet)\n  (PersistentHashSet. nil (.-EMPTY PersistentArrayMap) empty-unordered-hash))\n\n(set! (.-fromArray PersistentHashSet)\n  (fn [items ^boolean no-clone]\n    (let [len (alength items)]\n      (if (\x3c\x3d len (.-HASHMAP-THRESHOLD PersistentArrayMap))\n        (let [arr (if no-clone items (aclone items))]\n          (loop [i 0\n                 out (transient (.-EMPTY PersistentArrayMap))]\n            (if (\x3c i len)\n              (recur (inc i) (-assoc! out (aget items i) nil))\n              (PersistentHashSet. nil (-persistent! out) nil))))\n       (loop [i 0\n              out (transient (.-EMPTY PersistentHashSet))]\n         (if (\x3c i len)\n           (recur (inc i) (-conj! out (aget items i)))\n           (-persistent! out)))))))\n\n(set! (.-createWithCheck PersistentHashSet)\n      (fn [items]\n        (let [len (alength items)\n              t (-as-transient (.-EMPTY PersistentHashSet))]\n          (dotimes [i len]\n            (-conj! t (aget items i))\n            (when-not (\x3d (count t) (inc i))\n              (throw (js/Error. (str "Duplicate key: " (aget items i))))))\n          (-persistent! t))))\n\n(set! (.-createAsIfByAssoc PersistentHashSet)\n      (fn [items]\n        (let [len (alength items)\n              t (-as-transient (.-EMPTY PersistentHashSet))]\n          (dotimes [i len] (-conj! t (aget items i)))\n          (-persistent! t))))\n\n(es6-iterable PersistentHashSet)\n\n(deftype TransientHashSet [^:mutable transient-map]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (set! transient-map (assoc! transient-map o nil))\n    tcoll)\n\n  (-persistent! [tcoll]\n    (PersistentHashSet. nil (persistent! transient-map) nil))\n\n  ITransientSet\n  (-disjoin! [tcoll v]\n    (set! transient-map (dissoc! transient-map v))\n    tcoll)\n\n  ICounted\n  (-count [tcoll] (count transient-map))\n\n  ILookup\n  (-lookup [tcoll v]\n    (-lookup tcoll v nil))\n\n  (-lookup [tcoll v not-found]\n    (if (identical? (-lookup transient-map v lookup-sentinel) lookup-sentinel)\n      not-found\n      v))\n\n  IFn\n  (-invoke [tcoll k]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      nil\n      k))\n\n  (-invoke [tcoll k not-found]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      not-found\n      k)))\n\n(deftype PersistentTreeSet [meta tree-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentTreeSet. meta tree-map __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentTreeSet. new-meta tree-map __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentTreeSet. meta (assoc tree-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeSet. meta (-empty tree-map) 0))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (\x3d\x3d (count coll) (count other))\n     ^boolean\n     (try\n       (reduce-kv\n         #(or (contains? other %2) (reduced false))\n         true tree-map)\n       (catch js/Error ex\n         false))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys tree-map))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (map key (-sorted-seq tree-map ascending?)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (map key (-sorted-seq-from tree-map k ascending?)))\n\n  (-entry-key [coll entry] entry)\n\n  (-comparator [coll] (-comparator tree-map))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? (count tree-map))\n      (map key (rseq tree-map))))\n\n  ICounted\n  (-count [coll] (count tree-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (let [n (.entry-at tree-map v)]\n      (if-not (nil? n)\n        (.-key n)\n        not-found)))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentTreeSet. meta (dissoc tree-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))\n\n(set! (.-EMPTY PersistentTreeSet)\n  (PersistentTreeSet. nil (.-EMPTY PersistentTreeMap) empty-unordered-hash))\n\n(es6-iterable PersistentTreeSet)\n\n(defn set-from-indexed-seq [iseq]\n  (let [arr (.-arr iseq)\n        ret (areduce arr i ^not-native res (-as-transient #{})\n              (-conj! res (aget arr i)))]\n    (-persistent! ^not-native ret)))\n\n(defn set\n  "Returns a set of the distinct elements of coll."\n  [coll]\n  (if (set? coll)\n    (with-meta coll nil)\n    (let [in (seq coll)]\n      (cond\n        (nil? in) #{}\n\n        (and (instance? IndexedSeq in) (zero? (.-i in)))\n        (.createAsIfByAssoc PersistentHashSet (.-arr in))\n\n        :else\n        (loop [^not-native in  in\n               ^not-native out (-as-transient #{})]\n          (if-not (nil? in)\n            (recur (next in) (-conj! out (-first in)))\n            (persistent! out)))))))\n\n(defn hash-set\n  "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj."\n  ([] #{})\n  ([\x26 keys] (set keys)))\n\n(defn sorted-set\n  "Returns a new sorted set with supplied keys."\n  ([\x26 keys]\n   (reduce -conj (.-EMPTY PersistentTreeSet) keys)))\n\n(defn sorted-set-by\n  "Returns a new sorted set with supplied keys, using the supplied comparator."\n  ([comparator \x26 keys]\n   (reduce -conj\n           (PersistentTreeSet. nil (sorted-map-by comparator) 0)\n           keys)))\n\n(defn replace\n  "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements \x3d a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided."\n  ([smap]\n     (map #(if-let [e (find smap %)] (val e) %)))\n  ([smap coll]\n     (if (vector? coll)\n       (let [n (count coll)]\n         (reduce (fn [v i]\n                   (if-let [e (find smap (nth v i))]\n                     (assoc v i (second e))\n                     v))\n           coll (take n (iterate inc 0))))\n       (map #(if-let [e (find smap %)] (second e) %) coll))))\n\n(defn distinct\n  "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided."\n  ([]\n    (fn [rf]\n      (let [seen (volatile! #{})]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if (contains? @seen input)\n              result\n              (do (vswap! seen conj input)\n                  (rf result input))))))))\n  ([coll]\n    (let [step (fn step [xs seen]\n                 (lazy-seq\n                   ((fn [[f :as xs] seen]\n                      (when-let [s (seq xs)]\n                        (if (contains? seen f)\n                          (recur (rest s) seen)\n                          (cons f (step (rest s) (conj seen f))))))\n                     xs seen)))]\n      (step coll #{}))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn butlast\n  "Return a seq of all but the last item in coll, in linear time"\n  [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))\n\n(defn name\n  "Returns the name String of a string, symbol or keyword."\n  [x]\n  (if (implements? INamed x)\n    (-name x)\n    (if (string? x)\n      x\n      (throw (js/Error. (str "Doesn\'t support name: " x))))))\n\n(defn zipmap\n  "Returns a map with the keys mapped to the corresponding vals."\n  [keys vals]\n    (loop [map (transient {})\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc! map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        (persistent! map))))\n\n(defn max-key\n  "Returns the x for which (k x), a number, is greatest.\n  \n  If there are multiple such xs, the last one is returned."\n  ([k x] x)\n  ([k x y] (if (\x3e (k x) (k y)) x y))\n  ([k x y \x26 more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))\n\n(defn min-key\n  "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned."\n  ([k x] x)\n  ([k x y] (if (\x3c (k x) (k y)) x y))\n  ([k x y \x26 more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))\n\n(deftype ArrayList [^:mutable arr]\n  Object\n  (add [_ x] (.push arr x))\n  (size [_] (alength arr))\n  (clear [_] (set! arr (array)))\n  (isEmpty [_] (zero? (alength arr)))\n  (toArray [_] arr))\n\n(defn array-list []\n  (ArrayList. (array)))\n\n(defn partition-all\n  "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided."\n  ([n]\n   (fn [rf]\n     (let [a (array-list)]\n       (fn\n         ([] (rf))\n         ([result]\n            (let [result (if (.isEmpty a)\n                           result\n                           (let [v (vec (.toArray a))]\n                             ;;clear first!\n                             (.clear a)\n                             (unreduced (rf result v))))]\n              (rf result)))\n         ([result input]\n            (.add a input)\n            (if (\x3d\x3d n (.size a))\n              (let [v (vec (.toArray a))]\n                (.clear a)\n                (rf result v))\n              result))))))\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))\n\n(defn take-while\n  "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."\n  ([pred]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (if (pred input)\n              (rf result input)\n              (reduced result))))))\n  ([pred coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (when (pred (first s))\n           (cons (first s) (take-while pred (rest s))))))))\n\n(defn mk-bound-fn\n  [sc test key]\n  (fn [e]\n    (let [comp (-comparator sc)]\n      (test (comp (-entry-key sc e) key) 0))))\n\n(defn subseq\n  "sc must be a sorted collection, test(s) one of \x3c, \x3c\x3d, \x3e or\n  \x3e\x3d. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{\x3e \x3e\x3d} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key true)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc true)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc start-key true)]\n       (take-while (mk-bound-fn sc end-test end-key)\n                   (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))\n\n(defn rsubseq\n  "sc must be a sorted collection, test(s) one of \x3c, \x3c\x3d, \x3e or\n  \x3e\x3d. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{\x3c \x3c\x3d} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key false)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc false)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc end-key false)]\n       (take-while (mk-bound-fn sc start-test start-key)\n                   (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))\n\n(deftype RangeChunk [start step count]\n  ICounted\n  (-count [coll] count)\n\n  ISeq\n  (-first [coll] start)\n\n  IIndexed\n  (-nth [coll i]\n    (+ start (* i step)))\n  (-nth [coll i not-found]\n    (if (and (\x3e\x3d i 0) (\x3c i count))\n      (+ start (* i step))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (\x3c\x3d count 1)\n      (throw (js/Error. "-drop-first of empty chunk"))\n      (RangeChunk. (+ start step) step (dec count)))))\n\n(deftype RangeIterator [^:mutable i end step]\n  Object\n  (hasNext [_]\n    (if (pos? step)\n      (\x3c i end)\n      (\x3e i end)))\n  (next [_]\n    (let [ret i]\n      (set! i (+ i step))\n      ret)))\n\n(deftype Range [meta start end step ^:mutable chunk ^:mutable chunk-next ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n  (forceChunk [coll]\n    (when (nil? chunk)\n      (let [count (-count coll)]\n        (if (\x3e count 32)\n          (do\n            (set! chunk-next (Range. nil (+ start (* step 32)) end step nil nil nil))\n            (set! chunk (RangeChunk. start step 32)))\n          (set! chunk (RangeChunk. start step count))))))\n\n  ICloneable\n  (-clone [_] (Range. meta start end step chunk chunk-next __hash))\n\n  IWithMeta\n  (-with-meta [rng new-meta]\n    (if (identical? new-meta meta)\n      rng\n      (Range. new-meta start end step chunk chunk-next __hash)))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeqable\n  (-seq [rng] rng)\n\n  ISeq\n  (-first [rng] start)\n  (-rest [rng]\n    (let [s (-next rng)]\n      (if (nil? s)\n        ()\n        s)))\n\n  IIterable\n  (-iterator [_]\n    (RangeIterator. start end step))\n\n  INext\n  (-next [rng]\n    (if (pos? step)\n      (when (\x3c (+ start step) end)\n        (Range. nil (+ start step) end step nil nil nil))\n      (when (\x3e (+ start step) end)\n        (Range. nil (+ start step) end step nil nil nil))))\n\n  IChunkedSeq\n  (-chunked-first [rng]\n    (.forceChunk rng)\n    chunk)\n  (-chunked-rest [rng]\n    (.forceChunk rng)\n    (if (nil? chunk-next)\n      ()\n      chunk-next))\n\n  IChunkedNext\n  (-chunked-next [rng]\n    (seq (-chunked-rest rng)))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (.-EMPTY List))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-ordered-coll __hash))\n\n  ICounted\n  (-count [rng]\n    (Math/ceil (/ (- end start) step)))\n\n  IIndexed\n  (-nth [rng n]\n    (if (and (\x3c\x3d 0 n) (\x3c n (-count rng)))\n      (+ start (* n step))\n      (if (and (\x3c\x3d 0 n) (\x3e start end) (zero? step))\n        start\n        (throw (js/Error. "Index out of bounds")))))\n  (-nth [rng n not-found]\n    (if (and (\x3c\x3d 0 n) (\x3c n (-count rng)))\n      (+ start (* n step))\n      (if (and (\x3c\x3d 0 n) (\x3e start end) (zero? step))\n        start\n        not-found)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f init]\n    (loop [i start ret init]\n      (if (if (pos? step) (\x3c i end) (\x3e i end))\n        (let [ret (f ret i)]\n          (if (reduced? ret)\n            @ret\n            (recur (+ i step) ret)))\n        ret))))\n\n(es6-iterable Range)\n\n(defn range\n  "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity."\n  ([] (range 0 (.-MAX_VALUE js/Number) 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step]\n   (cond\n     (pos? step)\n     (if (\x3c\x3d end start)\n       ()\n       (Range. nil start end step nil nil nil))\n\n     (neg? step)\n     (if (\x3e\x3d end start)\n       ()\n       (Range. nil start end step nil nil nil))\n\n     :else\n     (if (\x3d\x3d end start)\n       ()\n       (repeat start)))))\n\n(defn take-nth\n  "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided."\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [ia (volatile! -1)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [i (vswap! ia inc)]\n                (if (zero? (rem i n))\n                  (rf result input)\n                  result)))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (cons (first s) (take-nth n (drop n s)))))))\n\n(defn split-with\n  "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])\n\n(defn partition-by\n  "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided."\n  ([f]\n     (fn [rf]\n       (let [a (array-list)\n             pa (volatile! ::none)]\n         (fn\n           ([] (rf))\n           ([result]\n              (let [result (if (.isEmpty a)\n                             result\n                             (let [v (vec (.toArray a))]\n                               ;;clear first!\n                               (.clear a)\n                               (unreduced (rf result v))))]\n                (rf result)))\n           ([result input]\n              (let [pval @pa\n                    val (f input)]\n                (vreset! pa val)\n                (if (or (keyword-identical? pval ::none)\n                        (\x3d val pval))\n                  (do\n                    (.add a input)\n                    result)\n                  (let [v (vec (.toArray a))]\n                    (.clear a)\n                    (let [ret (rf result v)]\n                      (when-not (reduced? ret)\n                        (.add a input))\n                      ret)))))))))\n  ([f coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [fst (first s)\n               fv (f fst)\n               run (cons fst (take-while #(\x3d fv (f %)) (next s)))]\n           (cons run (partition-by f (lazy-seq (drop (count run) s)))))))))\n\n(defn frequencies\n  "Returns a map from distinct items in coll to the number of times\n  they appear."\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))\n\n(defn reductions\n  "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init."\n  ([f coll]\n   (lazy-seq\n     (if-let [s (seq coll)]\n       (reductions f (first s) (rest s))\n       (list (f)))))\n  ([f init coll]\n   (if (reduced? init)\n     (list @init)\n     (cons init\n       (lazy-seq\n         (when-let [s (seq coll)]\n           (reductions f (f init (first s)) (rest s))))))))\n\n(defn juxt\n  "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) \x3d\x3e [(a x) (b x) (c x)]"\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z \x26 args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z \x26 args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z \x26 args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h \x26 fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z \x26 args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))\n\n(defn dorun\n  "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil."\n  ([coll]\n   (when-let [s (seq coll)]\n     (recur (next s))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))\n\n(defn doall\n  "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time."\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))\n\n;;;;;;;;;;;;;;;;;;;;;;;;; Regular Expressions ;;;;;;;;;;\n\n(defn regexp?\n  "Returns true if x is a JavaScript RegExp instance."\n  [x]\n  (instance? js/RegExp x))\n\n(defn re-matches\n  "Returns the result of (re-find re s) if re fully matches s."\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when (\x3d (first matches) s)\n        (if (\x3d\x3d (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. "re-matches must match against a string."))))\n\n\n(defn re-find\n  "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when-not (nil? matches)\n        (if (\x3d\x3d (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. "re-find must match against a string."))))\n\n(defn- re-seq* [re s]\n  (when-some [matches (.exec re s)]\n    (let [match-str (aget matches 0)\n          match-vals (if (\x3d\x3d (.-length matches) 1)\n                       match-str\n                       (vec matches))]\n      (cons match-vals\n            (lazy-seq\n             (let [post-idx (+ (.-index matches)\n                               (max 1 (.-length match-str)))]\n               (when (\x3c\x3d post-idx (.-length s))\n                 (re-seq* re (subs s post-idx)))))))))\n\n(defn re-seq\n  "Returns a lazy sequence of successive matches of re in s."\n  [re s]\n  (if (string? s)\n    (re-seq* re s)\n    (throw (js/TypeError. "re-seq must match against a string."))))\n\n(defn re-pattern\n  "Returns an instance of RegExp which has compiled the provided string."\n  [s]\n  (if (instance? js/RegExp s)\n    s\n    (let [[prefix flags] (re-find #"^\\(\\?([idmsux]*)\\)" s)\n          pattern (subs s (count prefix))]\n      (js/RegExp. pattern (or flags "")))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Printing ;;;;;;;;;;;;;;;;\n\n(defn pr-sequential-writer [writer print-one begin sep end opts coll]\n  (binding [*print-level* (when-not (nil? *print-level*) (dec *print-level*))]\n    (if (and (not (nil? *print-level*)) (neg? *print-level*))\n      (-write writer "#")\n      (do\n        (-write writer begin)\n        (if (zero? (:print-length opts))\n          (when (seq coll)\n            (-write writer (or (:more-marker opts) "...")))\n          (do\n            (when (seq coll)\n              (print-one (first coll) writer opts))\n            (loop [coll (next coll) n (dec (:print-length opts))]\n              (if (and coll (or (nil? n) (not (zero? n))))\n                (do\n                  (-write writer sep)\n                  (print-one (first coll) writer opts)\n                  (recur (next coll) (dec n)))\n                (when (and (seq coll) (zero? n))\n                  (-write writer sep)\n                  (-write writer (or (:more-marker opts) "...")))))))\n        (-write writer end)))))\n\n(defn write-all [writer \x26 ss]\n  (doseq [s ss]\n    (-write writer s)))\n\n(defn string-print [x]\n  (when (nil? *print-fn*)\n    (throw (js/Error. "No *print-fn* fn set for evaluation environment")))\n  (*print-fn* x)\n  nil)\n\n(defn flush [] ;stub\n  nil)\n\n(def ^:private char-escapes\n  (js-obj\n    "\\"" "\\\\\\""\n    "\\\\" "\\\\\\\\"\n    "\\b" "\\\\b"\n    "\\f" "\\\\f"\n    "\\n" "\\\\n"\n    "\\r" "\\\\r"\n    "\\t" "\\\\t"))\n\n(defn ^:private quote-string\n  [s]\n  (str \\"\n       (.replace s (js/RegExp "[\\\\\\\\\\"\\b\\f\\n\\r\\t]" "g")\n         (fn [match] (unchecked-get char-escapes match)))\n       \\"))\n\n(declare print-map)\n\n(defn print-meta? [opts obj]\n  (and (boolean (get opts :meta))\n       (implements? IMeta obj)\n       (not (nil? (meta obj)))))\n\n(defn- pr-writer-impl\n  [obj writer opts]\n  (cond\n    (nil? obj) (-write writer "nil")\n    :else\n    (do\n      (when (print-meta? opts obj)\n        (-write writer "^")\n        (pr-writer (meta obj) writer opts)\n        (-write writer " "))\n      (cond\n        ;; handle CLJS ctors\n        ^boolean (.-cljs$lang$type obj)\n        (.cljs$lang$ctorPrWriter obj obj writer opts)\n\n        ; Use the new, more efficient, IPrintWithWriter interface when possible.\n        (satisfies? IPrintWithWriter obj)\n        (-pr-writer obj writer opts)\n\n        (or (true? obj) (false? obj))\n        (-write writer (str obj))\n\n        (number? obj)\n        (-write writer\n          (cond\n            ^boolean (js/isNaN obj) "##NaN"\n            (identical? obj js/Number.POSITIVE_INFINITY) "##Inf"\n            (identical? obj js/Number.NEGATIVE_INFINITY) "##-Inf"\n            :else (str obj)))\n\n        (object? obj)\n        (do\n          (-write writer "#js ")\n          (print-map\n            (map (fn [k]\n                   (MapEntry. (cond-\x3e k (some? (re-matches #"[A-Za-z_\\*\\+\\?!\\-\'][\\w\\*\\+\\?!\\-\']*" k)) keyword) (unchecked-get obj k) nil))\n              (js-keys obj))\n            pr-writer writer opts))\n\n        (array? obj)\n        (pr-sequential-writer writer pr-writer "#js [" " " "]" opts obj)\n\n        ^boolean (goog/isString obj)\n        (if (:readably opts)\n          (-write writer (quote-string obj))\n          (-write writer obj))\n\n        ^boolean (goog/isFunction obj)\n        (let [name (.-name obj)\n              name (if (or (nil? name) (gstring/isEmpty name))\n                     "Function"\n                     name)]\n          (write-all writer "#object[" name\n            (if *print-fn-bodies*\n              (str " \\"" (str obj) "\\"")\n              "")\n            "]"))\n\n        (instance? js/Date obj)\n        (let [normalize (fn [n len]\n                          (loop [ns (str n)]\n                            (if (\x3c (count ns) len)\n                              (recur (str "0" ns))\n                              ns)))]\n          (write-all writer\n            "#inst \\""\n            (str (.getUTCFullYear obj))             "-"\n            (normalize (inc (.getUTCMonth obj)) 2)  "-"\n            (normalize (.getUTCDate obj) 2)         "T"\n            (normalize (.getUTCHours obj) 2)        ":"\n            (normalize (.getUTCMinutes obj) 2)      ":"\n            (normalize (.getUTCSeconds obj) 2)      "."\n            (normalize (.getUTCMilliseconds obj) 3) "-"\n            "00:00\\""))\n\n        (regexp? obj) (write-all writer "#\\"" (.-source obj) "\\"")\n\n        :else\n        (if (some-\x3e obj .-constructor .-cljs$lang$ctorStr)\n          (write-all writer\n            "#object[" (.replace (.. obj -constructor -cljs$lang$ctorStr)\n                         (js/RegExp. "/" "g") ".") "]")\n          (let [name (some-\x3e obj .-constructor .-name)\n                name (if (or (nil? name) (gstring/isEmpty name))\n                       "Object"\n                       name)]\n            (if (nil? (. obj -constructor))\n              (write-all writer "#object[" name "]")\n              (write-all writer "#object[" name " " (str obj) "]"))))))))\n\n(defn- pr-writer\n  "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."\n  [obj writer opts]\n  (if-let [alt-impl (:alt-impl opts)]\n    (alt-impl obj writer (assoc opts :fallback-impl pr-writer-impl))\n    (pr-writer-impl obj writer opts)))\n\n(defn pr-seq-writer [objs writer opts]\n  (pr-writer (first objs) writer opts)\n  (doseq [obj (next objs)]\n    (-write writer " ")\n    (pr-writer obj writer opts)))\n\n(defn- pr-sb-with-opts [objs opts]\n  (let [sb (StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (pr-seq-writer objs writer opts)\n    (-flush writer)\n    sb))\n\n(defn pr-str-with-opts\n  "Prints a sequence of objects to a string, observing all the\n  options given in opts"\n  [objs opts]\n  (if (empty? objs)\n    ""\n    (str (pr-sb-with-opts objs opts))))\n\n(defn prn-str-with-opts\n  "Same as pr-str-with-opts followed by (newline)"\n  [objs opts]\n  (if (empty? objs)\n    "\\n"\n    (let [sb (pr-sb-with-opts objs opts)]\n      (.append sb \\newline)\n      (str sb))))\n\n(defn- pr-with-opts\n  "Prints a sequence of objects using string-print, observing all\n  the options given in opts"\n  [objs opts]\n  (string-print (pr-str-with-opts objs opts)))\n\n(defn newline\n  "Prints a newline using *print-fn*"\n  ([] (newline nil))\n  ([opts]\n   (string-print "\\n")\n   (when (get opts :flush-on-newline)\n     (flush))))\n\n(defn pr-str\n  "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."\n  [\x26 objs]\n  (pr-str-with-opts objs (pr-opts)))\n\n(defn prn-str\n  "Same as pr-str followed by (newline)"\n  [\x26 objs]\n  (prn-str-with-opts objs (pr-opts)))\n\n(defn pr\n  "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader"\n  [\x26 objs]\n  (pr-with-opts objs (pr-opts)))\n\n(def ^{:doc\n  "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}\n  print\n  (fn cljs-core-print [\x26 objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))\n\n(defn print-str\n  "print to a string, returning it"\n  [\x26 objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))\n\n(defn println\n  "Same as print followed by (newline)"\n  [\x26 objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (when *print-newline*\n    (newline (pr-opts))))\n\n(defn println-str\n  "println to a string, returning it"\n  [\x26 objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))\n\n(defn prn\n  "Same as pr followed by (newline)."\n  [\x26 objs]\n  (pr-with-opts objs (pr-opts))\n  (when *print-newline*\n    (newline (pr-opts))))\n\n(defn- strip-ns\n  [named]\n  (if (symbol? named)\n    (symbol nil (name named))\n    (keyword nil (name named))))\n\n(defn- lift-ns\n  "Returns [lifted-ns lifted-map] or nil if m can\'t be lifted."\n  [m]\n  (when *print-namespace-maps*\n    (loop [ns nil\n           [[k v :as entry] \x26 entries] (seq m)\n           lm (empty m)]\n      (if entry\n        (when (or (keyword? k) (symbol? k))\n          (if ns\n            (when (\x3d ns (namespace k))\n              (recur ns entries (assoc lm (strip-ns k) v)))\n            (when-let [new-ns (namespace k)]\n              (recur new-ns entries (assoc lm (strip-ns k) v)))))\n        [ns lm]))))\n\n(defn print-prefix-map [prefix m print-one writer opts]\n  (pr-sequential-writer\n    writer\n    (fn [e w opts]\n      (do (print-one (key e) w opts)\n          (-write w \\space)\n          (print-one (val e) w opts)))\n    (str prefix "{") ", " "}"\n    opts (seq m)))\n\n(defn print-map [m print-one writer opts]\n  (let [[ns lift-map] (when (map? m)\n                        (lift-ns m))]\n    (if ns\n      (print-prefix-map (str "#:" ns) lift-map print-one writer opts)\n      (print-prefix-map nil m print-one writer opts))))\n\n(extend-protocol IPrintWithWriter\n  LazySeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  TransformerIterator\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  IndexedSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  RSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  PersistentQueue\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "#queue [" " " "]" opts (seq coll)))\n\n  PersistentQueueSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  PersistentTreeMapSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  NodeSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  ArrayNodeSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  List\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  Cons\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  EmptyList\n  (-pr-writer [coll writer opts] (-write writer "()"))\n\n  PersistentVector\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "[" " " "]" opts coll))\n\n  ChunkedCons\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  ChunkedSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  Subvec\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "[" " " "]" opts coll))\n\n  BlackNode\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "[" " " "]" opts coll))\n\n  RedNode\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "[" " " "]" opts coll))\n\n  MapEntry\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "[" " " "]" opts coll))\n\n  ObjMap\n  (-pr-writer [coll writer opts]\n    (print-map coll pr-writer writer opts))\n\n  KeySeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  ValSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  PersistentArrayMapSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  PersistentArrayMap\n  (-pr-writer [coll writer opts]\n    (print-map coll pr-writer writer opts))\n\n  PersistentHashMap\n  (-pr-writer [coll writer opts]\n    (print-map coll pr-writer writer opts))\n\n  PersistentTreeMap\n  (-pr-writer [coll writer opts]\n    (print-map coll pr-writer writer opts))\n\n  PersistentHashSet\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "#{" " " "}" opts coll))\n\n  PersistentTreeSet\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "#{" " " "}" opts coll))\n\n  Range\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  Cycle\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  Repeat\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  Iterate\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  ES6IteratorSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer "(" " " ")" opts coll))\n\n  Atom\n  (-pr-writer [a writer opts]\n    (-write writer "#object[cljs.core.Atom ")\n    (pr-writer {:val (.-state a)} writer opts)\n    (-write writer "]"))\n\n  Volatile\n  (-pr-writer [a writer opts]\n    (-write writer "#object[cljs.core.Volatile ")\n    (pr-writer {:val (.-state a)} writer opts)\n    (-write writer "]"))\n\n  Var\n  (-pr-writer [a writer opts]\n    (-write writer "#\'")\n    (pr-writer (.-sym a) writer opts)))\n\n;; IComparable\n(extend-protocol IComparable\n  Symbol\n  (-compare [x y]\n    (if (symbol? y)\n      (compare-symbols x y)\n      (throw (js/Error. (str "Cannot compare " x " to " y)))))\n\n  Keyword\n  (-compare [x y]\n    (if (keyword? y)\n      (compare-keywords x y)\n      (throw (js/Error. (str "Cannot compare " x " to " y)))))\n\n  Subvec\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str "Cannot compare " x " to " y)))))\n  \n  PersistentVector\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str "Cannot compare " x " to " y)))))\n\n  MapEntry\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str "Cannot compare " x " to " y)))))\n\n  BlackNode\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str "Cannot compare " x " to " y)))))\n\n  RedNode\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str "Cannot compare " x " to " y))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Reference Types ;;;;;;;;;;;;;;;;\n\n(defn alter-meta!\n  "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects"\n  [iref f \x26 args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))\n\n(defn reset-meta!\n  "Atomically resets the metadata for an atom"\n  [iref m]\n  (set! (.-meta iref) m))\n\n(defn add-watch\n  "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference\'s state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom\'s state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom\'s value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (\x3d\x3d 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;\x3d\x3e 1"\n  [iref key f]\n  (-add-watch iref key f)\n  iref)\n\n(defn remove-watch\n  "Removes a watch (set by add-watch) from a reference"\n  [iref key]\n  (-remove-watch iref key)\n  iref)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; gensym ;;;;;;;;;;;;;;;;\n;; Internal - do not use!\n(def\n  ^{:jsdoc ["@type {*}"]}\n  gensym_counter nil)\n\n(defn gensym\n  "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is \'G__\'."\n  ([] (gensym "G__"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Delay ;;;;;;;;;;;;;;;;;;;;\n\n(deftype Delay [^:mutable f ^:mutable value]\n  IDeref\n  (-deref [_]\n    (when f\n      (set! value (f))\n      (set! f nil))\n    value)\n\n  IPending\n  (-realized? [x]\n    (not f))\n\n  IPrintWithWriter\n  (-pr-writer [x writer opts]\n    (-write writer "#object[cljs.core.Delay ")\n    (pr-writer {:status (if (nil? f) :ready :pending), :val value} writer opts)\n    (-write writer "]")))\n\n(defn delay?\n  "returns true if x is a Delay created with delay"\n  [x] (instance? Delay x))\n\n(defn force\n  "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))\n\n(defn ^boolean realized?\n  "Returns true if a value has been produced for a delay or lazy sequence."\n  [x]\n  (-realized? x))\n\n(defn- preserving-reduced\n  [rf]\n  #(let [ret (rf %1 %2)]\n     (if (reduced? ret)\n       (reduced ret)\n       ret)))\n\n(defn cat\n  "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction."\n  {:added "1.7"}\n  [rf]\n  (let [rf1 (preserving-reduced rf)]\n    (fn\n      ([] (rf))\n      ([result] (rf result))\n      ([result input]\n         (reduce rf1 result input)))))\n\n(defn halt-when\n  "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected."\n  {:added "1.9"}\n  ([pred] (halt-when pred nil))\n  ([pred retf]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result]\n            (if (and (map? result) (contains? result ::halt))\n              (::halt result)\n              (rf result)))\n         ([result input]\n            (if (pred input)\n              (reduced {::halt (if retf (retf (rf result) input) input)})\n              (rf result input)))))))\n\n(defn dedupe\n  "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided."\n  ([]\n   (fn [rf]\n     (let [pa (volatile! ::none)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [prior @pa]\n              (vreset! pa input)\n              (if (\x3d prior input)\n                result\n                (rf result input))))))))\n  ([coll] (sequence (dedupe) coll)))\n\n(declare rand)\n\n(defn random-sample\n  "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided."\n  ([prob]\n     (filter (fn [_] (\x3c (rand) prob))))\n  ([prob coll]\n     (filter (fn [_] (\x3c (rand) prob)) coll)))\n\n(deftype Eduction [xform coll]\n  Object\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ISequential\n\n  IIterable\n  (-iterator [_]\n    (.create TransformerIterator xform (iter coll)))\n\n  ISeqable\n  (-seq [_] (seq (sequence xform coll)))\n\n  IReduce\n  (-reduce [_ f] (transduce xform (completing f) coll))\n  (-reduce [_ f init] (transduce xform (completing f) init coll))\n\n  IPrintWithWriter\n  (-pr-writer [coll writer opts]\n    (pr-sequential-writer writer pr-writer "(" " " ")" opts coll)))\n\n(es6-iterable Eduction)\n\n(defn eduction\n  "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called."\n  {:arglists \'([xform* coll])}\n  [\x26 xforms]\n  (Eduction. (apply comp (butlast xforms)) (last xforms)))\n\n(defn run!\n  "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"\n  [proc coll]\n  (reduce #(proc %2) nil coll)\n  nil)\n\n(defprotocol IEncodeJS\n  (-clj-\x3ejs [x] "Recursively transforms clj values to JavaScript")\n  (-key-\x3ejs [x] "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"))\n\n(declare clj-\x3ejs)\n\n(defn key-\x3ejs\n  ([k] (key-\x3ejs k clj-\x3ejs))\n  ([k primitive-fn]\n   (cond\n     (satisfies? IEncodeJS k) (-clj-\x3ejs k)\n     (or (string? k)\n         (number? k)\n         (keyword? k)\n         (symbol? k)) (primitive-fn k)\n     :default (pr-str k))))\n\n(defn clj-\x3ejs\n  "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by `key-\x3ejs`.\n  Options is a key-value pair, where the only valid key is\n  :keyword-fn, which should point to a single-argument function to be\n  called on keyword keys. Default to `name`."\n  [x \x26 {:keys [keyword-fn]\n        :or   {keyword-fn name}\n        :as options}]\n  (letfn [(keyfn [k] (key-\x3ejs k thisfn))\n          (thisfn [x] (cond\n                        (nil? x) nil\n                        (satisfies? IEncodeJS x) (-clj-\x3ejs x)\n                        (keyword? x) (keyword-fn x)\n                        (symbol? x) (str x)\n                        (map? x) (let [m (js-obj)]\n                                   (doseq [[k v] x]\n                                     (gobject/set m (keyfn k) (thisfn v)))\n                                   m)\n                        (coll? x) (let [arr (array)]\n                                    (doseq [x (map thisfn x)]\n                                      (.push arr x))\n                                    arr)\n                        :else x))]\n    (thisfn x)))\n\n\n(defprotocol IEncodeClojure\n  (-js-\x3eclj [x options] "Transforms JavaScript values to Clojure"))\n\n(defn js-\x3eclj\n  "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option \':keywordize-keys true\' will convert object fields from\n  strings to keywords."\n  ([x] (js-\x3eclj x :keywordize-keys false))\n  ([x \x26 opts]\n    (let [{:keys [keywordize-keys]} opts\n          keyfn (if keywordize-keys keyword str)\n          f (fn thisfn [x]\n              (cond\n                (satisfies? IEncodeClojure x)\n                (-js-\x3eclj x (apply array-map opts))\n\n                (seq? x)\n                (doall (map thisfn x))\n\n                (map-entry? x)\n                (MapEntry. (thisfn (key x)) (thisfn (val x)) nil)\n\n                (coll? x)\n                (into (empty x) (map thisfn) x)\n\n                (array? x)\n                (persistent!\n                 (reduce #(conj! %1 (thisfn %2))\n                         (transient []) x))\n\n                (identical? (type x) js/Object)\n                (persistent!\n                 (reduce (fn [r k] (assoc! r (keyfn k) (thisfn (gobject/get x k))))\n                         (transient {}) (js-keys x)))\n                :else x))]\n      (f x))))\n\n(defn memoize\n  "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."\n  [f]\n  (let [mem (atom {})]\n    (fn [\x26 args]\n      (let [v (get @mem args lookup-sentinel)]\n        (if (identical? v lookup-sentinel)\n          (let [ret (apply f args)]\n            (swap! mem assoc args ret)\n            ret)\n          v)))))\n\n(defn trampoline\n  "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns."\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f \x26 args]\n     (trampoline #(apply f args))))\n\n(defn rand\n  "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive)."\n  ([] (rand 1))\n  ([n] (* (Math/random) n)))\n\n(defn rand-int\n  "Returns a random integer between 0 (inclusive) and n (exclusive)."\n  [n] (Math/floor (* (Math/random) n)))\n\n(defn rand-nth\n  "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."\n  [coll]\n  (nth coll (rand-int (count coll))))\n\n(defn group-by\n  "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."\n  [f coll]\n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))\n\n(defn make-hierarchy\n  "Creates a hierarchy object for use with derive, isa? etc."\n  [] {:parents {} :descendants {} :ancestors {}})\n\n(def\n  ^{:private true\n    :jsdoc ["@type {*}"]}\n  -global-hierarchy nil)\n\n(defn- get-global-hierarchy []\n  (when (nil? -global-hierarchy)\n    (set! -global-hierarchy (atom (make-hierarchy))))\n  -global-hierarchy)\n\n(defn- swap-global-hierarchy! [f \x26 args]\n  (apply swap! (get-global-hierarchy) f args))\n\n(defn ^boolean isa?\n  "Returns true if (\x3d child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy"\n  ([child parent] (isa? @(get-global-hierarchy) child parent))\n  ([h child parent]\n     (or (\x3d child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (\x3d\x3d (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (\x3d\x3d i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))\n\n(defn parents\n  "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"\n  ([tag] (parents @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:parents h) tag))))\n\n(defn ancestors\n  "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"\n  ([tag] (ancestors @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))\n\n(defn descendants\n  "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships."\n  ([tag] (descendants @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))\n\n(defn derive\n  "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap-global-hierarchy! derive tag parent) nil)\n  ([h tag parent]\n   (assert (not\x3d tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag "already has" parent "as ancestor"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str "Cyclic derivation:" parent "has" tag "as ancestor"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))\n\n(defn underive\n  "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."\n  ([tag parent]\n    (swap-global-hierarchy! underive tag parent)\n    nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))\n\n(defn- reset-cache\n  [method-cache method-table cached-hierarchy hierarchy]\n  (swap! method-cache (fn [_] (deref method-table)))\n  (swap! cached-hierarchy (fn [_] (deref hierarchy))))\n\n(defn- prefers*\n  [x y prefer-table]\n  (let [xprefs (@prefer-table x)]\n    (or\n     (when (and xprefs (xprefs y))\n       true)\n     (loop [ps (parents y)]\n       (when (pos? (count ps))\n         (when (prefers* x (first ps) prefer-table)\n           true)\n         (recur (rest ps))))\n     (loop [ps (parents x)]\n       (when (pos? (count ps))\n         (when (prefers* (first ps) y prefer-table)\n           true)\n         (recur (rest ps))))\n     false)))\n\n(defn- dominates\n  [x y prefer-table hierarchy]\n  (or (prefers* x y prefer-table) (isa? hierarchy x y)))\n\n(defn- find-and-cache-best-method\n  [name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]\n  (let [best-entry (reduce (fn [be [k _ :as e]]\n                             (if (isa? @hierarchy dispatch-val k)\n                               (let [be2 (if (or (nil? be) (dominates k (first be) prefer-table @hierarchy))\n                                           e\n                                           be)]\n                                 (when-not (dominates (first be2) k prefer-table @hierarchy)\n                                   (throw (js/Error.\n                                            (str "Multiple methods in multimethod \'" name\n                                              "\' match dispatch value: " dispatch-val " -\x3e " k\n                                              " and " (first be2) ", and neither is preferred"))))\n                                 be2)\n                               be))\n                     nil @method-table)\n        best-entry (if-let [entry (and (nil? best-entry) (@method-table default-dispatch-val))]\n                     [default-dispatch-val entry]\n                     best-entry)]\n    (when best-entry\n      (if (\x3d @cached-hierarchy @hierarchy)\n        (do\n          (swap! method-cache assoc dispatch-val (second best-entry))\n          (second best-entry))\n        (do\n          (reset-cache method-cache method-table cached-hierarchy hierarchy)\n          (find-and-cache-best-method name dispatch-val hierarchy method-table prefer-table\n            method-cache cached-hierarchy default-dispatch-val))))))\n\n(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-default-dispatch-val [mf])\n  (-dispatch-fn [mf]))\n\n(defn- throw-no-method-error [name dispatch-val]\n  (throw (js/Error. (str "No method in multimethod \'" name "\' for dispatch value: " dispatch-val))))\n\n(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IFn\n  (-invoke [mf]\n    (let [dispatch-val (dispatch-fn)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn)))\n  (-invoke [mf a]\n    (let [dispatch-val (dispatch-fn a)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a)))\n  (-invoke [mf a b]\n    (let [dispatch-val (dispatch-fn a b)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b)))\n  (-invoke [mf a b c]\n    (let [dispatch-val (dispatch-fn a b c)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c)))\n  (-invoke [mf a b c d]\n    (let [dispatch-val (dispatch-fn a b c d)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d)))\n  (-invoke [mf a b c d e]\n    (let [dispatch-val (dispatch-fn a b c d e)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e)))\n  (-invoke [mf a b c d e f]\n    (let [dispatch-val (dispatch-fn a b c d e f)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f)))\n  (-invoke [mf a b c d e f g]\n    (let [dispatch-val (dispatch-fn a b c d e f g)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g)))\n  (-invoke [mf a b c d e f g h]\n    (let [dispatch-val (dispatch-fn a b c d e f g h)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h)))\n  (-invoke [mf a b c d e f g h i]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i)))\n  (-invoke [mf a b c d e f g h i j]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j)))\n  (-invoke [mf a b c d e f g h i j k]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k)))\n  (-invoke [mf a b c d e f g h i j k l]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l)))\n  (-invoke [mf a b c d e f g h i j k l m]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m)))\n  (-invoke [mf a b c d e f g h i j k l m n]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n)))\n  (-invoke [mf a b c d e f g h i j k l m n o]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o)))\n  (-invoke [mf a b c d e f g h i j k l m n o p]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s t)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s t)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t rest]\n    (let [dispatch-val (apply dispatch-fn a b c d e f g h i j k l m n o p q r s t rest)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (apply target-fn a b c d e f g h i j k l m n o p q r s t rest)))\n\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (\x3d @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (find-and-cache-best-method name dispatch-val hierarchy method-table\n        prefer-table method-cache cached-hierarchy default-dispatch-val)))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str "Preference conflict in multimethod \'" name "\': " dispatch-val-y\n                   " is already preferred to " dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n  (-default-dispatch-val [mf] default-dispatch-val)\n  (-dispatch-fn [mf] dispatch-fn)\n\n  INamed\n  (-name [this] (-name name))\n  (-namespace [this] (-namespace name))\n\n  IHash\n  (-hash [this] (goog/getUid this)))\n\n(defn remove-all-methods\n  "Removes all of the methods of multimethod."\n [multifn]\n (-reset multifn))\n\n(defn remove-method\n  "Removes the method of multimethod associated with dispatch-value."\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))\n\n(defn prefer-method\n  "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))\n\n(defn methods\n  "Given a multimethod, returns a map of dispatch values -\x3e dispatch fns"\n  [multifn] (-methods multifn))\n\n(defn get-method\n  "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"\n  [multifn dispatch-val] (-get-method multifn dispatch-val))\n\n(defn prefers\n  "Given a multimethod, returns a map of preferred value -\x3e set of other values"\n  [multifn] (-prefers multifn))\n\n(defn default-dispatch-val\n  "Given a multimethod, return it\'s default-dispatch-val."\n  [multifn] (-default-dispatch-val multifn))\n\n(defn dispatch-fn\n  "Given a multimethod, return it\'s dispatch-fn."\n  [multifn] (-dispatch-fn multifn))\n\n;; UUID\n(defprotocol IUUID "A marker protocol for UUIDs")\n\n(deftype UUID [uuid ^:mutable __hash]\n  IUUID\n\n  Object\n  (toString [_] uuid)\n  (equiv [this other]\n    (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (and (instance? UUID other) (identical? uuid (.-uuid other))))\n\n  IPrintWithWriter\n  (-pr-writer [_ writer _]\n    (-write writer (str "#uuid \\"" uuid "\\"")))\n\n  IHash\n  (-hash [this]\n    (when (nil? __hash)\n      (set! __hash (hash uuid)))\n    __hash)\n\n  IComparable\n  (-compare [_ other]\n    (garray/defaultCompare uuid (.-uuid other))))\n\n(defn uuid [s]\n  (assert (string? s))\n  (UUID. (.toLowerCase s) nil))\n\n(defn random-uuid []\n  (letfn [(hex [] (.toString (rand-int 16) 16))]\n    (let [rhex (.toString (bit-or 0x8 (bit-and 0x3 (rand-int 16))) 16)]\n      (uuid\n        (str (hex) (hex) (hex) (hex)\n             (hex) (hex) (hex) (hex) "-"\n             (hex) (hex) (hex) (hex) "-"\n             "4"   (hex) (hex) (hex) "-"\n             rhex  (hex) (hex) (hex) "-"\n             (hex) (hex) (hex) (hex)\n             (hex) (hex) (hex) (hex)\n             (hex) (hex) (hex) (hex))))))\n\n(defn uuid?\n  [x] (implements? IUUID x))\n\n;;; ExceptionInfo\n\n(defn- pr-writer-ex-info [obj writer opts]\n  (-write writer "#error {:message ")\n  (pr-writer (.-message obj) writer opts)\n  (when (.-data obj)\n    (-write writer ", :data ")\n    (pr-writer (.-data obj) writer opts))\n  (when (.-cause obj)\n    (-write writer ", :cause ")\n    (pr-writer (.-cause obj) writer opts))\n  (-write writer "}"))\n\n(defn ^{:jsdoc ["@constructor"]}\n  ExceptionInfo [message data cause]\n  (let [e (js/Error. message)]\n    (this-as this\n      (set! (.-message this) message)\n      (set! (.-data this) data)\n      (set! (.-cause this) cause)\n      (do\n        (set! (.-name this) (.-name e))\n        ;; non-standard\n        (set! (.-description this) (.-description e))\n        (set! (.-number this) (.-number e))\n        (set! (.-fileName this) (.-fileName e))\n        (set! (.-lineNumber this) (.-lineNumber e))\n        (set! (.-columnNumber this) (.-columnNumber e))\n        (set! (.-stack this) (.-stack e)))\n      this)))\n\n(set! (.. ExceptionInfo -prototype -__proto__) js/Error.prototype)\n\n(extend-type ExceptionInfo\n  IPrintWithWriter\n  (-pr-writer [obj writer opts]\n    (pr-writer-ex-info obj writer opts)))\n\n(set! (.. ExceptionInfo -prototype -toString)\n  (fn []\n    (this-as this (pr-str* this))))\n\n(defn ex-info\n  "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data."\n  ([msg data] (ex-info msg data nil))\n  ([msg data cause]\n    (ExceptionInfo. msg data cause)))\n\n(defn ex-data\n  "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-data ex)))\n\n(defn ex-message\n  "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."\n  [ex]\n  (when (instance? js/Error ex)\n    (.-message ex)))\n\n(defn ex-cause\n  "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-cause ex)))\n\n(defn comparator\n  "Returns an JavaScript compatible comparator based upon pred."\n  [pred]\n  (fn [x y]\n    (cond (pred x y) -1 (pred y x) 1 :else 0)))\n\n(defn ^boolean special-symbol?\n  "Returns true if x names a special form"\n  [x]\n  (contains?\n    \'#{if def fn* do let* loop* letfn* throw try catch finally\n       recur new set! ns deftype* defrecord* . js* \x26 quote case* var ns*}\n    x))\n\n(defn test\n  "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"\n  [v]\n  (let [f (.-cljs$lang$test v)]\n    (if f\n      (do (f) :ok)\n      :no-test)))\n\n\n(deftype TaggedLiteral [tag form]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IEquiv\n  (-equiv [this other]\n    (and (instance? TaggedLiteral other)\n         (\x3d tag (.-tag other))\n         (\x3d form (.-form other))))\n\n  IHash\n  (-hash [this]\n    (+ (* 31 (hash tag))\n       (hash form)))\n\n  ILookup\n  (-lookup [this v]\n    (-lookup this v nil))\n  (-lookup [this v not-found]\n    (case v\n      :tag tag\n      :form form\n      not-found))\n\n  IPrintWithWriter\n  (-pr-writer [o writer opts]\n    (-write writer (str "#" tag " "))\n    (pr-writer form writer opts)))\n\n(defn tagged-literal?\n  "Return true if the value is the data representation of a tagged literal"\n  [value]\n  (instance? TaggedLiteral value))\n\n(defn tagged-literal\n  "Construct a data representation of a tagged literal from a\n  tag symbol and a form."\n  [tag form]\n  {:pre [(symbol? tag)]}\n  (TaggedLiteral. tag form))\n\n(def\n  ^{:private true\n    :jsdoc ["@type {*}"]}\n  js-reserved-arr\n  #js ["arguments" "abstract" "await" "boolean" "break" "byte" "case"\n       "catch" "char" "class" "const" "continue"\n       "debugger" "default" "delete" "do" "double"\n       "else" "enum" "export" "extends" "final"\n       "finally" "float" "for" "function" "goto" "if"\n       "implements" "import" "in" "instanceof" "int"\n       "interface" "let" "long" "native" "new"\n       "package" "private" "protected" "public"\n       "return" "short" "static" "super" "switch"\n       "synchronized" "this" "throw" "throws"\n       "transient" "try" "typeof" "var" "void"\n       "volatile" "while" "with" "yield" "methods"\n       "null" "constructor"])\n\n(def\n  ^{:jsdoc ["@type {null|Object}"]}\n  js-reserved nil)\n\n(defn- js-reserved? [x]\n  (when (nil? js-reserved)\n    (set! js-reserved\n      (reduce #(do (gobject/set %1 %2 true) %1)\n        #js {} js-reserved-arr)))\n  (.hasOwnProperty js-reserved x))\n\n(defn- demunge-pattern []\n  (when-not DEMUNGE_PATTERN\n    (set! DEMUNGE_PATTERN\n      (let [ks (sort (fn [a b] (- (. b -length) (. a -length)))\n                 (js-keys DEMUNGE_MAP))]\n        (loop [ks ks ret ""]\n          (if (seq ks)\n            (recur\n              (next ks)\n              (str\n                (cond-\x3e ret\n                  (not (identical? ret "")) (str "|"))\n                (first ks)))\n            (str ret "|\\\\$"))))))\n  DEMUNGE_PATTERN)\n\n(defn- munge-str [name]\n  (let [sb (StringBuffer.)]\n    (loop [i 0]\n      (if (\x3c i (. name -length))\n        (let [c (.charAt name i)\n              sub (gobject/get CHAR_MAP c)]\n          (if-not (nil? sub)\n            (.append sb sub)\n            (.append sb c))\n          (recur (inc i)))))\n    (.toString sb)))\n\n(defn munge [name]\n  (let [name\' (munge-str (str name))\n        name\' (cond\n                (identical? name\' "..") "_DOT__DOT_"\n                (js-reserved? name\') (str name\' "$")\n                :else name\')]\n    (if (symbol? name)\n      (symbol name\')\n      name\')))\n\n(defn- demunge-str [munged-name]\n  (let [r (js/RegExp. (demunge-pattern) "g")\n        munged-name (if (gstring/endsWith munged-name "$")\n                      (.substring munged-name 0 (dec (. munged-name -length)))\n                      munged-name)]\n    (loop [ret "" last-match-end 0]\n      (if-let [match (.exec r munged-name)]\n        (let [[x] match]\n          (recur\n            (str ret\n              (.substring munged-name last-match-end\n                (- (. r -lastIndex) (. x -length)))\n              (if (identical? x "$") "/" (gobject/get DEMUNGE_MAP x)))\n            (. r -lastIndex)))\n        (str ret\n          (.substring munged-name last-match-end (.-length munged-name)))))))\n\n(defn demunge [name]\n  ((if (symbol? name) symbol str)\n    (let [name\' (str name)]\n      (if (identical? name\' "_DOT__DOT_")\n        ".."\n        (demunge-str name\')))))\n\n(defonce ^{:jsdoc ["@type {*}"] :private true}\n  tapset nil)\n\n(defn- maybe-init-tapset []\n  (when (nil? tapset)\n    (set! tapset (atom #{}))))\n\n(defn add-tap\n  "Adds f, a fn of one argument, to the tap set. This function will be called with\n  anything sent via tap\x3e. Remember f in order to remove-tap"\n  [f]\n  (maybe-init-tapset)\n  (swap! tapset conj f)\n  nil)\n\n(defn remove-tap\n  "Remove f from the tap set."\n  [f]\n  (maybe-init-tapset)\n  (swap! tapset disj f)\n  nil)\n\n(defn ^boolean tap\x3e\n  "Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value."\n  [x]\n  (maybe-init-tapset)\n  (*exec-tap-fn*\n    (fn []\n      (doseq [tap @tapset]\n        (try\n          (tap x)\n          (catch js/Error ex))))))\n\n;; -----------------------------------------------------------------------------\n;; Bootstrap helpers - incompatible with advanced compilation\n\n(defn- ns-lookup\n  "Bootstrap only."\n  [ns-obj k]\n  (fn [] (gobject/get ns-obj k)))\n\n;; Bootstrap only\n(deftype Namespace [obj name]\n  Object\n  (findInternedVar [this sym]\n    (let [k (munge (str sym))]\n      (when ^boolean (gobject/containsKey obj k)\n        (let [var-sym (symbol (str name) (str sym))\n              var-meta {:ns this}]\n          (Var. (ns-lookup obj k) var-sym var-meta)))))\n  (getName [_] name)\n  (toString [_]\n    (str name))\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Namespace other)\n      (\x3d name (.-name other))\n      false))\n  IHash\n  (-hash [_]\n    (hash name)))\n\n(def\n  ^{:doc "Bootstrap only." :jsdoc ["@type {*}"]}\n  NS_CACHE nil)\n\n(defn- find-ns-obj*\n  "Bootstrap only."\n  [ctxt xs]\n  (cond\n    (nil? ctxt) nil\n    (nil? xs) ctxt\n    :else (recur (gobject/get ctxt (first xs)) (next xs))))\n\n(defn find-ns-obj\n  "Bootstrap only."\n  [ns]\n  (let [munged-ns (munge (str ns))\n        segs (.split munged-ns ".")]\n    (case *target*\n      "nodejs"  (if ^boolean js/COMPILED\n                  ; Under simple optimizations on nodejs, namespaces will be in module\n                  ; rather than global scope and must be accessed by a direct call to eval.\n                  ; The first segment may refer to an undefined variable, so its evaluation\n                  ; may throw ReferenceError.\n                  (find-ns-obj*\n                    (try\n                      (let [ctxt (js/eval (first segs))]\n                        (when (and ctxt (object? ctxt))\n                          ctxt))\n                      (catch js/ReferenceError e\n                        nil))\n                    (next segs))\n                  (find-ns-obj* goog/global segs))\n      ("default" "webworker") (find-ns-obj* goog/global segs)\n      (throw (js/Error. (str "find-ns-obj not supported for target " *target*))))))\n\n(defn ns-interns*\n  "Returns a map of the intern mappings for the namespace.\n  Bootstrap only."\n  [sym]\n  (let [ns-obj (find-ns-obj sym)\n        ns     (Namespace. ns-obj sym)]\n    (letfn [(step [ret k]\n              (let [var-sym (symbol (demunge k))]\n                (assoc ret\n                  var-sym (Var. #(gobject/get ns-obj k)\n                            (symbol (str sym) (str var-sym)) {:ns ns}))))]\n      (reduce step {} (js-keys ns-obj)))))\n\n(defn create-ns\n  "Create a new namespace named by the symbol. Bootstrap only."\n  ([sym]\n   (create-ns sym (find-ns-obj sym)))\n  ([sym ns-obj]\n   (Namespace. ns-obj sym)))\n\n(defn find-ns\n  "Returns the namespace named by the symbol or nil if it doesn\'t exist.\n  Bootstrap only."\n  [ns]\n  (when (nil? NS_CACHE)\n    (set! NS_CACHE (atom {})))\n  (let [the-ns (get @NS_CACHE ns)]\n    (if-not (nil? the-ns)\n      the-ns\n      (let [ns-obj (find-ns-obj ns)]\n        (when-not (nil? ns-obj)\n          (let [new-ns (create-ns ns ns-obj)]\n            (swap! NS_CACHE assoc ns new-ns)\n            new-ns))))))\n\n(defn find-macros-ns\n  "Returns the macros namespace named by the symbol or nil if it doesn\'t exist.\n  Bootstrap only."\n  [ns]\n  (when (nil? NS_CACHE)\n    (set! NS_CACHE (atom {})))\n  (let [ns-str (str ns)\n        ns (if (not ^boolean (gstring/contains ns-str "$macros"))\n             (symbol (str ns-str "$macros"))\n             ns)\n        the-ns (get @NS_CACHE ns)]\n    (if-not (nil? the-ns)\n      the-ns\n      (let [ns-obj (find-ns-obj ns)]\n       (when-not (nil? ns-obj)\n         (let [new-ns (create-ns ns ns-obj)]\n           (swap! NS_CACHE assoc ns new-ns)\n           new-ns))))))\n\n(defn ns-name\n  "Returns the name of the namespace, a Namespace object.\n  Bootstrap only."\n  [ns-obj]\n  (.-name ns-obj))\n\n(defn uri?\n  "Returns true x is a goog.Uri instance."\n  {:added "1.9"}\n  [x]\n  (instance? goog.Uri x))\n\n(defn- maybe-enable-print! []\n  (cond\n    (exists? js/console)\n    (enable-console-print!)\n\n    (or (identical? *target* "nashorn")\n        (identical? *target* "graaljs"))\n    (let [system (.type js/Java "java.lang.System")]\n      (set! *print-newline* false)\n      (set-print-fn!\n        (fn []\n          (let [xs (js-arguments)\n                s  (.join (garray/clone xs) "")]\n            (.println (.-out system) s))))\n      (set-print-err-fn!\n        (fn []\n          (let [xs (js-arguments)\n                s  (.join (garray/clone xs) "")]\n            (.println (.-error system) s)))))))\n\n(maybe-enable-print!)\n\n(defonce\n  ^{:doc "Runtime environments may provide a way to evaluate ClojureScript\n  forms. Whatever function *eval* is bound to will be passed any forms which\n  should be evaluated." :dynamic true}\n  *eval*\n  (fn [_]\n    (throw (js/Error. "cljs.core/*eval* not bound"))))\n\n(defn eval\n  "Evaluates the form data structure (not text!) and returns the result.\n  Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\n  which sets up an implementation of cljs.core/*eval* for that environment."\n  [form]\n  (*eval* form))\n'],
null),new p(null,3,[Cl,"cljs/analyzer.cljc",Xn,"cljs.analyzer",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.analyzer\n  #?(:clj  (:refer-clojure :exclude [macroexpand-1 ensure])\n     :cljs (:refer-clojure :exclude [macroexpand-1 ns-interns ensure js-reserved]))\n  #?(:cljs (:require-macros\n             [cljs.analyzer.macros\n              :refer [no-warn wrapping-errors with-warning-handlers\n                      disallowing-recur allowing-redef disallowing-ns*]]\n             [cljs.env.macros :refer [ensure]]))\n  #?(:clj (:require [cljs.util :as util :refer [ns-\x3erelpath topo-sort]]\n                    [clojure.java.io :as io]\n                    [clojure.string :as string]\n                    [clojure.set :as set]\n                    [cljs.env :as env :refer [ensure]]\n                    [cljs.js-deps :as deps]\n                    [cljs.tagged-literals :as tags]\n                    [clojure.tools.reader :as reader]\n                    [clojure.tools.reader.reader-types :as readers]\n                    [clojure.edn :as edn])\n     :cljs (:require [goog.string :as gstring]\n                     [clojure.string :as string]\n                     [clojure.set :as set]\n                     [cljs.env :as env]\n                     [cljs.tagged-literals :as tags]\n                     [cljs.tools.reader :as reader]\n                     [cljs.tools.reader.reader-types :as readers]\n                     [cljs.reader :as edn]))\n  #?(:clj (:import [java.io File Reader PushbackReader FileOutputStream FileInputStream]\n                   [java.util.regex Pattern]\n                   [java.net URL]\n                   [java.lang Throwable]\n                   [clojure.lang Namespace Var LazySeq ArityException]\n                   [cljs.tagged_literals JSValue])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; User file-local compiler flags\n#?(:clj (def ^:dynamic *unchecked-if* false))\n#?(:clj (def ^:dynamic *unchecked-arrays* false))\n\n;; Compiler dynamic vars\n(def ^:dynamic *cljs-ns* \'cljs.user)\n(def ^:dynamic *cljs-file* nil)\n(def ^:dynamic *checked-arrays* false)\n(def ^:dynamic *check-alias-dupes* true)\n(def ^:dynamic *cljs-static-fns* false)\n(def ^:dynamic *fn-invoke-direct* false)\n(def ^:dynamic *cljs-macros-path* "/cljs/core")\n(def ^:dynamic *cljs-macros-is-classpath* true)\n(def ^:dynamic *cljs-dep-set* (with-meta #{} {:dep-path []}))\n(def ^:dynamic *analyze-deps* true)\n(def ^:dynamic *load-tests* true)\n(def ^:dynamic *load-macros* true)\n(def ^:dynamic *reload-macros* false)\n(def ^:dynamic *macro-infer* true)\n(def ^:dynamic *passes* nil)\n(def ^:dynamic *file-defs* nil)\n(def ^:dynamic *private-var-access-nowarn* false)\n\n(def constants-ns-sym\n  "The namespace of the constants table as a symbol."\n  \'cljs.core.constants)\n\n(def ^:private identity-counter (atom 0))\n\n(defn- add-identity [m]\n  (assoc m :identity (swap! identity-counter inc)))\n\n#?(:clj\n   (def transit-read-opts\n     (try\n       (require \'[cognitect.transit])\n       (when-some [ns (find-ns \'cognitect.transit)]\n         (let [read-handler     @(ns-resolve ns \'read-handler)\n               read-handler-map @(ns-resolve ns \'read-handler-map)]\n           {:handlers\n             (read-handler-map\n               {"cljs/js"    (read-handler (fn [v] (JSValue. v)))\n                "cljs/regex" (read-handler (fn [v] (Pattern/compile v)))})}))\n       (catch Throwable t\n         nil))))\n\n#?(:clj\n   (def transit-write-opts\n     (try\n       (require \'[cognitect.transit])\n       (when-some [ns (find-ns \'cognitect.transit)]\n         (let [write-handler     @(ns-resolve ns \'write-handler)\n               write-handler-map @(ns-resolve ns \'write-handler-map)]\n           {:handlers\n             (write-handler-map\n               {JSValue\n                (write-handler\n                  (fn [_] "cljs/js")\n                  (fn [js] (.val ^JSValue js)))\n                Pattern\n                (write-handler\n                  (fn [_] "cljs/regex")\n                  (fn [pat] (.pattern ^Pattern pat)))})}))\n       (catch Throwable t\n         nil))))\n\n#?(:clj\n   (def transit\n     (delay\n       (try\n         (require \'[cognitect.transit])\n         (when-some [ns (find-ns \'cognitect.transit)]\n           {:writer @(ns-resolve ns \'writer)\n            :reader @(ns-resolve ns \'reader)\n            :write  @(ns-resolve ns \'write)\n            :read   @(ns-resolve ns \'read)})\n         (catch Throwable t\n           nil)))))\n\n;; log compiler activities\n(def ^:dynamic *verbose* false)\n\n(def -cljs-macros-loaded (atom false))\n\n(def ^:dynamic *cljs-warnings*\n  {:preamble-missing true\n   :unprovided true\n   :undeclared-var true\n   :private-var-access true\n   :undeclared-ns true\n   :undeclared-ns-form true\n   :redef true\n   :redef-in-file true\n   :dynamic true\n   :fn-var true\n   :fn-arity true\n   :fn-deprecated true\n   :declared-arglists-mismatch true\n   :protocol-deprecated true\n   :undeclared-protocol-symbol true\n   :invalid-protocol-symbol true\n   :multiple-variadic-overloads true\n   :variadic-max-arity true\n   :overload-arity true\n   :extending-base-js-type true\n   :invoke-ctor true\n   :invalid-arithmetic true\n   :invalid-array-access true\n   :protocol-invalid-method true\n   :protocol-duped-method true\n   :protocol-multiple-impls true\n   :protocol-with-variadic-method true\n   :protocol-impl-with-variadic-method true\n   :protocol-impl-recur-with-target true\n   :single-segment-namespace true\n   :munged-namespace true\n   :ns-var-clash true\n   :non-dynamic-earmuffed-var true\n   :extend-type-invalid-method-shape true\n   :unsupported-js-module-type true\n   :unsupported-preprocess-value true\n   :js-shadowed-by-local true\n   :infer-warning false})\n\n(defn unchecked-arrays? []\n  *unchecked-arrays*)\n\n(defn checked-arrays\n  "Returns false-y, :warn, or :error based on configuration and the\n   current value of *unchecked-arrays*."\n  []\n  (when (and (not (-\x3e @env/*compiler* :options :advanced))\n             (not *unchecked-arrays*))\n    *checked-arrays*))\n\n(def js-reserved\n  #{"arguments" "abstract" "await" "boolean" "break" "byte" "case"\n    "catch" "char" "class" "const" "continue"\n    "debugger" "default" "delete" "do" "double"\n    "else" "enum" "export" "extends" "final"\n    "finally" "float" "for" "function" "goto" "if"\n    "implements" "import" "in" "instanceof" "int"\n    "interface" "let" "long" "native" "new"\n    "package" "private" "protected" "public"\n    "return" "short" "static" "super" "switch"\n    "synchronized" "this" "throw" "throws"\n    "transient" "try" "typeof" "var" "void"\n    "volatile" "while" "with" "yield" "methods"\n    "null" "constructor"})\n\n(def es5-allowed\n  #{"default"})\n\n#?(:clj (def SENTINEL (Object.))\n   :cljs (def SENTINEL (js-obj)))\n\n(defn gets\n  ([m k0 k1]\n    (let [m (get m k0 SENTINEL)]\n      (when-not (identical? m SENTINEL)\n        (get m k1))))\n  ([m k0 k1 k2]\n   (let [m (get m k0 SENTINEL)]\n     (when-not (identical? m SENTINEL)\n       (let [m (get m k1 SENTINEL)]\n         (when-not (identical? m SENTINEL)\n           (get m k2))))))\n  ([m k0 k1 k2 k3]\n   (let [m (get m k0 SENTINEL)]\n     (when-not (identical? m SENTINEL)\n       (let [m (get m k1 SENTINEL)]\n         (when-not (identical? m SENTINEL)\n           (let [m (get m k2 SENTINEL)]\n             (when-not (identical? m SENTINEL)\n               (get m k3)))))))))\n\n#?(:cljs\n   (def CLJ_NIL_SYM \'clj-nil))\n\n#?(:cljs\n   (def NUMBER_SYM \'number))\n\n#?(:cljs\n   (def STRING_SYM \'string))\n\n(def BOOLEAN_SYM \'boolean)\n\n#?(:cljs\n   (def JS_STAR_SYM \'js*))\n\n#?(:cljs\n   (def DOT_SYM \'.))\n\n#?(:cljs\n   (def NEW_SYM \'new))\n\n#?(:cljs\n   (def CLJS_CORE_SYM \'cljs.core))\n\n#?(:cljs\n   (def CLJS_CORE_MACROS_SYM \'cljs.core$macros))\n\n(def IGNORE_SYM \'ignore)\n\n(def ANY_SYM \'any)\n\n#?(:cljs\n   (defn ^boolean cljs-seq? [x]\n     (implements? ISeq x)))\n\n#?(:cljs\n   (defn ^boolean cljs-map? [x]\n     (implements? IMap x)))\n\n#?(:cljs\n   (defn ^boolean cljs-vector? [x]\n     (implements? IVector x)))\n\n#?(:cljs\n   (defn ^boolean cljs-set? [x]\n     (implements? ISet x)))\n\n#?(:cljs\n   (defn munge-path [ss]\n     (munge (str ss))))\n\n#?(:cljs\n   (defn ns-\x3erelpath\n     "Given a namespace as a symbol return the relative path. May optionally\n     provide the file extension, defaults to :cljs."\n     ([ns] (ns-\x3erelpath ns :cljs))\n     ([ns ext]\n      (str (string/replace (munge-path ns) \\. \\/) "." (name ext)))))\n\n#?(:cljs\n   (defn topo-sort\n     ([x get-deps]\n      (topo-sort x 0 (atom (sorted-map)) (memoize get-deps)))\n     ([x depth state memo-get-deps]\n      (let [deps (memo-get-deps x)]\n        (swap! state update-in [depth] (fnil into #{}) deps)\n        (doseq [dep deps]\n          (topo-sort dep (inc depth) state memo-get-deps))\n        (doseq [[\x3cdepth _] (subseq @state \x3c depth)]\n          (swap! state update-in [\x3cdepth] set/difference deps))\n        (when (\x3d depth 0)\n          (distinct (apply concat (vals @state))))))))\n\n(declare message namespaces)\n\n(defn ast?\n  #?(:cljs {:tag boolean})\n  [x]\n  (and (map? x) (contains? x :op)))\n\n(defmulti error-message (fn [warning-type \x26 _] warning-type))\n\n(defmethod error-message :preamble-missing\n  [warning-type info]\n  (str "Preamble resource file not found: " (string/join " " (:missing info))))\n\n(defmethod error-message :unprovided\n  [warning-type info]\n  (str "Required namespace not provided for " (string/join " " (:unprovided info))))\n\n(defmethod error-message :undeclared-var\n  [warning-type info]\n  (str (if (:macro-present? info)\n         "Can\'t take value of macro "\n         "Use of undeclared Var ")\n    (:prefix info) "/" (:suffix info)))\n\n(defmethod error-message :private-var-access\n  [warning-type info]\n  (str "var: " (:sym info) " is not public"))\n\n(defmethod error-message :undeclared-ns\n  [warning-type {:keys [ns-sym js-provide] :as info}]\n  (str "No such namespace: " ns-sym\n       ", could not locate " (ns-\x3erelpath ns-sym :cljs)\n       ", " (ns-\x3erelpath ns-sym :cljc)\n       ", or JavaScript source providing \\"" js-provide "\\""\n    (when (string/includes? (ns-\x3erelpath ns-sym) "_")\n      " (Please check that namespaces with dashes use underscores in the ClojureScript file name)")))\n\n(defmethod error-message :undeclared-macros-ns\n  [warning-type {:keys [ns-sym js-provide] :as info}]\n  (str "No such macros namespace: " ns-sym\n       ", could not locate " (ns-\x3erelpath ns-sym :clj)\n       " or " (ns-\x3erelpath ns-sym :cljc)))\n\n(defmethod error-message :dynamic\n  [warning-type info]\n  (str (:name info) " not declared ^:dynamic"))\n\n(defmethod error-message :redef\n  [warning-type info]\n  (str (:sym info) " already refers to: " (symbol (str (:ns info)) (str (:sym info)))\n    " being replaced by: " (symbol (str (:ns-name info)) (str (:sym info)))))\n\n(defmethod error-message :redef-in-file\n  [warning-type info]\n  (str (:sym info) " at line " (:line info) " is being replaced"))\n\n(defmethod error-message :fn-var\n  [warning-type info]\n  (str (symbol (str (:ns-name info)) (str (:sym info)))\n    " no longer fn, references are stale"))\n\n(defmethod error-message :fn-arity\n  [warning-type info]\n  (str "Wrong number of args (" (:argc info) ") passed to "\n    (or (:ctor info)\n      (:name info))))\n\n(defmethod error-message :fn-deprecated\n  [warning-type info]\n  (str (-\x3e info :fexpr :info :name) " is deprecated"))\n\n(defmethod error-message :declared-arglists-mismatch\n  [warning-type info]\n  (str (symbol (str (:ns-name info)) (str (:sym info)))\n    " declared arglists " (:declared info)\n    " mismatch defined arglists " (:defined info)))\n\n(defmethod error-message :undeclared-ns-form\n  [warning-type info]\n  (str "Invalid :refer, " (:type info) " " (:lib info) "/" (:sym info) " does not exist"))\n\n(defmethod error-message :protocol-deprecated\n  [warning-type info]\n  (str "Protocol " (:protocol info) " is deprecated"))\n\n(defmethod error-message :undeclared-protocol-symbol\n  [warning-type info]\n  (str "Can\'t resolve protocol symbol " (:protocol info)))\n\n(defmethod error-message :invalid-protocol-symbol\n  [warning-type info]\n  (str "Symbol " (:protocol info) " is not a protocol"))\n\n(defmethod error-message :protocol-invalid-method\n  [warning-type info]\n  (if (:no-such-method info)\n    (str "Bad method signature in protocol implementation, "\n      (:protocol info) " does not declare method called " (:fname info))\n    (str "Bad method signature in protocol implementation, "\n      (:protocol info) " " (:fname info) " does not declare arity " (:invalid-arity info))))\n\n(defmethod error-message :protocol-duped-method\n  [warning-type info]\n  (str "Duplicated methods in protocol implementation " (:protocol info) " " (:fname info)))\n\n(defmethod error-message :protocol-multiple-impls\n  [warning-type info]\n  (str "Protocol " (:protocol info) " implemented multiple times"))\n\n(defmethod error-message :protocol-with-variadic-method\n  [warning-type info]\n  (str "Protocol " (:protocol info) " declares method "\n       (:name info) " with variadic signature (\x26)"))\n\n(defmethod error-message :protocol-impl-with-variadic-method\n  [warning-type info]\n  (str "Protocol " (:protocol info) " implements method "\n    (:name info) " with variadic signature (\x26)"))\n\n(defmethod error-message :protocol-impl-recur-with-target\n  [warning-type info]\n  (str "Ignoring target object \\"" (pr-str (:form info)) "\\" passed in recur to protocol method head"))\n\n(defmethod error-message :multiple-variadic-overloads\n  [warning-type info]\n  (str (:name info) ": Can\'t have more than 1 variadic overload"))\n\n(defmethod error-message :variadic-max-arity\n  [warning-type info]\n  (str (:name info) ": Can\'t have fixed arity function with more params than variadic function"))\n\n(defmethod error-message :overload-arity\n  [warning-type info]\n  (str (:name info) ": Can\'t have 2 overloads with same arity"))\n\n(defmethod error-message :extending-base-js-type\n  [warning-type info]\n  (str "Extending an existing JavaScript type - use a different symbol name "\n       "instead of " (:current-symbol info) " e.g " (:suggested-symbol info)))\n\n(defmethod error-message :invalid-arithmetic\n  [warning-type info]\n  (str (:js-op info) ", all arguments must be numbers, got " (:types info) " instead"))\n\n(defmethod error-message :invalid-array-access\n  [warning-type {:keys [name types]}]\n  (case name\n    (cljs.core/checked-aget cljs.core/checked-aget\')\n    (str "cljs.core/aget, arguments must be an array followed by numeric indices, got " types " instead"\n      (when (or (\x3d \'object (first types))\n                (every? #{\'string} (rest types)))\n        (str " (consider "\n          (if (\x3d\x3d 2 (count types))\n            "goog.object/get"\n            "goog.object/getValueByKeys")\n          " for object access)")))\n\n    (cljs.core/checked-aset cljs.core/checked-aset\')\n    (str "cljs.core/aset, arguments must be an array, followed by numeric indices, followed by a value, got " types " instead"\n      (when (or (\x3d \'object (first types))\n                (every? #{\'string} (butlast (rest types))))\n        " (consider goog.object/set for object access)"))))\n\n(defmethod error-message :invoke-ctor\n  [warning-type info]\n  (str "Cannot invoke type constructor " (-\x3e info :fexpr :info :name) " as function "))\n\n(defmethod error-message :single-segment-namespace\n  [warning-type info]\n  (str (:name info) " is a single segment namespace"))\n\n(defmethod error-message :munged-namespace\n  [warning-type {:keys [name] :as info}]\n  (let [munged (-\x3e\x3e (string/split (clojure.core/name name) #"\\.")\n                 (map #(if (js-reserved %) (str % "$") %))\n                 (string/join ".")\n                 (munge))]\n    (str "Namespace " name " contains a reserved JavaScript keyword,"\n         " the corresponding Google Closure namespace will be munged to " munged)))\n\n(defmethod error-message :ns-var-clash\n  [warning-type {:keys [ns var] :as info}]\n  (str "Namespace " ns " clashes with var " var))\n\n(defmethod error-message :non-dynamic-earmuffed-var\n  [warning-type {:keys [var] :as info}]\n  (str var " not declared dynamic and thus is not dynamically rebindable, but its name "\n    "suggests otherwise. Please either indicate ^:dynamic " var " or change the name"))\n\n(defmethod error-message :extend-type-invalid-method-shape\n  [warning-type {:keys [protocol method] :as info}]\n  (str "Bad extend-type method shape for protocol " protocol " method " method\n       ", method arities must be grouped together"))\n\n(defmethod error-message :unsupported-js-module-type\n  [warning-type {:keys [module-type file] :as info}]\n  (str "Unsupported JavaScript module type " module-type " for foreign library "\n       file "."))\n\n(defmethod error-message :unsupported-preprocess-value\n  [warning-type {:keys [preprocess file]}]\n  (str "Unsupported preprocess value " preprocess " for foreign library "\n       file "."))\n\n(defmethod error-message :js-shadowed-by-local\n  [warning-type {:keys [name]}]\n  (str name " is shadowed by a local"))\n\n(defmethod error-message :infer-warning\n  [warning-type {:keys [warn-type form type property]}]\n  (case warn-type\n    :target   (str "Cannot infer target type in expression " form "")\n    :property (str "Cannot resolve property " property\n                   " for inferred type " type  " in expression " form)\n    :object   (str "Adding extern to Object for property " property " due to "\n                   "ambiguous expression " form)))\n\n(defn default-warning-handler [warning-type env extra]\n  (when (warning-type *cljs-warnings*)\n    (when-let [s (error-message warning-type extra)]\n      #?(:clj  (binding [*out* *err*]\n                 (println (message env (str "WARNING: " s))))\n         :cljs (binding [*print-fn* *print-err-fn*]\n                 (println (message env (str "WARNING: " s))))))))\n\n(def ^:dynamic *cljs-warning-handlers*\n  [default-warning-handler])\n\n#?(:clj\n   (defmacro with-warning-handlers [handlers \x26 body]\n     `(binding [*cljs-warning-handlers* ~handlers]\n        ~@body)))\n\n(defn- repeat-char [c n]\n  (loop [ret c n n]\n    (if (pos? n)\n      (recur (str ret c) (dec n))\n      ret)))\n\n(defn- hex-format [s pad]\n  #?(:clj  (str "_u" (format (str "%0" pad "x") (int (first s))) "_")\n     :cljs (let [hex (.toString (.charCodeAt s 0) 16)\n                 len (. hex -length)\n                 hex (if (\x3c len pad)\n                       (str (repeat-char "0" (- pad len)) hex)\n                       hex)]\n             (str "_u" hex "_"))))\n\n(defn gen-constant-id [value]\n  (let [prefix (cond\n                 (keyword? value) "cst$kw$"\n                 (symbol? value)  "cst$sym$"\n                 :else\n                 (throw\n                   #?(:clj (Exception. (str "constant type " (type value) " not supported"))\n                      :cljs (js/Error. (str "constant type " (type value) " not supported")))))\n        name   (if (keyword? value)\n                 (subs (str value) 1)\n                 (str value))\n        name   (if (\x3d "." name)\n                 "_DOT_"\n                 (-\x3e name\n                     (string/replace "-" "_DASH_")\n                     (munge)\n                     (string/replace "." "$")\n                     (string/replace #"(?i)[^a-z0-9$_]" #(hex-format % 4))))]\n    (symbol (str prefix name))))\n\n(defn- register-constant!\n  ([val] (register-constant! nil val))\n  ([env val]\n   (swap! env/*compiler*\n     (fn [cenv]\n       (cond-\x3e\n         (-\x3e cenv\n           (update-in [::constant-table]\n             (fn [table]\n               (if (get table val)\n                 table\n                 (assoc table val (gen-constant-id val))))))\n         env (update-in [::namespaces (-\x3e env :ns :name) ::constants]\n               (fn [{:keys [seen order] :or {seen #{} order []} :as constants}]\n                 (cond-\x3e constants\n                   (not (contains? seen val))\n                   (assoc\n                     :seen (conj seen val)\n                     :order (conj order val))))))))))\n\n(def default-namespaces \'{cljs.core {:name cljs.core}\n                          cljs.user {:name cljs.user}})\n\n;; this exists solely to support read-only namespace access from macros.\n;; External tools should look at the authoritative ::namespaces slot in the\n;; compiler-env atoms/maps they\'re using already; this value will yield only\n;; `default-namespaces` when accessed outside the scope of a\n;; compilation/analysis call\n(def namespaces\n  #?(:clj\n     (reify clojure.lang.IDeref\n       (deref [_]\n         (if (some? env/*compiler*)\n           (::namespaces @env/*compiler*)\n           default-namespaces)))\n     :cljs\n     (reify IDeref\n       (-deref [_]\n         (if (some? env/*compiler*)\n           (::namespaces @env/*compiler*)\n           default-namespaces)))))\n\n(defn get-namespace\n  ([key]\n    (get-namespace env/*compiler* key))\n  ([cenv key]\n   (if-some [ns (get-in @cenv [::namespaces key])]\n       ns\n       (when (\x3d \'cljs.user key)\n         {:name \'cljs.user}))))\n\n#?(:clj\n   (defmacro no-warn [\x26 body]\n     (let [no-warnings (zipmap (keys *cljs-warnings*) (repeat false))]\n       `(binding [*cljs-warnings* ~no-warnings]\n          ~@body))))\n\n#?(:clj\n   (defmacro all-warn [\x26 body]\n     (let [all-warnings (zipmap (keys *cljs-warnings*) (repeat true))]\n       `(binding [*cljs-warnings* ~all-warnings]\n          ~@body))))\n\n(defn get-line [x env]\n  (or (-\x3e x meta :line) (:line env)))\n\n(defn get-col [x env]\n  (or (-\x3e x meta :column) (:column env)))\n\n(defn intern-macros\n  "Given a Clojure namespace intern all macros into the ambient ClojureScript\n   analysis environment."\n  ([ns] (intern-macros ns false))\n  ([ns reload]\n    (when (or (nil? (gets @env/*compiler* ::namespaces ns :macros))\n              reload)\n      (swap! env/*compiler* assoc-in [::namespaces ns :macros]\n        (-\x3e\x3e #?(:clj (ns-interns ns) :cljs (ns-interns* ns))\n             (filter (fn [[_ ^Var v]] (.isMacro v)))\n             (map (fn [[k v]]\n                    [k (as-\x3e (meta v) vm\n                         (let [ns (.getName ^Namespace (:ns vm))]\n                           (assoc vm\n                             :ns ns\n                             :name (symbol (str ns) (str k))\n                             :macro true)))]))\n             (into {}))))))\n\n#?(:clj\n   (def load-mutex (Object.)))\n\n#?(:clj\n   (defn load-core []\n     (when (not @-cljs-macros-loaded)\n       (reset! -cljs-macros-loaded true)\n       (if *cljs-macros-is-classpath*\n         (locking load-mutex\n           (load *cljs-macros-path*))\n         (locking load-mutex\n           (load-file *cljs-macros-path*))))\n     (intern-macros \'cljs.core)))\n\n#?(:clj\n   (defmacro with-core-macros\n     [path \x26 body]\n     `(do\n        (when (not\x3d *cljs-macros-path* ~path)\n          (reset! -cljs-macros-loaded false))\n        (binding [*cljs-macros-path* ~path]\n          ~@body))))\n\n#?(:clj\n   (defmacro with-core-macros-file\n     [path \x26 body]\n     `(do\n        (when (not\x3d *cljs-macros-path* ~path)\n          (reset! -cljs-macros-loaded false))\n        (binding [*cljs-macros-path* ~path\n                  *cljs-macros-is-classpath* false]\n          ~@body))))\n\n(defn empty-env\n  "Construct an empty analysis environment. Required to analyze forms."\n  []\n  (ensure\n    {:ns (get-namespace *cljs-ns*)\n     :context :statement\n     :locals {}\n     :fn-scope []\n     :js-globals (into {}\n                   (map #(vector % {:op :js-var :name % :ns \'js})\n                     \'(alert window document console escape unescape\n                       screen location navigator history location\n                       global process require module exports)))}))\n\n(defn- source-info-\x3eerror-data\n  [{:keys [file line column]}]\n  {:clojure.error/source file\n   :clojure.error/line   line\n   :clojure.error/column column})\n\n(defn source-info\n  ([env]\n   (when (:line env)\n     (source-info nil env)))\n  ([name env]\n   (cond-\x3e {:file (if (\x3d (-\x3e env :ns :name) \'cljs.core)\n                    "cljs/core.cljs"\n                    *cljs-file*)\n            :line (get-line name env)\n            :column (get-col name env)}\n     (:root-source-info env)\n     (merge (select-keys env [:root-source-info])))))\n\n(defn message [env s]\n  (str s\n    (if (:line env)\n      (str " at line " (:line env) " " *cljs-file*)\n      (when *cljs-file*\n        (str " in file " *cljs-file*)))))\n\n(defn warning [warning-type env extra]\n  (doseq [handler *cljs-warning-handlers*]\n    (handler warning-type env extra)))\n\n(defn- accumulating-warning-handler [warn-acc]\n  (fn [warning-type env extra]\n    (when (warning-type *cljs-warnings*)\n      (swap! warn-acc conj [warning-type env extra]))))\n\n(defn- replay-accumulated-warnings [warn-acc]\n  (run! #(apply warning %) @warn-acc))\n\n(defn- error-data\n  ([env phase]\n   (error-data env phase nil))\n  ([env phase symbol]\n   (merge (-\x3e (source-info env) source-info-\x3eerror-data)\n     {:clojure.error/phase phase}\n     (when symbol\n       {:clojure.error/symbol symbol}))))\n\n(defn- compile-syntax-error\n  [env msg symbol]\n  (ex-info nil (error-data env :compile-syntax-check symbol)\n    #?(:clj (RuntimeException. ^String msg) :cljs (js/Error. msg))))\n\n(defn error\n  ([env msg]\n   (error env msg nil))\n  ([env msg cause]\n   (ex-info (message env msg)\n     (assoc (source-info env) :tag :cljs/analysis-error)\n     cause)))\n\n(defn analysis-error?\n  #?(:cljs {:tag boolean})\n  [ex]\n  (\x3d :cljs/analysis-error (:tag (ex-data ex))))\n\n(defn has-error-data?\n  #?(:cljs {:tag boolean})\n  [ex]\n  (contains? (ex-data ex) :clojure.error/phase))\n\n#?(:clj\n   (defmacro wrapping-errors [env \x26 body]\n     `(try\n        ~@body\n        (catch Throwable err#\n          (cond\n            (has-error-data? err#) (throw err#)\n            (analysis-error? err#) (throw (ex-info nil (error-data ~env :compilation) err#))\n            :else (throw (ex-info nil (error-data ~env :compilation) (error ~env (.getMessage err#) err#))))))))\n\n;; namespaces implicit to the inclusion of cljs.core\n(def implicit-nses \'#{goog goog.object goog.string goog.array Math String})\n\n(defn implicit-import?\n  #?(:cljs {:tag boolean})\n  [env prefix suffix]\n  (contains? implicit-nses prefix))\n\n(declare get-expander)\n\n(defn confirm-var-exist-warning [env prefix suffix]\n  (fn [env prefix suffix]\n    (warning :undeclared-var env\n      {:prefix         prefix\n       :suffix         suffix\n       :macro-present? (not (nil? (get-expander (symbol (str prefix) (str suffix)) env)))})))\n\n(defn loaded-js-ns?\n  "Check if a JavaScript namespace has been loaded. JavaScript vars are\n  not currently checked."\n  #?(:cljs {:tag boolean})\n  [env prefix]\n  (when-not (gets @env/*compiler* ::namespaces prefix)\n    (let [ns (:ns env)]\n      (or (some? (get (:requires ns) prefix))\n          (some? (get (:imports ns) prefix))))))\n\n(defn- internal-js-module-exists?\n  [js-module-index module]\n  ;; we need to check both keys and values of the JS module index, because\n  ;; macroexpansion will be looking for the provided name - António Monteiro\n  (contains?\n    (into #{}\n      (mapcat (fn [[k v]]\n                [k (:name v)]))\n      js-module-index)\n    (str module)))\n\n(def js-module-exists?* (memoize internal-js-module-exists?))\n\n(defn js-module-exists?\n  [module]\n  (js-module-exists?* (get-in @env/*compiler* [:js-module-index]) module))\n\n(defn node-module-dep?\n  #?(:cljs {:tag boolean})\n  [module]\n  #?(:clj (contains?\n            (get-in @env/*compiler* [:node-module-index])\n            (str module))\n     :cljs (try\n             (and (\x3d *target* "nodejs")\n                  (boolean (js/require.resolve (str module))))\n             (catch :default _\n               false))))\n\n(defn dep-has-global-exports?\n  [module]\n  (let [global-exports (get-in @env/*compiler* [:js-dependency-index (str module) :global-exports])]\n    (or (contains? global-exports (symbol module))\n        (contains? global-exports (name module)))))\n\n(defn confirm-var-exists\n  ([env prefix suffix]\n   (let [warn (confirm-var-exist-warning env prefix suffix)]\n     (confirm-var-exists env prefix suffix warn)))\n  ([env prefix suffix missing-fn]\n   (let [sufstr     (str suffix)\n         suffix-str (if (and #?(:clj  (not\x3d ".." sufstr)\n                                :cljs (not (identical? ".." sufstr))) ;; leave cljs.core$macros/.. alone\n                          #?(:clj  (re-find #"\\." sufstr)\n                             :cljs ^boolean (.test #"\\." sufstr)))\n                      (first (string/split sufstr #"\\."))\n                      suffix)\n         suffix     (symbol suffix-str)]\n     (when (and (not (implicit-import? env prefix suffix))\n                (not (loaded-js-ns? env prefix))\n                (not (and (\x3d \'cljs.core prefix) (\x3d \'unquote suffix)))\n                (nil? (gets @env/*compiler* ::namespaces prefix :defs suffix))\n                (not (js-module-exists? prefix)))\n       (missing-fn env prefix suffix)))))\n\n(defn confirm-var-exists-throw []\n  (fn [env prefix suffix]\n    (confirm-var-exists env prefix suffix\n      (fn [env prefix suffix]\n        (throw (error env (str "Unable to resolve var: " suffix " in this context")))))))\n\n(defn resolve-ns-alias\n  ([env name]\n   (resolve-ns-alias env name (symbol name)))\n  ([env name not-found]\n   (let [sym (symbol name)]\n     (get (:requires (:ns env)) sym not-found))))\n\n(defn resolve-macro-ns-alias\n  ([env name]\n   (resolve-macro-ns-alias env name (symbol name)))\n  ([env name not-found]\n   (let [sym (symbol name)]\n     (get (:require-macros (:ns env)) sym not-found))))\n\n(defn confirm-ns\n  "Given env, an analysis environment, and ns-sym, a symbol identifying a\n   namespace, confirm that the namespace exists. Warn if not found."\n  [env ns-sym]\n  (when (and (not\x3d \'cljs.core ns-sym)\n             (nil? (get implicit-nses ns-sym))\n             (nil? (get (-\x3e env :ns :requires) ns-sym))\n             ;; something else may have loaded the namespace, i.e. load-file\n             (nil? (gets @env/*compiler* ::namespaces ns-sym))\n             ;; macros may refer to namespaces never explicitly required\n             ;; confirm that the library at least exists\n             #?(:clj (nil? (util/ns-\x3esource ns-sym)))\n             (not (js-module-exists? ns-sym)))\n    (warning :undeclared-ns env {:ns-sym ns-sym :js-provide ns-sym})))\n\n(defn core-name?\n  "Is sym visible from core in the current compilation namespace?"\n  #?(:cljs {:tag boolean})\n  [env sym]\n  (and (or (some? (gets @env/*compiler* ::namespaces \'cljs.core :defs sym))\n           (if-some [mac (get-expander sym env)]\n             (let [^Namespace ns (-\x3e mac meta :ns)]\n               (\x3d (.getName ns) #?(:clj \'cljs.core :cljs \'cljs.core$macros)))\n             false))\n       (not (contains? (-\x3e env :ns :excludes) sym))))\n\n(defn public-name?\n  "Is sym public?"\n  #?(:cljs {:tag boolean})\n  [ns sym]\n  (let [var-ast (or (gets @env/*compiler* ::namespaces ns :defs sym)\n                    #?(:clj  (gets @env/*compiler* ::namespaces ns :macros sym)\n                       :cljs (gets @env/*compiler* ::namespaces (symbol (str (name ns) "$macros")) :defs sym)))]\n    (and (some? var-ast)\n         (not (or (:private var-ast)\n                  (:anonymous var-ast))))))\n\n(defn js-tag? [x]\n  (and (symbol? x)\n       (or (\x3d \'js x)\n           (\x3d "js" (namespace x)))))\n\n(defn normalize-js-tag [x]\n  ;; if not \'js, assume constructor\n  (if-not (\x3d \'js x)\n    (with-meta \'js\n      {:prefix (conj (-\x3e\x3e (string/split (name x) #"\\.")\n                       (map symbol) vec)\n                 \'prototype)})\n    x))\n\n(defn -\x3etype-set\n  "Ensures that a type tag is a set."\n  [t]\n  (if #?(:clj  (set? t)\n         :cljs (cljs-set? t))\n    t\n    #{t}))\n\n(defn canonicalize-type [t]\n  "Ensures that a type tag is either nil, a type symbol, or a non-singleton\n  set of type symbols, absorbing clj-nil into seq and all types into any."\n  (cond\n    (symbol? t) t\n    (empty? t) nil\n    (\x3d\x3d 1 (count t)) (first t)\n    (contains? t \'any) \'any\n    (contains? t \'seq) (let [res (disj t \'clj-nil)]\n                         (if (\x3d\x3d 1 (count res))\n                           \'seq\n                           res))\n    :else t))\n\n(defn add-types\n  "Produces a union of types."\n  ([] \'any)\n  ([t1] t1)\n  ([t1 t2]\n   (if (or (nil? t1)\n           (nil? t2))\n     \'any\n     (-\x3e (set/union (-\x3etype-set t1) (-\x3etype-set t2))\n       canonicalize-type)))\n  ([t1 t2 \x26 ts]\n   (apply add-types (add-types t1 t2) ts)))\n\n(def alias-\x3etype\n  \'{object   Object\n    string   String\n    number   Number\n    array    Array\n    function Function\n    boolean  Boolean\n    symbol   Symbol})\n\n(defn has-extern?*\n  ([pre externs]\n   (let [pre (if-some [me (find\n                            (get-in externs \'[Window prototype])\n                            (first pre))]\n               (if-some [tag (-\x3e me first meta :tag)]\n                 (into [tag \'prototype] (next pre))\n                 pre)\n               pre)]\n     (has-extern?* pre externs externs)))\n  ([pre externs top]\n   (cond\n     (empty? pre) true\n     :else\n     (let [x  (first pre)\n           me (find externs x)]\n       (cond\n         (not me) false\n         :else\n         (let [[x\' externs\'] me\n               xmeta (meta x\')]\n           (if (and (\x3d \'Function (:tag xmeta)) (:ctor xmeta))\n             (or (has-extern?* (into \'[prototype] (next pre)) externs\' top)\n                 (has-extern?* (next pre) externs\' top))\n             (recur (next pre) externs\' top))))))))\n\n(defn has-extern?\n  ([pre]\n    (has-extern? pre (get @env/*compiler* ::externs)))\n  ([pre externs]\n   (or (has-extern?* pre externs)\n       (when (\x3d 1 (count pre))\n         (let [x (first pre)]\n           (or (get-in externs (conj \'[Window prototype] x))\n               (get-in externs (conj \'[Number] x)))))\n       (-\x3e (last pre) str (string/starts-with? "cljs$")))))\n\n(defn js-tag\n  ([pre]\n   (js-tag pre :tag))\n  ([pre tag-type]\n   (js-tag pre tag-type (get @env/*compiler* ::externs)))\n  ([pre tag-type externs]\n   (js-tag pre tag-type externs externs))\n  ([pre tag-type externs top]\n   (when-let [[p externs\' :as me] (find externs (first pre))]\n     (let [tag (-\x3e p meta tag-type)]\n       (if (\x3d (count pre) 1)\n         (when tag (symbol "js" (str (alias-\x3etype tag tag))))\n         (or (js-tag (next pre) tag-type externs\' top)\n             (js-tag (into \'[prototype] (next pre)) tag-type (get top tag) top)))))))\n\n(defn dotted-symbol? [sym]\n  (let [s (str sym)]\n    #?(:clj  (and (.contains s ".")\n                  (not (.contains s "..")))\n       :cljs (and ^boolean (goog.string/contains s ".")\n                  (not ^boolean (goog.string/contains s ".."))))))\n\n(defn munge-node-lib [name]\n  (str "node$module$" (munge (string/replace (str name) #"[.\\/]" #?(:clj "\\\\$"\n                                                                    :cljs "$$")))))\n\n(defn munge-global-export [name]\n  (str "global$module$" (munge (string/replace (str name) #"[.\\/]" #?(:clj "\\\\$"\n                                                                      :cljs "$$")))))\n\n(defn resolve-alias\n  "Takes a namespace and an unqualified symbol and potentially returns a new\n  symbol to be used in lieu of the original."\n  [ns sym]\n  ;; Conditionally alias aget/aset fns to checked variants\n  (if (and (\x3d \'cljs.core ns)\n           (\'#{aget aset} sym)\n           (checked-arrays))\n    (get-in \'{:warn  {aget checked-aget\n                      aset checked-aset}\n              :error {aget checked-aget\'\n                      aset checked-aset\'}}\n      [(checked-arrays) sym])\n    sym))\n\n(defn ns-\x3emodule-type [ns]\n  (cond\n    (js-module-exists? ns) :js\n    (node-module-dep? ns) :node\n    (dep-has-global-exports? ns) :global))\n\n(defmulti resolve* (fn [env sym full-ns current-ns] (ns-\x3emodule-type full-ns)))\n\n(defmethod resolve* :js\n  [env sym full-ns current-ns]\n  {:name (symbol (str full-ns) (str (name sym)))\n   :op :js-var\n   :ns full-ns})\n\n(defmethod resolve* :node\n  [env sym full-ns current-ns]\n  {:name (symbol (str current-ns) (str (munge-node-lib full-ns) "." (name sym)))\n   :op :js-var\n   :ns current-ns})\n\n(defmethod resolve* :global\n  [env sym full-ns current-ns]\n  (let [pre (into \'[Object] (-\x3e\x3e (string/split (name sym) #"\\.") (map symbol) vec))]\n    (when-not (has-extern? pre)\n      (swap! env/*compiler* update-in\n        (into [::namespaces current-ns :externs] pre) merge {}))\n    {:name (symbol (str current-ns) (str (munge-global-export full-ns) "." (name sym)))\n     :op :js-var\n     :ns current-ns\n     :tag (with-meta \'js {:prefix pre})}))\n\n(def ^:private private-var-access-exceptions\n  "Specially-treated symbols for which we don\'t trigger :private-var-access warnings."\n  \'#{cljs.core/checked-aget\n     cljs.core/checked-aset\n     cljs.core/checked-aget\'\n     cljs.core/checked-aset\'})\n\n(defmethod resolve* :default\n  [env sym full-ns current-ns]\n  (let [sym-ast (gets @env/*compiler* ::namespaces full-ns :defs (symbol (name sym)))\n        sym-name (symbol (str full-ns) (str (name sym)))]\n    (when (and (not\x3d current-ns full-ns)\n               (:private sym-ast)\n               (not *private-var-access-nowarn*)\n               (not (contains? private-var-access-exceptions sym-name)))\n      (warning :private-var-access env\n        {:sym sym-name}))\n    (merge sym-ast\n      {:name sym-name\n       :op :var\n       :ns   full-ns})))\n\n(defn required? [ns env]\n  (or (contains? (set (vals (gets env :ns :requires))) ns)\n      (contains? (set (vals (gets env :ns :uses))) ns)))\n\n(defn invokeable-ns?\n  "Returns true if ns is a required namespace and a JavaScript module that\n   might be invokeable as a function."\n  [ns env]\n  (let [ns (resolve-ns-alias env ns)]\n    (and (required? ns env)\n         (or (js-module-exists? ns)\n             (node-module-dep? ns)\n             (dep-has-global-exports? ns)))))\n\n(defn resolve-invokeable-ns [ns current-ns env]\n  (let [ns (resolve-ns-alias env ns)\n        module-type (ns-\x3emodule-type ns)]\n    (case module-type\n      :js     {:name (symbol\n                       (or (gets @env/*compiler* :js-module-index ns :name)\n                           (resolve-ns-alias env ns)))\n               :op :js-var\n               :ns \'js}\n      :node   {:name (symbol (str current-ns)\n                       (munge-node-lib (resolve-ns-alias env ns)))\n               :op :js-var\n               :ns current-ns}\n      :global {:name (symbol (str current-ns)\n                       (munge-global-export (resolve-ns-alias env ns)))\n               :op :js-var\n               :ns current-ns})))\n\n;; core.async calls `macroexpand-1` manually with an ill-formed\n;; :locals map. Normally :locals maps symbols maps, but\n;; core.async adds entries mapping symbols to symbols. We work\n;; around that specific case here. This is called defensively\n;; every time we lookup the :locals map.\n(defn handle-symbol-local [sym lb]\n  (if (symbol? lb)\n    {:name sym}\n    lb))\n\n(defn resolve-var\n  "Resolve a var. Accepts a side-effecting confirm fn for producing\n   warnings about unresolved vars."\n  ([env sym] (resolve-var env sym nil))\n  ([env sym confirm]\n   (let [locals (:locals env)]\n     (if #?(:clj  (\x3d "js" (namespace sym))\n            :cljs (identical? "js" (namespace sym)))\n       (let [symn (-\x3e sym name symbol)\n             shadowed-by-local (handle-symbol-local symn (get locals symn))]\n         (cond\n           (some? shadowed-by-local)\n           (do (warning :js-shadowed-by-local env {:name sym})\n               (assoc shadowed-by-local :op :local))\n\n           :else\n           (let [pre (-\x3e\x3e (string/split (name sym) #"\\.") (map symbol) vec)]\n             (when (and (not (has-extern? pre))\n                        ;; ignore exists? usage\n                        (not (-\x3e sym meta ::no-resolve)))\n               (swap! env/*compiler* update-in\n                 (into [::namespaces (-\x3e env :ns :name) :externs] pre) merge {}))\n             (merge\n               {:name sym\n                :op :js-var\n                :ns   \'js\n                :tag  (with-meta (or (js-tag pre) (:tag (meta sym)) \'js) {:prefix pre})}\n               (when-let [ret-tag (js-tag pre :ret-tag)]\n                 {:js-fn-var true\n                  :ret-tag ret-tag})))))\n       (let [s  (str sym)\n             lb (handle-symbol-local sym (get locals sym))\n             current-ns (-\x3e env :ns :name)]\n         (cond\n           (some? lb) (assoc lb :op :local)\n\n           (some? (namespace sym))\n           (let [ns      (namespace sym)\n                 ns      (if #?(:clj  (\x3d "clojure.core" ns)\n                                :cljs (identical? "clojure.core" ns))\n                           "cljs.core"\n                           ns)\n                 full-ns (resolve-ns-alias env ns\n                           (or (and (js-module-exists? ns)\n                                    (gets @env/*compiler* :js-module-index ns :name))\n                             (symbol ns)))]\n             (when (some? confirm)\n               (when (not\x3d current-ns full-ns)\n                 (confirm-ns env full-ns))\n               (confirm env full-ns (symbol (name sym))))\n             (resolve* env sym full-ns current-ns))\n\n           (dotted-symbol? sym)\n           (let [idx    (.indexOf s ".")\n                 prefix (symbol (subs s 0 idx))\n                 suffix (subs s (inc idx))]\n             (if-some [lb (handle-symbol-local prefix (get locals prefix))]\n               {:op :local\n                :name (symbol (str (:name lb) "." suffix))}\n               (if-some [full-ns (gets @env/*compiler* ::namespaces current-ns :imports prefix)]\n                 {:op :js-var\n                  :name (symbol (str full-ns) suffix)}\n                 (if-some [info (gets @env/*compiler* ::namespaces current-ns :defs prefix)]\n                   (merge info\n                     {:name (symbol (str current-ns) (str sym))\n                      :op :var\n                      :ns current-ns})\n                   (merge (gets @env/*compiler* ::namespaces prefix :defs (symbol suffix))\n                     {:name (if (\x3d "" prefix) (symbol suffix) (symbol (str prefix) suffix))\n                      :op :var\n                      :ns prefix})))))\n\n           (some? (gets @env/*compiler* ::namespaces current-ns :uses sym))\n           (let [full-ns (gets @env/*compiler* ::namespaces current-ns :uses sym)]\n             (resolve* env sym full-ns current-ns))\n\n           (some? (gets @env/*compiler* ::namespaces current-ns :renames sym))\n           (let [qualified-symbol (gets @env/*compiler* ::namespaces current-ns :renames sym)\n                 full-ns (symbol (namespace qualified-symbol))\n                 sym     (symbol (name qualified-symbol))]\n             (resolve* env sym full-ns current-ns))\n\n           (some? (gets @env/*compiler* ::namespaces current-ns :imports sym))\n           (recur env (gets @env/*compiler* ::namespaces current-ns :imports sym) confirm)\n\n           (some? (gets @env/*compiler* ::namespaces current-ns :defs sym))\n           (do\n             (when (some? confirm)\n               (confirm env current-ns sym))\n             (merge (gets @env/*compiler* ::namespaces current-ns :defs sym)\n               {:name (symbol (str current-ns) (str sym))\n                :op :var\n                :ns current-ns}))\n\n           (core-name? env sym)\n           (do\n             (when (some? confirm)\n               (confirm env \'cljs.core sym))\n             (merge (gets @env/*compiler* ::namespaces \'cljs.core :defs sym)\n               {:name (symbol "cljs.core" (str sym))\n                :op :var\n                :ns \'cljs.core}))\n\n           (invokeable-ns? s env)\n           (resolve-invokeable-ns s current-ns env)\n\n           :else\n           (do\n             (when (some? confirm)\n               (confirm env current-ns sym))\n             (merge (gets @env/*compiler* ::namespaces current-ns :defs sym)\n               {:name (symbol (str current-ns) (str sym))\n                :op :var\n                :ns current-ns}))))))))\n\n(defn resolve-existing-var\n  "Given env, an analysis environment, and sym, a symbol, resolve an existing var.\n   Emits a warning if no such var exists."\n  [env sym]\n  (if-not (-\x3e sym meta ::no-resolve)\n    (resolve-var env sym confirm-var-exists)\n    (resolve-var env sym)))\n\n(defn confirm-bindings\n  "Given env, an analysis environment env, and names, a list of symbols, confirm\n   that all correspond to declared dynamic vars."\n  [env names]\n  (doseq [name names]\n    (let [env (assoc env :ns (get-namespace *cljs-ns*))\n          ev (resolve-existing-var env name)]\n      (when (and ev (not (-\x3e ev :dynamic)))\n        (warning :dynamic env {:ev ev :name (:name ev)})))))\n\n(defn resolve-macro-var\n  "Given env, an analysis environment, and sym, a symbol, resolve a macro."\n  [env sym]\n  (let [ns (-\x3e env :ns :name)\n        namespaces (get @env/*compiler* ::namespaces)]\n    (cond\n      (some? (namespace sym))\n      (let [ns (namespace sym)\n            ns (if (\x3d "clojure.core" ns) "cljs.core" ns)\n            full-ns (resolve-macro-ns-alias env ns)\n            #?@(:cljs [full-ns (if-not (string/ends-with? (str full-ns) "$macros")\n                                 (symbol (str full-ns "$macros"))\n                                 full-ns)])]\n        #?(:clj (get-in namespaces [full-ns :macros (symbol (name sym))])\n           :cljs (get-in namespaces [full-ns :defs (symbol (name sym))])))\n\n      (some? (get-in namespaces [ns :use-macros sym]))\n      (let [full-ns (get-in namespaces [ns :use-macros sym])]\n        (get-in namespaces [full-ns :macros sym]))\n\n      (some? (get-in namespaces [ns :rename-macros sym]))\n      (let [qualified-symbol (get-in namespaces [ns :rename-macros sym])\n            full-ns (symbol (namespace qualified-symbol))\n            sym     (symbol (name qualified-symbol))]\n        (get-in namespaces [full-ns :macros sym]))\n\n      :else\n      (let [ns (cond\n                 (some? (get-in namespaces [ns :macros sym])) ns\n                 (core-name? env sym) #?(:clj  \'cljs.core\n                                         :cljs CLJS_CORE_MACROS_SYM))]\n        (when (some? ns)\n          #?(:clj  (get-in namespaces [ns :macros sym])\n             :cljs (get-in namespaces [ns :defs sym])))))))\n\n(declare analyze analyze-symbol analyze-seq)\n\n;; Note: This is the set of parse multimethod dispatch values,\n;; along with \'\x26, and differs from cljs.core/special-symbol?\n(def specials \'#{if def fn* do let* loop* letfn* throw try recur new set!\n                 ns deftype* defrecord* . js* \x26 quote case* var ns*})\n\n(def ^:dynamic *recur-frames* nil)\n(def ^:dynamic *loop-lets* ())\n(def ^:dynamic *allow-redef* false)\n(def ^:dynamic *allow-ns* true)\n\n#?(:clj\n   (defmacro disallowing-recur [\x26 body]\n     `(binding [*recur-frames* (cons nil *recur-frames*)] ~@body)))\n\n#?(:clj\n   (defmacro allowing-redef [\x26 body]\n     `(binding [*allow-redef* true] ~@body)))\n\n#?(:clj\n   (defmacro disallowing-ns* [\x26 body]\n     `(binding [*allow-ns* false] ~@body)))\n\n;; TODO: move this logic out - David\n(defn analyze-keyword\n  [env sym]\n  (register-constant! env sym)\n  {:op :const :val sym :env env :form sym :tag \'cljs.core/Keyword})\n\n(defn get-tag [e]\n  (if-some [tag (-\x3e e :form meta :tag)]\n    tag\n    (if-some [tag (-\x3e e :tag)]\n      tag\n      (-\x3e e :info :tag))))\n\n(defn find-matching-method [f params]\n  ;; if local fn, need to look in :info\n  (let [methods (or (:methods f) (-\x3e f :info :methods))\n        c       (count params)]\n    (some\n      (fn [m]\n        (and (or (\x3d\x3d (:fixed-arity m) c)\n                 (:variadic? m))\n             m))\n      methods)))\n\n(defn type?\n  #?(:cljs {:tag boolean})\n  [env t]\n  ;; don\'t use resolve-existing-var to avoid warnings\n  (when (and (some? t) (symbol? t))\n    (let [var (resolve-var env t)]\n      (if-some [type (:type var)]\n        type\n          (if-some [type (-\x3e var :info :type)]\n            type\n              (if-some [proto (:protocol-symbol var)]\n                proto\n                (get \'#{cljs.core/PersistentHashMap cljs.core/List} t)))))))\n\n(declare infer-tag)\n\n(def NOT_NATIVE \'#{clj not-native})\n\n(def BOOLEAN_OR_SEQ \'#{boolean seq})\n\n(defn unwrap-quote [{:keys [op] :as expr}]\n  (if #?(:clj (\x3d op :quote)\n         :cljs (keyword-identical? op :quote))\n    (:expr expr)\n    expr))\n\n(defn infer-if [env e]\n  (let [{:keys [op form]} (unwrap-quote (:test e))\n        then-tag (infer-tag env (:then e))]\n    (if (and #?(:clj (\x3d op :const)\n                :cljs (keyword-identical? op :const))\n             (not (nil? form))\n             (not (false? form)))\n      then-tag\n      (let [else-tag (infer-tag env (:else e))]\n        (cond\n          (or #?(:clj (\x3d then-tag else-tag)\n                 :cljs (symbol-identical? then-tag else-tag))\n              #?(:clj (\x3d else-tag IGNORE_SYM)\n                 :cljs (symbol-identical? else-tag IGNORE_SYM))) then-tag\n          #?(:clj (\x3d then-tag IGNORE_SYM)\n             :cljs (symbol-identical? then-tag IGNORE_SYM)) else-tag\n          ;; TODO: temporary until we move not-native -\x3e clj - David\n          (and (or (some? (get NOT_NATIVE then-tag)) (type? env then-tag))\n               (or (some? (get NOT_NATIVE else-tag)) (type? env else-tag)))\n          \'clj\n          :else\n          (if (and (some? (get BOOLEAN_OR_SEQ then-tag))\n                   (some? (get BOOLEAN_OR_SEQ else-tag)))\n            \'seq\n            (let [then-tag (if #?(:clj (set? then-tag)\n                                  :cljs (cljs-set? then-tag))\n                             then-tag #{then-tag})\n                  else-tag (if #?(:clj (set? else-tag)\n                                  :cljs (cljs-set? else-tag))\n                             else-tag #{else-tag})]\n              (into then-tag else-tag))))))))\n\n(defn infer-invoke [env {f :fn :keys [args] :as e}]\n  (let [me (assoc (find-matching-method f args) :op :fn-method)]\n    (if-some [ret-tag (infer-tag env me)]\n      ret-tag\n      (let [{:keys [info]} f]\n        (if-some [ret-tag (if (or (true? (:fn-var info))\n                                  (true? (:js-fn-var info)))\n                            (:ret-tag info)\n                            (when (\x3d \'js (:ns info)) \'js))]\n          ret-tag\n          ANY_SYM)))))\n\n(defn infer-tag\n  "Given env, an analysis environment, and e, an AST node, return the inferred\n   type of the node"\n  [env e]\n    (if-some [tag (get-tag e)]\n      tag\n      (case (:op e)\n        :recur    IGNORE_SYM\n        :throw    IGNORE_SYM\n        :let      (infer-tag env (:body e))\n        :loop     (infer-tag env (:body e))\n        :do       (infer-tag env (:ret e))\n        :fn-method (infer-tag env (:body e))\n        :def      (infer-tag env (:init e))\n        :invoke   (infer-invoke env e)\n        :if       (infer-if env e)\n        :const    (case (:form e)\n                    true BOOLEAN_SYM\n                    false BOOLEAN_SYM\n                    ANY_SYM)\n        :quote    (infer-tag env (:expr e))\n        (:var :local :js-var :binding)\n                  (if-some [init (:init e)]\n                    (infer-tag env init)\n                    (infer-tag env (:info e)))\n        (:host-field :host-call)      ANY_SYM\n        :js       ANY_SYM\n        nil)))\n\n(defmulti parse (fn [op \x26 rest] op))\n\n(defn var-meta\n  ([var]\n    (var-meta var nil))\n  ([var expr-env]\n   (let [sym (:name var)\n         ks [:ns :doc :file :line :column]\n         m (merge\n             (let [user-meta (:meta var)\n                   uks (keys user-meta)]\n               (zipmap uks\n                 (map #(list \'quote (get user-meta %)) uks)))\n             (assoc (zipmap ks (map #(list \'quote (get var %)) ks))\n               :name `(quote ~(symbol (name (:name var))))\n               :test `(when ~sym (.-cljs$lang$test ~sym))\n               :arglists (let [arglists (:arglists var)\n                               arglists\' (if (\x3d \'quote (first arglists))\n                                           (second arglists)\n                                           arglists)]\n                           (list \'quote\n                             (doall (map with-meta arglists\'\n                                      (:arglists-meta var)))))))]\n     (if expr-env\n       (analyze expr-env m)\n       m))))\n\n(defn var-ast\n  [env sym]\n  ;; we need to dissoc locals for the `(let [x 1] (def x x))` case, because we\n  ;; want the var\'s AST and `resolve-var` will check locals first. - António Monteiro\n  (binding [*private-var-access-nowarn* true]\n    (let [env      (dissoc env :locals)\n          var      (resolve-var env sym (confirm-var-exists-throw))\n          expr-env (assoc env :context :expr)]\n      (when-some [var-ns (:ns var)]\n        {:var  (analyze expr-env sym)\n         :sym  (analyze expr-env `(quote ~(symbol (name var-ns) (name (:name var)))))\n         :meta (var-meta var expr-env)}))))\n\n(defmethod parse \'var\n  [op env [_ sym :as form] _ _]\n  (when (not\x3d 2 (count form))\n    (throw (error env "Wrong number of args to var")))\n  (when-not (symbol? sym)\n    (throw (error env "Argument to var must be symbol")))\n  (merge\n    {:env env\n     :op :the-var\n     :children [:var :sym :meta]\n     :form form}\n    (var-ast env sym)))\n\n(def ^:private predicate-\x3etag\n  \'{\n    ;; Base values\n    cljs.core/nil?            clj-nil\n    cljs.core/undefined?      clj-nil\n    cljs.core/false?          boolean\n    cljs.core/true?           boolean\n    cljs.core/zero?           number\n    cljs.core/infinite?       number\n\n    ;; Base types\n    cljs.core/boolean?        boolean\n    cljs.core/string?         string\n    cljs.core/char?           string\n    cljs.core/number?         number\n    cljs.core/integer?        number\n    cljs.core/float?          number\n    cljs.core/double?         number\n    cljs.core/array?          array\n    cljs.core/seq?            seq\n\n    ;; JavaScript types\n    cljs.core/regexp?         js/RegExp\n\n    ;; Types\n    cljs.core/keyword?        cljs.core/Keyword\n    cljs.core/var?            cljs.core/Var\n    cljs.core/symbol?         cljs.core/Symbol\n    cljs.core/volatile?       cljs.core/Volatile\n    cljs.core/delay?          cljs.core/Delay\n    cljs.core/reduced?        cljs.core/Reduced\n\n    ;;; Note: For non-marker protocol entries below, we\n    ;;; omit predicates that are based on satisfies? because\n    ;;; we cannot safely apply the fast-path optimization\n    ;;; which is enabled when the protocol type is inferred.\n    ;;; If adding a non-marker entry here, also add a test to\n    ;;; cljs.extend-to-native-test/test-extend-to-protocols.\n\n    ;; Protocols\n    cljs.core/map-entry?      cljs.core/IMapEntry\n    cljs.core/uuid?           cljs.core/IUUID\n    cljs.core/tagged-literal? cljs.core/ITaggedLiteral\n    cljs.core/inst?           cljs.core/Inst\n    cljs.core/sequential?     cljs.core/ISequential\n    cljs.core/list?           cljs.core/IList\n    cljs.core/record?         cljs.core/IRecord\n    cljs.core/chunked-seq?    cljs.core/IChunkedSeq\n\n    ;; Composites\n    cljs.core/seqable?        #{cljs.core/ISeqable array string}\n    cljs.core/ident?          #{cljs.core/Keyword cljs.core/Symbol}\n    })\n\n(defn- simple-predicate-induced-tag\n  "Look for a predicate-induced tag when the test expression is a simple\n   application of a predicate to a local, as in (string? x)."\n  [env test]\n  (when (and (list? test)\n             (\x3d\x3d 2 (count test))\n             (every? symbol? test))\n    (let [analyzed-fn (no-warn (analyze (assoc env :context :expr) (first test)))]\n      (when (\x3d :var (:op analyzed-fn))\n        (when-let [tag (predicate-\x3etag (:name analyzed-fn))]\n          (let [sym (last test)]\n            (when (and (nil? (namespace sym))\n                       (get-in env [:locals sym]))\n              [sym tag])))))))\n\n(defn- type-check-induced-tag\n  "Look for a type-check-induced tag when the test expression is the use of\n   instance? on a local, as in (instance? ICounted x)."\n  [env test]\n  (when (and (list? test)\n             (\x3d\x3d 3 (count test))\n             (every? symbol? test))\n    (let [analyzed-fn (no-warn (analyze (assoc env :context :expr) (first test)))]\n      (when (\x3d :var (:op analyzed-fn))\n        (when (\'#{cljs.core/instance?} (:name analyzed-fn))\n          (let [analyzed-type (no-warn (analyze (assoc env :context :expr) (second test)))\n                tag (:name analyzed-type)\n                sym (last test)]\n            (when (and (\x3d :var (:op analyzed-type))\n                       (nil? (namespace sym))\n                       (get-in env [:locals sym]))\n              [sym tag])))))))\n\n(defn- truth-induced-tag\n  "Refine a tag to exclude clj-nil if the test is a simple symbol."\n  [env test]\n  (when (and (symbol? test)\n             (nil? (namespace test)))\n    (let [analyzed-symbol (no-warn (analyze (assoc env :context :expr) test))]\n      (when-let [tag (:tag analyzed-symbol)]\n        (when (and (set? tag)\n                   (contains? tag \'clj-nil))\n          [test (canonicalize-type (disj tag \'clj-nil))])))))\n\n(defn- set-test-induced-tags\n  "Looks at the test and sets any tags which are induced by virtue\n  of the test being truthy. For example in (if (string? x) x :bar)\n  the local x in the then branch must be of string type."\n  [env test]\n  (let [[local tag] (or (simple-predicate-induced-tag env test)\n                        (type-check-induced-tag env test)\n                        (truth-induced-tag env test))]\n    (cond-\x3e env\n      local (assoc-in [:locals local :tag] tag))))\n\n(defmethod parse \'if\n  [op env [_ test then else :as form] name _]\n  (when (\x3c (count form) 3)\n    (throw (compile-syntax-error env "Too few arguments to if" \'if)))\n  (when (\x3e (count form) 4)\n    (throw (compile-syntax-error env "Too many arguments to if" \'if)))\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (allowing-redef (analyze (set-test-induced-tags env test) then))\n        else-expr (allowing-redef (analyze env else))]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :unchecked *unchecked-if*\n     :children [:test :then :else]}))\n\n(defmethod parse \'case*\n  [op env [_ sym tests thens default :as form] name _]\n  (assert (symbol? sym) "case* must switch on symbol")\n  (assert (every? vector? tests) "case* tests must be grouped in vectors")\n  (let [expr-env (assoc env :context :expr)\n        v        (disallowing-recur (analyze expr-env sym))\n        tests    (mapv #(mapv (fn [t] (analyze expr-env t)) %) tests)\n        thens    (mapv #(analyze env %) thens)\n        nodes    (mapv (fn [tests then]\n                         {:op :case-node\n                          ;synthetic node, no :form\n                          :env env\n                          :tests (mapv (fn [test]\n                                         {:op :case-test\n                                          :form (:form test)\n                                          :env expr-env\n                                          :test test\n                                          :children [:test]})\n                                       tests)\n                          :then {:op :case-then\n                                 :form (:form then)\n                                 :env env\n                                 :then then\n                                 :children [:then]}\n                          :children [:tests :then]})\n                       tests\n                       thens)\n        default  (analyze env default)]\n    (assert (every? (fn [t]\n                      (or\n                        (-\x3e t :info :const)\n                        (and (\x3d :const (:op t))\n                             ((some-fn number? string? char?) (:form t)))))\n              (apply concat tests))\n      "case* tests must be numbers, strings, or constants")\n    {:env env :op :case :form form\n     :test v :nodes nodes :default default\n     :children [:test :nodes :default]}))\n\n(defmethod parse \'throw\n  [op env [_ throw-form :as form] name _]\n  (cond\n    (\x3d 1 (count form))\n    (throw\n      (error env "Too few arguments to throw, throw expects a single Error instance"))\n    (\x3c 2 (count form))\n    (throw\n      (error env "Too many arguments to throw, throw expects a single Error instance")))\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw-form))]\n    {:env env :op :throw :form form\n     :exception throw-expr\n     :children [:exception]}))\n\n(defmethod parse \'try\n  [op env [_ \x26 body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (\x3d :expr %) :return %))\n        catch? (every-pred seq? #(\x3d (first %) \'catch))\n        default? (every-pred catch? #(\x3d (second %) :default))\n        finally? (every-pred seq? #(\x3d (first %) \'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form \x26 forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env "Invalid try form")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env "Unexpected form after finally"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (-\x3e (disallowing-recur (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n                      (assoc :body? true)))\n        e (when (or (seq cblocks) dblock) (gensym "e"))\n        default (if-let [[_ _ name \x26 cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name \x26 cb]]\n                        (when name (assert (not (namespace name)) "Can\'t qualify symbol in catch"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (disallowing-recur (analyze (assoc catchenv :locals locals) cblock)))\n        try (disallowing-recur (analyze (if (or e finally) catchenv env) `(do ~@body)))]\n\n    {:env env :op :try :form form\n     :body (assoc try :body? true)\n     :finally finally\n     :name e\n     :catch catch\n     :children (vec\n                 (concat [:body]\n                         (when catch\n                           [:catch])\n                         (when finally\n                           [:finally])))}))\n\n(defn valid-proto [x]\n  (when (symbol? x) x))\n\n(defn elide-env [env ast opts]\n  (dissoc ast :env))\n\n(defn replace-env-pass [new-env]\n  (fn [env ast opts]\n    (assoc ast :env new-env)))\n\n(defn ast-children [ast]\n  (mapcat (fn [c]\n            (let [g (get ast c)]\n              (cond\n                (vector? g) g\n                g [g])))\n          (:children ast)))\n\n(defn constant-value?\n  [{:keys [op] :as ast}]\n  (or (#{:quote :const} op)\n      (and (#{:map :set :vector} op)\n           (every? constant-value? (ast-children ast)))))\n\n(defn const-expr-\x3econstant-value [{:keys [op] :as e}]\n  (case op\n    :quote  (const-expr-\x3econstant-value (:expr e))\n    :const  (:val e)\n    :map    (zipmap (map const-expr-\x3econstant-value (:keys e))\n                    (map const-expr-\x3econstant-value (:vals e)))\n    :set    (into #{} (map const-expr-\x3econstant-value (:items e)))\n    :vector (into [] (map const-expr-\x3econstant-value (:items e)))))\n\n(defn- earmuffed? [sym]\n  (let [s (name sym)]\n    (and (\x3e (count s) 2)\n         (string/starts-with? s "*")\n         (string/ends-with? s "*"))))\n\n(defn- core-ns? [ns-sym]\n  (let [s (name ns-sym)]\n    (and (not\x3d \'cljs.user ns-sym)\n         (or (string/starts-with? s "cljs.")\n             (string/starts-with? s "clojure.")))))\n\n(defmethod parse \'def\n  [op env form _ _]\n  (when (\x3e (count form) 4)\n    (throw (error env "Too many arguments to def")))\n  (let [pfn (fn\n              ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)\n        const? (-\x3e sym meta :const)\n        sym-meta (meta sym)\n        tag (-\x3e sym meta :tag)\n        protocol (-\x3e sym meta :protocol valid-proto)\n        dynamic (-\x3e sym meta :dynamic)\n        ns-name (-\x3e env :ns :name)\n        locals (:locals env)\n        clash-ns (symbol (str ns-name "." sym))\n        sym-ns   (namespace sym)\n        sym      (cond\n                   (and sym-ns (not #?(:clj  (\x3d (symbol sym-ns) ns-name)\n                                       :cljs (symbol-identical? (symbol sym-ns) ns-name))))\n                   (throw (error env (str "Can\'t def ns-qualified name in namespace " sym-ns)))\n\n                   (some? sym-ns)\n                   (symbol (name sym))\n\n                   :else sym)]\n    (when (some? (get-in @env/*compiler* [::namespaces clash-ns]))\n      (warning :ns-var-clash env\n        {:ns (symbol (str ns-name "." sym))\n         :var (symbol (str ns-name) (str sym))}))\n    (when (some? (:const (resolve-var (dissoc env :locals) sym)))\n      (throw (error env "Can\'t redefine a constant")))\n    (when-some [doc (:doc args)]\n      (when-not (string? doc)\n        (throw (error env "Too many arguments to def"))))\n    (when (and (not dynamic)\n               (earmuffed? sym)\n               (not (core-ns? ns-name)))\n      (warning :non-dynamic-earmuffed-var env\n        {:var (str sym)}))\n    (when-some [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n      (when (and (not *allow-redef*)\n                 (not (:declared v))\n                 (not (:declared sym-meta))\n                 *file-defs*\n                 (get @*file-defs* sym))\n        (warning :redef-in-file env {:sym sym :line (:line v)}))\n      (when (and (:declared v)\n                 (:arglists v)\n                 (not\x3d (:arglists v) (:arglists sym-meta)))\n        (warning :declared-arglists-mismatch env {:ns-name  ns-name :sym sym\n                                                  :declared (second (:arglists v))\n                                                  :defined  (second (:arglists sym-meta))})))\n    (let [env (if (or (and (not\x3d ns-name \'cljs.core)\n                           (core-name? env sym))\n                      (some? (get-in @env/*compiler* [::namespaces ns-name :uses sym])))\n                (let [ev (resolve-existing-var (dissoc env :locals)\n                           ;; ::no-resolve true is to suppress "can\'t take value\n                           ;; of macro warning" when sym resolves to a macro\n                           (with-meta sym {::no-resolve true}))\n                      conj-to-set (fnil conj #{})]\n                  (when (public-name? (:ns ev) sym)\n                    (warning :redef env {:sym sym :ns (:ns ev) :ns-name ns-name}))\n                  (swap! env/*compiler* update-in [::namespaces ns-name :excludes]\n                     conj-to-set sym)\n                  (update-in env [:ns :excludes] conj-to-set sym))\n                env)\n          var-name (:name (resolve-var (dissoc env :locals) sym))\n          init-expr (when (contains? args :init)\n                      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n                        (merge\n                          {:name var-name}\n                          sym-meta\n                          (when (true? dynamic) {:dynamic true})\n                          (source-info var-name env)))\n                      (disallowing-recur\n                        (disallowing-ns*\n                          (analyze (assoc env :context :expr) (:init args) sym))))\n          fn-var? (and (some? init-expr) (\x3d (:op init-expr) :fn))\n          tag (if fn-var?\n                (or (:ret-tag init-expr) tag (:inferred-ret-tag init-expr))\n                (or tag (:tag init-expr)))\n          export-as (when-let [export-val (-\x3e sym meta :export)]\n                      (if (\x3d true export-val) var-name export-val))\n          doc (or (:doc args) (-\x3e sym meta :doc))]\n      (when-some [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n        (when (and (not (-\x3e sym meta :declared))\n                   (and (true? (:fn-var v)) (not fn-var?)))\n          (warning :fn-var env {:ns-name ns-name :sym sym})))\n\n      ;; declare must not replace any analyzer data of an already def\'d sym\n      (when (or (nil? (get-in @env/*compiler* [::namespaces ns-name :defs sym]))\n                (not (:declared sym-meta)))\n        (when *file-defs*\n          (swap! *file-defs* conj sym))\n\n        (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n          (merge\n            {:name var-name}\n            ;; remove actual test metadata, as it includes non-valid EDN and\n            ;; cannot be present in analysis cached to disk - David\n            (cond-\x3e sym-meta\n              (:test sym-meta) (assoc :test true))\n            {:meta (-\x3e sym-meta\n                       (dissoc :test)\n                       (update-in [:file]\n                         (fn [f]\n                           (if (\x3d (-\x3e env :ns :name) \'cljs.core)\n                             "cljs/core.cljs"\n                             f))))}\n            (when doc {:doc doc})\n            (when const?\n              (let [const-expr\n                    (binding [*passes* (conj *passes* (replace-env-pass {:context :expr}))]\n                      (analyze env (:init args)))]\n                (when (constant-value? const-expr)\n                  {:const-expr const-expr})))\n            (when (true? dynamic) {:dynamic true})\n            (source-info var-name env)\n            ;; the protocol a protocol fn belongs to\n            (when protocol\n              {:protocol protocol})\n            ;; symbol for reified protocol\n            (when-let [protocol-symbol (-\x3e sym meta :protocol-symbol)]\n              {:protocol-symbol protocol-symbol\n               :info (-\x3e protocol-symbol meta :protocol-info)\n               :impls #{}})\n            (when fn-var?\n              (let [params (map #(vec (map :name (:params %))) (:methods init-expr))]\n                (merge\n                  {:fn-var (not (:macro sym-meta))\n                   ;; protocol implementation context\n                   :protocol-impl (:protocol-impl init-expr)\n                   ;; inline protocol implementation context\n                   :protocol-inline (:protocol-inline init-expr)}\n                  (if-some [top-fn-meta (:top-fn sym-meta)]\n                    top-fn-meta\n                    {:variadic? (:variadic? init-expr)\n                     :max-fixed-arity (:max-fixed-arity init-expr)\n                     :method-params params\n                     :arglists (:arglists sym-meta)\n                     :arglists-meta (doall (map meta (:arglists sym-meta)))}))))\n            (when (and (:declared sym-meta)\n                       (:arglists sym-meta))\n              {:declared true\n               :fn-var true\n               :method-params (second (:arglists sym-meta))})\n            (if (and fn-var? (some? tag))\n              {:ret-tag tag}\n              (when tag {:tag tag})))))\n      (merge\n        {:env env\n         :op :def\n         :form form\n         :ns ns-name\n         :name var-name\n         :var (assoc\n                (analyze\n                  (-\x3e env (dissoc :locals)\n                    (assoc :context :expr)\n                    (assoc :def-var true))\n                  sym)\n                :op :var)\n         :doc doc\n         :jsdoc (:jsdoc sym-meta)}\n        (when (true? (:def-emits-var env))\n          {:var-ast (var-ast env sym)})\n        (when-some [test (:test sym-meta)]\n          {:test (analyze (assoc env :context :expr) test)})\n        (when (some? tag)\n          (if fn-var?\n            {:ret-tag tag}\n            {:tag tag}))\n        (when (true? dynamic) {:dynamic true})\n        (when (some? export-as) {:export export-as})\n        (if (some? init-expr)\n          {:init init-expr\n           :children [:var :init]}\n          {:children [:var]})))))\n\n(defn analyze-fn-method-param [env]\n  (fn [[locals params] [arg-id name]]\n    (when (namespace name)\n      (throw (error env (str "Can\'t use qualified name as parameter: " name))))\n    (let [line   (get-line name env)\n          column (get-col name env)\n          nmeta  (meta name)\n          tag    (:tag nmeta)\n          shadow (when (some? locals)\n                   (handle-symbol-local name (locals name)))\n          env    (merge (select-keys env [:context])\n                   {:line line :column column})\n          param  {:op :binding\n                  :name name\n                  :line line\n                  :column column\n                  :tag tag\n                  :shadow shadow\n                  :local :arg\n                  :arg-id arg-id\n                  ;; Give the fn params the same shape\n                  ;; as a :var, so it gets routed\n                  ;; correctly in the compiler\n                  :env env\n                  :info {:name name :shadow shadow}\n                  :binding-form? true}]\n     [(assoc locals name param) (conj params param)])))\n\n(defn analyze-fn-method-body [env form recur-frames]\n  (binding [*recur-frames* recur-frames]\n    (analyze env form)))\n\n(defn- analyze-fn-method [env locals form type analyze-body?]\n  (let [param-names     (first form)\n        variadic        (boolean (some \'#{\x26} param-names))\n        param-names     (vec (remove \'#{\x26} param-names))\n        body            (next form)\n        step            (analyze-fn-method-param env)\n        step-init       [locals []]\n        [locals params] (reduce step step-init (map-indexed vector param-names))\n        params\'         (if (true? variadic)\n                          (butlast params)\n                          params)\n        fixed-arity     (count params\')\n        recur-frame     {:protocol-impl (:protocol-impl env)\n                         :params        params\n                         :flag          (atom nil)\n                         :tags          (atom [])}\n        recur-frames    (cons recur-frame *recur-frames*)\n        body-env        (assoc env :context :return :locals locals)\n        body-form       `(do ~@body)\n        expr            (when analyze-body?\n                          (analyze-fn-method-body body-env body-form recur-frames))\n        recurs          @(:flag recur-frame)]\n    (merge\n      {:env env\n       :op :fn-method\n       :variadic? variadic\n       :params params\n       :fixed-arity fixed-arity\n       :type type\n       :form form\n       :recurs recurs}\n      (if (some? expr)\n        {:body (assoc expr :body? true)\n         :children [:params :body]}\n        {:children [:params]}))))\n\n(declare analyze-wrap-meta)\n\n(defn fn-name-var [env locals name]\n  (when (some? name)\n    (let [ns       (-\x3e env :ns :name)\n          shadow   (handle-symbol-local name (get locals name))\n          shadow   (when (nil? shadow)\n                     (get-in env [:js-globals name]))\n          fn-scope (:fn-scope env)\n          name-var {:name name\n                    :op :binding\n                    :local :fn\n                    :info {:fn-self-name true\n                           :fn-scope fn-scope\n                           :ns ns\n                           :shadow shadow}}\n          tag      (-\x3e name meta :tag)\n          ret-tag  (when (some? tag)\n                     {:ret-tag tag})]\n      (merge name-var ret-tag))))\n\n(defn analyze-fn-methods-pass2* [menv locals type meths]\n  (mapv #(analyze-fn-method menv locals % type true) meths))\n\n(defn analyze-fn-methods-pass2 [menv locals type meths]\n  (analyze-fn-methods-pass2* menv locals type meths))\n\n(defmethod parse \'fn*\n  [op env [_ \x26 args :as form] name _]\n  (let [named-fn?    (symbol? (first args))\n        [name meths] (if named-fn?\n                         [(first args) (next args)]\n                         [name (seq args)])\n        ;; turn (fn [] ...) into (fn ([]...))\n        meths        (if (vector? (first meths))\n                       (list meths)\n                       meths)\n        locals       (:locals env)\n        name-var     (fn-name-var env locals name)\n        env          (if (some? name)\n                       (update-in env [:fn-scope] conj name-var)\n                       env)\n        locals       (if (and (some? locals)\n                              named-fn?)\n                       (assoc locals name name-var)\n                       locals)\n        form-meta    (meta form)\n        type         (::type form-meta)\n        proto-impl   (::protocol-impl form-meta)\n        proto-inline (::protocol-inline form-meta)\n        menv         (if (\x3e (count meths) 1)\n                       (assoc env :context :expr)\n                       env)\n        menv         (merge menv\n                       {:protocol-impl proto-impl\n                        :protocol-inline proto-inline})\n        methods      (map #(disallowing-ns* (analyze-fn-method menv locals % type (nil? name))) meths)\n        mfa          (transduce (map :fixed-arity) max 0 methods)\n        variadic     (boolean (some :variadic? methods))\n        locals       (if named-fn?\n                       (update-in locals [name] assoc\n                         ;; TODO: can we simplify? - David\n                         :fn-var true\n                         :variadic? variadic\n                         :max-fixed-arity mfa\n                         :method-params (map :params methods))\n                       locals)\n        methods      (if (some? name)\n                       ;; a second pass with knowledge of our function-ness/arity\n                       ;; lets us optimize self calls\n                       (disallowing-ns* (analyze-fn-methods-pass2 menv locals type meths))\n                       (vec methods))\n        form         (vary-meta form dissoc ::protocol-impl ::protocol-inline ::type)\n        js-doc       (when (true? variadic)\n                       "@param {...*} var_args")\n        children     (if (some? name-var)\n                       [:local :methods]\n                       [:methods])\n        inferred-ret-tag (let [inferred-tags (map (partial infer-tag env) (map :body methods))]\n                           (when (apply \x3d inferred-tags)\n                             (first inferred-tags)))\n        ast   (merge {:op :fn\n                      :env env\n                      :form form\n                      :name name-var\n                      :methods methods\n                      :variadic? variadic\n                      :tag \'function\n                      :inferred-ret-tag inferred-ret-tag\n                      :recur-frames *recur-frames*\n                      :loop-lets *loop-lets*\n                      :jsdoc [js-doc]\n                      :max-fixed-arity mfa\n                      :protocol-impl proto-impl\n                      :protocol-inline proto-inline\n                      :children children}\n                     (when (some? name-var)\n                       {:local name-var}))]\n    (let [variadic-methods (into []\n                             (comp (filter :variadic?) (take 1))\n                             methods)\n          variadic-params  (if (pos? (count variadic-methods))\n                             (count (:params (nth variadic-methods 0)))\n                             0)\n          param-counts     (into [] (map (comp count :params)) methods)]\n      (when (\x3c 1 (count variadic-methods))\n        (warning :multiple-variadic-overloads env {:name name-var}))\n      (when (not (or (zero? variadic-params) (\x3d\x3d variadic-params (+ 1 mfa))))\n        (warning :variadic-max-arity env {:name name-var}))\n      (when (not\x3d (distinct param-counts) param-counts)\n        (warning :overload-arity env {:name name-var})))\n    (analyze-wrap-meta ast)))\n\n(defmethod parse \'letfn*\n  [op env [_ bindings \x26 exprs :as form] name _]\n  (when-not (and (vector? bindings) (even? (count bindings)))\n    (throw (error env "bindings must be vector of even number of elements")))\n  (let [n-\x3efexpr (into {} (map (juxt first second) (partition 2 bindings)))\n        names    (keys n-\x3efexpr)\n        context  (:context env)\n        ;; first pass to collect information for recursive references\n        [meth-env bes]\n        (reduce (fn [[{:keys [locals] :as env} bes] n]\n                  (let [ret-tag (-\x3e n meta :tag)\n                        fexpr (no-warn (analyze env (n-\x3efexpr n)))\n                        be (cond-\x3e\n                             {:name n\n                              :op :binding\n                              :fn-var true\n                              :line (get-line n env)\n                              :column (get-col n env)\n                              :local :letfn\n                              :shadow (handle-symbol-local n (locals n))\n                              :variadic? (:variadic? fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))}\n                             ret-tag (assoc :ret-tag ret-tag))]\n                    [(assoc-in env [:locals n] be)\n                     (conj bes be)]))\n                [env []] names)\n        meth-env (assoc meth-env :context :expr)\n        ;; the real pass\n        [meth-env bes]\n        (reduce (fn [[meth-env bes] {:keys [name shadow] :as be}]\n                  (let [env (assoc-in meth-env [:locals name] shadow)\n                        fexpr (analyze env (n-\x3efexpr name))\n                        be\' (assoc be\n                              :init fexpr\n                              :variadic? (:variadic? fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr)))]\n                    [(assoc-in env [:locals name] be\')\n                     (conj bes be\')]))\n          [meth-env []] bes)\n        expr (-\x3e (analyze (assoc meth-env :context (if (\x3d :expr context) :return context)) `(do ~@exprs))\n                 (assoc :body? true))]\n    {:env env :op :letfn :bindings bes :body expr :form form\n     :children [:bindings :body]}))\n\n(defn analyze-do-statements* [env exprs]\n  (mapv #(analyze (assoc env :context :statement) %) (butlast exprs)))\n\n(defn analyze-do-statements [env exprs]\n  (disallowing-recur (analyze-do-statements* env exprs)))\n\n(defmethod parse \'do\n  [op env [_ \x26 exprs :as form] _ _]\n  (let [statements (analyze-do-statements env exprs)]\n    (if (\x3c\x3d (count exprs) 1)\n      (let [ret      (analyze env (first exprs))\n            children [:statements :ret]]\n        {:op :do\n         :env env\n         :form form\n         :statements statements :ret ret\n         :children children})\n      (let [ret-env  (if (\x3d :statement (:context env))\n                       (assoc env :context :statement)\n                       (assoc env :context :return))\n            ret      (analyze ret-env (last exprs))\n            children [:statements :ret]]\n        {:op :do\n         :env env\n         :form form\n         :statements statements\n         :ret ret\n         :children children}))))\n\n(defn analyze-let-binding-init [env init loop-lets]\n  (binding [*loop-lets* loop-lets]\n    (analyze env init)))\n\n(defn get-let-tag [name init-expr]\n  (if-some [tag (-\x3e name meta :tag)]\n      tag\n        (if-some [tag (-\x3e init-expr :tag)]\n          tag\n          (-\x3e init-expr :info :tag))))\n\n(defn analyze-let-bindings* [encl-env bindings op]\n  (loop [bes []\n         env (assoc encl-env :context :expr)\n         bindings (seq (partition 2 bindings))]\n\n      (if-some [[name init] (first bindings)]\n        (let []\n          (when (or (some? (namespace name))\n                  #?(:clj  (.contains (str name) ".")\n                     :cljs ^boolean (goog.string/contains (str name) ".")))\n            (throw (error encl-env (str "Invalid local name: " name))))\n          (let [init-expr (analyze-let-binding-init env init (cons {:params bes} *loop-lets*))\n                line (get-line name env)\n                col (get-col name env)\n                shadow (handle-symbol-local name (get-in env [:locals name]))\n                be {:name name\n                    :line line\n                    :column col\n                    :init init-expr\n                    :tag (get-let-tag name init-expr)\n                    :local op\n                    :shadow shadow\n                    ;; Give let* bindings same shape as var so\n                    ;; they get routed correctly in the compiler\n                    :op :binding\n                    :env {:line line :column col}\n                    :info {:name name\n                           :shadow shadow}\n                    :binding-form? true}\n                be (if (\x3d :fn (:op init-expr))\n                     ;; TODO: can we simplify - David\n                     (merge be\n                       {:fn-var true\n                        ;; copy over the :fn-method information we need for invoke type inference\n                        :methods (into [] (map #(select-keys % [:tag :fixed-arity :variadic?]) (:methods init-expr)))\n                        :variadic? (:variadic? init-expr)\n                        :max-fixed-arity (:max-fixed-arity init-expr)\n                        :method-params (map :params (:methods init-expr))})\n                     be)\n                be (add-identity be)]\n            (recur (conj bes be)\n              (assoc-in env [:locals name] be)\n              (next bindings))))\n        [bes env])))\n\n(defn analyze-let-bindings [encl-env bindings op]\n  (disallowing-recur (analyze-let-bindings* encl-env bindings op)))\n\n(defn analyze-let-body* [env context exprs]\n  (analyze (assoc env :context (if (\x3d :expr context) :return context)) `(do ~@exprs)))\n\n(defn analyze-let-body [env context exprs recur-frames loop-lets]\n  (binding [*recur-frames* recur-frames\n            *loop-lets* loop-lets]\n    (analyze-let-body* env context exprs)))\n\n(defn analyze-let\n  [encl-env [_ bindings \x26 exprs :as form] is-loop widened-tags]\n  (when-not (and (vector? bindings) (even? (count bindings)))\n    (throw (error encl-env "bindings must be vector of even number of elements")))\n  (let [context      (:context encl-env)\n        op           (if (true? is-loop) :loop :let)\n        bindings     (if widened-tags\n                       (vec (mapcat\n                              (fn [[name init] widened-tag]\n                                [(vary-meta name assoc :tag widened-tag) init])\n                              (partition 2 bindings)\n                              widened-tags))\n                       bindings)\n        [bes env]    (analyze-let-bindings encl-env bindings op)\n        recur-frame  (when (true? is-loop)\n                       {:params bes\n                        :flag (atom nil)\n                        :tags (atom (mapv :tag bes))})\n        recur-frames (if recur-frame\n                       (cons recur-frame *recur-frames*)\n                       *recur-frames*)\n        loop-lets    (cond\n                       (true? is-loop) *loop-lets*\n                       (some? *loop-lets*) (cons {:params bes} *loop-lets*))\n        ;; Accumulate warnings for deferred replay iff there\'s a possibility of re-analyzing\n        warn-acc     (when (and is-loop\n                                (not widened-tags))\n                       (atom []))\n        expr         (if warn-acc\n                       (with-warning-handlers [(accumulating-warning-handler warn-acc)]\n                         (analyze-let-body env context exprs recur-frames loop-lets))\n                       (analyze-let-body env context exprs recur-frames loop-lets))\n        children     [:bindings :body]\n        nil-\x3eany     (fnil identity \'any)]\n    (if (and is-loop\n             (not widened-tags)\n             (not\x3d (mapv nil-\x3eany @(:tags recur-frame))\n                   (mapv (comp nil-\x3eany :tag) bes)))\n      (recur encl-env form is-loop @(:tags recur-frame))\n      (do\n        (when warn-acc\n          (replay-accumulated-warnings warn-acc))\n        {:op       op\n         :env      encl-env\n         :bindings bes\n         :body     (assoc expr :body? true)\n         :form     form\n         :children children}))))\n\n(defmethod parse \'let*\n  [op encl-env form _ _]\n  (analyze-let encl-env form false nil))\n\n(defmethod parse \'loop*\n  [op encl-env form _ _]\n  (analyze-let encl-env form true nil))\n\n(defmethod parse \'recur\n  [op env [_ \x26 exprs :as form] _ _]\n  (let [context (:context env)\n        frame (first *recur-frames*)\n        ;; Add dummy implicit target object if recuring to proto impl method head\n        add-implicit-target-object? (and (:protocol-impl frame)\n                                         (\x3d (count exprs) (dec (count (:params frame)))))\n        exprs (cond-\x3e\x3e exprs add-implicit-target-object? (cons nil))\n        exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs)))]\n    (when-not frame\n      (throw (error env "Can\'t recur here")))\n    (when-not (\x3d (count exprs) (count (:params frame)))\n      (throw (error env (str "recur argument count mismatch, expected: "\n                          (count (:params frame)) " args, got: " (count exprs)))))\n    (when (and (:protocol-impl frame)\n               (not add-implicit-target-object?))\n      (warning :protocol-impl-recur-with-target env {:form (:form (first exprs))}))\n    (reset! (:flag frame) true)\n    (swap! (:tags frame) (fn [tags]\n                           (mapv (fn [tag expr]\n                                   (add-types tag (:tag expr)))\n                             tags exprs)))\n    (assoc {:env env :op :recur :form form}\n      :frame frame\n      :exprs exprs\n      :children [:exprs])))\n\n(defn analyze-const\n  [env form]\n  (let [;; register constants\n        {:keys [tag]} (analyze (assoc env :quoted? true) form)]\n    {:op       :const\n     :env      env\n     :literal? true\n     :val      form\n     :tag      tag\n     :form     form}))\n\n(defmethod parse \'quote\n  [_ env [_ x :as form] _ _]\n  (when (not\x3d 2 (count form))\n    (throw (error env "Wrong number of args to quote")))\n  (let [expr (analyze-const env x)]\n    {:op :quote\n     :expr expr\n     :env env\n     :form form\n     :tag (:tag expr)\n     :children [:expr]}))\n\n(defmethod parse \'new\n  [_ env [_ ctor \x26 args :as form] _ _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         ctor-var (when (#{:var :local :js-var} (:op ctorexpr))\n                    (resolve-existing-var env ctor))\n         record-args\n         (when (and (:record ctor-var) (not (-\x3e ctor meta :internal-ctor)))\n           (repeat 3 (analyze enve nil)))\n         argexprs (into (vec (map #(analyze enve %) args)) record-args)\n         known-num-fields (:num-fields ctor-var)\n         argc (count args)]\n     (when (and (not (-\x3e ctor meta :internal-ctor))\n                (some? known-num-fields) (not\x3d known-num-fields argc))\n       (warning :fn-arity env {:argc argc :ctor ctor}))\n     {:env env :op :new :form form :class ctorexpr :args argexprs\n      :children [:class :args]\n      :tag (let [name (-\x3e ctorexpr :info :name)]\n             (or (\'{js/Object object\n                    js/String string\n                    js/Array  array\n                    js/Number number\n                    js/Function function\n                    js/Boolean boolean} name)\n                 name))})))\n\n(defmethod parse \'set!\n  [_ env [_ target val alt :as form] _ _]\n  (let [[target val] (if alt\n                       ;; (set! o -prop val)\n                       [`(. ~target ~val) alt]\n                       [target val])]\n    (disallowing-recur\n      (binding [*private-var-access-nowarn* true]\n        (let [enve  (assoc env :context :expr)\n              texpr (cond\n                      (symbol? target)\n                      (do\n                        (cond\n                          (and (\x3d target \'*unchecked-if*)   ;; TODO: proper resolve\n                               (or (true? val) (false? val)))\n                          (set! *unchecked-if* val)\n\n                          (and (\x3d target \'*unchecked-arrays*) ;; TODO: proper resolve\n                               (or (true? val) (false? val)))\n                          (set! *unchecked-arrays* val)\n\n                          (and (\x3d target \'*warn-on-infer*)\n                               (or (true? val) (false? val)))\n                          (set! *cljs-warnings* (assoc *cljs-warnings* :infer-warning val)))\n                        (when (some? (:const (resolve-var (dissoc env :locals) target)))\n                          (throw (error env "Can\'t set! a constant")))\n                        (let [local (handle-symbol-local target (-\x3e env :locals target))]\n                          (when-not (or (nil? local)\n                                        (and (:field local)\n                                             (or (:mutable local)\n                                                 (:unsynchronized-mutable local)\n                                                 (:volatile-mutable local))))\n                            (throw (error env "Can\'t set! local var or non-mutable field"))))\n                        (analyze-symbol enve target))\n\n                      :else\n                      (when (seq? target)\n                        (let [texpr (analyze-seq enve target nil)]\n                          (when (:field texpr)\n                            texpr))))\n              vexpr (analyze enve val)]\n          ;; as top level fns are decomposed for Closure cross-module code motion, we need to\n          ;; restore their :methods information\n          (when (seq? target)\n            (let [sym  (some-\x3e target second)\n                  meta (meta sym)]\n              (when-let [info (and (\x3d :fn (:op vexpr)) (:top-fn meta))]\n                (swap! env/*compiler* update-in\n                  [::namespaces (-\x3e env :ns :name) :defs sym :methods]\n                  (fnil conj [])\n                  ;; just use original fn meta, as the fn method is already desugared\n                  ;; only get tag from analysis\n                  (merge\n                    (select-keys info [:fixed-arity :variadic?])\n                    (select-keys (-\x3e vexpr :methods first) [:tag]))))))\n          (when-not texpr\n            (throw (error env "set! target must be a field or a symbol naming a var")))\n          (cond\n            (and (not (:def-emits-var env))                 ;; non-REPL context\n                 (some? (\'#{*unchecked-if* *unchecked-arrays* *warn-on-infer*} target)))\n            {:env env :op :no-op}\n\n            :else\n            {:env env :op :set! :form form :target texpr :val vexpr\n             :children [:target :val]}))))))\n\n#?(:clj (declare analyze-file))\n\n#?(:clj\n   (defn locate-src\n     "Given a namespace return the corresponding ClojureScript (.cljs or .cljc)\n     resource on the classpath or file from the root of the build."\n     [ns]\n     (or (util/ns-\x3esource ns)\n       ;; Find sources available in inputs given to cljs.closure/build - Juho Teperi\n       (some (fn [source]\n               (if (\x3d ns (:ns source))\n                 (:source-file source)))\n             (:sources @env/*compiler*))\n       ;; Find sources in directory given to cljs.compiler/compile-root - Juho Teperi\n       (let [rootp (when-let [root (:root @env/*compiler*)]\n                     (.getPath ^File root))\n             cljsf (io/file rootp (ns-\x3erelpath ns :cljs))\n             cljcf (io/file rootp (ns-\x3erelpath ns :cljc))]\n         (if (and (.exists cljsf) (.isFile cljsf))\n           cljsf\n           (if (and (.exists cljcf) (.isFile cljcf))\n             cljcf))))))\n\n(defn foreign-dep?\n  #?(:cljs {:tag boolean})\n  [dep]\n  (let [js-index (:js-dependency-index @env/*compiler*)]\n    (if-some [[_ {:keys [foreign]}] (find js-index (name dep))]\n      foreign\n      false)))\n\n(defn analyze-deps\n  "Given a lib, a namespace, deps, its dependencies, env, an analysis environment\n   and opts, compiler options - analyze all of the dependencies. Required to\n   correctly analyze usage of other namespaces."\n  ([lib deps env]\n   (analyze-deps lib deps env\n     (when env/*compiler*\n       (:options @env/*compiler*))))\n  ([lib deps env opts]\n   (let [compiler @env/*compiler*]\n     (binding [*cljs-dep-set* (vary-meta (conj *cljs-dep-set* lib) update-in [:dep-path] conj lib)]\n       (assert (every? #(not (contains? *cljs-dep-set* %)) deps)\n         (str "Circular dependency detected, "\n           (apply str\n             (interpose " -\x3e "\n               (conj (-\x3e *cljs-dep-set* meta :dep-path)\n                 (some *cljs-dep-set* deps))))))\n       (doseq [dep deps]\n         (when-not (or (some? (get-in compiler [::namespaces dep :defs]))\n                       (contains? (:js-dependency-index compiler) (name dep))\n                       (node-module-dep? dep)\n                       (js-module-exists? (name dep))\n                       #?(:clj (deps/find-classpath-lib dep)))\n           #?(:clj (if-some [src (locate-src dep)]\n                     (analyze-file src opts)\n                     (throw\n                       (error env\n                         (error-message :undeclared-ns {:ns-sym dep :js-provide (name dep)}))))\n              :cljs (throw\n                      (error env\n                        (error-message :undeclared-ns {:ns-sym dep :js-provide (name dep)}))))))))))\n\n(defn missing-use? [lib sym cenv]\n  (let [js-lib (get-in cenv [:js-dependency-index (name lib)])]\n    (and (\x3d (get-in cenv [::namespaces lib :defs sym] ::not-found) ::not-found)\n         (not (\x3d (get js-lib :group) :goog))\n         (not (get js-lib :closure-lib))\n         (not (node-module-dep? lib))\n         (not (dep-has-global-exports? lib)))))\n\n(defn missing-rename? [sym cenv]\n  (let [lib (symbol (namespace sym))\n        sym (symbol (name sym))]\n    (missing-use? lib sym cenv)))\n\n(defn missing-use-macro? [lib sym]\n  ;; guard against string requires\n  (when (symbol? lib)\n    (let [the-ns #?(:clj (find-ns lib) :cljs (find-macros-ns lib))]\n      (or (nil? the-ns) (nil? (.findInternedVar ^clojure.lang.Namespace the-ns sym))))))\n\n(defn missing-rename-macro? [sym]\n  (let [lib (symbol (namespace sym))\n        sym (symbol (name sym))\n        the-ns #?(:clj (find-ns lib) :cljs (find-macros-ns lib))]\n    (or (nil? the-ns) (nil? (.findInternedVar ^clojure.lang.Namespace the-ns sym)))))\n\n;; returns (s/map-of symbol? symbol?)\n(defn missing-uses\n  [uses env]\n  (let [cenv @env/*compiler*]\n    (into {} (filter (fn [[sym lib]] (missing-use? lib sym cenv)) uses))))\n\n;; returns (s/map-of symbol? qualified-symbol?)\n(defn missing-renames [renames env]\n  (let [cenv @env/*compiler*]\n    (into {} (filter (fn [[_ qualified-sym]] (missing-rename? qualified-sym cenv)) renames))))\n\n;; returns (s/map-of symbol? symbol?)\n(defn missing-use-macros [use-macros env]\n  (let [cenv @env/*compiler*]\n    (into {} (filter (fn [[sym lib]] (missing-use-macro? lib sym)) use-macros))))\n\n;; returns (s/map-of symbol? symbol?)\n(defn inferred-use-macros [use-macros env]\n  (let [cenv @env/*compiler*]\n    (into {} (filter (fn [[sym lib]] (not (missing-use-macro? lib sym))) use-macros))))\n\n;; returns (s/map-of symbol? symbol?)\n(defn inferred-rename-macros [rename-macros env]\n  (into {} (filter (fn [[_ qualified-sym]] (not (missing-rename-macro? qualified-sym))) rename-macros)))\n\n(defn check-uses [uses env]\n  (let [cenv @env/*compiler*]\n    (doseq [[sym lib] uses]\n      (when (missing-use? lib sym cenv)\n        (throw\n          (error env\n            (error-message :undeclared-ns-form {:type "var" :lib lib :sym sym})))))))\n\n(defn check-use-macros\n  ([use-macros env]\n    (check-use-macros use-macros nil env))\n  ([use-macros missing-uses env]\n   (let [cenv @env/*compiler*]\n     (doseq [[sym lib] use-macros]\n       (when (missing-use-macro? lib sym)\n         (throw\n           (error env\n             (error-message :undeclared-ns-form {:type "macro" :lib lib :sym sym})))))\n     (check-uses (missing-use-macros missing-uses env) env)\n     (inferred-use-macros missing-uses env))))\n\n(defn check-use-macros-inferring-missing\n  [{:keys [name uses use-macros] :as ast} env]\n  (let [missing-uses        (when (and *analyze-deps* (seq uses))\n                              (missing-uses uses env))\n        maybe-macros        (apply dissoc uses (keys missing-uses))\n        remove-missing-uses #(apply dissoc % (keys missing-uses))\n        ast\' (-\x3e ast\n               (update-in [:use-macros]\n                 #(-\x3e %\n                   (merge (check-use-macros use-macros missing-uses env))\n                   (merge (inferred-use-macros maybe-macros env))))\n               (update-in [:uses] remove-missing-uses))]\n    (swap! env/*compiler*\n      #(-\x3e %\n        (update-in [::namespaces name :use-macros] merge (:use-macros ast\'))\n        (update-in [::namespaces name :uses] remove-missing-uses)))\n    ast\'))\n\n(defn check-rename-macros-inferring-missing\n  [{:keys [name renames] :as ast} env]\n  (let [missing-renames        (when (and *analyze-deps* (seq renames))\n                                 (missing-renames renames env))\n        maybe-macros           (apply dissoc renames (keys missing-renames))\n        missing-rename-macros  (inferred-rename-macros missing-renames env)\n        remove-missing-renames #(apply dissoc % (keys missing-renames))\n        ast\' (-\x3e ast\n               (update-in [:rename-macros]\n                 #(-\x3e %\n                   (merge missing-rename-macros)\n                   (merge (inferred-rename-macros maybe-macros env))))\n               (update-in [:renames] remove-missing-renames))]\n    (swap! env/*compiler*\n      #(-\x3e %\n        (update-in [::namespaces name :rename-macros] merge (:rename-macros ast\'))\n        (update-in [::namespaces name :renames] remove-missing-renames)))\n    ast\'))\n\n(defn parse-ns-error-msg [spec msg]\n  (str msg "; offending spec: " (pr-str spec)))\n\n(defn basic-validate-ns-spec [env macros? spec]\n  (when-not (or (symbol? spec) (string? spec) (sequential? spec))\n    (throw\n      (error env\n        (parse-ns-error-msg spec\n          "Only [lib.ns \x26 options] and lib.ns specs supported in :require / :require-macros"))))\n  (when (sequential? spec)\n    (when-not (or (symbol? (first spec)) (string? (first spec)))\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            "Library name must be specified as a symbol in :require / :require-macros"))))\n    (when-not (odd? (count spec))\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            "Only :as alias, :refer (names) and :rename {from to} options supported in :require"))))\n    (when-not (every? #{:as :refer :rename} (map first (partition 2 (next spec))))\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            "Only :as, :refer and :rename options supported in :require / :require-macros"))))\n    (when-not (let [fs (frequencies (next spec))]\n                (and (\x3c\x3d (fs :as 0) 1)\n                     (\x3c\x3d (fs :refer 0) 1)))\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            "Each of :as and :refer options may only be specified once in :require / :require-macros"))))))\n\n(defn parse-ns-excludes [env args]\n  (reduce\n    (fn [s [k \x26 filters]]\n      (if (\x3d k :refer-clojure)\n        (do\n          (when (seq (:excludes s))\n            (throw (error env "Only one :refer-clojure form is allowed per namespace definition")))\n          (let [valid-kws #{:exclude :rename}\n                xs\n                (loop [fs (seq filters)\n                       ret {:excludes #{}\n                            :renames {}}\n                       err (not (even? (count filters)))]\n                  (cond\n                    (true? err)\n                    (throw\n                      (error env "Only [:refer-clojure :exclude (names)] and optionally `:rename {from to}` specs supported"))\n\n                    (some? fs)\n                    (let [kw (first fs)]\n                      (if (valid-kws kw)\n                        (let [refs (second fs)]\n                          (cond\n                            (not (or (and (\x3d kw :exclude) (sequential? refs) (every? symbol? refs))\n                                     (and (\x3d kw :rename) (map? refs) (every? #(every? symbol? %) refs))))\n                            (recur fs ret true)\n\n                            (\x3d kw :exclude)\n                            (recur (nnext fs) (update-in ret [:excludes] into refs) false)\n\n                            (\x3d kw :rename)\n                            (recur (nnext fs) (update-in ret [:renames] merge refs) false)))\n                        (recur fs ret true)))\n\n                    :else ret))]\n            (merge-with into s xs)))\n        s))\n    {:excludes #{}\n     :renames {}} args))\n\n(defn use-\x3erequire [env [lib \x26 filters :as spec]]\n  (when-not (and (symbol? lib) (odd? (count spec)))\n    (throw\n      (error env\n        (parse-ns-error-msg spec\n          "Only [lib.ns :only (names)] and optionally `:rename {from to}` specs supported in :use / :use-macros"))))\n  (loop [fs (seq filters) ret [lib] err false]\n    (cond\n      (true? err)\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            "Only [lib.ns :only (names)] and optionally `:rename {from to}` specs supported in :use / :use-macros")))\n\n      (some? fs)\n      (let [kw (first fs)\n            only? (\x3d kw :only)]\n        (if (or only? (\x3d kw :rename))\n          (if (some? (some #{(if only? :refer kw)} ret))\n            (throw\n              (error env\n                (parse-ns-error-msg spec\n                  "Each of :only and :rename options may only be specified once in :use / :use-macros")))\n            (let [refs (second fs)]\n              (if-not (or (and only? (sequential? refs) (every? symbol? refs))\n                          (and (\x3d kw :rename) (map? refs) (every? #(every? symbol? %) refs)))\n                (recur fs ret true)\n                (recur (nnext fs) (into ret [(if only? :refer kw) refs]) false))))\n          (recur fs ret true )))\n\n      :else (if (some? (some #{:refer} ret))\n              ret\n              (recur fs ret true)))))\n\n(defn parse-require-spec [env macros? deps aliases spec]\n  (if (or (symbol? spec) (string? spec))\n    (recur env macros? deps aliases [spec])\n    (do\n      (basic-validate-ns-spec env macros? spec)\n      (let [[lib \x26 opts] spec\n            ;; We need to load JS modules by the name that has been created by the\n            ;; Google Closure compiler, e.g. module$resources$libs$calculator.\n            ;; This means that we need to create an alias from the module name\n            ;; given with :provides to the new name.\n            [lib js-module-provides] (if-some [js-module-name (gets @env/*compiler* :js-module-index (str lib) :name)]\n                                       [(symbol js-module-name) lib]\n                                       [lib nil])\n            {alias :as referred :refer renamed :rename\n             :or {alias (if (string? lib)\n                          (symbol (munge lib))\n                          lib)}}\n            (apply hash-map opts)\n            referred-without-renamed (seq (remove (set (keys renamed)) referred))\n            [rk uk renk] (if macros? [:require-macros :use-macros :rename-macros] [:require :use :rename])]\n        (when-not (or (symbol? alias) (nil? alias))\n          (throw\n            (error env\n              (parse-ns-error-msg spec\n                ":as must be followed by a symbol in :require / :require-macros"))))\n        (when (some? alias)\n          (let [alias-type (if macros? :macros :fns)\n                lib\'       ((alias-type @aliases) alias)]\n            (when (and (some? lib\') (not\x3d lib lib\'))\n              (throw (error env (parse-ns-error-msg spec ":as alias must be unique"))))\n            (swap! aliases\n              update-in [alias-type]\n              conj [alias lib] (when js-module-provides [js-module-provides lib]))))\n        (when-not (or (and (sequential? referred)\n                           (every? symbol? referred))\n                      (nil? referred))\n          (throw\n            (error env\n              (parse-ns-error-msg spec\n                ":refer must be followed by a sequence of symbols in :require / :require-macros"))))\n        (when-not macros?\n          (swap! deps conj lib))\n        (merge\n          (when (some? alias)\n            {rk (merge {alias lib} {lib lib}\n                  (when js-module-provides {js-module-provides lib}))})\n          (when (some? referred-without-renamed)\n            {uk (apply hash-map (interleave referred-without-renamed (repeat lib)))})\n          (when (some? renamed)\n            {renk (reduce (fn [m [original renamed]]\n                            (when-not (some #{original} referred)\n                              (throw (error env\n                                       (str "Renamed symbol " original " not referred"))))\n                            (assoc m renamed (symbol (str lib) (str original))))\n                    {} renamed)}))))))\n\n(defn parse-import-spec [env deps spec]\n  (when-not (or (and (sequential? spec)\n                     (every? symbol? spec))\n                (and (symbol? spec) (nil? (namespace spec))))\n    (throw (error env (parse-ns-error-msg spec "Only lib.ns.Ctor or [lib.ns Ctor*] spec supported in :import"))))\n  (let [import-map (if (sequential? spec)\n                     (-\x3e\x3e (rest spec)\n                       (map #(vector % (symbol (str (first spec) "." %))))\n                       (into {}))\n                     {(symbol (last (string/split (str spec) #"\\."))) spec})]\n    (doseq [[_ spec] import-map]\n      (swap! deps conj spec))\n    {:import  import-map\n     :require import-map}))\n\n#?(:clj (declare parse-ns))\n\n(defn macro-autoload-ns?\n  "Given a spec form check whether the spec namespace requires a macro file\n   of the same name. If so return true."\n  #?(:cljs {:tag boolean})\n  [form]\n  (when *macro-infer*\n    (let [ns (if (sequential? form) (first form) form)\n         {:keys [use-macros require-macros]}\n         (or (get-in @env/*compiler* [::namespaces ns])\n             #?(:clj\n                (when-let [res (util/ns-\x3esource ns)]\n                  (:ast (parse-ns res)))))]\n      (or (some #{ns} (vals use-macros))\n          (some #{ns} (vals require-macros))))))\n\n(defn clj-ns-\x3ecljs-ns\n  "Given a symbol that starts with clojure as the first segment return the\n   same symbol with the first segment replaced with cljs"\n  [sym]\n  (let [segs (string/split (clojure.core/name sym) #"\\.")]\n    (if (\x3d "clojure" (first segs))\n      (symbol (string/join "." (cons "cljs" (next segs))))\n      sym)))\n\n#?(:clj\n   (defn aliasable-clj-ns?\n     "Predicate for testing with a symbol represents an aliasable clojure namespace."\n     [sym]\n     (when-not (util/ns-\x3esource sym)\n       (let [[seg1 :as segs] (string/split (clojure.core/name sym) #"\\.")]\n         (when (\x3d "clojure" seg1)\n           (let [sym\' (clj-ns-\x3ecljs-ns sym)]\n             (util/ns-\x3esource sym\')))))))\n\n#?(:clj\n   (defn process-rewrite-form [[k \x26 specs :as form]]\n     (letfn [(process-spec [maybe-spec]\n               (let [[lib \x26 xs] (if (sequential? maybe-spec)\n                                  maybe-spec\n                                  [maybe-spec])]\n                 (if (and (symbol? lib) (aliasable-clj-ns? lib))\n                   (let [lib\' (clj-ns-\x3ecljs-ns lib)\n                         spec (cons lib\' xs)]\n                     (into (if xs [spec] []) [(list lib\' :as lib)]))\n                   [maybe-spec])))]\n       (if (#{:use :require} k)\n         (cons k (mapcat process-spec specs))\n         form))))\n\n#?(:clj\n   (defn rewrite-cljs-aliases\n     "Alias non-existing clojure.* namespaces to existing cljs.* namespaces if\n      possible."\n     [args]\n     (map process-rewrite-form args)))\n\n(defn canonicalize-specs [specs]\n  (letfn [(canonicalize [quoted-spec-or-kw]\n            (if (keyword? quoted-spec-or-kw)\n              quoted-spec-or-kw\n              (as-\x3e (second quoted-spec-or-kw) spec\n                (if (or (vector? spec) (map? spec)) spec [spec]))))]\n    (map canonicalize specs)))\n\n(defn canonicalize-import-specs [specs]\n  (letfn [(canonicalize [quoted-spec-or-kw]\n            (if (keyword? quoted-spec-or-kw)\n              quoted-spec-or-kw\n              (second quoted-spec-or-kw)))]\n    (map canonicalize specs)))\n\n(defn desugar-ns-specs\n  "Given an original set of ns specs desugar :include-macros and :refer-macros\n   usage into only primitive spec forms - :use, :require, :use-macros,\n   :require-macros. If a library includes a macro file of with the same name\n   as the namespace will also be desugared."\n  [args]\n  (let [{:keys [require] :as indexed}\n        (-\x3e\x3e args\n          (map (fn [[k \x26 specs]] [k (into [] specs)]))\n          (into {}))\n        sugar-keys #{:include-macros :refer-macros}\n        ;; drop spec k and value from spec for generated :require-macros\n        remove-from-spec\n        (fn [pred spec]\n          (if-not (and (sequential? spec) (some pred spec))\n            spec\n            (let [[l r] (split-with (complement pred) spec)]\n              (recur pred (concat l (drop 2 r))))))\n        ;; rewrite :refer-macros to :refer for generated :require-macros\n        replace-refer-macros\n        (fn [spec]\n          (if-not (sequential? spec)\n            spec\n            (map (fn [x] (if (\x3d x :refer-macros) :refer x)) spec)))\n        reload-spec? #(#{:reload :reload-all} %)\n        to-macro-specs\n        (fn [specs]\n          (-\x3e\x3e specs\n            (filter\n              (fn [x]\n                (or (and (sequential? x)\n                         (some sugar-keys x))\n                    (reload-spec? x)\n                    (macro-autoload-ns? x))))\n            (map (fn [x]\n                   (if-not (reload-spec? x)\n                     (-\x3e\x3e x (remove-from-spec #{:include-macros})\n                            (remove-from-spec #{:refer})\n                            (remove-from-spec #{:rename})\n                            (replace-refer-macros))\n                     x)))))\n        remove-sugar (partial remove-from-spec sugar-keys)]\n    (if-some [require-specs (seq (to-macro-specs require))]\n      (map (fn [x]\n             (if-not (reload-spec? x)\n               (let [[k v] x]\n                 (cons k (map remove-sugar v)))\n               x))\n        (update-in indexed [:require-macros] (fnil into []) require-specs))\n      args)))\n\n(defn find-def-clash [env ns segments]\n  (let [to-check (map (fn [xs]\n                        [(symbol (string/join "." (butlast xs)))\n                         (symbol (last xs))])\n                   (drop 2 (reductions conj [] segments)))]\n    (doseq [[clash-ns name] to-check]\n      (when (get-in @env/*compiler* [::namespaces clash-ns :defs name])\n        (warning :ns-var-clash env\n          {:ns ns\n           :var (symbol (str clash-ns) (str name))})))))\n\n(defn macro-ns-name [name]\n  (let [name-str (str name)]\n    (if-not #?(:clj  (.endsWith name-str "$macros")\n               :cljs (gstring/endsWith name-str "$macros"))\n      (symbol (str name-str "$macros"))\n      name)))\n\n(defmethod parse \'ns\n  [_ env [_ name \x26 args :as form] _ opts]\n  (when-not *allow-ns*\n    (throw (error env "Namespace declarations must appear at the top-level.")))\n  (when-not (symbol? name)\n    (throw (error env "Namespaces must be named by a symbol.")))\n  (let [name (cond-\x3e name (:macros-ns opts) macro-ns-name)]\n    (let [segments (string/split (clojure.core/name name) #"\\.")]\n      (when (\x3d 1 (count segments))\n        (warning :single-segment-namespace env {:name name}))\n      (let [segment (some js-reserved segments)]\n        (when (some? segment)\n          (warning :munged-namespace env {:name name})))\n      (find-def-clash env name segments)\n      #?(:clj\n         (when (some (complement util/valid-js-id-start?) segments)\n           (throw\n             (AssertionError.\n               (str "Namespace " name " has a segment starting with an invaild "\n                    "JavaScript identifier"))))))\n    (let [docstring    (when (string? (first args)) (first args))\n          mdocstr      (-\x3e name meta :doc)\n          args         (if (some? docstring) (next args) args)\n          metadata     (when (map? (first args)) (first args))\n          args         (desugar-ns-specs\n                         #?(:clj  (rewrite-cljs-aliases\n                                    (if metadata (next args) args))\n                            :cljs (if (some? metadata) (next args) args)))\n          name         (vary-meta name merge metadata)\n          {excludes :excludes core-renames :renames} (parse-ns-excludes env args)\n          core-renames (reduce (fn [m [original renamed]]\n                                 (assoc m renamed (symbol "cljs.core" (str original))))\n                         {} core-renames)\n          deps         (atom [])\n          aliases      (atom {:fns {} :macros {}})\n          spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                        :require-macros (partial parse-require-spec env true deps aliases)\n                        :use            (comp (partial parse-require-spec env false deps aliases)\n                                          (partial use-\x3erequire env))\n                        :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                          (partial use-\x3erequire env))\n                        :import         (partial parse-import-spec env deps)}\n          valid-forms  (atom #{:use :use-macros :require :require-macros :import})\n          reload       (atom {:use nil :require nil :use-macros nil :require-macros nil})\n          reloads      (atom {})\n          {uses :use requires :require renames :rename\n           use-macros :use-macros require-macros :require-macros\n           rename-macros :rename-macros imports :import :as params}\n          (reduce\n            (fn [m [k \x26 libs :as libspec]]\n              (when-not (#{:use :use-macros :require :require-macros :import} k)\n                (throw (error env (str "Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported. Got " libspec " instead."))))\n              (when-not (@valid-forms k)\n                (throw (error env (str "Only one " k " form is allowed per namespace definition"))))\n              (swap! valid-forms disj k)\n              ;; check for spec type reloads\n              (when-not (\x3d :import k)\n                (when (some? (some #{:reload} libs))\n                  (swap! reload assoc k :reload))\n                (when (some? (some #{:reload-all} libs))\n                  (swap! reload assoc k :reload-all)))\n              ;; check for individual ns reloads from REPL interactions\n              (when-let [xs (seq (filter #(-\x3e % meta :reload) libs))]\n                (swap! reloads assoc k\n                  (zipmap (map first xs) (map #(-\x3e % meta :reload) xs))))\n              (apply merge-with merge m\n                (map (spec-parsers k)\n                  (remove #{:reload :reload-all} libs))))\n            {} (remove (fn [[r]] (\x3d r :refer-clojure)) args))\n          ;; patch `require-macros` and `use-macros` in Bootstrap for namespaces\n          ;; that require their own macros\n          #?@(:cljs [[require-macros use-macros]\n                     (map (fn [spec-map]\n                            (if (:macros-ns opts)\n                              (let [ns (symbol (subs (str name) 0 (- (count (str name)) 7)))]\n                                (reduce (fn [m [k v]]\n                                          (cond-\x3e m\n                                            (not (symbol-identical? v ns))\n                                            (assoc k v)))\n                                  {} spec-map))\n                              spec-map)) [require-macros use-macros])])]\n      (set! *cljs-ns* name)\n      (let [ns-info\n            {:name           name\n             :doc            (or docstring mdocstr)\n             :excludes       excludes\n             :use-macros     use-macros\n             :require-macros require-macros\n             :rename-macros  rename-macros\n             :uses           uses\n             :requires       requires\n             :renames        (merge renames core-renames)\n             :imports        imports}]\n        (swap! env/*compiler* update-in [::namespaces name] merge ns-info)\n        (merge {:op      :ns\n                :env     env\n                :form    form\n                :deps    (into [] (distinct @deps))\n                :reload  @reload\n                :reloads @reloads}\n          (cond-\x3e ns-info\n            (@reload :use)\n            (update-in [:uses]\n              (fn [m] (with-meta m {(@reload :use) true})))\n            (@reload :require)\n            (update-in [:requires]\n              (fn [m] (with-meta m {(@reload :require) true})))))))))\n\n(defn- check-duplicate-aliases\n  [env old new]\n  (let [ns-name (:name old)]\n    (doseq [k [:requires :require-macros]]\n      (let [old-aliases (get old k)\n            new-aliases (get new k)]\n        (when-some [alias (some (set (keys new-aliases))\n                            (-\x3e\x3e old-aliases\n                              (remove (fn [[k v :as entry]]\n                                        (or (\x3d k v)\n                                            (\x3d entry (find new-aliases k)))))\n                              keys))]\n          (throw (error env\n                   (str "Alias " alias " already exists in namespace " ns-name\n                     ", aliasing " (get old-aliases alias)))))))))\n\n(defmethod parse \'ns*\n  [_ env [_ quoted-specs :as form] _ opts]\n  (when-let [not-quoted (-\x3e\x3e (remove keyword? quoted-specs)\n                          (remove #(and (seq? %) (\x3d \'quote (first %))) )\n                          first)]\n    (throw (error env (str "Arguments to " (name (first quoted-specs))\n                        " must be quoted. Offending spec: " not-quoted))))\n  (when-not *allow-ns*\n    (throw (error env (str "Calls to `" (name (first quoted-specs))\n                        "` must appear at the top-level."))))\n  (let [specs        (if (\x3d :import (first quoted-specs))\n                       (canonicalize-import-specs quoted-specs)\n                       (canonicalize-specs quoted-specs))\n        name         (-\x3e env :ns :name)\n        args         (desugar-ns-specs\n                       #?(:clj  (list (process-rewrite-form\n                                        specs))\n                          :cljs (list specs)))\n        {excludes :excludes core-renames :renames} (parse-ns-excludes env args)\n        core-renames (reduce (fn [m [original renamed]]\n                               (assoc m renamed (symbol "cljs.core" (str original))))\n                       {} core-renames)\n        deps         (atom [])\n        aliases      (atom {:fns {} :macros {}})\n        spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                      :require-macros (partial parse-require-spec env true deps aliases)\n                      :use            (comp (partial parse-require-spec env false deps aliases)\n                                        (partial use-\x3erequire env))\n                      :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                        (partial use-\x3erequire env))\n                      :import         (partial parse-import-spec env deps)}\n        reload       (atom {:use nil :require nil :use-macros nil :require-macros nil})\n        reloads      (atom {})\n        {uses :use requires :require renames :rename\n         use-macros :use-macros require-macros :require-macros\n         rename-macros :rename-macros imports :import :as params}\n        (reduce\n          (fn [m [k \x26 libs]]\n            ;; check for spec type reloads\n            (when-not (\x3d :import k)\n              (when (some? (some #{:reload} libs))\n                (swap! reload assoc k :reload))\n              (when (some? (some #{:reload-all} libs))\n                (swap! reload assoc k :reload-all)))\n            ;; check for individual ns reloads from REPL interactions\n            (when-some [xs (seq (filter #(-\x3e % meta :reload) libs))]\n              (swap! reloads assoc k\n                (zipmap (map first xs) (map #(-\x3e % meta :reload) xs))))\n            (apply merge-with merge m\n              (map (spec-parsers k)\n                (remove #{:reload :reload-all} libs))))\n          {} (remove (fn [[r]] (\x3d r :refer-clojure)) args))]\n    (set! *cljs-ns* name)\n    (let [require-info\n          {:name           name\n           :excludes       excludes\n           :use-macros     use-macros\n           :require-macros require-macros\n           :rename-macros  rename-macros\n           :uses           uses\n           :requires       requires\n           :renames        (merge renames core-renames)\n           :imports        imports}\n          ns-info\n          (let [ns-info\' (get-in @env/*compiler* [::namespaces name])]\n            (if (pos? (count ns-info\'))\n              (let [merge-keys\n                    [:use-macros :require-macros :rename-macros\n                     :uses :requires :renames :imports]]\n                #?(:clj\n                   (when *check-alias-dupes*\n                     (check-duplicate-aliases env ns-info\' require-info)))\n                (merge\n                  ns-info\'\n                  {:excludes excludes}\n                  (merge-with merge\n                    (select-keys ns-info\' merge-keys)\n                    (select-keys require-info merge-keys))))\n              require-info))]\n      (swap! env/*compiler* update-in [::namespaces name] merge ns-info)\n      (merge {:op      :ns*\n              :env     env\n              :form    form\n              :deps    (into [] (distinct @deps))\n              :reload  @reload\n              :reloads @reloads}\n        (cond-\x3e require-info\n          (@reload :use)\n          (update-in [:uses]\n            (fn [m] (with-meta m {(@reload :use) true})))\n          (@reload :require)\n          (update-in [:requires]\n            (fn [m] (with-meta m {(@reload :require) true}))))))))\n\n(defn parse-type\n  [op env [_ tsym fields pmasks body :as form]]\n  (let [t (:name (resolve-var (dissoc env :locals) tsym))\n        locals (reduce (fn [m fld]\n                         (assoc m fld\n                                {:name fld\n                                 :line (get-line fld env)\n                                 :column (get-col fld env)\n                                 :local :field\n                                 :field true\n                                 :mutable (-\x3e fld meta :mutable)\n                                 :unsynchronized-mutable (-\x3e fld meta :unsynchronized-mutable)\n                                 :volatile-mutable (-\x3e fld meta :volatile-mutable)\n                                 :tag (-\x3e fld meta :tag)\n                                 :shadow (m fld)}))\n                       {} (if (\x3d :defrecord op)\n                            (concat fields \'[__meta __extmap ^:mutable __hash])\n                            fields))\n        protocols (-\x3e tsym meta :protocols)]\n    (swap! env/*compiler* update-in [::namespaces (-\x3e env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {})\n                       :name t\n                       :tag \'function\n                       :type true\n                       :num-fields (count fields)\n                       :record (\x3d :defrecord op))]\n               (merge m\n                      (dissoc (meta tsym) :protocols)\n                      {:protocols protocols}\n                      (source-info tsym env)))))\n    {:op op :env env :form form :t t :fields fields :pmasks pmasks\n     :tag \'function\n     :protocols (disj protocols \'cljs.core/Object)\n     :children [#_:fields :body]\n     :body (analyze (assoc env :locals locals) body)}))\n\n(defmethod parse \'deftype*\n  [_ env form _ _]\n  (parse-type :deftype env form))\n\n(defmethod parse \'defrecord*\n  [_ env form _ _]\n  (parse-type :defrecord env form) )\n\n;; dot accessor code\n\n(def ^:private property-symbol? #(boolean (and (symbol? %) (re-matches #"^-.*" (name %)))))\n\n(defn- classify-dot-form\n  [[target member args]]\n  [(cond (nil? target) ::error\n         :default      ::expr)\n   (cond (property-symbol? member) ::property\n         (symbol? member)          ::symbol\n         (seq? member)             ::list\n         :default                  ::error)\n   (cond (nil? args) ()\n         :default    ::expr)])\n\n(defmulti build-dot-form #(classify-dot-form %))\n\n;; (. o -p)\n;; (. (...) -p)\n(defmethod build-dot-form [::expr ::property ()]\n  [[target prop _]]\n  {:dot-action ::access :target target :field (-\x3e prop name (.substring 1) symbol)})\n\n;; (. o -p \x3cargs\x3e)\n(defmethod build-dot-form [::expr ::property ::list]\n  [[target prop args]]\n  #?(:clj  (throw (Error. (str "Cannot provide arguments " args " on property access " prop)))\n     :cljs (throw (js/Error. (str "Cannot provide arguments " args " on property access " prop)))))\n\n(defn- build-method-call\n  "Builds the intermediate method call map used to reason about the parsed form during\n  compilation."\n  [target meth args]\n  (if (symbol? meth)\n    {:dot-action ::call :target target :method meth :args args}\n    {:dot-action ::call :target target :method (first meth) :args args}))\n\n;; (. o m 1 2)\n(defmethod build-dot-form [::expr ::symbol ::expr]\n  [[target meth args]]\n  (build-method-call target meth args))\n\n;; (. o m)\n(defmethod build-dot-form [::expr ::symbol ()]\n  [[target meth args]]\n  (build-method-call target meth args))\n\n;; (. o (m))\n;; (. o (m 1 2))\n(defmethod build-dot-form [::expr ::list ()]\n  [[target meth-expr _]]\n  (build-method-call target (first meth-expr) (rest meth-expr)))\n\n(defmethod build-dot-form :default\n  [dot-form]\n  #?(:clj  (throw\n             (Error.\n               (str "Unknown dot form of "\n                 (list* \'. dot-form) " with classification "\n                 (classify-dot-form dot-form))))\n     :cljs (throw\n             (js/Error.\n               (str "Unknown dot form of "\n                 (list* \'. dot-form) " with classification "\n                 (classify-dot-form dot-form))))))\n\n(defn analyze-dot [env target field member+ form]\n  (let [v [target field member+]\n        {:keys [dot-action target method field args]} (build-dot-form v)\n        enve       (assoc env :context :expr)\n        targetexpr (analyze enve target)\n        form-meta  (meta form)\n        target-tag (:tag targetexpr)\n        prop       (or field method)\n        tag        (or (:tag form-meta)\n                       (and (js-tag? target-tag)\n                            (vary-meta (normalize-js-tag target-tag)\n                              update-in [:prefix] (fnil conj \'[Object]) prop))\n                       nil)]\n    (when (and (not\x3d \'constructor prop)\n               (not (string/starts-with? (str prop) "cljs$")))\n      ;; Adding to Object\n      (when (\x3d \'Object (first (-\x3e tag meta :prefix)))\n        (warning :infer-warning env\n          {:warn-type :object :form form :property prop}))\n      (when (not\x3d \'js target-tag)\n        ;; Cannot determine type of the target\n        (when (or (nil? target-tag) (\'#{any} target-tag))\n          (warning :infer-warning env\n            {:warn-type :target :form form}))\n        ;; Unresolveable property on existing extern\n        (let [[pre\' pre] ((juxt butlast identity) (-\x3e tag meta :prefix))]\n          (when (and (has-extern? pre\') (not (has-extern? pre)))\n            (warning :infer-warning env\n              {:warn-type :property :form form\n               :type (symbol "js"\n                       (string/join "."\n                         (cond-\x3e pre\' (\x3d \'prototype (last pre\')) butlast)))\n               :property prop})))))\n    (when (js-tag? tag)\n      (let [pre (-\x3e tag meta :prefix)]\n        (when-not (has-extern? pre)\n          (swap! env/*compiler* update-in\n            (into [::namespaces (-\x3e env :ns :name) :externs] pre) merge {}))))\n    (case dot-action\n      ::access (let [children [:target]]\n                 {:op :host-field\n                  :env env\n                  :form form\n                  :target targetexpr\n                  :field field\n                  :children children\n                  :tag (if (js-tag? tag)\n                         (or (js-tag (-\x3e tag meta :prefix) :tag) tag)\n                         tag)})\n      ::call   (let [argexprs (mapv #(analyze enve %) args)\n                     children [:target :args]]\n                 {:op :host-call\n                  :env env\n                  :form form\n                  :target targetexpr\n                  :method method\n                  :args argexprs\n                  :children children\n                  :tag (if (js-tag? tag)\n                         (or (js-tag (-\x3e tag meta :prefix) :ret-tag) \'js)\n                         tag)}))))\n\n(defmethod parse \'.\n  [_ env [_ target \x26 [field \x26 member+] :as form] _ _]\n  (disallowing-recur (analyze-dot env target field member+ form)))\n\n(defn get-js-tag [form]\n  (let [form-meta (meta form)]\n    (if-some [tag (:tag form-meta)]\n      tag\n      (when (true? (:numeric form-meta))\n        \'number))))\n\n(defn js-star-interp\n  [env ^String s]\n  (let [idx (.indexOf s "~{")]\n    (if (\x3d\x3d -1 idx)\n      (list s)\n      (let [end (.indexOf s "}" idx)\n            inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n        (lazy-seq\n          (cons (subs s 0 idx)\n            (cons inner\n              (js-star-interp env (subs s (inc end))))))))))\n\n(defn js-star-seg\n  [^String s]\n  (let [idx (.indexOf s "~{")]\n    (if (\x3d\x3d -1 idx)\n      (list s)\n      (let [end (.indexOf s "}" idx)]\n        (lazy-seq\n          (cons (subs s 0 idx)\n            (js-star-seg (subs s (inc end)))))))))\n\n(def NUMERIC_SET \'#{any number long double})\n\n(defn numeric-type?\n  #?(:cljs {:tag boolean})\n  [t]\n  ;; TODO: type inference is not strong enough to detect that\n  ;; when functions like first won\'t return nil, so variadic\n  ;; numeric functions like cljs.core/\x3c would produce a spurious\n  ;; warning without this - David\n  (cond\n    (nil? t) true\n    (\x3d \'clj-nil t) true\n    (js-tag? t) true ;; TODO: revisit\n    :else\n    (if (and (symbol? t) (some? (get NUMERIC_SET t)))\n      true\n      (when #?(:clj  (set? t)\n               :cljs (cljs-set? t))\n        (or (contains? t \'number)\n            (contains? t \'long)\n            (contains? t \'double)\n            (contains? t \'any)\n            (contains? t \'js))))))\n\n(def array-types\n  \'#{array objects ints longs floats doubles chars shorts bytes boolean})\n\n(defn array-type?\n  #?(:cljs {:tag boolean})\n  [t]\n  ;; TODO same inference caveats as the numeric-type? fn above\n  (cond\n    (nil? t) true\n    (\x3d \'clj-nil t) true\n    (js-tag? t) true ;; TODO: revisit\n    (\x3d \'any t) true\n    (contains? array-types t) true\n    :else\n    (boolean\n      (when #?(:clj  (set? t)\n               :cljs (cljs-set? t))\n        (or (contains? t \'any)\n            (contains? t \'js)\n            (some array-types t))))))\n\n(defn analyze-js-star* [env jsform args form]\n  (let [enve      (assoc env :context :expr)\n        argexprs  (vec (map #(analyze enve %) args))\n        form-meta (meta form)\n        segs      (js-star-seg jsform)\n        tag       (get-js-tag form)\n        js-op     (:js-op form-meta)\n        numeric   (:numeric form-meta)\n        validate  (fn [warning-type valid-types?]\n                    (let [types (map #(infer-tag env %) argexprs)]\n                      (when-not (valid-types? types)\n                        (warning warning-type env\n                          {:js-op js-op\n                           :types (into [] types)}))))\n        op-match? (fn [sym]\n                    #?(:clj  (\x3d sym (:js-op form-meta))\n                       :cljs (symbol-identical? sym (:js-op form-meta))))]\n    (when (true? numeric)\n      (validate :invalid-arithmetic #(every? numeric-type? %)))\n    {:op :js\n     :env env\n     :segs segs\n     :args argexprs\n     :tag tag\n     :form form\n     :children [:args]\n     :js-op js-op\n     :numeric numeric}))\n\n(defn analyze-js-star [env jsform args form]\n  (disallowing-recur (analyze-js-star* env jsform args form)))\n\n(defmethod parse \'js*\n  [op env [_ jsform \x26 args :as form] _ _]\n  (when-not (string? jsform)\n    (throw (error env "Invalid js* form")))\n  (if (some? args)\n    (analyze-js-star env jsform args form)\n    (let [code      (apply str (js-star-interp env jsform))\n          tag       (get-js-tag form)\n          form-meta (meta form)\n          js-op     (:js-op form-meta)\n          numeric   (:numeric form-meta)]\n      {:op :js\n       :env env\n       :form form\n       :code code\n       :tag tag\n       :js-op js-op\n       :numeric numeric})))\n\n;; TODO: analyzed analyzed? should take pass name as qualified keyword arg\n;; then compiler passes can mark/check individually - David\n\n(defn- unsorted-map? [x]\n  (and (map? x)\n       (not (sorted? x))))\n\n(defn analyzed\n  "Mark a form as being analyzed. Assumes x satisfies IMeta. Useful to suppress\n  warnings that will have been caught by a first compiler pass."\n  [x]\n  (cond\n    (unsorted-map? x) (assoc x ::analyzed true)\n    :else (vary-meta x assoc ::analyzed true)))\n\n(defn analyzed?\n  "Returns boolean if the form has already been marked as analyzed."\n  #?(:cljs {:tag boolean})\n  [x]\n  (boolean\n    (cond\n      (unsorted-map? x) (::analyzed x)\n      :else (::analyzed (meta x)))))\n\n(defn- all-values?\n  #?(:cljs {:tag boolean})\n  [exprs]\n  (every? #(or (nil? %) (symbol? %) (string? %) (number? %) (true? %) (false? %)) exprs))\n\n(defn- valid-arity?\n  #?(:cljs {:tag boolean})\n  [argc method-params]\n  (boolean (some #{argc} (map count method-params))))\n\n(defn parse-invoke*\n  [env [f \x26 args :as form]]\n  (let [enve    (assoc env :context :expr)\n        fexpr   (analyze enve f)\n        argc    (count args)\n        fn-var? (-\x3e fexpr :info :fn-var)\n        kw?     (\x3d \'cljs.core/Keyword (:tag fexpr))\n        cur-ns  (-\x3e env :ns :name)\n        HO-invoke? (and (boolean *cljs-static-fns*)\n                        (not fn-var?)\n                        (not (js-tag? f))\n                        (not kw?)\n                        (not (analyzed? f)))\n        ;; function expressions, eg: ((deref m) x) or ((:x m) :a)\n        bind-f-expr? (and HO-invoke?\n                          (not (symbol? f)))\n        ;; Higher order invokes with (some) argument expressions. Bind the arguments\n        ;; to avoid exponential complexity that is created by the IFn arity check branch.\n        bind-args? (and HO-invoke?\n                        (not (all-values? args)))]\n    (when ^boolean fn-var?\n      (let [{^boolean variadic :variadic? :keys [max-fixed-arity method-params name ns macro]} (:info fexpr)]\n        ;; don\'t warn about invalid arity when when compiling a macros namespace\n        ;; that requires itself, as that code is not meant to be executed in the\n        ;; `$macros` ns - António Monteiro\n        (when (and #?(:cljs (not (and (gstring/endsWith (str cur-ns) "$macros")\n                                      (symbol-identical? cur-ns ns)\n                                      (true? macro))))\n                   (not (valid-arity? argc method-params))\n                   (or (not variadic)\n                       (and variadic (\x3c argc max-fixed-arity))))\n          (warning :fn-arity env {:name name :argc argc}))))\n    (when (and kw? (not (or (\x3d\x3d 1 argc) (\x3d\x3d 2 argc))))\n      (warning :fn-arity env {:name (first form) :argc argc}))\n    (let [deprecated? (-\x3e fexpr :info :deprecated)\n          no-warn? (-\x3e form meta :deprecation-nowarn)]\n      (when (and (boolean deprecated?)\n                 (not (boolean no-warn?)))\n        (warning :fn-deprecated env {:fexpr fexpr})))\n    (when (some? (-\x3e fexpr :info :type))\n      (warning :invoke-ctor env {:fexpr fexpr}))\n    (if (or bind-args? bind-f-expr?)\n      (let [arg-syms (when bind-args? (take argc (repeatedly gensym)))\n            f-sym (when bind-f-expr? (gensym "fexpr__"))\n            bindings (cond-\x3e []\n                       bind-args? (into (interleave arg-syms args))\n                       bind-f-expr? (conj f-sym (analyzed f)))]\n        (analyze env\n          `(let [~@bindings]\n             (~(analyzed (if bind-f-expr? f-sym f))\n               ~@(if bind-args? arg-syms args)))))\n      (let [ana-expr #(analyze enve %)\n            argexprs (mapv ana-expr args)]\n        {:env env :op :invoke :form form :fn fexpr :args argexprs\n         :children [:fn :args]}))))\n\n(defn parse-invoke\n  [env form]\n  (disallowing-recur (parse-invoke* env form)))\n\n(defn desugar-dotted-expr [{:keys [op] :as expr}]\n  (case op\n    (:var :local) (if (dotted-symbol? (symbol (name (:name expr))))\n                    (let [s      (name (:name expr))\n                          idx    (.lastIndexOf s ".")\n                          _ (assert (not\x3d (inc idx) (count s)))\n                          prefix (with-meta (symbol (namespace (:name expr)) (subs s 0 idx))\n                                            (meta (:form expr)))\n                          field (symbol (subs s (inc idx)))]\n                      (assert (not (:const-expr expr)))\n                      {:op :host-field\n                       :env (:env expr)\n                       :form (list \'. prefix field)\n                       :target (desugar-dotted-expr (-\x3e expr\n                                                        (assoc :name prefix\n                                                               :form prefix)\n                                                        (dissoc :tag)\n                                                        (assoc-in [:info :name] prefix)\n                                                        (assoc-in [:env :context] :expr)))\n                       :field field\n                       :tag (:tag expr)\n                       :children [:target]})\n                    expr)\n    ;:var\n    expr))\n\n\n(defn analyze-symbol\n  "Finds the var associated with sym"\n  [env sym]\n  (if ^boolean (:quoted? env)\n    (do\n      (register-constant! env sym)\n      (analyze-wrap-meta {:op :const :val sym :env env :form sym :tag \'cljs.core/Symbol}))\n    (let [{:keys [line column]} (meta sym)\n          env  (if-not (nil? line)\n                 (assoc env :line line)\n                 env)\n          env  (if-not (nil? column)\n                 (assoc env :column column)\n                 env)\n          ret  {:env env :form sym}\n          lcls (:locals env)]\n      (if-some [lb (handle-symbol-local sym (get lcls sym))]\n        (merge\n          (assoc ret :op :local :info lb)\n          ;; this is a temporary workaround for core.async see CLJS-3030 - David\n          (when (map? lb)\n            (select-keys lb [:name :local :arg-id :variadic? :init])))\n        (let [sym-meta (meta sym)\n              sym-ns (namespace sym)\n              cur-ns (str (-\x3e env :ns :name))\n              ;; when compiling a macros namespace that requires itself, we need\n              ;; to resolve calls to `my-ns.core/foo` to `my-ns.core$macros/foo`\n              ;; to avoid undeclared variable warnings - António Monteiro\n              #?@(:cljs [sym (if (and sym-ns\n                                   (not\x3d sym-ns "cljs.core")\n                                   (gstring/endsWith cur-ns "$macros")\n                                   (not (gstring/endsWith sym-ns "$macros"))\n                                   (\x3d sym-ns (subs cur-ns 0 (- (count cur-ns) 7))))\n                               (symbol (str sym-ns "$macros") (name sym))\n                               sym)])\n              info     (if-not (contains? sym-meta ::analyzed)\n                         (resolve-existing-var env sym)\n                         (resolve-var env sym))]\n          (assert (:op info) (:op info))\n          (desugar-dotted-expr\n            (if-not (true? (:def-var env))\n              (merge\n                (assoc ret :info info)\n                (select-keys info [:op :name :ns :tag])\n                (when-let [const-expr (:const-expr info)]\n                  {:const-expr const-expr}))\n              (let [info (resolve-var env sym)]\n                (merge (assoc ret :op :var :info info)\n                       (select-keys info [:op :name :ns :tag]))))))))))\n\n(defn excluded?\n  #?(:cljs {:tag boolean})\n  [env sym]\n  (or (some? (gets env :ns :excludes sym))\n      (some? (gets @env/*compiler* ::namespaces (gets env :ns :name) :excludes sym))))\n\n(defn used?\n  #?(:cljs {:tag boolean})\n  [env sym]\n  (or (some? (gets env :ns :use-macros sym))\n      (some? (gets @env/*compiler* ::namespaces (gets env :ns :name) :use-macros sym))))\n\n(defn get-expander-ns [env ^String nstr]\n  ;; first check for clojure.* -\x3e cljs.* cases\n  (let [res  (or (resolve-macro-ns-alias env nstr nil)\n                 (resolve-ns-alias env nstr nil))\n        nstr (if (some? res) (str res) nstr)]\n    (cond\n     #?@(:clj  [(\x3d "clojure.core" nstr) (find-ns \'cljs.core)]\n         :cljs [(identical? "clojure.core" nstr) (find-macros-ns CLJS_CORE_MACROS_SYM)])\n     #?@(:clj  [(\x3d "clojure.repl" nstr) (find-ns \'cljs.repl)]\n         :cljs [(identical? "clojure.repl" nstr) (find-macros-ns \'cljs.repl)])\n     #?@(:clj  [(.contains nstr ".") (find-ns (symbol nstr))]\n         :cljs [(goog.string/contains nstr ".") (find-macros-ns (symbol nstr))])\n     :else (some-\x3e env :ns :require-macros (get (symbol nstr)) #?(:clj  find-ns\n                                                                  :cljs find-macros-ns)))))\n\n(defn get-expander* [sym env]\n  (when-not (or (some? (gets env :locals sym)) ; locals hide macros\n                (and (excluded? env sym) (not (used? env sym))))\n    (let [nstr (namespace sym)]\n      (cond\n        (some? nstr)\n        (let [ns (get-expander-ns env nstr)]\n          (when (some? ns)\n            (.findInternedVar ^clojure.lang.Namespace ns (symbol (name sym)))))\n\n        (some? (gets env :ns :rename-macros sym))\n        (let [qualified-symbol (gets env :ns :rename-macros sym)\n              nsym (symbol (namespace qualified-symbol))\n              sym  (symbol (name qualified-symbol))]\n          (.findInternedVar ^clojure.lang.Namespace\n            #?(:clj (find-ns nsym) :cljs (find-macros-ns nsym)) sym))\n\n        :else\n        (let [nsym (gets env :ns :use-macros sym)]\n          (if (and (some? nsym) (symbol? nsym))\n            (.findInternedVar ^clojure.lang.Namespace\n              #?(:clj (find-ns nsym) :cljs (find-macros-ns nsym)) sym)\n            (.findInternedVar ^clojure.lang.Namespace\n              #?(:clj (find-ns \'cljs.core) :cljs (find-macros-ns CLJS_CORE_MACROS_SYM)) sym)))))))\n\n(defn get-expander\n  "Given a sym, a symbol identifying a macro, and env, an analysis environment\n   return the corresponding Clojure macroexpander."\n  [sym env]\n  (let [mvar (get-expander* sym env)]\n    (when (and (some? mvar)\n            #?(:clj  (.isMacro ^clojure.lang.Var mvar)\n               :cljs ^boolean (.isMacro mvar)))\n      mvar)))\n\n#?(:cljs\n   (let [cached-var (delay (get (ns-interns* \'cljs.spec.alpha) \'macroexpand-check))]\n     (defn get-macroexpand-check-var []\n       (when (some? (find-ns-obj \'cljs.spec.alpha))\n         @cached-var))))\n\n(defn- var-\x3esym [var]\n  #?(:clj  (symbol (str (.-ns ^clojure.lang.Var var)) (str (.-sym ^clojure.lang.Var var)))\n     :cljs (.-sym var)))\n\n(defn- do-macroexpand-check\n  [env form mac-var]\n  (when (not (-\x3e @env/*compiler* :options :spec-skip-macros))\n    (let [mchk #?(:clj (some-\x3e (find-ns \'clojure.spec.alpha)\n                       (ns-resolve \'macroexpand-check))\n                :cljs (get-macroexpand-check-var))]\n    (when (some? mchk)\n      (try\n        (mchk mac-var (next form))\n        (catch #?(:clj Throwable :cljs :default) e\n          (throw (ex-info nil (error-data env :macro-syntax-check (var-\x3esym mac-var)) e))))))))\n\n(defn macroexpand-1*\n  [env form]\n  (let [op (first form)]\n    (if (contains? specials op)\n      (do\n        (when (\x3d \'ns op)\n          (do-macroexpand-check env form (get-expander \'cljs.core/ns-special-form env)))\n        form)\n      ;else\n        (if-some [mac-var (when (symbol? op) (get-expander op env))]\n          (#?@(:clj [binding [*ns* (create-ns *cljs-ns*)]]\n               :cljs [do])\n            (do-macroexpand-check env form mac-var)\n            (let [form\' (try\n                          (apply @mac-var form env (rest form))\n                          #?(:clj (catch ArityException e\n                                    (throw (ArityException. (- (.actual e) 2) (.name e)))))\n                          (catch #?(:clj Throwable :cljs :default) e\n                            (throw (ex-info nil (error-data env :macroexpansion (var-\x3esym mac-var)) e))))]\n              (if #?(:clj (seq? form\') :cljs (cljs-seq? form\'))\n                (let [sym\' (first form\')\n                      sym  (first form)]\n                  (if #?(:clj  (\x3d sym\' \'js*)\n                         :cljs (symbol-identical? sym\' JS_STAR_SYM))\n                    (let [sym   (if (some? (namespace sym))\n                                  sym\n                                  (symbol "cljs.core" (str sym)))\n                          js-op {:js-op sym}\n                          numeric #?(:clj  (-\x3e mac-var meta ::numeric)\n                                     :cljs (let [mac-var-ns   (symbol (namespace (.-sym mac-var)))\n                                                 mac-var-name (symbol (name (.-sym mac-var)))]\n                                             (get-in @env/*compiler*\n                                               [::namespaces mac-var-ns :defs mac-var-name :meta ::numeric])))\n                          js-op (if (true? numeric)\n                                  (assoc js-op :numeric true)\n                                  js-op)]\n                      (vary-meta form\' merge js-op))\n                    form\'))\n                form\')))\n          (if (symbol? op)\n            (let [opname (str op)]\n              (cond\n                (identical? \\.\n                  #?(:clj  (first opname)\n                     :cljs (.charAt opname 0)))\n                (let [[target \x26 args] (next form)]\n                  (with-meta (list* #?(:clj \'. :cljs DOT_SYM) target (symbol (subs opname 1)) args)\n                    (meta form)))\n\n                (identical? \\.\n                  #?(:clj  (last opname)\n                     :cljs (.charAt opname (dec (. opname -length)))))\n                (with-meta\n                  (list* #?(:clj \'new :cljs NEW_SYM) (symbol (subs opname 0 (dec (count opname)))) (next form))\n                  (meta form))\n\n                :else form))\n            form)))))\n\n(defn macroexpand-1\n  "Given a env, an analysis environment, and form, a ClojureScript form,\n   macroexpand the form once."\n  [env form]\n  (wrapping-errors env (macroexpand-1* env form)))\n\n(declare analyze-list)\n\n(defn analyze-seq* [op env form name opts]\n  (if (contains? specials op)\n    (parse op env form name opts)\n    (parse-invoke env form)))\n\n(defn analyze-seq*-wrap [op env form name opts]\n  (wrapping-errors env\n    (analyze-seq* op env form name opts)))\n\n(defn analyze-seq\n  ([env form name]\n   (analyze-seq env form name\n     (when env/*compiler*\n       (:options @env/*compiler*))))\n  ([env form name opts]\n   (if ^boolean (:quoted? env)\n     (analyze-list env form)\n     (let [line (-\x3e form meta :line)\n           line (if (nil? line)\n                  (:line env)\n                  line)\n           col  (-\x3e form meta :column)\n           col  (if (nil? col)\n                  (:column env)\n                  col)\n           env  (assoc env :line line :column col)]\n       (let [op (first form)]\n         (when (nil? op)\n           (throw (error env "Can\'t call nil")))\n         (let [mform (macroexpand-1 env form)]\n           (if (identical? form mform)\n             (analyze-seq*-wrap op env form name opts)\n             (analyze env mform name opts))))))))\n\n(defn analyze-map\n  [env form]\n  (let [expr-env (assoc env :context :expr)\n        ks (disallowing-recur (mapv #(analyze expr-env %) (keys form)))\n        vs (disallowing-recur (mapv #(analyze expr-env %) (vals form)))]\n    (analyze-wrap-meta {:op :map :env env :form form\n                        :keys ks :vals vs\n                        :children [:keys :vals]\n                        :tag \'cljs.core/IMap})))\n\n;; :list is not used in the emitter any more, but analyze-list is called from analyze-const\n;; to hit the `register-constant!` cases for symbols and keywords.\n(defn analyze-list\n  [env form]\n  (let [expr-env (assoc env :context :expr)\n        items (disallowing-recur (mapv #(analyze expr-env %) form))]\n    (analyze-wrap-meta {:op :list :env env :form form :items items :children [:items] :tag \'cljs.core/IList})))\n\n(defn analyze-vector\n  [env form]\n  (let [expr-env (assoc env :context :expr)\n        items (disallowing-recur (mapv #(analyze expr-env %) form))]\n    (analyze-wrap-meta {:op :vector :env env :form form :items items :children [:items] :tag \'cljs.core/IVector})))\n\n(defn analyze-set\n  [env form]\n  (let [expr-env (assoc env :context :expr)\n        items (disallowing-recur (mapv #(analyze expr-env %) form))]\n    (analyze-wrap-meta {:op :set :env env :form form :items items :children [:items] :tag \'cljs.core/ISet})))\n\n(defn analyze-js-value\n  [env ^JSValue form]\n  (let [val (.-val form)\n        expr-env (assoc env :context :expr)]\n    (if (map? val)\n      (let [keys (vec (keys val))\n            vals (disallowing-recur\n                   (mapv #(analyze expr-env %) (vals val)))]\n        {:op :js-object\n         :env env\n         :form form\n         :keys keys\n         :vals vals\n         :children [:vals]\n         :tag \'object})\n      (let [items (disallowing-recur\n                    (mapv #(analyze expr-env %) val))]\n        {:op :js-array\n         :env env\n         :form form\n         :items items\n         :children [:items]\n         :tag \'array}))))\n\n(defn record-ns+name [x]\n  (map symbol\n       #?(:clj\n          ((juxt (comp #(string/join "." %) butlast) last)\n           (string/split (.getName ^Class (type x)) #"\\."))\n          :cljs\n          (string/split (pr-str (type x)) #"/"))))\n\n(defn analyze-record\n  [env x]\n  (let [;; register constansts\n        _items_   (disallowing-recur\n                    (analyze (assoc env :context :expr) (into {} x)))\n        [ns name] (record-ns+name x)]\n    {:op :const\n     :val x\n     :env env\n     :form x\n     :tag (symbol (str ns) (str name))}))\n\n(defn elide-reader-meta [m]\n  (dissoc m :file :line :column :end-column :end-line :source))\n\n(defn elide-analyzer-meta [m]\n  (dissoc m ::analyzed))\n\n(defn elide-irrelevant-meta [m]\n  (-\x3e m elide-reader-meta elide-analyzer-meta))\n\n(defn analyze-wrap-meta [expr]\n  (let [form (:form expr)\n        m    (elide-irrelevant-meta (meta form))]\n    (if (some? (seq m))\n      (let [env (:env expr) ; take on expr\'s context ourselves\n            expr (assoc-in expr [:env :context] :expr) ; change expr to :expr\n            meta-expr (analyze-map (:env expr) m)]\n        {:op :with-meta :env env :form form\n         :meta meta-expr :expr expr :children [:meta :expr]})\n      expr)))\n\n(defn infer-type [env {:keys [tag] :as ast} _]\n  (if (or (nil? tag) (\x3d \'function tag))\n    ;; infer-type won\'t get a chance to process :methods\n    ;; so treat :fn as a special case for now, could probably\n    ;; fix up to use :children to walk child nodes\n    (if (\x3d :fn (:op ast))\n      (update ast :methods\n        (fn [ms] (into [] (map #(infer-type env % _)) ms)))\n      (if-some [tag (infer-tag env ast)]\n        (assoc ast :tag tag)\n        ast))\n    ast))\n\n(defn- repl-self-require? [env deps]\n  (and (:repl-env env) (some #{*cljs-ns*} deps)))\n\n#?(:clj\n   (defn ns-side-effects\n     [env {:keys [op] :as ast} opts]\n     (if (#{:ns :ns*} op)\n       (let [{:keys [name deps uses require-macros use-macros reload reloads]} ast]\n         (when (and *analyze-deps* (seq deps))\n           (analyze-deps\n             (if (repl-self-require? env deps) \'cljs.user name)\n             deps env (dissoc opts :macros-ns)))\n         (if *load-macros*\n           (do\n             (load-core)\n             (doseq [nsym (vals use-macros)]\n               (let [k (or (:use-macros reload)\n                         (get-in reloads [:use-macros nsym])\n                         (and (\x3d nsym name) *reload-macros* :reload))]\n                 (if k\n                   (locking load-mutex\n                     (clojure.core/require nsym k))\n                   (locking load-mutex\n                     (clojure.core/require nsym)))\n                 (intern-macros nsym k)))\n             (doseq [nsym (vals require-macros)]\n               (let [k (or (:require-macros reload)\n                         (get-in reloads [:require-macros nsym])\n                         (and (\x3d nsym name) *reload-macros* :reload))]\n                 (if k\n                   (locking load-mutex\n                     (clojure.core/require nsym k))\n                   (locking load-mutex\n                     (clojure.core/require nsym)))\n                 (intern-macros nsym k)))\n             (-\x3e ast\n               (check-use-macros-inferring-missing env)\n               (check-rename-macros-inferring-missing env)))\n           (do\n             (check-uses\n               (when (and *analyze-deps* (seq uses))\n                 (missing-uses uses env))\n               env)\n             ast)))\n       ast)))\n\n;; A set of validators that can be used to do static type\n;; checking of runtime fns based on inferred argument types.\n(def invoke-arg-type-validators\n  (let [aget-validator {:valid?       #(and (array-type? (first %))\n                                            (every? numeric-type? (rest %)))\n                        :warning-type :invalid-array-access}\n        aset-validator {:valid?       #(and (array-type? (first %))\n                                            (every? numeric-type? (butlast (rest %))))\n                        :warning-type :invalid-array-access}]\n    {\'cljs.core/checked-aget  aget-validator\n     \'cljs.core/checked-aset  aset-validator\n     \'cljs.core/checked-aget\' aget-validator\n     \'cljs.core/checked-aset\' aset-validator}))\n\n(defn check-invoke-arg-types\n  [env {:keys [op] :as ast} opts]\n  (when (and (not (analyzed? ast))\n             #?(:clj  (\x3d :invoke op)\n                :cljs (keyword-identical? :invoke op)))\n    (when-some [[name {:keys [valid? warning-type]}] (find invoke-arg-type-validators (-\x3e ast :fn :info :name))]\n      (let [types (mapv :tag (:args ast))]\n        (when-not (valid? types)\n          (warning warning-type env\n            {:name  name\n             :types types})))))\n  (analyzed ast))\n\n#?(:clj\n   (defn analyze-form [env form name opts]\n     (cond\n       (symbol? form) (analyze-symbol env form)\n       (and (seq? form) (seq form)) (analyze-seq env form name opts)\n       (record? form) (analyze-record env form)\n       (map? form) (analyze-map env form)\n       (vector? form) (analyze-vector env form)\n       (set? form) (analyze-set env form)\n       (keyword? form) (analyze-keyword env form)\n       (instance? JSValue form) (analyze-js-value env form)\n       :else\n       (let [tag (cond\n                   (nil? form) \'clj-nil\n                   (number? form) \'number\n                   (string? form) \'string\n                   (instance? Character form) \'string\n                   (true? form) \'boolean\n                   (false? form) \'boolean\n                   (\x3d () form) \'cljs.core/IList)]\n         (cond-\x3e {:op :const :val form :env env :form form}\n           tag (assoc :tag tag))))))\n\n#?(:cljs\n   (defn analyze-form [env form name opts]\n     (cond\n       (symbol? form) (analyze-symbol env form)\n       (and (cljs-seq? form) (some? (seq form))) (analyze-seq env form name opts)\n       (record? form) (analyze-record env form)\n       (cljs-map? form) (analyze-map env form)\n       (cljs-vector? form) (analyze-vector env form)\n       (cljs-set? form) (analyze-set env form)\n       (keyword? form) (analyze-keyword env form)\n       (instance? cljs.tagged-literals/JSValue form) (analyze-js-value env form)\n       :else\n       (let [tag (cond\n                   (nil? form) CLJ_NIL_SYM\n                   (number? form) NUMBER_SYM\n                   (string? form) STRING_SYM\n                   (true? form) BOOLEAN_SYM\n                   (false? form) BOOLEAN_SYM\n                   (\x3d () form) \'cljs.core/IList)]\n         (cond-\x3e {:op :const :val form :env env :form form}\n           tag (assoc :tag tag))))))\n\n(defn analyze* [env form name opts]\n  (let [passes *passes*\n        passes (if (nil? passes)\n                 #?(:clj  [infer-type check-invoke-arg-types ns-side-effects]\n                    :cljs [infer-type check-invoke-arg-types])\n                 passes)\n        form   (if (instance? LazySeq form)\n                 (if (seq form) form ())\n                 form)\n        ast    (analyze-form env form name opts)]\n    (reduce (fn [ast pass] (pass env ast opts)) ast passes)))\n\n(defn analyze\n  "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n  (one of :statement, :expr, :return), :ns (a symbol naming the\n  compilation ns)}, and form, returns an expression object (a map\n  containing at least :form, :op and :env keys). If expr has any (immediately)\n  nested exprs, must have a :children entry. This must be a vector of keywords naming\n  the immediately nested fields mapped to an expr or vector of exprs. This will\n  facilitate code walking without knowing the details of the op set."\n  ([env form] (analyze env form nil))\n  ([env form name]\n   (analyze env form name\n     (when env/*compiler*\n       (:options @env/*compiler*))))\n  ([env form name opts]\n   (wrapping-errors env\n     (if (analyzed? form)\n       (no-warn (analyze* env form name opts))\n       (analyze* env form name opts)))))\n\n(defn add-consts\n  "Given a compiler state and a map from fully qualified symbols to constant\n  EDN values, update the compiler state marking these vars as const to support\n  direct substitution of these vars in source."\n  [compiler-state constants-map]\n  (reduce-kv\n    (fn [compiler-state sym value]\n      (let [ns (symbol (namespace sym))]\n        (update-in compiler-state\n          [::namespaces ns :defs (symbol (name sym))] merge\n          {:const-expr\n           (binding [*passes* (conj *passes* (replace-env-pass {:context :expr}))]\n             (analyze (empty-env) value))})))\n    compiler-state constants-map))\n\n#?(:clj\n   (defn- source-path\n     "Returns a path suitable for providing to tools.reader as a \'filename\'."\n     [x]\n     (cond\n       (instance? File x) (.getAbsolutePath ^File x)\n       :default (str x))))\n\n(defn resolve-symbol [sym]\n  (if (and (not (namespace sym))\n           (dotted-symbol? sym))\n    sym\n    (:name (binding [*private-var-access-nowarn* true]\n             (resolve-var (assoc @env/*compiler* :ns (get-namespace *cljs-ns*))\n               sym)))))\n\n#?(:clj\n   (defn forms-seq*\n     "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\n     accepts a filename argument which will be used in any emitted errors."\n     ([^Reader rdr] (forms-seq* rdr nil))\n     ([^Reader rdr filename]\n      {:pre [(instance? Reader rdr)]}\n      (let [eof-sentinel (Object.)\n            opts (merge\n                   {:eof eof-sentinel}\n                   (if (and filename (\x3d (util/ext filename) "cljc"))\n                     {:read-cond :allow :features #{:cljs}}))\n            pbr (readers/indexing-push-back-reader\n                  (PushbackReader. rdr) 1 filename)\n            data-readers tags/*cljs-data-readers*\n            forms-seq_\n            (fn forms-seq_ []\n              (lazy-seq\n                (let [form (binding [*ns* (create-ns *cljs-ns*)\n                                     reader/*data-readers* data-readers\n                                     reader/*alias-map*\n                                     (apply merge\n                                       ((juxt :requires :require-macros)\n                                         (get-namespace *cljs-ns*)))\n                                     reader/resolve-symbol resolve-symbol]\n                             (reader/read opts pbr))]\n                  (if (identical? form eof-sentinel)\n                    (.close rdr)\n                    (cons form (forms-seq_))))))]\n        (forms-seq_)))))\n\n#?(:clj\n   (defn forms-seq\n     "DEPRECATED: Seq of Clojure/ClojureScript forms from [f], which can be anything\n     for which `clojure.java.io/reader` can produce a `java.io.Reader`. Optionally\n     accepts a [filename] argument, which the reader will use in any emitted errors."\n     ([f] (forms-seq f (source-path f)))\n     ([f filename] (forms-seq f filename false))\n     ([f filename return-reader?]\n      (let [rdr (io/reader f)\n            pbr (readers/indexing-push-back-reader\n                  (PushbackReader. rdr) 1 filename)\n            data-readers tags/*cljs-data-readers*\n            forms-seq*\n            (fn forms-seq* []\n              (lazy-seq\n                (let [eof-sentinel (Object.)\n                      form (binding [*ns* (create-ns *cljs-ns*)\n                                     reader/*data-readers* data-readers\n                                     reader/*alias-map*\n                                     (apply merge\n                                       ((juxt :requires :require-macros)\n                                         (get-namespace *cljs-ns*)))]\n                             (reader/read pbr nil eof-sentinel))]\n                  (if (identical? form eof-sentinel)\n                    (.close rdr)\n                    (cons form (forms-seq*))))))]\n        (if (true? return-reader?)\n          [(forms-seq*) rdr]\n          (forms-seq*))))))\n\n#?(:clj\n   (defn gen-user-ns\n     [src]\n     (if (sequential? src)\n       (symbol (str "cljs.user.source$form$" (util/content-sha (pr-str src) 7)))\n       (let [full-name (str src)\n             name (.substring full-name\n                    (inc (.lastIndexOf full-name "/"))\n                    (.lastIndexOf full-name "."))]\n         (symbol (str "cljs.user." name (util/content-sha full-name 7)))))))\n\n#?(:clj\n   (defn ^:dynamic parse-ns\n     "Helper for parsing only the essential namespace information from a\n      ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n      map _not_ a namespace AST node.\n\n      By default does not load macros or perform any analysis of dependencies. If\n      opts parameter provided :analyze-deps and :load-macros keys their values will\n      be used for *analyze-deps* and *load-macros* bindings respectively. This\n      function does _not_ side-effect the ambient compilation environment unless\n      requested via opts where :restore is false."\n     ([src]\n      (parse-ns src nil\n        (when env/*compiler*\n          (:options @env/*compiler*))))\n     ([src opts] (parse-ns src nil opts))\n     ([src dest opts]\n      (ensure\n        (let [src (if (symbol? src)\n                    (util/ns-\x3esource src)\n                    src)\n              ijs\n              (binding [env/*compiler* (if (false? (:restore opts))\n                                         env/*compiler*\n                                         (atom @env/*compiler*))\n                        *cljs-ns* \'cljs.user\n                        *cljs-file* src\n                        *macro-infer*\n                        (or (when (contains? opts :macro-infer)\n                              (:macro-infer opts))\n                          false)\n                        *analyze-deps*\n                        (or (when (contains? opts :analyze-deps)\n                              (:analyze-deps opts))\n                          false)\n                        *load-macros*\n                        (or (when (contains? opts :load-macros)\n                              (:load-macros opts))\n                          false)]\n                (let [rdr (when-not (sequential? src) (io/reader src))]\n                  (try\n                    (loop [forms (if rdr\n                                   (forms-seq* rdr (source-path src))\n                                   src)\n                           ret (merge\n                                 {:file         dest\n                                  :source-file  (when rdr src)\n                                  :source-forms (when-not rdr src)\n                                  :macros-ns    (:macros-ns opts)\n                                  :requires     (cond-\x3e #{\'cljs.core}\n                                                  (get-in @env/*compiler* [:options :emit-constants])\n                                                  (conj constants-ns-sym))}\n                                 (when (and dest (.exists ^File dest))\n                                   {:lines (with-open [reader (io/reader dest)]\n                                             (-\x3e reader line-seq count))}))]\n                      (if (seq forms)\n                        (let [env (empty-env)\n                              ast (no-warn (analyze env (first forms) nil opts))]\n                          (cond\n                            (\x3d :ns (:op ast))\n                            (let [ns-name (:name ast)\n                                  ns-name (if (and (\x3d \'cljs.core ns-name)\n                                                   (\x3d "cljc" (util/ext src)))\n                                            \'cljs.core$macros\n                                            ns-name)\n                                  deps (merge (:uses ast) (:requires ast))]\n                              (merge\n                                {:ns           (or ns-name \'cljs.user)\n                                 :provides     [ns-name]\n                                 :requires     (if (\x3d \'cljs.core ns-name)\n                                                 (set (vals deps))\n                                                 (cond-\x3e (conj (set (vals deps)) \'cljs.core)\n                                                   (get-in @env/*compiler* [:options :emit-constants])\n                                                   (conj constants-ns-sym)))\n                                 :file         dest\n                                 :source-file  (when rdr src)\n                                 :source-forms (when-not rdr src)\n                                 :ast          ast\n                                 :macros-ns    (or (:macros-ns opts)\n                                                   (\x3d \'cljs.core$macros ns-name))}\n                                (when (and dest (.exists ^File dest))\n                                  {:lines (with-open [reader (io/reader dest)]\n                                            (-\x3e reader line-seq count))})))\n\n                            (\x3d :ns* (:op ast))\n                            (let [deps (merge (:uses ast) (:requires ast))]\n                              (recur (rest forms)\n                                (cond-\x3e (update-in ret [:requires] into (set (vals deps)))\n                                  ;; we need to defer generating the user namespace\n                                  ;; until we actually need or it will break when\n                                  ;; `src` is a sequence of forms - António Monteiro\n                                  (not (:ns ret))\n                                  (assoc :ns (gen-user-ns src) :provides [(gen-user-ns src)]))))\n\n                            :else ret))\n                        ret))\n                    (finally\n                      (when rdr\n                        (.close ^Reader rdr))))))]\n          (cond-\x3e ijs\n            (not (contains? ijs :ns))\n            (merge\n              {:ns (gen-user-ns src)\n               :provides [(gen-user-ns src)]})))))))\n\n#?(:clj\n   (defn- cache-analysis-ext\n     ([] (cache-analysis-ext (get-in @env/*compiler* [:options :cache-analysis-format] :transit)))\n     ([format]\n      (if (and (\x3d format :transit) @transit) "json" "edn"))))\n\n#?(:clj\n   (defn build-affecting-options [opts]\n     (select-keys opts\n       [:static-fns :fn-invoke-direct :optimize-constants :elide-asserts :target\n        :cache-key :checked-arrays :language-out])))\n\n#?(:clj\n   (defn build-affecting-options-sha [path opts]\n     (let [m (assoc (build-affecting-options opts) :path path)]\n       (util/content-sha (pr-str m) 7))))\n\n#?(:clj\n   (defn ^File cache-base-path\n     ([path]\n      (cache-base-path path nil))\n     ([path opts]\n      (io/file (System/getProperty "user.home")\n        ".cljs" ".aot_cache" (util/clojurescript-version)\n        (build-affecting-options-sha path opts)))))\n\n#?(:clj\n   (defn cacheable-files\n     ([rsrc ext]\n      (cacheable-files rsrc ext nil))\n     ([rsrc ext opts]\n      (let [{:keys [ns]} (parse-ns rsrc)\n            path (cache-base-path (util/path rsrc) opts)\n            name (util/ns-\x3erelpath ns nil File/separatorChar)]\n        (into {}\n          (map\n            (fn [[k v]]\n              [k (io/file path\n                   (if (and (\x3d (str "cljs" File/separatorChar "core$macros") name)\n                         (\x3d :source k))\n                     (str "cljs" File/separatorChar "core.cljc")\n                     (str name v)))]))\n          {:source (str "." ext)\n           :output-file ".js"\n           :source-map ".js.map"\n           :analysis-cache-edn (str "." ext ".cache.edn")\n           :analysis-cache-json (str "." ext ".cache.json")})))))\n\n#?(:clj\n   (defn cache-file\n     "Given a ClojureScript source file returns the read/write path to the analysis\n      cache file. Defaults to the read path which is usually also the write path."\n     ([src] (cache-file src "out"))\n     ([src output-dir] (cache-file src (parse-ns src) output-dir))\n     ([src ns-info output-dir]\n      (cache-file src ns-info output-dir :read nil))\n     ([src ns-info output-dir mode]\n      (cache-file src ns-info output-dir mode nil))\n     ([src ns-info output-dir mode opts]\n      {:pre [(map? ns-info)]}\n      (let [ext (cache-analysis-ext)]\n        (if-let [core-cache\n                 (and (\x3d mode :read)\n                      (\x3d (:ns ns-info) \'cljs.core)\n                      (io/resource (str "cljs/core.cljs.cache.aot." ext)))]\n          core-cache\n          (let [aot-cache-file\n                (when (util/url? src)\n                  ((keyword (str "analysis-cache-" ext))\n                    (cacheable-files src (util/ext src) opts)))]\n            (if (and aot-cache-file (.exists ^File aot-cache-file))\n              aot-cache-file\n              (let [target-file (util/to-target-file output-dir ns-info\n                                  (util/ext (:source-file ns-info)))]\n                (io/file (str target-file ".cache." ext))))))))))\n\n#?(:clj\n   (defn requires-analysis?\n     "Given a src, a resource, and output-dir, a compilation output directory\n      return true or false depending on whether src needs to be (re-)analyzed.\n      Can optionally pass cache, the analysis cache file."\n     ([src] (requires-analysis? src "out"))\n     ([src output-dir]\n      (let [cache (cache-file src output-dir)]\n        (requires-analysis? src cache output-dir nil)))\n     ([src cache output-dir]\n      (requires-analysis? src cache output-dir nil))\n     ([src cache output-dir opts]\n      (cond\n        (util/url? cache)\n        (let [path (.getPath ^URL cache)]\n          (if (or (.endsWith path "cljs/core.cljs.cache.aot.edn")\n                  (.endsWith path "cljs/core.cljs.cache.aot.json"))\n            false\n            (throw (Exception. (str "Invalid anlaysis cache, must be file not URL " cache)))))\n\n        (and (util/file? cache)\n             (not (.exists ^File cache)))\n        true\n\n        :else\n        (let [out-src   (util/to-target-file output-dir (parse-ns src))\n              cache-src (:output-file (cacheable-files src (util/ext src) opts))]\n          (if (and (not (.exists out-src))\n                   (not (.exists ^File cache-src)))\n            true\n            (or (not cache) (util/changed? src cache))))))))\n\n#?(:clj\n   (defn- get-spec-vars\n     []\n     (when-let [spec-ns (find-ns \'cljs.spec.alpha)]\n       (locking load-mutex\n         {:registry-ref (ns-resolve spec-ns \'registry-ref)\n          :speced-vars  (ns-resolve spec-ns \'_speced_vars)})))\n   :cljs\n   (let [registry-ref (delay (get (ns-interns* \'cljs.spec.alpha$macros) \'registry-ref))\n         ;; Here, we look up the symbol \'-speced-vars because ns-interns*\n         ;; is implemented by invoking demunge on the result of js-keys.\n         speced-vars  (delay (get (ns-interns* \'cljs.spec.alpha$macros) \'-speced-vars))]\n     (defn- get-spec-vars []\n       (when (some? (find-ns-obj \'cljs.spec.alpha$macros))\n         {:registry-ref @registry-ref\n          :speced-vars  @speced-vars}))))\n\n(defn dump-specs\n  "Dumps registered speced vars for a given namespace into the compiler\n  environment."\n  [ns]\n  (let [spec-vars (get-spec-vars)\n        ns-str    (str ns)]\n    (swap! env/*compiler* update-in [::namespaces ns]\n      merge\n      (when-let [registry-ref (:registry-ref spec-vars)]\n        {:cljs.spec/registry-ref\n         (into []\n           (filter (fn [[k _]] (\x3d ns-str (namespace k))))\n           @@registry-ref)})\n      (when-let [speced-vars (:speced-vars spec-vars)]\n        {:cljs.spec/speced-vars\n         (into []\n           (filter\n             (fn [v]\n               (or (\x3d ns-str (namespace v))\n                   (\x3d ns (-\x3e v meta :fdef-ns)))))\n           @@speced-vars)}))))\n\n(defn register-specs\n  "Registers speced vars found in a namespace analysis cache."\n  [cached-ns]\n  #?(:clj (try\n            (locking load-mutex\n              (clojure.core/require \'cljs.spec.alpha))\n            (catch Throwable t)))\n  (let [{:keys [registry-ref speced-vars]} (get-spec-vars)]\n    (when-let [registry (seq (:cljs.spec/registry-ref cached-ns))]\n      (when registry-ref\n        (swap! @registry-ref into registry)))\n    (when-let [vars (seq (:cljs.spec/speced-vars cached-ns))]\n      (when speced-vars\n        (swap! @speced-vars into vars)))))\n\n#?(:clj\n   (defn write-analysis-cache\n     ([ns cache-file]\n       (write-analysis-cache ns cache-file nil))\n     ([ns ^File cache-file src]\n      (util/mkdirs cache-file)\n      (dump-specs ns)\n      (let [ext (util/ext cache-file)\n            analysis (dissoc (get-in @env/*compiler* [::namespaces ns]) :macros)]\n        (case ext\n          "edn"  (spit cache-file\n                   (str ";; Analyzed by ClojureScript " (util/clojurescript-version) "\\n"\n                     (pr-str analysis)))\n          "json" (when-let [{:keys [writer write]} @transit]\n                   (write\n                     (writer (FileOutputStream. cache-file) :json\n                       transit-write-opts)\n                     analysis))))\n      (when src\n        (.setLastModified ^File cache-file (util/last-modified src))))))\n\n#?(:clj\n   (defn read-analysis-cache\n     ([cache-file src]\n      (read-analysis-cache cache-file src nil))\n     ([^File cache-file src opts]\n       ;; we want want to keep dependency analysis information\n       ;; don\'t revert the environment - David\n      (let [{:keys [ns]} (parse-ns src\n                           (merge opts\n                             {:restore false\n                              :analyze-deps true\n                              :load-macros true}))\n            ext          (util/ext cache-file)\n            cached-ns    (case ext\n                           "edn"  (edn/read-string (slurp cache-file))\n                           "json" (let [{:keys [reader read]} @transit]\n                                    (with-open [is (io/input-stream cache-file)]\n                                      (read (reader is :json transit-read-opts)))))]\n        (when (or *verbose* (:verbose opts))\n          (util/debug-prn "Reading analysis cache for" (str src)))\n        (swap! env/*compiler*\n          (fn [cenv]\n            (do\n              (register-specs cached-ns)\n              (doseq [x (get-in cached-ns [::constants :order])]\n                (register-constant! x))\n              (-\x3e cenv\n                (assoc-in [::namespaces ns] cached-ns)))))))))\n\n(defn analyze-form-seq\n  ([forms]\n   (analyze-form-seq forms\n     (when env/*compiler*\n       (:options @env/*compiler*))))\n  ([forms opts]\n   (analyze-form-seq forms opts false))\n  ([forms opts return-last?]\n   (let [env (assoc (empty-env) :build-options opts)]\n     (binding [*file-defs* nil\n               #?@(:clj [*unchecked-if* false\n                         *unchecked-arrays* false])\n               *cljs-ns* \'cljs.user\n               *cljs-file* nil\n               reader/*alias-map* (or reader/*alias-map* {})]\n       (loop [ns nil forms forms last-ast nil]\n         (if (some? forms)\n           (let [form (first forms)\n                 env  (assoc env :ns (get-namespace *cljs-ns*))\n                 ast  (analyze env form nil opts)]\n             (if (\x3d (:op ast) :ns)\n               (recur (:name ast) (next forms) ast)\n               (recur ns (next forms) ast)))\n           (if return-last?\n             last-ast\n             ns)))))))\n\n(defn ensure-defs\n  "Ensures that a non-nil defs map exists in the compiler state for a given\n  ns. (A non-nil defs map signifies that the namespace has been analyzed.)"\n  [ns]\n  (swap! env/*compiler* update-in [::namespaces ns :defs] #(or % {})))\n\n#?(:clj\n   (defn analyze-file\n     "Given a java.io.File, java.net.URL or a string identifying a resource on the\n      classpath attempt to analyze it.\n\n      This function side-effects the ambient compilation environment\n      `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n      compiler options, if :cache-analysis true will cache analysis to\n      \\":output-dir/some/ns/foo.cljs.cache.edn\\". This function does not return a\n      meaningful value."\n     ([f]\n      (analyze-file f\n        (when env/*compiler*\n          (:options @env/*compiler*))))\n     ([f opts]\n      (analyze-file f false opts))\n     ([f skip-cache opts]\n      (binding [*file-defs*        (atom #{})\n                *unchecked-if*     false\n                *unchecked-arrays* false\n                *cljs-warnings*    *cljs-warnings*]\n        (let [output-dir (util/output-directory opts)\n              res        (cond\n                           (instance? File f) f\n                           (instance? URL f) f\n                           (re-find #"^file://" f) (URL. f)\n                           :else (io/resource f))]\n          (assert res (str "Can\'t find " f " in classpath"))\n          (ensure\n            (let [ns-info (parse-ns res)\n                  path    (if (instance? File res)\n                            (.getPath ^File res)\n                            (.getPath ^URL res))\n                  cache   (when (:cache-analysis opts)\n                            (cache-file res ns-info output-dir :read opts))]\n              (when-not (get-in @env/*compiler* [::namespaces (:ns ns-info) :defs])\n                (if (or skip-cache (not cache) (requires-analysis? res cache output-dir opts))\n                  (binding [*cljs-ns* \'cljs.user\n                            *cljs-file* path\n                            reader/*alias-map* (or reader/*alias-map* {})]\n                    (when (or *verbose* (:verbose opts))\n                      (util/debug-prn "Analyzing" (str res)))\n                    (let [env (assoc (empty-env) :build-options opts)\n                          ns  (with-open [rdr (io/reader res)]\n                                (loop [ns nil forms (seq (forms-seq* rdr (util/path res)))]\n                                  (if forms\n                                    (let [form (first forms)\n                                          env (assoc env :ns (get-namespace *cljs-ns*))\n                                          ast (analyze env form nil opts)]\n                                      (cond\n                                        (\x3d (:op ast) :ns)\n                                        (recur (:name ast) (next forms))\n\n                                        (and (nil? ns) (\x3d (:op ast) :ns*))\n                                        (recur (gen-user-ns res) (next forms))\n\n                                        :else\n                                        (recur ns (next forms))))\n                                    ns)))]\n                      (ensure-defs ns)\n                      (when (and cache (true? (:cache-analysis opts)))\n                        (write-analysis-cache ns cache res))))\n                  (try\n                    (read-analysis-cache cache res opts)\n                    (catch Throwable e\n                      (analyze-file f true opts))))))))))))\n'],
null),new p(null,3,[Cl,"cljs/spec/alpha.cljs",Xn,"cljs.spec.alpha",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.alpha\n  (:refer-clojure :exclude [+ * and or cat def keys merge])\n  (:require-macros [cljs.core :as c]\n                   [cljs.spec.alpha :as s])\n  (:require [goog.object :as gobj]\n            [cljs.core :as c]\n            [clojure.walk :as walk]\n            [cljs.spec.gen.alpha :as gen]\n            [clojure.string :as str]))\n\n(def ^:const MAX_INT 9007199254740991)\n\n(def ^:dynamic *recursion-limit*\n  "A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\n  can be recursed through during generation. After this a\n  non-recursive branch will be chosen."\n  4)\n\n(def ^:dynamic *fspec-iterations*\n  "The number of times an anonymous fn specified by fspec will be (generatively) tested during conform"\n  21)\n\n(def ^:dynamic *coll-check-limit*\n  "The number of items validated in a collection spec\'ed with \'every\'"\n  101)\n\n(def ^:dynamic *coll-error-limit*\n  "The number of errors reported by explain in a collection spec\'ed with \'every\'"\n  20)\n\n(defprotocol Spec\n  (conform* [spec x])\n  (unform* [spec y])\n  (explain* [spec path via in x])\n  (gen* [spec overrides path rmap])\n  (with-gen* [spec gfn])\n  (describe* [spec]))\n\n(defonce ^:private registry-ref (atom {}))\n\n(defn- deep-resolve [reg k]\n  (loop [spec k]\n    (if (ident? spec)\n      (recur (get reg spec))\n      spec)))\n\n(defn- reg-resolve\n  "returns the spec/regex at end of alias chain starting with k, nil if not found, k if k not ident"\n  [k]\n  (if (ident? k)\n    (let [reg @registry-ref\n          spec (get reg k)]\n      (if-not (ident? spec)\n        spec\n        (deep-resolve reg spec)))\n    k))\n\n(defn- reg-resolve!\n  "returns the spec/regex at end of alias chain starting with k, throws if not found, k if k not ident"\n  [k]\n  (if (ident? k)\n    (c/or (reg-resolve k)\n          (throw (js/Error. (str "Unable to resolve spec: " k))))\n    k))\n\n(defn spec?\n  "returns x if x is a spec object, else logical false"\n  [x]\n  (when (implements? Spec x)\n    x))\n\n(defn regex?\n  "returns x if x is a (cljs.spec.alpha) regex op, else logical false"\n  [x]\n  (c/and (::op x) x))\n\n(defn- with-name [spec name]\n  (cond\n   (ident? spec) spec\n   (regex? spec) (assoc spec ::name name)\n\n   (implements? IMeta spec)\n   (with-meta spec (assoc (meta spec) ::name name))))\n\n(defn- spec-name [spec]\n  (cond\n   (ident? spec) spec\n\n   (regex? spec) (::name spec)\n\n   (implements? IMeta spec)\n   (-\x3e (meta spec) ::name)))\n\n(declare ^{:arglists \'([form pred gfn cpred?] [form pred gfn cpred? unc])} spec-impl)\n(declare ^{:arglists \'([re gfn])} regex-spec-impl)\n\n(defn- maybe-spec\n  "spec-or-k must be a spec, regex or resolvable kw/sym, else returns nil."\n  [spec-or-k]\n  (let [s (c/or (c/and (ident? spec-or-k) (reg-resolve spec-or-k))\n                (spec? spec-or-k)\n                (regex? spec-or-k)\n                nil)]\n    (if (regex? s)\n      (with-name (regex-spec-impl s nil) (spec-name s))\n      s)))\n\n(defn- the-spec\n  "spec-or-k must be a spec, regex or kw/sym, else returns nil. Throws if unresolvable kw/sym"\n  [spec-or-k]\n  (c/or (maybe-spec spec-or-k)\n        (when (ident? spec-or-k)\n          (throw (js/Error. (str "Unable to resolve spec: " spec-or-k))))))\n\n(defn- fn-sym [f-n]\n  (when-not (str/blank? f-n)\n    (let [xs (map demunge (str/split f-n "$"))]\n      (when (c/and (\x3c\x3d 2 (count xs))\n                   (every? #(not (str/blank? %)) xs))\n        (let [[xs y] ((juxt butlast last) xs)]\n          (symbol (str (str/join "." xs) "/" y)))))))\n\n(defprotocol Specize\n  (specize* [_] [_ form]))\n\n(extend-protocol Specize\n  Keyword\n  (specize* ([k] (specize* (reg-resolve! k)))\n            ([k _] (specize* (reg-resolve! k))))\n\n  Symbol\n  (specize* ([s] (specize* (reg-resolve! s)))\n            ([s _] (specize* (reg-resolve! s))))\n\n  PersistentHashSet\n  (specize* ([s] (spec-impl s s nil nil))\n            ([s form] (spec-impl form s nil nil)))\n\n  PersistentTreeSet\n  (specize* ([s] (spec-impl s s nil nil))\n            ([s form] (spec-impl form s nil nil)))\n\n  default\n  (specize*\n    ([o]\n     (if-let [f-n (c/and (fn? o) (fn-sym (.-name o)))]\n       (spec-impl f-n o nil nil)\n       (spec-impl ::unknown o nil nil)))\n    ([o form] (spec-impl form o nil nil))))\n\n(defn- specize\n  ([s] (c/or (spec? s) (specize* s)))\n  ([s form] (c/or (spec? s) (specize* s form))))\n\n(defn invalid?\n  "tests the validity of a conform return value"\n  [ret]\n  (keyword-identical? ::invalid ret))\n\n(defn conform\n  "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value."\n  [spec x]\n  (conform* (specize spec) x))\n\n(defn unform\n  "Given a spec and a value created by or compliant with a call to\n  \'conform\' with the same spec, returns a value with all conform\n   destructuring undone."\n  [spec x]\n  (unform* (specize spec) x))\n\n(defn form\n  "returns the spec as data"\n  [spec]\n  ;;TODO - incorporate gens\n  (describe* (specize spec)))\n\n(defn abbrev [form]\n  (cond\n    (seq? form)\n    (walk/postwalk (fn [form]\n                     (cond\n                       (c/and (symbol? form) (namespace form))\n                       (-\x3e form name symbol)\n\n                       (c/and (seq? form) (\x3d \'fn (first form)) (\x3d \'[%] (second form)))\n                       (last form)\n\n                       :else form))\n                   form)\n\n    (c/and (symbol? form) (namespace form))\n    (-\x3e form name symbol)\n\n    :else form))\n\n(defn describe\n  "returns an abbreviated description of the spec as data"\n  [spec]\n  (abbrev (form spec)))\n\n(defn with-gen\n  "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator"\n  [spec gen-fn]\n  (let [spec (reg-resolve spec)]\n    (if (regex? spec)\n      (assoc spec ::gfn gen-fn)\n      (with-gen* (specize spec) gen-fn))))\n\n(defn explain-data* [spec path via in x]\n  (when-let [probs (explain* (specize spec) path via in x)]\n    (when-not (empty? probs)\n      {::problems probs\n       ::spec spec\n       ::value x})))\n\n(defn explain-data\n  "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path."\n  [spec x]\n  (explain-data* spec [] (if-let [name (spec-name spec)] [name] []) [] x))\n\n(defn explain-printer\n  "Default printer for explain-data. nil indicates a successful validation."\n  [ed]\n  (if ed\n    (let [problems (-\x3e\x3e (::problems ed)\n                     (sort-by #(- (count (:in %))))\n                     (sort-by #(- (count (:path %)))))]\n      (print\n        (with-out-str\n          ;;(prn {:ed ed})\n          (doseq [{:keys [path pred val reason via in] :as prob} problems]\n            (pr val)\n            (print " - failed: ")\n            (if reason (print reason) (pr (abbrev pred)))\n            (when-not (empty? in)\n              (print (str " in: " (pr-str in))))\n            (when-not (empty? path)\n              (print (str " at: " (pr-str path))))\n            (when-not (empty? via)\n              (print (str " spec: " (pr-str (last via)))))\n            (doseq [[k v] prob]\n              (when-not (#{:path :pred :val :reason :via :in} k)\n                (print "\\n\\t" (pr-str k) " ")\n                (pr v)))\n            (newline)))))\n    (println "Success!")))\n\n(def ^:dynamic *explain-out* explain-printer)\n\n(defn explain-out\n  "Prints explanation data (per \'explain-data\') to *out* using the printer in *explain-out*,\n    by default explain-printer."\n  [ed]\n  (*explain-out* ed))\n\n(defn explain\n  "Given a spec and a value that fails to conform, prints an explanation to *out*."\n  [spec x]\n  (explain-out (explain-data spec x)))\n\n(defn explain-str\n  "Given a spec and a value that fails to conform, returns an explanation as a string."\n  [spec x]\n  (with-out-str (explain spec x)))\n\n(declare ^{:arglists \'([spec x] [spec x form])} valid?)\n\n(defn- gensub\n  [spec overrides path rmap form]\n  ;;(prn {:spec spec :over overrides :path path :form form})\n  (let [spec (specize spec)]\n    (if-let [g (c/or (when-let [gfn (c/or (get overrides (c/or (spec-name spec) spec))\n                                          (get overrides path))]\n                       (gfn))\n                 (gen* spec overrides path rmap))]\n      (gen/such-that #(valid? spec %) g 100)\n      (throw (js/Error. (str "Unable to construct gen at: " path " for: " (abbrev form)))))))\n\n(defn gen\n  "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)"\n  ([spec] (gen spec nil))\n  ([spec overrides] (gensub spec overrides [] {::recursion-limit *recursion-limit*} spec)))\n\n(defn ^:skip-wiki def-impl\n  "Do not call this directly, use \'def\'"\n  [k form spec]\n  (assert (c/and (ident? k) (namespace k)) "k must be namespaced keyword or resolveable symbol")\n  (if (nil? spec)\n    (swap! registry-ref dissoc k)\n    (let [spec (if (c/or (spec? spec) (regex? spec) (get @registry-ref spec))\n                 spec\n                 (spec-impl form spec nil nil))]\n      (swap! registry-ref assoc k (with-name spec k))))\n  k)\n\n(defn registry\n  "returns the registry map, prefer \'get-spec\' to lookup a spec by name"\n  []\n  @registry-ref)\n\n(defn- -\x3esym\n  "Returns a symbol from a symbol or var"\n  [x]\n  (if (var? x)\n    (.-sym x)\n    x))\n\n(defn get-spec\n  "Returns spec registered for keyword/symbol/var k, or nil."\n  [k]\n  (get (registry) (if (keyword? k) k (-\x3esym k))))\n\n(declare map-spec)\n\n(defn- macroexpand-check\n  [v args]\n  (let [specs (get-spec v)]\n    (when-let [arg-spec (:args specs)]\n      (when (invalid? (conform arg-spec args))\n        (let [ed (assoc (explain-data* arg-spec []\n                          (if-let [name (spec-name arg-spec)] [name] []) [] args)\n                   ::args args)]\n          (throw (ex-info\n                   (str\n                     "Call to " (-\x3esym v) " did not conform to spec.")\n                   ed)))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; impl ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn- recur-limit? [rmap id path k]\n  (c/and (\x3e (get rmap id) (::recursion-limit rmap))\n         (contains? (set path) k)))\n\n(defn- inck [m k]\n  (assoc m k (inc (c/or (get m k) 0))))\n\n(defn- dt\n  ([pred x form] (dt pred x form nil))\n  ([pred x form cpred?]\n   (if pred\n     (if-let [spec (the-spec pred)]\n       (conform spec x)\n       (if (ifn? pred)\n         (if cpred?\n           (pred x)\n           (if (pred x) x ::invalid))\n         (throw (js/Error. (str (pr-str form) " is not a fn, expected predicate fn")))))\n     x)))\n\n(defn valid?\n  "Helper function that returns true when x is valid for spec."\n  ([spec x]\n   (let [spec (specize spec)]\n     (not (invalid? (conform* spec x)))))\n  ([spec x form]\n   (let [spec (specize spec form)]\n     (not (invalid? (conform* spec x))))))\n\n(defn- pvalid?\n  "internal helper function that returns true when x is valid for spec."\n  ([pred x]\n   (not (invalid? (dt pred x ::unknown))))\n  ([pred x form]\n   (not (invalid? (dt pred x form)))))\n\n(defn- explain-1 [form pred path via in v]\n  ;;(prn {:form form :pred pred :path path :in in :v v})\n  (let [pred (maybe-spec pred)]\n    (if (spec? pred)\n      (explain* pred path (if-let [name (spec-name pred)] (conj via name) via) in v)\n      [{:path path :pred form :val v :via via :in in}])))\n\n(declare ^{:arglists \'([s] [min-count s])} or-k-gen\n         ^{:arglists \'([s])} and-k-gen)\n\n(defn- k-gen\n  "returns a generator for form f, which can be a keyword or a list\n  starting with \'or or \'and."\n  [f]\n  (cond\n    (keyword? f)       (gen/return f)\n    (\x3d \'or  (first f)) (or-k-gen 1 (rest f))\n    (\x3d \'and (first f)) (and-k-gen (rest f))))\n\n(defn- or-k-gen\n  "returns a tuple generator made up of generators for a random subset\n  of min-count (default 0) to all elements in s."\n  ([s] (or-k-gen 0 s))\n  ([min-count s]\n   (gen/bind (gen/tuple\n               (gen/choose min-count (count s))\n               (gen/shuffle (map k-gen s)))\n     (fn [[n gens]]\n       (apply gen/tuple (take n gens))))))\n\n(defn- and-k-gen\n  "returns a tuple generator made up of generators for every element\n  in s."\n  [s]\n  (apply gen/tuple (map k-gen s)))\n\n(defn ^:skip-wiki map-spec-impl\n  "Do not call this directly, use \'spec\' with a map argument"\n  [{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn]\n    :as argm}]\n  (let [k-\x3es (zipmap (concat req-keys opt-keys) (concat req-specs opt-specs))\n        keys-\x3especnames #(c/or (k-\x3es %) %)\n        id (random-uuid)]\n    (reify\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ m]\n        (if (keys-pred m)\n          (let [reg (registry)]\n            (loop [ret m, [[k v] \x26 ks :as keys] m]\n              (if keys\n                (let [sname (keys-\x3especnames k)]\n                  (if-let [s (get reg sname)]\n                    (let [cv (conform s v)]\n                      (if (invalid? cv)\n                        ::invalid\n                        (recur (if (identical? cv v) ret (assoc ret k cv))\n                          ks)))\n                    (recur ret ks)))\n                ret)))\n          ::invalid))\n      (unform* [_ m]\n        (let [reg (registry)]\n          (loop [ret m, [k \x26 ks :as keys] (c/keys m)]\n            (if keys\n              (if (contains? reg (keys-\x3especnames k))\n                (let [cv (get m k)\n                      v (unform (keys-\x3especnames k) cv)]\n                  (recur (if (identical? cv v) ret (assoc ret k v))\n                    ks))\n                (recur ret ks))\n              ret))))\n      (explain* [_ path via in x]\n        (if-not (map? x)\n          [{:path path :pred `map? :val x :via via :in in}]\n          (let [reg (registry)]\n            (apply concat\n                   (when-let [probs (-\x3e\x3e (map (fn [pred form] (when-not (pred x) form))\n                                              pred-exprs pred-forms)\n                                         (keep identity)\n                                         seq)]\n                     (map\n                       #(identity {:path path :pred % :val x :via via :in in})\n                       probs))\n                   (map (fn [[k v]]\n                          (when-not (c/or (not (contains? reg (keys-\x3especnames k)))\n                                      (pvalid? (keys-\x3especnames k) v k))\n                            (explain-1 (keys-\x3especnames k) (keys-\x3especnames k) (conj path k) via (conj in k) v)))\n                     (seq x))))))\n      (gen* [_ overrides path rmap]\n        (if gfn\n          (gfn)\n          (let [rmap (inck rmap id)\n                rgen (fn [k s] [k (gensub s overrides (conj path k) rmap k)])\n                ogen (fn [k s]\n                       (when-not (recur-limit? rmap id path k)\n                         [k (gen/delay (gensub s overrides (conj path k) rmap k))]))\n                reqs (map rgen req-keys req-specs)\n                opts (remove nil? (map ogen opt-keys opt-specs))]\n            (when (every? identity (concat (map second reqs) (map second opts)))\n              (gen/bind\n                (gen/tuple\n                  (and-k-gen req)\n                  (or-k-gen opt)\n                  (and-k-gen req-un)\n                  (or-k-gen opt-un))\n                (fn [[req-ks opt-ks req-un-ks opt-un-ks]]\n                  (let [qks (flatten (concat req-ks opt-ks))\n                        unqks (map (comp keyword name) (flatten (concat req-un-ks opt-un-ks)))]\n                    (-\x3e\x3e (into reqs opts)\n                      (filter #((set (concat qks unqks)) (first %)))\n                      (apply concat)\n                      (apply gen/hash-map)))))))))\n      (with-gen* [_ gfn] (map-spec-impl (assoc argm :gfn gfn)))\n      (describe* [_] (cons `keys\n                           (cond-\x3e []\n                                   req (conj :req req)\n                                   opt (conj :opt opt)\n                                   req-un (conj :req-un req-un)\n                                   opt-un (conj :opt-un opt-un)))))))\n\n(defn ^:skip-wiki spec-impl\n  "Do not call this directly, use \'spec\'"\n  ([form pred gfn cpred?] (spec-impl form pred gfn cpred? nil))\n  ([form pred gfn cpred? unc]\n   (cond\n     (spec? pred) (cond-\x3e pred gfn (with-gen gfn))\n     (regex? pred) (regex-spec-impl pred gfn)\n     (ident? pred) (cond-\x3e (the-spec pred) gfn (with-gen gfn))\n     :else\n     (reify\n       Specize\n       (specize* [s] s)\n       (specize* [s _] s)\n\n       Spec\n       (conform* [_ x] (let [ret (pred x)]\n                         (if cpred?\n                           ret\n                           (if ret x ::invalid))))\n       (unform* [_ x] (if cpred?\n                        (if unc\n                          (unc x)\n                          (throw (js/Error. "no unform fn for conformer")))\n                        x))\n       (explain* [_ path via in x]\n         (when (invalid? (dt pred x form cpred?))\n           [{:path path :pred form :val x :via via :in in}]))\n       (gen* [_ _ _ _] (if gfn\n                         (gfn)\n                         (gen/gen-for-pred pred)))\n       (with-gen* [_ gfn] (spec-impl form pred gfn cpred? unc))\n       (describe* [_] form)))))\n\n(defn ^:skip-wiki multi-spec-impl\n  "Do not call this directly, use \'multi-spec\'"\n  ([form mmvar retag] (multi-spec-impl form mmvar retag nil))\n  ([form mmvar retag gfn]\n   (let [id (random-uuid)\n         predx #(let [mm @mmvar]\n                 (c/and (-get-method mm ((-dispatch-fn mm) %))\n                        (mm %)))\n         dval #((-dispatch-fn @mmvar) %)\n         tag (if (keyword? retag)\n               #(assoc %1 retag %2)\n               retag)]\n     (reify\n       Specize\n       (specize* [s] s)\n       (specize* [s _] s)\n\n       Spec\n       (conform* [_ x] (if-let [pred (predx x)]\n                         (dt pred x form)\n                         ::invalid))\n       (unform* [_ x] (if-let [pred (predx x)]\n                        (unform pred x)\n                        (throw (js/Error. (str "No method of: " form " for dispatch value: " (dval x))))))\n       (explain* [_ path via in x]\n         (let [dv (dval x)\n               path (conj path dv)]\n           (if-let [pred (predx x)]\n             (explain-1 form pred path via in x)\n             [{:path path :pred form :val x :reason "no method" :via via :in in}])))\n       (gen* [_ overrides path rmap]\n         (if gfn\n           (gfn)\n           (let [gen (fn [[k f]]\n                       (let [p (f nil)]\n                         (let [rmap (inck rmap id)]\n                           (when-not (recur-limit? rmap id path k)\n                             (gen/delay\n                               (gen/fmap\n                                 #(tag % k)\n                                 (gensub p overrides (conj path k) rmap (list \'method form k))))))))\n                 gs (-\x3e\x3e (methods @mmvar)\n                         (remove (fn [[k]] (invalid? k)))\n                         (map gen)\n                         (remove nil?))]\n             (when (every? identity gs)\n               (gen/one-of gs)))))\n       (with-gen* [_ gfn] (multi-spec-impl form mmvar retag gfn))\n       (describe* [_] `(multi-spec ~form ~retag))))))\n\n(defn ^:skip-wiki tuple-impl\n  "Do not call this directly, use \'tuple\'"\n  ([forms preds] (tuple-impl forms preds nil))\n  ([forms preds gfn]\n   (let [specs (delay (mapv specize preds forms))\n         cnt (count preds)]\n     (reify\n       Specize\n       (specize* [s] s)\n       (specize* [s _] s)\n\n       Spec\n       (conform* [_ x]\n         (let [specs @specs]\n           (if-not (c/and (vector? x)\n                     (\x3d (count x) cnt))\n             ::invalid\n             (loop [ret x, i 0]\n               (if (\x3d i cnt)\n                 ret\n                 (let [v (x i)\n                       cv (conform* (specs i) v)]\n                   (if (invalid? cv)\n                     ::invalid\n                     (recur (if (identical? cv v) ret (assoc ret i cv))\n                            (inc i)))))))))\n       (unform* [_ x]\n         (assert (c/and (vector? x)\n                   (\x3d (count x) (count preds))))\n         (loop [ret x, i 0]\n           (if (\x3d i (count x))\n             ret\n             (let [cv (x i)\n                   v (unform (preds i) cv)]\n               (recur (if (identical? cv v) ret (assoc ret i v))\n                 (inc i))))))\n       (explain* [_ path via in x]\n         (cond\n           (not (vector? x))\n           [{:path path :pred `vector? :val x :via via :in in}]\n\n           (not\x3d (count x) (count preds))\n           [{:path path :pred `(\x3d (count ~\'%) ~(count preds)) :val x :via via :in in}]\n\n           :else\n           (apply concat\n             (map (fn [i form pred]\n                    (let [v (x i)]\n                      (when-not (pvalid? pred v)\n                        (explain-1 form pred (conj path i) via (conj in i) v))))\n               (range (count preds)) forms preds))))\n       (gen* [_ overrides path rmap]\n         (if gfn\n           (gfn)\n           (let [gen (fn [i p f]\n                       (gensub p overrides (conj path i) rmap f))\n                 gs (map gen (range (count preds)) preds forms)]\n             (when (every? identity gs)\n               (apply gen/tuple gs)))))\n       (with-gen* [_ gfn] (tuple-impl forms preds gfn))\n       (describe* [_] `(tuple ~@forms))))))\n\n(defn- tagged-ret [tag ret]\n  (MapEntry. tag ret nil))\n\n(defn ^:skip-wiki or-spec-impl\n  "Do not call this directly, use \'or\'"\n  [keys forms preds gfn]\n  (let [id (random-uuid)\n        kps (zipmap keys preds)\n        specs (delay (mapv specize preds forms))\n        cform (case (count preds)\n                2 (fn [x]\n                    (let [specs @specs\n                          ret (conform* (specs 0) x)]\n                      (if (invalid? ret)\n                        (let [ret (conform* (specs 1) x)]\n                          (if (invalid? ret)\n                            ::invalid\n                            (tagged-ret (keys 1) ret)))\n                        (tagged-ret (keys 0) ret))))\n                3 (fn [x]\n                    (let [specs @specs\n                          ret (conform* (specs 0) x)]\n                      (if (invalid? ret)\n                        (let [ret (conform* (specs 1) x)]\n                          (if (invalid? ret)\n                            (let [ret (conform* (specs 2) x)]\n                              (if (invalid? ret)\n                                ::invalid\n                                (tagged-ret (keys 2) ret)))\n                            (tagged-ret (keys 1) ret)))\n                        (tagged-ret (keys 0) ret))))\n                (fn [x]\n                  (let [specs @specs]\n                    (loop [i 0]\n                      (if (\x3c i (count specs))\n                        (let [spec (specs i)]\n                          (let [ret (conform* spec x)]\n                            (if (invalid? ret)\n                              (recur (inc i))\n                              (tagged-ret (keys i) ret))))\n                        ::invalid)))))]\n    (reify\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ x] (cform x))\n      (unform* [_ [k x]] (unform (kps k) x))\n      (explain* [this path via in x]\n        (when-not (pvalid? this x)\n          (apply concat\n                 (map (fn [k form pred]\n                        (when-not (pvalid? pred x)\n                          (explain-1 form pred (conj path k) via in x)))\n                      keys forms preds))))\n      (gen* [_ overrides path rmap]\n        (if gfn\n          (gfn)\n          (let [gen (fn [k p f]\n                      (let [rmap (inck rmap id)]\n                        (when-not (recur-limit? rmap id path k)\n                          (gen/delay\n                            (gensub p overrides (conj path k) rmap f)))))\n                gs (remove nil? (map gen keys preds forms))]\n            (when-not (empty? gs)\n              (gen/one-of gs)))))\n      (with-gen* [_ gfn] (or-spec-impl keys forms preds gfn))\n      (describe* [_] `(or ~@(mapcat vector keys forms))))))\n\n(defn- and-preds [x preds forms]\n  (loop [ret x\n         [pred \x26 preds] preds\n         [form \x26 forms] forms]\n    (if pred\n      (let [nret (dt pred ret form)]\n        (if (invalid? nret)\n          ::invalid\n          ;;propagate conformed values\n          (recur nret preds forms)))\n      ret)))\n\n(defn- explain-pred-list\n  [forms preds path via in x]\n  (loop [ret x\n         [form \x26 forms] forms\n         [pred \x26 preds] preds]\n    (when pred\n      (let [nret (dt pred ret form)]\n        (if (invalid? nret)\n          (explain-1 form pred path via in ret)\n          (recur nret forms preds))))))\n\n(defn ^:skip-wiki and-spec-impl\n  "Do not call this directly, use \'and\'"\n  [forms preds gfn]\n  (let [specs (delay (mapv specize preds forms))\n        cform\n        (case (count preds)\n          2 (fn [x]\n              (let [specs @specs\n                    ret (conform* (specs 0) x)]\n                (if (invalid? ret)\n                  ::invalid\n                  (conform* (specs 1) ret))))\n          3 (fn [x]\n              (let [specs @specs\n                    ret (conform* (specs 0) x)]\n                (if (invalid? ret)\n                  ::invalid\n                  (let [ret (conform* (specs 1) ret)]\n                    (if (invalid? ret)\n                      ::invalid\n                      (conform* (specs 2) ret))))))\n          (fn [x]\n            (let [specs @specs]\n              (loop [ret x i 0]\n                (if (\x3c i (count specs))\n                  (let [nret (conform* (specs i) ret)]\n                    (if (invalid? nret)\n                      ::invalid\n                      ;;propagate conformed values\n                      (recur nret (inc i))))\n                  ret)))))]\n    (reify\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ x] (cform x))\n      (unform* [_ x] (reduce #(unform %2 %1) x (reverse preds)))\n      (explain* [_ path via in x] (explain-pred-list forms preds path via in x))\n      (gen* [_ overrides path rmap] (if gfn (gfn) (gensub (first preds) overrides path rmap (first forms))))\n      (with-gen* [_ gfn] (and-spec-impl forms preds gfn))\n      (describe* [_] `(and ~@forms)))))\n\n(defn- coll-prob [x kfn kform distinct count min-count max-count\n                  path via in]\n  (let [pred (c/or kfn coll?)\n        kform (c/or kform `coll?)]\n    (cond\n     (not (pvalid? pred x))\n     (explain-1 kform pred path via in x)\n\n     (c/and count (not\x3d count (bounded-count count x)))\n     [{:path path :pred `(\x3d ~count (c/count ~\'%)) :val x :via via :in in}]\n\n     (c/and (c/or min-count max-count)\n       (not (\x3c\x3d (c/or min-count 0)\n              (bounded-count (if max-count (inc max-count) min-count) x)\n              (c/or max-count MAX_INT))))\n     [{:path path :pred `(\x3c\x3d ~(c/or min-count 0) (c/count ~\'%) ~(c/or max-count MAX_INT)) :val x :via via :in in}]\n\n     (c/and distinct (not (empty? x)) (not (apply distinct? x)))\n     [{:path path :pred \'distinct? :val x :via via :in in}])))\n\n(defn ^:skip-wiki merge-spec-impl\n  "Do not call this directly, use \'merge\'"\n  [forms preds gfn]\n  (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n\n    Spec\n    (conform* [_ x] (let [ms (map #(dt %1 x %2) preds forms)]\n                      (if (some invalid? ms)\n                        ::invalid\n                        (apply c/merge ms))))\n    (unform* [_ x] (apply c/merge (map #(unform % x) (reverse preds))))\n    (explain* [_ path via in x]\n      (apply concat\n        (map #(explain-1 %1 %2 path via in x)\n          forms preds)))\n    (gen* [_ overrides path rmap]\n      (if gfn\n        (gfn)\n        (gen/fmap\n          #(apply c/merge %)\n          (apply gen/tuple (map #(gensub %1 overrides path rmap %2)\n                             preds forms)))))\n    (with-gen* [_ gfn] (merge-spec-impl forms preds gfn))\n    (describe* [_] `(merge ~@forms))))\n\n(def ^:private empty-coll {`vector? [], `set? #{}, `list? (), `map? {}})\n\n(defn ^:skip-wiki every-impl\n  "Do not call this directly, use \'every\', \'every-kv\', \'coll-of\' or \'map-of\'"\n  ([form pred opts] (every-impl form pred opts nil))\n  ([form pred {conform-into :into\n               describe-form ::describe\n               :keys [kind ::kind-form count max-count min-count distinct gen-max ::kfn ::cpred\n                      conform-keys ::conform-all]\n               :or {gen-max 20}\n               :as opts}\n    gfn]\n   (let [gen-into (if conform-into (empty conform-into) (get empty-coll kind-form))\n         spec (delay (specize pred))\n         check? #(valid? @spec %)\n         kfn (c/or kfn (fn [i v] i))\n         addcv (fn [ret i v cv] (conj ret cv))\n         cfns (fn [x]\n                ;;returns a tuple of [init add complete] fns\n                (cond\n                  (c/and (vector? x) (c/or (not conform-into) (vector? conform-into)))\n                  [identity\n                   (fn [ret i v cv]\n                     (if (identical? v cv)\n                       ret\n                       (assoc ret i cv)))\n                   identity]\n\n                  (c/and (map? x) (c/or (c/and kind (not conform-into)) (map? conform-into)))\n                  [(if conform-keys empty identity)\n                   (fn [ret i v cv]\n                     (if (c/and (identical? v cv) (not conform-keys))\n                       ret\n                       (assoc ret (nth (if conform-keys cv v) 0) (nth cv 1))))\n                   identity]\n\n                  (c/or (list? conform-into) (seq? conform-into) (c/and (not conform-into) (c/or (list? x) (seq? x))))\n                  [empty addcv reverse]\n\n                  :else [#(empty (c/or conform-into %)) addcv identity]))]\n     (reify\n       Specize\n       (specize* [s] s)\n       (specize* [s _] s)\n\n       Spec\n       (conform* [_ x]\n         (let [spec @spec]\n           (cond\n             (not (cpred x)) ::invalid\n\n             conform-all\n             (let [[init add complete] (cfns x)]\n               (loop [ret (init x), i 0, [v \x26 vs :as vseq] (seq x)]\n                 (if vseq\n                   (let [cv (conform* spec v)]\n                     (if (invalid? cv)\n                       ::invalid\n                       (recur (add ret i v cv) (inc i) vs)))\n                   (complete ret))))\n\n             :else\n             (if (indexed? x)\n               (let [step (max 1 (long (/ (c/count x) *coll-check-limit*)))]\n                 (loop [i 0]\n                   (if (\x3e\x3d i (c/count x))\n                     x\n                     (if (valid? spec (nth x i))\n                       (recur (c/+ i step))\n                       ::invalid))))\n               (let [limit *coll-check-limit*]\n                 (loop [i 0 [v \x26 vs :as vseq] (seq x)]\n                   (cond\n                     (c/or (nil? vseq) (\x3d i limit)) x\n                     (valid? spec v) (recur (inc i) vs)\n                     :else ::invalid)))))))\n       (unform* [_ x]\n         (if conform-all\n           (let [spec @spec\n                 [init add complete] (cfns x)]\n             (loop [ret (init x), i 0, [v \x26 vs :as vseq] (seq x)]\n               (if (\x3e\x3d i (c/count x))\n                 (complete ret)\n                 (recur (add ret i v (unform* spec v)) (inc i) vs))))\n           x))\n       (explain* [_ path via in x]\n         (c/or (coll-prob x kind kind-form distinct count min-count max-count\n                          path via in)\n           (apply concat\n             ((if conform-all identity (partial take *coll-error-limit*))\n               (keep identity\n                 (map (fn [i v]\n                        (let [k (kfn i v)]\n                          (when-not (check? v)\n                            (let [prob (explain-1 form pred path via (conj in k) v)]\n                              prob))))\n                   (range) x))))))\n       (gen* [_ overrides path rmap]\n         (if gfn\n           (gfn)\n           (let [pgen (gensub pred overrides path rmap form)]\n             (gen/bind\n               (cond\n                 gen-into (gen/return gen-into)\n                 kind (gen/fmap #(if (empty? %) % (empty %))\n                        (gensub kind overrides path rmap form))\n                 :else (gen/return []))\n               (fn [init]\n                 (gen/fmap\n                   #(if (vector? init) % (into init %))\n                   (cond\n                     distinct\n                     (if count\n                       (gen/vector-distinct pgen {:num-elements count :max-tries 100})\n                       (gen/vector-distinct pgen {:min-elements (c/or min-count 0)\n                                                  :max-elements (c/or max-count (max gen-max (c/* 2 (c/or min-count 0))))\n                                                  :max-tries 100}))\n\n                     count\n                     (gen/vector pgen count)\n\n                     (c/or min-count max-count)\n                     (gen/vector pgen (c/or min-count 0) (c/or max-count (max gen-max (c/* 2 (c/or min-count 0)))))\n\n                     :else\n                     (gen/vector pgen 0 gen-max))))))))\n\n       (with-gen* [_ gfn] (every-impl form pred opts gfn))\n       (describe* [_] (c/or describe-form `(every ~(s/mres form) ~@(mapcat identity opts))))))))\n\n;;;;;;;;;;;;;;;;;;;;;;; regex ;;;;;;;;;;;;;;;;;;;\n;;See:\n;; http://matt.might.net/articles/implementation-of-regular-expression-matching-in-scheme-with-derivatives/\n;; http://www.ccs.neu.edu/home/turon/re-deriv.pdf\n\n;;ctors\n(defn- accept [x] {::op ::accept :ret x})\n\n(defn- accept? [{:keys [::op]}]\n  (\x3d ::accept op))\n\n(defn- pcat* [{[p1 \x26 pr :as ps] :ps,  [k1 \x26 kr :as ks] :ks, [f1 \x26 fr :as forms] :forms, ret :ret, rep+ :rep+}]\n  (when (every? identity ps)\n    (if (accept? p1)\n      (let [rp (:ret p1)\n            ret (conj ret (if ks {k1 rp} rp))]\n        (if pr\n          (pcat* {:ps pr :ks kr :forms fr :ret ret})\n          (accept ret)))\n      {::op ::pcat, :ps ps, :ret ret, :ks ks, :forms forms :rep+ rep+})))\n\n(defn- pcat [\x26 ps] (pcat* {:ps ps :ret []}))\n\n(defn ^:skip-wiki cat-impl\n  "Do not call this directly, use \'cat\'"\n  [ks ps forms]\n  (pcat* {:ks ks, :ps ps, :forms forms, :ret {}}))\n\n(defn- rep* [p1 p2 ret splice form]\n  (when p1\n    (let [r {::op ::rep, :p2 p2, :splice splice, :forms form :id (random-uuid)}]\n      (if (accept? p1)\n        (assoc r :p1 p2 :ret (conj ret (:ret p1)))\n        (assoc r :p1 p1, :ret ret)))))\n\n(defn ^:skip-wiki rep-impl\n  "Do not call this directly, use \'*\'"\n  [form p] (rep* p p [] false form))\n\n(defn ^:skip-wiki rep+impl\n  "Do not call this directly, use \'+\'"\n  [form p]\n  (pcat* {:ps [p (rep* p p [] true form)] :forms `[~form (* ~form)] :ret [] :rep+ form}))\n\n(defn ^:skip-wiki amp-impl\n  "Do not call this directly, use \'\x26\'"\n  [re re-form preds pred-forms]\n  {::op ::amp :p1 re :amp re-form :ps preds :forms pred-forms})\n\n(defn- filter-alt [ps ks forms f]\n  (if (c/or ks forms)\n    (let [pks (-\x3e\x3e (map vector ps\n                        (c/or (seq ks) (repeat nil))\n                        (c/or (seq forms) (repeat nil)))\n                   (filter #(-\x3e % first f)))]\n      [(seq (map first pks)) (when ks (seq (map second pks))) (when forms (seq (map #(nth % 2) pks)))])\n    [(seq (filter f ps)) ks forms]))\n\n(defn- alt* [ps ks forms]\n  (let [[[p1 \x26 pr :as ps] [k1 :as ks] forms] (filter-alt ps ks forms identity)]\n    (when ps\n      (let [ret {::op ::alt, :ps ps, :ks ks :forms forms}]\n        (if (nil? pr)\n          (if k1\n            (if (accept? p1)\n              (accept (tagged-ret k1 (:ret p1)))\n              ret)\n            p1)\n          ret)))))\n\n(defn- alts [\x26 ps] (alt* ps nil nil))\n(defn- alt2 [p1 p2] (if (c/and p1 p2) (alts p1 p2) (c/or p1 p2)))\n\n(defn ^:skip-wiki alt-impl\n  "Do not call this directly, use \'alt\'"\n  [ks ps forms] (assoc (alt* ps ks forms) :id (random-uuid)))\n\n(defn ^:skip-wiki maybe-impl\n  "Do not call this directly, use \'?\'"\n  [p form] (assoc (alt* [p (accept ::nil)] nil [form ::nil]) :maybe form))\n\n(defn- noret? [p1 pret]\n  (c/or (\x3d pret ::nil)\n        (c/and (#{::rep ::pcat} (::op (reg-resolve! p1))) ;;hrm, shouldn\'t know these\n               (empty? pret))\n        nil))\n\n(declare ^{:arglists \'([p])} preturn)\n\n(defn- accept-nil? [p]\n  (let [{:keys [::op ps p1 p2 forms] :as p} (reg-resolve! p)]\n    (case op\n      ::accept true\n      nil nil\n      ::amp (c/and (accept-nil? p1)\n                   (let [ret (-\x3e (preturn p1) (and-preds ps (next forms)))]\n                     (not (invalid? ret))))\n      ::rep (c/or (identical? p1 p2) (accept-nil? p1))\n      ::pcat (every? accept-nil? ps)\n      ::alt (c/some accept-nil? ps))))\n\n(declare ^{:arglists \'([p r k])} add-ret)\n\n(defn- preturn [p]\n  (let [{[p0 \x26 pr :as ps] :ps, [k :as ks] :ks, :keys [::op p1 ret forms] :as p} (reg-resolve! p)]\n    (case op\n      ::accept ret\n      nil nil\n      ::amp (let [pret (preturn p1)]\n              (if (noret? p1 pret)\n                ::nil\n                (and-preds pret ps forms)))\n      ::rep (add-ret p1 ret k)\n      ::pcat (add-ret p0 ret k)\n      ::alt (let [[[p0] [k0]] (filter-alt ps ks forms accept-nil?)\n                  r (if (nil? p0) ::nil (preturn p0))]\n              (if k0 (tagged-ret k0 r) r)))))\n\n(defn- op-unform [p x]\n  ;;(prn {:p p :x x})\n  (let [{[p0 \x26 pr :as ps] :ps, [k :as ks] :ks, :keys [::op p1 ret forms rep+ maybe] :as p} (reg-resolve! p)\n        kps (zipmap ks ps)]\n    (case op\n      ::accept [ret]\n      nil [(unform p x)]\n      ::amp (let [px (reduce #(unform %2 %1) x (reverse ps))]\n              (op-unform p1 px))\n      ::rep (mapcat #(op-unform p1 %) x)\n      ::pcat (if rep+\n               (mapcat #(op-unform p0 %) x)\n               (mapcat (fn [k]\n                         (when (contains? x k)\n                           (op-unform (kps k) (get x k))))\n                 ks))\n      ::alt (if maybe\n              [(unform p0 x)]\n              (let [[k v] x]\n                (op-unform (kps k) v))))))\n\n(defn- add-ret [p r k]\n  (let [{:keys [::op ps splice] :as p} (reg-resolve! p)\n        prop #(let [ret (preturn p)]\n               (if (empty? ret) r ((if splice into conj) r (if k {k ret} ret))))]\n    (case op\n      nil r\n      (::alt ::accept ::amp)\n      (let [ret (preturn p)]\n        ;;(prn {:ret ret})\n        (if (\x3d ret ::nil) r (conj r (if k {k ret} ret))))\n\n      (::rep ::pcat) (prop))))\n\n(defn- deriv\n  [p x]\n  (let [{[p0 \x26 pr :as ps] :ps, [k0 \x26 kr :as ks] :ks, :keys [::op p1 p2 ret splice forms amp] :as p} (reg-resolve! p)]\n    (when p\n      (case op\n        ::accept nil\n        nil (let [ret (dt p x p)]\n              (when-not (invalid? ret) (accept ret)))\n        ::amp (when-let [p1 (deriv p1 x)]\n                (if (\x3d ::accept (::op p1))\n                  (let [ret (-\x3e (preturn p1) (and-preds ps (next forms)))]\n                    (when-not (invalid? ret)\n                      (accept ret)))\n                  (amp-impl p1 amp ps forms)))\n        ::pcat (alt2 (pcat* {:ps (cons (deriv p0 x) pr), :ks ks, :forms forms, :ret ret})\n                     (when (accept-nil? p0) (deriv (pcat* {:ps pr, :ks kr, :forms (next forms), :ret (add-ret p0 ret k0)}) x)))\n        ::alt (alt* (map #(deriv % x) ps) ks forms)\n        ::rep (alt2 (rep* (deriv p1 x) p2 ret splice forms)\n                    (when (accept-nil? p1) (deriv (rep* p2 p2 (add-ret p1 ret nil) splice forms) x)))))))\n\n(defn- op-describe [p]\n  (let [{:keys [::op ps ks forms splice p1 rep+ maybe amp] :as p} (reg-resolve! p)]\n    ;;(prn {:op op :ks ks :forms forms :p p})\n    (when p\n      (case op\n        ::accept nil\n        nil p\n        ::amp (list* \'cljs.spec.alpha/\x26 amp forms)\n        ::pcat (if rep+\n                 (list `+ rep+)\n                 (cons `cat (mapcat vector (c/or (seq ks) (repeat :_)) forms)))\n        ::alt (if maybe\n                (list `? maybe)\n                (cons `alt (mapcat vector ks forms)))\n        ::rep (list (if splice `+ `*) forms)))))\n\n(defn- op-explain [form p path via in input]\n  ;;(prn {:form form :p p :path path :input input})\n  (let [[x :as input] input\n        {:keys [::op ps ks forms splice p1 p2] :as p} (reg-resolve! p)\n        via (if-let [name (spec-name p)] (conj via name) via)\n        insufficient (fn [path form]\n                       [{:path path\n                         :reason "Insufficient input"\n                         :pred form\n                         :val ()\n                         :via via\n                         :in in}])]\n    (when p\n      (case op\n        ::accept nil\n        nil (if (empty? input)\n              (insufficient path form)\n              (explain-1 form p path via in x))\n        ::amp (if (empty? input)\n                (if (accept-nil? p1)\n                  (explain-pred-list forms ps path via in (preturn p1))\n                  (insufficient path (:amp p)))\n                (if-let [p1 (deriv p1 x)]\n                  (explain-pred-list forms ps path via in (preturn p1))\n                  (op-explain (:amp p) p1 path via in input)))\n        ::pcat (let [pkfs (map vector\n                               ps\n                               (c/or (seq ks) (repeat nil))\n                               (c/or (seq forms) (repeat nil)))\n                     [pred k form] (if (\x3d 1 (count pkfs))\n                                     (first pkfs)\n                                     (first (remove (fn [[p]] (accept-nil? p)) pkfs)))\n                     path (if k (conj path k) path)\n                     form (c/or form (op-describe pred))]\n                 (if (c/and (empty? input) (not pred))\n                   (insufficient path form)\n                   (op-explain form pred path via in input)))\n        ::alt (if (empty? input)\n                (insufficient path (op-describe p))\n                (apply concat\n                       (map (fn [k form pred]\n                              (op-explain (c/or form (op-describe pred))\n                                          pred\n                                          (if k (conj path k) path)\n                                          via\n                                          in\n                                          input))\n                            (c/or (seq ks) (repeat nil))\n                            (c/or (seq forms) (repeat nil))\n                            ps)))\n        ::rep (op-explain (if (identical? p1 p2)\n                            forms\n                            (op-describe p1))\n                          p1 path via in input)))))\n\n(defn- re-gen [p overrides path rmap f]\n  ;;(prn {:op op :ks ks :forms forms})\n  (let [{:keys [::op ps ks p1 p2 forms splice ret id ::gfn] :as p} (reg-resolve! p)\n        rmap (if id (inck rmap id) rmap)\n        ggens (fn [ps ks forms]\n                (let [gen (fn [p k f]\n                            ;;(prn {:k k :path path :rmap rmap :op op :id id})\n                            (when-not (c/and rmap id k (recur-limit? rmap id path k))\n                              (if id\n                                (gen/delay (re-gen p overrides (if k (conj path k) path) rmap (c/or f p)))\n                                (re-gen p overrides (if k (conj path k) path) rmap (c/or f p)))))]\n                  (map gen ps (c/or (seq ks) (repeat nil)) (c/or (seq forms) (repeat nil)))))]\n    (c/or (when-let [g (get overrides path)]\n            (case op\n              (:accept nil) (gen/fmap vector g)\n              g))\n          (when gfn\n            (gfn))\n          (when p\n            (case op\n              ::accept (if (\x3d ret ::nil)\n                         (gen/return [])\n                         (gen/return [ret]))\n              nil (when-let [g (gensub p overrides path rmap f)]\n                    (gen/fmap vector g))\n              ::amp (re-gen p1 overrides path rmap (op-describe p1))\n              ::pcat (let [gens (ggens ps ks forms)]\n                       (when (every? identity gens)\n                         (apply gen/cat gens)))\n              ::alt (let [gens (remove nil? (ggens ps ks forms))]\n                      (when-not (empty? gens)\n                        (gen/one-of gens)))\n              ::rep (if (recur-limit? rmap id [id] id)\n                      (gen/return [])\n                      (when-let [g (re-gen p2 overrides path rmap forms)]\n                        (gen/fmap #(apply concat %)\n                                  (gen/vector g)))))))))\n\n(defn- re-conform [p [x \x26 xs :as data]]\n  ;;(prn {:p p :x x :xs xs})\n  (if (empty? data)\n    (if (accept-nil? p)\n      (let [ret (preturn p)]\n        (if (\x3d ret ::nil)\n          nil\n          ret))\n      ::invalid)\n    (if-let [dp (deriv p x)]\n      (recur dp xs)\n      ::invalid)))\n\n(defn- re-explain [path via in re input]\n  (loop [p re [x \x26 xs :as data] input i 0]\n    ;;(prn {:p p :x x :xs xs :re re}) (prn)\n    (if (empty? data)\n      (if (accept-nil? p)\n        nil ;;success\n        (op-explain (op-describe p) p path via in nil))\n      (if-let [dp (deriv p x)]\n        (recur dp xs (inc i))\n        (if (accept? p)\n          (if (\x3d (::op p) ::pcat)\n            (op-explain (op-describe p) p path via (conj in i) (seq data))\n            [{:path path\n              :reason "Extra input"\n              :pred (op-describe re)\n              :val data\n              :via via\n              :in (conj in i)}])\n          (c/or (op-explain (op-describe p) p path via (conj in i) (seq data))\n                [{:path path\n                  :reason "Extra input"\n                  :pred (op-describe p)\n                  :val data\n                  :via via\n                  :in (conj in i)}]))))))\n\n(defn ^:skip-wiki regex-spec-impl\n  "Do not call this directly, use \'spec\' with a regex op argument"\n  [re gfn]\n  (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n\n    Spec\n    (conform* [_ x]\n      (if (c/or (nil? x) (sequential? x))\n        (re-conform re (seq x))\n        ::invalid))\n    (unform* [_ x] (op-unform re x))\n    (explain* [_ path via in x]\n      (if (c/or (nil? x) (sequential? x))\n        (re-explain path via in re (seq x))\n        [{:path path :pred `(fn [~\'%] (c/or (nil? ~\'%) (sequential? ~\'%))) :val x :via via :in in}]))\n    (gen* [_ overrides path rmap]\n      (if gfn\n        (gfn)\n        (re-gen re overrides path rmap (op-describe re))))\n    (with-gen* [_ gfn] (regex-spec-impl re gfn))\n    (describe* [_] (op-describe re))))\n\n;;;;;;;;;;;;;;;;; HOFs ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- call-valid?\n  [f specs args]\n  (let [cargs (conform (:args specs) args)]\n    (when-not (invalid? cargs)\n      (let [ret (apply f args)\n            cret (conform (:ret specs) ret)]\n        (c/and (not (invalid? cret))\n               (if (:fn specs)\n                 (pvalid? (:fn specs) {:args cargs :ret cret})\n                 true))))))\n\n(defn- validate-fn\n  "returns f if valid, else smallest"\n  [f specs iters]\n  (let [g (gen (:args specs))\n        prop (gen/for-all* [g] #(call-valid? f specs %))]\n    (let [ret (gen/quick-check iters prop)]\n      (if-let [[smallest] (-\x3e ret :shrunk :smallest)]\n        smallest\n        f))))\n\n(defn ^:skip-wiki fspec-impl\n  "Do not call this directly, use \'fspec\'"\n  [argspec aform retspec rform fnspec fform gfn]\n  (let [specs {:args argspec :ret retspec :fn fnspec}]\n    (reify\n      ILookup\n      (-lookup [this k] (get specs k))\n      (-lookup [_ k not-found] (get specs k not-found))\n\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ f] (if (ifn? f)\n                        (if (identical? f (validate-fn f specs *fspec-iterations*)) f ::invalid)\n                        ::invalid))\n      (unform* [_ f] f)\n      (explain* [_ path via in f]\n        (if (ifn? f)\n          (let [args (validate-fn f specs 100)]\n            (if (identical? f args) ;;hrm, we might not be able to reproduce\n              nil\n              (let [ret (try (apply f args) (catch js/Error t t))]\n                (if (instance? js/Error ret)\n                  ;;TODO add exception data\n                  [{:path path :pred \'(apply fn) :val args :reason (.-message ret) :via via :in in}]\n\n                  (let [cret (dt retspec ret rform)]\n                    (if (invalid? cret)\n                      (explain-1 rform retspec (conj path :ret) via in ret)\n                      (when fnspec\n                        (let [cargs (conform argspec args)]\n                          (explain-1 fform fnspec (conj path :fn) via in {:args cargs :ret cret})))))))))\n          [{:path path :pred \'ifn? :val f :via via :in in}]))\n      (gen* [_ overrides _ _] (if gfn\n                        (gfn)\n                        (gen/return\n                          (fn [\x26 args]\n                            (assert (pvalid? argspec args) (with-out-str (explain argspec args)))\n                            (gen/generate (gen retspec overrides))))))\n      (with-gen* [_ gfn] (fspec-impl argspec aform retspec rform fnspec fform gfn))\n      (describe* [_] `(fspec :args ~aform :ret ~rform :fn ~fform)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; non-primitives ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(cljs.spec.alpha/def ::kvs-\x3emap (cljs.spec.alpha/conformer #(zipmap (map ::k %) (map ::v %)) #(map (fn [[k v]] {::k k ::v v}) %)))\n\n(defn nonconforming\n  "takes a spec and returns a spec that has the same properties except\n  \'conform\' returns the original (not the conformed) value. Note, will specize regex ops."\n  [spec]\n  (let [spec (delay (specize spec))]\n    (reify\n     Specize\n     (specize* [s] s)\n     (specize* [s _] s)\n\n     Spec\n     (conform* [_ x] (let [ret (conform* @spec x)]\n                       (if (invalid? ret)\n                         ::invalid\n                         x)))\n     (unform* [_ x] (unform* @spec x))\n     (explain* [_ path via in x] (explain* @spec path via in x))\n     (gen* [_ overrides path rmap] (gen* @spec overrides path rmap))\n     (with-gen* [_ gfn] (nonconforming (with-gen* @spec gfn)))\n     (describe* [_] `(nonconforming ~(describe* @spec))))))\n\n(defn ^:skip-wiki nilable-impl\n  "Do not call this directly, use \'nilable\'"\n  [form pred gfn]\n  (let [spec (delay (specize pred form))]\n    (reify\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ x] (if (nil? x) nil (conform* @spec x)))\n      (unform* [_ x] (if (nil? x) nil (unform* @spec x)))\n      (explain* [_ path via in x]\n        (when-not (c/or (pvalid? @spec x) (nil? x))\n          (conj\n            (explain-1 form pred (conj path ::pred) via in x)\n            {:path (conj path ::nil) :pred \'nil? :val x :via via :in in})))\n      (gen* [_ overrides path rmap]\n        (if gfn\n          (gfn)\n          (gen/frequency\n            [[1 (gen/delay (gen/return nil))]\n             [9 (gen/delay (gensub pred overrides (conj path ::pred) rmap form))]])))\n      (with-gen* [_ gfn] (nilable-impl form pred gfn))\n      (describe* [_] `(nilable ~(s/mres form))))))\n\n(defn exercise\n  "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen"\n  ([spec] (exercise spec 10))\n  ([spec n] (exercise spec n nil))\n  ([spec n overrides]\n   (map #(vector % (conform spec %)) (gen/sample (gen spec overrides) n))))\n\n(defn inst-in-range?\n  "Return true if inst at or after start and before end"\n  [start end inst]\n  (c/and (inst? inst)\n         (let [t (inst-ms inst)]\n           (c/and (\x3c\x3d (inst-ms start) t) (\x3c t (inst-ms end))))))\n\n(defn int-in-range?\n  "Return true if start \x3c\x3d val, val \x3c end and val is a fixed\n  precision integer."\n  [start end val]\n  (cond\n    (integer? val) (c/and (\x3c\x3d start val) (\x3c val end))\n\n    (instance? goog.math.Long val)\n    (c/and (.lessThanOrEqual start val)\n           (.lessThan val end))\n\n    (instance? goog.math.Integer val)\n    (c/and (.lessThanOrEqual start val)\n           (.lessThan val end))\n\n    :else false))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; assert ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defonce\n  ^{:dynamic true\n    :doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See \'assert\'.\nInitially set to the negation of the \':elide-asserts\' compiler option.\nDefaults to true."}\n  *compile-asserts*\n  (s/init-compile-asserts))\n\n(defonce ^{:private true\n           :dynamic true}\n  *runtime-asserts*\n  false)\n\n(defn ^boolean check-asserts?\n  "Returns the value set by check-asserts."\n  []\n  *runtime-asserts*)\n\n(defn check-asserts\n  "Enable or disable spec asserts that have been compiled\nwith \'*compile-asserts*\' true.  See \'assert\'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false."\n  [^boolean flag]\n  (set! *runtime-asserts* flag))\n\n(defn assert*\n  "Do not call this directly, use \'assert\'."\n  [spec x]\n  (if (valid? spec x)\n    x\n    (let [ed (c/merge (assoc (explain-data* spec [] [] [] x)\n                        ::failure :assertion-failed))]\n      (throw (js/Error.\n              (str "Spec assertion failed\\n" (with-out-str (explain-out ed))))))))\n'],
null),new p(null,3,[Cl,"cljs/spec/gen/alpha.cljc",Xn,"cljs.spec.gen.alpha",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.gen.alpha\n  (:refer-clojure :exclude [delay])\n  (:require [cljs.core :as c]\n            [clojure.string :as string]))\n\n(defmacro dynaload [[quote s]]\n  `(cljs.spec.gen.alpha/LazyVar.\n     (fn []\n       (if (c/exists? ~s)\n         ~(vary-meta s assoc :cljs.analyzer/no-resolve true)\n         (throw\n           (js/Error.\n             (str "Var " \'~s " does not exist, "\n                  (namespace \'~s) " never required")))))\n     nil))\n\n(defmacro delay\n  "given body that returns a generator, returns a\n  generator that delegates to that, but delays\n  creation until used."\n  [\x26 body]\n  `(delay-impl (c/delay ~@body)))\n\n(defmacro ^:skip-wiki lazy-combinator\n  "Implementation macro, do not call directly."\n  [s]\n  (let [fqn (symbol "clojure.test.check.generators" (name s))\n        doc (str "Lazy loaded version of " fqn)]\n    `(let [g# (dynaload \'~fqn)]\n       (defn ~s\n         ~doc\n         [\x26 ~\'args]\n         (apply @g# ~\'args)))))\n\n(defmacro ^:skip-wiki lazy-combinators\n  "Implementation macro, do not call directly."\n  [\x26 syms]\n  `(do\n     ~@(map\n         (fn [s] (list `lazy-combinator s))\n         syms)))\n\n(defmacro ^:skip-wiki lazy-prim\n  "Implementation macro, do not call directly."\n  [s]\n  (let [fqn (symbol "clojure.test.check.generators" (name s))\n        doc (str "Fn returning " fqn)]\n    `(let [g# (dynaload \'~fqn)]\n       (defn ~s\n         ~doc\n         [\x26 ~\'args]\n         @g#))))\n\n(defmacro ^:skip-wiki lazy-prims\n  "Implementation macro, do not call directly."\n  [\x26 syms]\n  `(do\n     ~@(map\n         (fn [s] (list `lazy-prim s))\n         syms)))'],
null),new p(null,3,[Cl,"cljs/reader.cljs",Xn,"cljs.reader",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.reader\n  (:require-macros [cljs.reader :refer [add-data-readers]])\n  (:require [goog.object :as gobject]\n            [cljs.tools.reader :as treader]\n            [cljs.tools.reader.edn :as edn])\n  (:import [goog.string StringBuffer]))\n\n(defn ^:private zero-fill-right-and-truncate [s width]\n  (cond\n    (\x3d width (count s)) s\n    (\x3c width (count s)) (subs s 0 width)\n    :else\n    (loop [b (StringBuffer. s)]\n      (if (\x3c (.getLength b) width)\n        (recur (.append b "0"))\n        (.toString b)))))\n\n(defn ^:private divisible?\n  [num div]\n  (zero? (mod num div)))\n\n(defn ^:private indivisible?\n  [num div]\n  (not (divisible? num div)))\n\n(defn ^:private leap-year?\n  [year]\n  (and (divisible? year 4)\n       (or (indivisible? year 100)\n           (divisible? year 400))))\n\n(def ^:private days-in-month\n  (let [dim-norm [nil 31 28 31 30 31 30 31 31 30 31 30 31]\n        dim-leap [nil 31 29 31 30 31 30 31 31 30 31 30 31]]\n    (fn [month leap-year?]\n      (get (if leap-year? dim-leap dim-norm) month))))\n\n(def ^:private timestamp-regex #"(\\d\\d\\d\\d)(?:-(\\d\\d)(?:-(\\d\\d)(?:[T](\\d\\d)(?::(\\d\\d)(?::(\\d\\d)(?:[.](\\d+))?)?)?)?)?)?(?:[Z]|([-+])(\\d\\d):(\\d\\d))?")\n\n(defn ^:private parse-int [s]\n  (let [n (js/parseInt s 10)]\n    (if-not (js/isNaN n)\n      n)))\n\n(defn ^:private check [low n high msg]\n  (when-not (\x3c\x3d low n high)\n    (throw (js/Error. (str msg " Failed:  " low "\x3c\x3d" n "\x3c\x3d" high))))\n  n)\n\n(defn parse-and-validate-timestamp [s]\n  (let [[_ years months days hours minutes seconds fraction offset-sign offset-hours offset-minutes :as v]\n        (re-matches timestamp-regex s)]\n    (if-not v\n      (throw (js/Error. (str "Unrecognized date/time syntax: " s)))\n      (let [years (parse-int years)\n            months (or (parse-int months) 1)\n            days (or (parse-int days) 1)\n            hours (or (parse-int hours) 0)\n            minutes (or (parse-int minutes) 0)\n            seconds (or (parse-int seconds) 0)\n            fraction (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n            offset-sign (if (\x3d offset-sign "-") -1 1)\n            offset-hours (or (parse-int offset-hours) 0)\n            offset-minutes (or (parse-int offset-minutes) 0)\n            offset (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n        [years\n         (check 1 months 12 "timestamp month field must be in range 1..12")\n         (check 1 days (days-in-month months (leap-year? years)) "timestamp day field must be in range 1..last day in month")\n         (check 0 hours 23 "timestamp hour field must be in range 0..23")\n         (check 0 minutes 59 "timestamp minute field must be in range 0..59")\n         (check 0 seconds (if (\x3d minutes 59) 60 59) "timestamp second field must be in range 0..60")\n         (check 0 fraction 999 "timestamp millisecond field must be in range 0..999")\n         offset]))))\n\n(defn parse-timestamp\n  [ts]\n  (if-let [[years months days hours minutes seconds ms offset]\n           (parse-and-validate-timestamp ts)]\n    (js/Date.\n      (- (.UTC js/Date years (dec months) days hours minutes seconds ms)\n        (* offset 60 1000)))\n    (throw (js/Error. (str "Unrecognized date/time syntax: " ts)))))\n\n(defn ^:private read-date\n  [s]\n  (if (string? s)\n    (parse-timestamp s)\n    (throw (js/Error. "Instance literal expects a string for its timestamp."))))\n\n(defn ^:private read-queue\n  [elems]\n  (if (vector? elems)\n    (into cljs.core/PersistentQueue.EMPTY elems)\n    (throw (js/Error. "Queue literal expects a vector for its elements."))))\n\n(defn ^:private read-js\n  [form]\n  (cond\n    (vector? form)\n    (let [arr (array)]\n      (doseq [x form]\n        (.push arr x))\n      arr)\n\n    (map? form)\n    (let [obj (js-obj)]\n      (doseq [[k v] form]\n        (gobject/set obj (name k) v))\n      obj)\n\n    :else\n    (throw\n      (js/Error.\n        (str "JS literal expects a vector or map containing "\n             "only string or unqualified keyword keys")))))\n\n(defn ^:private read-uuid\n  [uuid]\n  (if (string? uuid)\n    (cljs.core/uuid uuid)\n    (throw (js/Error. "UUID literal expects a string as its representation."))))\n\n(def ^:dynamic *default-data-reader-fn*\n  (atom nil))\n\n(def ^:dynamic *tag-table*\n  (atom\n    (add-data-readers\n      {\'inst  read-date\n       \'uuid  read-uuid\n       \'queue read-queue\n       \'js    read-js})))\n\n(defn read\n  "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.tools.reader.edn/read doesn\'t depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value."\n  ([reader]\n   (edn/read\n     {:readers @*tag-table*\n      :default @*default-data-reader-fn*\n      :eof nil}\n     reader))\n  ([{:keys [eof] :as opts} reader]\n   (edn/read\n     (update (merge opts {:default @*default-data-reader-fn*})\n       :readers (fn [m] (merge @*tag-table* m))) reader))\n  ([reader eof-error? eof opts]\n   (edn/read reader eof-error? eof\n     (update (merge opts {:default @*default-data-reader-fn*})\n       :readers (fn [m] (merge @*tag-table* m))))))\n\n(defn read-string\n  "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.tools.reader.edn/read"\n  ([s]\n   (edn/read-string\n     {:readers @*tag-table*\n      :default @*default-data-reader-fn*\n      :eof nil} s))\n  ([opts s]\n   (edn/read-string\n     (update (merge {:default @*default-data-reader-fn*} opts)\n       :readers (fn [m] (merge @*tag-table* m))) s)))\n\n(defn register-tag-parser!\n  [tag f]\n  (let [old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* assoc tag f)\n    old-parser))\n\n(defn deregister-tag-parser!\n  [tag]\n  (let [old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* dissoc tag)\n    old-parser))\n\n(defn register-default-tag-parser!\n  [f]\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] f))\n    old-parser))\n\n(defn deregister-default-tag-parser!\n  []\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] nil))\n    old-parser))\n'],
null),new p(null,3,[Cl,"cljs/repl.cljs",Xn,"cljs.repl",nr,';; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.repl\n  (:require-macros cljs.repl)\n  (:require [cljs.spec.alpha :as spec]\n            [goog.string :as gstring]\n            [goog.string.format]))\n\n(defn print-doc [{n :ns nm :name :as m}]\n  (println "-------------------------")\n  (println (or (:spec m) (str (when-let [ns (:ns m)] (str ns "/")) (:name m))))\n  (when (:protocol m)\n    (println "Protocol"))\n  (cond\n    (:forms m) (doseq [f (:forms m)]\n                 (println "  " f))\n    (:arglists m) (let [arglists (:arglists m)]\n                    (if (or (:macro m)\n                         (:repl-special-function m))\n                     (prn arglists)\n                     (prn\n                       (if (\x3d \'quote (first arglists))\n                         (second arglists)\n                         arglists)))))\n  (if (:special-form m)\n    (do\n      (println "Special Form")\n      (println " " (:doc m))\n      (if (contains? m :url)\n        (when (:url m)\n          (println (str "\\n  Please see http://clojure.org/" (:url m))))\n        (println (str "\\n  Please see http://clojure.org/special_forms#"\n                   (:name m)))))\n    (do\n      (when (:macro m)\n        (println "Macro"))\n      (when (:spec m)\n        (println "Spec"))\n      (when (:repl-special-function m)\n        (println "REPL Special Function"))\n      (println " " (:doc m))\n      (when (:protocol m)\n        (doseq [[name {:keys [doc arglists]}] (:methods m)]\n          (println)\n          (println " " name)\n          (println " " arglists)\n          (when doc\n            (println " " doc))))\n      (when n\n        (when-let [fnspec (spec/get-spec (symbol (str (ns-name n)) (name nm)))]\n          (print "Spec")\n          (doseq [role [:args :ret :fn]]\n            (when-let [spec (get fnspec role)]\n              (print (str "\\n " (name role) ":") (spec/describe spec)))))))))\n\n(defn Error-\x3emap\n  "Constructs a data representation for a Error with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements"\n  [o]\n  (let [base (fn [t]\n               (merge {:type (cond\n                               (instance? ExceptionInfo t) \'ExceptionInfo\n                               (instance? js/EvalError t) \'js/EvalError\n                               (instance? js/RangeError t) \'js/RangeError\n                               (instance? js/ReferenceError t) \'js/ReferenceError\n                               (instance? js/SyntaxError t) \'js/SyntaxError\n                               (instance? js/URIError t) \'js/URIError\n                               (instance? js/Error t) \'js/Error\n                               :else nil)}\n                 (when-let [msg (ex-message t)]\n                   {:message msg})\n                 (when-let [ed (ex-data t)]\n                   {:data ed})\n                 #_(let [st (extract-canonical-stacktrace t)]\n                   (when (pos? (count st))\n                     {:at st}))))\n        via (loop [via [], t o]\n              (if t\n                (recur (conj via t) (ex-cause t))\n                via))\n        root (peek via)]\n    (merge {:via   (vec (map base via))\n            :trace nil #_(extract-canonical-stacktrace (or root o))}\n      (when-let [root-msg (ex-message root)]\n        {:cause root-msg})\n      (when-let [data (ex-data root)]\n        {:data data})\n      (when-let [phase (-\x3e o ex-data :clojure.error/phase)]\n        {:phase phase}))))\n\n(defn ex-triage\n  "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable-\x3emap. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error"\n  [datafied-throwable]\n  (let [{:keys [via trace phase] :or {phase :execution}} datafied-throwable\n        {:keys [type message data]} (last via)\n        {:cljs.spec.alpha/keys [problems fn] :cljs.spec.test.alpha/keys [caller]} data\n        {:keys [:clojure.error/source] :as top-data} (:data (first via))]\n    (assoc\n     (case phase\n       :read-source\n       (let [{:keys [:clojure.error/line :clojure.error/column]} data]\n         (cond-\x3e (merge (-\x3e via second :data) top-data)\n           source (assoc :clojure.error/source source)\n           (#{"NO_SOURCE_FILE" "NO_SOURCE_PATH"} source) (dissoc :clojure.error/source)\n           message (assoc :clojure.error/cause message)))\n\n       (:compile-syntax-check :compilation :macro-syntax-check :macroexpansion)\n       (cond-\x3e top-data\n         source (assoc :clojure.error/source source)\n         (#{"NO_SOURCE_FILE" "NO_SOURCE_PATH"} source) (dissoc :clojure.error/source)\n         type (assoc :clojure.error/class type)\n         message (assoc :clojure.error/cause message)\n         problems (assoc :clojure.error/spec data))\n\n       (:read-eval-result :print-eval-result)\n       (let [[source method file line] (-\x3e trace first)]\n         (cond-\x3e top-data\n           line (assoc :clojure.error/line line)\n           file (assoc :clojure.error/source file)\n           (and source method) (assoc :clojure.error/symbol (vector #_java-loc-\x3esource source method))\n           type (assoc :clojure.error/class type)\n           message (assoc :clojure.error/cause message)))\n\n       :execution\n       (let [[source method file line] (-\x3e\x3e trace #_(drop-while #(core-class? (name (first %)))) first)\n             file (first (remove #(or (nil? %) (#{"NO_SOURCE_FILE" "NO_SOURCE_PATH"} %)) [(:file caller) file]))\n             err-line (or (:line caller) line)]\n         (cond-\x3e {:clojure.error/class type}\n           err-line (assoc :clojure.error/line err-line)\n           message (assoc :clojure.error/cause message)\n           (or fn (and source method)) (assoc :clojure.error/symbol (or fn (vector #_java-loc-\x3esource source method)))\n           file (assoc :clojure.error/source file)\n           problems (assoc :clojure.error/spec data))))\n      :clojure.error/phase phase)))\n\n(defn ex-str\n  "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause."\n  [{:clojure.error/keys [phase source line column symbol class cause spec] :as triage-data}]\n  (let [loc          (str (or source "\x3ccljs repl\x3e") ":" (or line 1) (if column (str ":" column) ""))\n        class-name   (name (or class ""))\n        simple-class class-name\n        cause-type   (if (contains? #{"Exception" "RuntimeException"} simple-class)\n                       ""                                   ;; omit, not useful\n                       (str " (" simple-class ")"))\n        format       gstring/format]\n    (case phase\n      :read-source\n      (format "Syntax error reading source at (%s).\\n%s\\n" loc cause)\n\n      :macro-syntax-check\n      (format "Syntax error macroexpanding %sat (%s).\\n%s"\n        (if symbol (str symbol " ") "")\n        loc\n        (if spec\n          (with-out-str\n            (spec/explain-out\n              (if true #_(\x3d s/*explain-out* s/explain-printer)\n                (update spec ::spec/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec)))\n          (format "%s\\n" cause)))\n\n      :macroexpansion\n      (format "Unexpected error%s macroexpanding %sat (%s).\\n%s\\n"\n        cause-type\n        (if symbol (str symbol " ") "")\n        loc\n        cause)\n\n      :compile-syntax-check\n      (format "Syntax error%s compiling %sat (%s).\\n%s\\n"\n        cause-type\n        (if symbol (str symbol " ") "")\n        loc\n        cause)\n\n      :compilation\n      (format "Unexpected error%s compiling %sat (%s).\\n%s\\n"\n        cause-type\n        (if symbol (str symbol " ") "")\n        loc\n        cause)\n\n      :read-eval-result\n      (format "Error reading eval result%s at %s (%s).\\n%s\\n" cause-type symbol loc cause)\n\n      :print-eval-result\n      (format "Error printing return value%s at %s (%s).\\n%s\\n" cause-type symbol loc cause)\n\n      :execution\n      (if spec\n        (format "Execution error - invalid arguments to %s at (%s).\\n%s"\n          symbol\n          loc\n          (with-out-str\n            (spec/explain-out\n              (if true #_(\x3d s/*explain-out* s/explain-printer)\n                (update spec ::spec/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec))))\n        (format "Execution error%s at %s(%s).\\n%s\\n"\n          cause-type\n          (if symbol (str symbol " ") "")\n          loc\n          cause)))))\n\n(defn error-\x3estr [error]\n  (ex-str (ex-triage (Error-\x3emap error))))\n'],
null),new p(null,3,[Cl,"clojure/test/check.cljc",Xn,"clojure.test.check",nr,';   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check\n  (:require [clojure.test.check.generators :as gen]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.results :as results]\n            [clojure.test.check.rose-tree :as rose]\n            [clojure.test.check.impl :refer [get-current-time-millis]]))\n\n(declare shrink-loop failure)\n\n(defn- make-rng\n  [seed]\n  (if seed\n    [seed (random/make-random seed)]\n    (let [non-nil-seed (get-current-time-millis)]\n      [non-nil-seed (random/make-random non-nil-seed)])))\n\n(defn- complete\n  [property num-trials seed start-time reporter-fn]\n  (let [time-elapsed-ms (- (get-current-time-millis) start-time)]\n    (reporter-fn {:type :complete\n                  :property property\n                  :result true\n                  :pass? true\n                  :num-tests num-trials\n                  :time-elapsed-ms time-elapsed-ms\n                  :seed seed})\n    {:result true\n     :pass? true\n     :num-tests num-trials\n     :time-elapsed-ms time-elapsed-ms\n     :seed seed}))\n\n\n(defn ^:private legacy-result\n  "Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."\n  [result]\n  (if (satisfies? results/Result result)\n    (let [d (results/result-data result)]\n      (if-let [[_ e] (find d :clojure.test.check.properties/error)]\n        #?(:clj e\n           :cljs (if (instance? js/Error e)\n                   e\n                   (ex-info "Non-Error object thrown in test"\n                            {}\n                            e)))\n        (results/pass? result)))\n    result))\n\n(defn quick-check\n  "Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the \'size\' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       \x3cnumber of tests run so far\x3e\n       :num-tests-total \x3ctotal number of tests to be run\x3e\n       :seed            42\n       :pass?           true\n       :property        #\x3c...\x3e\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    \x3ctests ran before failure found\x3e\n       :pass?        false\n       :property     #\x3c...\x3e\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (\x3e (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (\x3d :failure (:type m))\n                                    (println \\"Uh oh...\\"))))"\n  [num-tests property \x26 {:keys [seed max-size reporter-fn]\n                         :or {max-size 200, reporter-fn (constantly nil)}}]\n  (let [[created-seed rng] (make-rng seed)\n        size-seq (gen/make-size-range-seq max-size)\n        start-time (get-current-time-millis)]\n    (loop [so-far 0\n           size-seq size-seq\n           rstate rng]\n      (if (\x3d\x3d so-far num-tests)\n        (complete property num-tests created-seed start-time reporter-fn)\n        (let [[size \x26 rest-size-seq] size-seq\n              [r1 r2] (random/split rstate)\n              result-map-rose (gen/call-gen property r1 size)\n              result-map (rose/root result-map-rose)\n              result (:result result-map)\n              args (:args result-map)\n              so-far (inc so-far)]\n          (if (results/pass? result)\n            (do\n              (reporter-fn {:type            :trial\n                            :args            args\n                            :num-tests       so-far\n                            :num-tests-total num-tests\n                            :pass?           true\n                            :property        property\n                            :result          result\n                            :result-data     (results/result-data result)\n                            :seed            seed})\n              (recur so-far rest-size-seq r2))\n            (failure property result-map-rose so-far size\n                     created-seed start-time reporter-fn)))))))\n\n(defn- smallest-shrink\n  [total-nodes-visited depth smallest start-time]\n  (let [{:keys [result]} smallest]\n    {:total-nodes-visited total-nodes-visited\n     :depth depth\n     :pass? false\n     :result (legacy-result result)\n     :result-data (results/result-data result)\n     :time-shrinking-ms (- (get-current-time-millis) start-time)\n     :smallest (:args smallest)}))\n\n(defn- shrink-loop\n  "Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."\n  [rose-tree reporter-fn]\n  (let [start-time (get-current-time-millis)\n        shrinks-this-depth (rose/children rose-tree)]\n    (loop [nodes shrinks-this-depth\n           current-smallest (rose/root rose-tree)\n           total-nodes-visited 0\n           depth 0]\n      (if (empty? nodes)\n        (smallest-shrink total-nodes-visited depth current-smallest start-time)\n        (let [;; can\'t destructure here because that could force\n              ;; evaluation of (second nodes)\n              head (first nodes)\n              tail (rest nodes)\n              result (:result (rose/root head))\n              args (:args (rose/root head))\n              pass? (results/pass? result)\n              reporter-fn-arg {:type :shrink-step\n                               :shrinking {:args                args\n                                           :depth               depth\n                                           :pass?               (boolean pass?)\n                                           :result              result\n                                           :result-data         (results/result-data result)\n                                           :smallest            (:args current-smallest)\n                                           :total-nodes-visited total-nodes-visited}}]\n          (if pass?\n            ;; this node passed the test, so now try testing its right-siblings\n            (do\n              (reporter-fn reporter-fn-arg)\n              (recur tail current-smallest (inc total-nodes-visited) depth))\n            ;; this node failed the test, so check if it has children,\n            ;; if so, traverse down them. If not, save this as the best example\n            ;; seen now and then look at the right-siblings\n            ;; children\n            (let [new-smallest (rose/root head)]\n              (reporter-fn (assoc-in reporter-fn-arg\n                                     [:shrinking :smallest]\n                                     (:args new-smallest)))\n              (if-let [children (seq (rose/children head))]\n                (recur children new-smallest (inc total-nodes-visited) (inc depth))\n                (recur tail new-smallest (inc total-nodes-visited) depth)))))))))\n\n(defn- failure\n  [property failing-rose-tree trial-number size seed start-time reporter-fn]\n  (let [failed-after-ms (- (get-current-time-millis) start-time)\n        root (rose/root failing-rose-tree)\n        result (:result root)\n        failure-data {:fail            (:args root)\n                      :failing-size    size\n                      :num-tests       trial-number\n                      :pass?           false\n                      :property        property\n                      :result          (legacy-result result)\n                      :result-data     (results/result-data result)\n                      :failed-after-ms failed-after-ms\n                      :seed            seed}]\n\n    (reporter-fn (assoc failure-data :type :failure))\n\n    (let [shrunk (shrink-loop failing-rose-tree\n                              #(reporter-fn (merge failure-data %)))]\n      (reporter-fn (assoc failure-data\n                          :type :shrunk\n                          :shrunk shrunk))\n      (-\x3e failure-data\n          (dissoc :property)\n          (assoc :shrunk shrunk)))))\n'],
null),new p(null,3,[Cl,"cljs/pprint.cljs",Xn,"cljs.pprint",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.pprint\n  (:refer-clojure :exclude [deftype print println pr prn float?])\n  (:require-macros\n    [cljs.pprint :as m :refer [with-pretty-writer getf setf deftype\n                               pprint-logical-block print-length-loop\n                               defdirectives formatter-out]])\n  (:require\n    [cljs.core :refer [IWriter IDeref]]\n    [clojure.string :as string]\n    [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; override print fns to use *out*\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn- print [\x26 more]\n  (-write *out* (apply print-str more)))\n\n(defn- println [\x26 more]\n  (apply print more)\n  (-write *out* \\newline))\n\n(defn- print-char [c]\n  (-write *out* (condp \x3d c\n                  \\backspace "\\\\backspace"\n                  \\tab "\\\\tab"\n                  \\newline "\\\\newline"\n                  \\formfeed "\\\\formfeed"\n                  \\return "\\\\return"\n                  \\" "\\\\\\""\n                  \\\\ "\\\\\\\\"\n                  (str "\\\\" c))))\n\n(defn- ^:dynamic pr [\x26 more]\n  (-write *out* (apply pr-str more)))\n\n(defn- prn [\x26 more]\n  (apply pr more)\n  (-write *out* \\newline))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; cljs specific utils\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn float?\n  "Returns true if n is an float."\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (not (\x3d\x3d (js/parseFloat n) (js/parseInt n 10)))))\n\n(defn char-code\n  "Convert char to int"\n  [c]\n  (cond\n    (number? c) c\n    (and (string? c) (\x3d\x3d (.-length c) 1)) (.charCodeAt c 0)\n    :else (throw (js/Error. "Argument to char must be a character or number"))))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Utilities\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn- map-passing-context [func initial-context lis]\n  (loop [context initial-context\n         lis lis\n         acc []]\n    (if (empty? lis)\n      [acc context]\n      (let [this (first lis)\n            remainder (next lis)\n            [result new-context] (apply func [this context])]\n        (recur new-context remainder (conj acc result))))))\n\n(defn- consume [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result new-context] (apply func [context])]\n      (if (not result)\n        [acc new-context]\n        (recur new-context (conj acc result))))))\n\n(defn- consume-while [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result continue new-context] (apply func [context])]\n      (if (not continue)\n        [acc context]\n        (recur new-context (conj acc result))))))\n\n(defn- unzip-map [m]\n  "Take a  map that has pairs in the value slots and produce a pair of maps,\n   the first having all the first elements of the pairs and the second all\n   the second elements of the pairs"\n  [(into {} (for [[k [v1 v2]] m] [k v1]))\n   (into {} (for [[k [v1 v2]] m] [k v2]))])\n\n(defn- tuple-map [m v1]\n  "For all the values, v, in the map, replace them with [v v1]"\n  (into {} (for [[k v] m] [k [v v1]])))\n\n(defn- rtrim [s c]\n  "Trim all instances of c from the end of sequence s"\n  (let [len (count s)]\n    (if (and (pos? len) (\x3d (nth s (dec (count s))) c))\n      (loop [n (dec len)]\n        (cond\n          (neg? n) ""\n          (not (\x3d (nth s n) c)) (subs s 0 (inc n))\n          true (recur (dec n))))\n      s)))\n\n(defn- ltrim [s c]\n  "Trim all instances of c from the beginning of sequence s"\n  (let [len (count s)]\n    (if (and (pos? len) (\x3d (nth s 0) c))\n      (loop [n 0]\n        (if (or (\x3d n len) (not (\x3d (nth s n) c)))\n          (subs s n)\n          (recur (inc n))))\n      s)))\n\n(defn- prefix-count [aseq val]\n  "Return the number of times that val occurs at the start of sequence aseq,\nif val is a seq itself, count the number of times any element of val occurs at the\nbeginning of aseq"\n  (let [test (if (coll? val) (set val) #{val})]\n    (loop [pos 0]\n      (if (or (\x3d pos (count aseq)) (not (test (nth aseq pos))))\n        pos\n        (recur (inc pos))))))\n\n;; Flush the pretty-print buffer without flushing the underlying stream\n(defprotocol IPrettyFlush\n  (-ppflush [pp]))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; column_writer.clj\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(def ^:dynamic ^{:private true} *default-page-width* 72)\n\n(defn- get-field [this sym]\n  (sym @@this))\n\n(defn- set-field [this sym new-val]\n  (swap! @this assoc sym new-val))\n\n(defn- get-column [this]\n  (get-field this :cur))\n\n(defn- get-line [this]\n  (get-field this :line))\n\n(defn- get-max-column [this]\n  (get-field this :max))\n\n(defn- set-max-column [this new-max]\n  (set-field this :max new-max)\n  nil)\n\n(defn- get-writer [this]\n  (get-field this :base))\n\n;; Why is the c argument an integer?\n(defn- c-write-char [this c]\n  (if (\x3d c \\newline)\n    (do\n      (set-field this :cur 0)\n      (set-field this :line (inc (get-field this :line))))\n    (set-field this :cur (inc (get-field this :cur))))\n  (-write (get-field this :base) c))\n\n(defn- column-writer\n  ([writer] (column-writer writer *default-page-width*))\n  ([writer max-columns]\n   (let [fields (atom {:max max-columns, :cur 0, :line 0 :base writer})]\n     (reify\n\n       IDeref\n       (-deref [_] fields)\n\n       IWriter\n       (-flush [_]\n         (-flush writer))\n       (-write\n         ;;-write isn\'t multi-arity, so need different way to do this\n         #_([this ^chars cbuf ^Number off ^Number len]\n          (let [writer (get-field this :base)]\n            (-write writer cbuf off len)))\n         [this x]\n         (condp \x3d (type x)\n           js/String\n           (let [s x\n                 nl (.lastIndexOf s \\newline)]\n             (if (neg? nl)\n               (set-field this :cur (+ (get-field this :cur) (count s)))\n               (do\n                 (set-field this :cur (- (count s) nl 1))\n                 (set-field this :line (+ (get-field this :line)\n                                          (count (filter #(\x3d % \\newline) s))))))\n             (-write (get-field this :base) s))\n           js/Number\n           (c-write-char this x)))))))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; pretty_writer.clj\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Forward declarations\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(declare ^{:arglists \'([this])} get-miser-width)\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; The data structures used by pretty-writer\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defrecord ^{:private true} logical-block\n  [parent section start-col indent\n   done-nl intra-block-nl\n   prefix per-line-prefix suffix\n   logical-block-callback])\n\n(defn- ancestor? [parent child]\n  (loop [child (:parent child)]\n    (cond\n      (nil? child) false\n      (identical? parent child) true\n      :else (recur (:parent child)))))\n\n(defn- buffer-length [l]\n  (let [l (seq l)]\n    (if l\n      (- (:end-pos (last l)) (:start-pos (first l)))\n      0)))\n\n;; A blob of characters (aka a string)\n(deftype buffer-blob :data :trailing-white-space :start-pos :end-pos)\n\n;; A newline\n(deftype nl-t :type :logical-block :start-pos :end-pos)\n\n(deftype start-block-t :logical-block :start-pos :end-pos)\n\n(deftype end-block-t :logical-block :start-pos :end-pos)\n\n(deftype indent-t :logical-block :relative-to :offset :start-pos :end-pos)\n\n(def ^:private pp-newline (fn [] "\\n"))\n\n(declare emit-nl)\n\n(defmulti ^{:private true} write-token #(:type-tag %2))\n\n(defmethod write-token :start-block-t [this token]\n  (when-let [cb (getf :logical-block-callback)] (cb :start))\n  (let [lb (:logical-block token)]\n    (when-let [prefix (:prefix lb)]\n      (-write (getf :base) prefix))\n    (let [col (get-column (getf :base))]\n      (reset! (:start-col lb) col)\n      (reset! (:indent lb) col))))\n\n(defmethod write-token :end-block-t [this token]\n  (when-let [cb (getf :logical-block-callback)] (cb :end))\n  (when-let [suffix (:suffix (:logical-block token))]\n    (-write (getf :base) suffix)))\n\n(defmethod write-token :indent-t [this token]\n  (let [lb (:logical-block token)]\n    (reset! (:indent lb)\n            (+ (:offset token)\n               (condp \x3d (:relative-to token)\n                 :block @(:start-col lb)\n                 :current (get-column (getf :base)))))))\n\n(defmethod write-token :buffer-blob [this token]\n  (-write (getf :base) (:data token)))\n\n(defmethod write-token :nl-t [this token]\n  (if (or (\x3d (:type token) :mandatory)\n          (and (not (\x3d (:type token) :fill))\n               @(:done-nl (:logical-block token))))\n    (emit-nl this token)\n    (if-let [tws (getf :trailing-white-space)]\n      (-write (getf :base) tws)))\n  (setf :trailing-white-space nil))\n\n(defn- write-tokens [this tokens force-trailing-whitespace]\n  (doseq [token tokens]\n    (if-not (\x3d (:type-tag token) :nl-t)\n      (if-let [tws (getf :trailing-white-space)]\n        (-write (getf :base) tws)))\n    (write-token this token)\n    (setf :trailing-white-space (:trailing-white-space token))\n    (let [tws (getf :trailing-white-space)]\n      (when (and force-trailing-whitespace tws)\n        (-write (getf :base) tws)\n        (setf :trailing-white-space nil)))))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; emit-nl? method defs for each type of new line. This makes\n;; the decision about whether to print this type of new line.\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn- tokens-fit? [this tokens]\n  (let [maxcol (get-max-column (getf :base))]\n    (or\n      (nil? maxcol)\n      (\x3c (+ (get-column (getf :base)) (buffer-length tokens)) maxcol))))\n\n(defn- linear-nl? [this lb section]\n  (or @(:done-nl lb)\n      (not (tokens-fit? this section))))\n\n(defn- miser-nl? [this lb section]\n  (let [miser-width (get-miser-width this)\n        maxcol (get-max-column (getf :base))]\n    (and miser-width maxcol\n         (\x3e\x3d @(:start-col lb) (- maxcol miser-width))\n         (linear-nl? this lb section))))\n\n(defmulti ^{:private true} emit-nl? (fn [t _ _ _] (:type t)))\n\n(defmethod emit-nl? :linear [newl this section _]\n  (let [lb (:logical-block newl)]\n    (linear-nl? this lb section)))\n\n(defmethod emit-nl? :miser [newl this section _]\n  (let [lb (:logical-block newl)]\n    (miser-nl? this lb section)))\n\n(defmethod emit-nl? :fill [newl this section subsection]\n  (let [lb (:logical-block newl)]\n    (or @(:intra-block-nl lb)\n        (not (tokens-fit? this subsection))\n        (miser-nl? this lb section))))\n\n(defmethod emit-nl? :mandatory [_ _ _ _]\n  true)\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Various support functions\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn- get-section [buffer]\n  (let [nl (first buffer)\n        lb (:logical-block nl)\n        section (seq (take-while #(not (and (nl-t? %) (ancestor? (:logical-block %) lb)))\n                                 (next buffer)))]\n    [section (seq (drop (inc (count section)) buffer))]))\n\n(defn- get-sub-section [buffer]\n  (let [nl (first buffer)\n        lb (:logical-block nl)\n        section (seq (take-while #(let [nl-lb (:logical-block %)]\n                                   (not (and (nl-t? %) (or (\x3d nl-lb lb) (ancestor? nl-lb lb)))))\n                                 (next buffer)))]\n    section))\n\n(defn- update-nl-state [lb]\n  (reset! (:intra-block-nl lb) true)\n  (reset! (:done-nl lb) true)\n  (loop [lb (:parent lb)]\n    (if lb\n      (do (reset! (:done-nl lb) true)\n          (reset! (:intra-block-nl lb) true)\n          (recur (:parent lb))))))\n\n(defn- emit-nl [this nl]\n  (-write (getf :base) (pp-newline))\n  (setf :trailing-white-space nil)\n  (let [lb (:logical-block nl)\n        prefix (:per-line-prefix lb)]\n    (if prefix\n      (-write (getf :base) prefix))\n    (let [istr (apply str (repeat (- @(:indent lb) (count prefix)) \\space))]\n      (-write (getf :base) istr))\n    (update-nl-state lb)))\n\n(defn- split-at-newline [tokens]\n  (let [pre (seq (take-while #(not (nl-t? %)) tokens))]\n    [pre (seq (drop (count pre) tokens))]))\n\n;; write-token-string is called when the set of tokens in the buffer\n;; is long than the available space on the line\n(defn- write-token-string [this tokens]\n  (let [[a b] (split-at-newline tokens)]\n    (if a (write-tokens this a false))\n    (if b\n      (let [[section remainder] (get-section b)\n            newl (first b)]\n        (let [do-nl (emit-nl? newl this section (get-sub-section b))\n              result (if do-nl\n                       (do\n                         (emit-nl this newl)\n                         (next b))\n                       b)\n              long-section (not (tokens-fit? this result))\n              result (if long-section\n                       (let [rem2 (write-token-string this section)]\n                         (if (\x3d rem2 section)\n                           (do ; If that didn\'t produce any output, it has no nls\n                             ; so we\'ll force it\n                             (write-tokens this section false)\n                             remainder)\n                           (into [] (concat rem2 remainder))))\n                       result)]\n          result)))))\n\n(defn- write-line [this]\n  (loop [buffer (getf :buffer)]\n    (setf :buffer (into [] buffer))\n    (if (not (tokens-fit? this buffer))\n      (let [new-buffer (write-token-string this buffer)]\n        (if-not (identical? buffer new-buffer)\n          (recur new-buffer))))))\n\n;; Add a buffer token to the buffer and see if it\'s time to start\n;; writing\n(defn- add-to-buffer [this token]\n  (setf :buffer (conj (getf :buffer) token))\n  (if (not (tokens-fit? this (getf :buffer)))\n    (write-line this)))\n\n;; Write all the tokens that have been buffered\n(defn- write-buffered-output [this]\n  (write-line this)\n  (if-let [buf (getf :buffer)]\n    (do\n      (write-tokens this buf true)\n      (setf :buffer []))))\n\n(defn- write-white-space [this]\n  (when-let [tws (getf :trailing-white-space)]\n    (-write (getf :base) tws)\n    (setf :trailing-white-space nil)))\n\n;;; If there are newlines in the string, print the lines up until the last newline,\n;;; making the appropriate adjustments. Return the remainder of the string\n(defn- write-initial-lines\n  [^Writer this ^String s]\n  (let [lines (string/split s "\\n" -1)]\n    (if (\x3d (count lines) 1)\n      s\n      (let [^String prefix (:per-line-prefix (first (getf :logical-blocks)))\n            ^String l (first lines)]\n        (if (\x3d :buffering (getf :mode))\n          (let [oldpos (getf :pos)\n                newpos (+ oldpos (count l))]\n            (setf :pos newpos)\n            (add-to-buffer this (make-buffer-blob l nil oldpos newpos))\n            (write-buffered-output this))\n          (do\n            (write-white-space this)\n            (-write (getf :base) l)))\n        (-write (getf :base) \\newline)\n        (doseq [^String l (next (butlast lines))]\n          (-write (getf :base) l)\n          (-write (getf :base) (pp-newline))\n          (if prefix\n            (-write (getf :base) prefix)))\n        (setf :buffering :writing)\n        (last lines)))))\n\n(defn- p-write-char [this c]\n  (if (\x3d (getf :mode) :writing)\n    (do\n      (write-white-space this)\n      (-write (getf :base) c))\n    (if (\x3d c \\newline)\n      (write-initial-lines this \\newline)\n      (let [oldpos (getf :pos)\n            newpos (inc oldpos)]\n        (setf :pos newpos)\n        (add-to-buffer this (make-buffer-blob (char c) nil oldpos newpos))))))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Initialize the pretty-writer instance\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn- pretty-writer [writer max-columns miser-width]\n  (let [lb (logical-block. nil nil (atom 0) (atom 0) (atom false) (atom false)\n                           nil nil nil nil)\n        ; NOTE: may want to just `specify!` #js { ... fields ... } with the protocols\n        fields (atom {:pretty-writer true\n                      :base (column-writer writer max-columns)\n                      :logical-blocks lb\n                      :sections nil\n                      :mode :writing\n                      :buffer []\n                      :buffer-block lb\n                      :buffer-level 1\n                      :miser-width miser-width\n                      :trailing-white-space nil\n                      :pos 0})]\n    (reify\n\n      IDeref\n      (-deref [_] fields)\n\n      IWriter\n      (-write [this x]\n        (condp \x3d (type x)\n          js/String\n          (let [s0 (write-initial-lines this x)\n                s (string/replace-first s0 #"\\s+$" "")\n                white-space (subs s0 (count s))\n                mode (getf :mode)]\n            (if (\x3d mode :writing)\n              (do\n                (write-white-space this)\n                (-write (getf :base) s)\n                (setf :trailing-white-space white-space))\n              (let [oldpos (getf :pos)\n                    newpos (+ oldpos (count s0))]\n                (setf :pos newpos)\n                (add-to-buffer this (make-buffer-blob s white-space oldpos newpos)))))\n          js/Number\n          (p-write-char this x)))\n      (-flush [this]\n        (-ppflush this)\n        (-flush (getf :base)))\n\n      IPrettyFlush\n      (-ppflush [this]\n        (if (\x3d (getf :mode) :buffering)\n          (do\n            (write-tokens this (getf :buffer) true)\n            (setf :buffer []))\n          (write-white-space this)))\n\n      )))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Methods for pretty-writer\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn- start-block\n  [this prefix per-line-prefix suffix]\n  (let [lb (logical-block. (getf :logical-blocks) nil (atom 0) (atom 0)\n                           (atom false) (atom false)\n                           prefix per-line-prefix suffix nil)]\n    (setf :logical-blocks lb)\n    (if (\x3d (getf :mode) :writing)\n      (do\n        (write-white-space this)\n        (when-let [cb (getf :logical-block-callback)] (cb :start))\n        (if prefix\n          (-write (getf :base) prefix))\n        (let [col (get-column (getf :base))]\n          (reset! (:start-col lb) col)\n          (reset! (:indent lb) col)))\n      (let [oldpos (getf :pos)\n            newpos (+ oldpos (if prefix (count prefix) 0))]\n        (setf :pos newpos)\n        (add-to-buffer this (make-start-block-t lb oldpos newpos))))))\n\n(defn- end-block [this]\n  (let [lb (getf :logical-blocks)\n        suffix (:suffix lb)]\n    (if (\x3d (getf :mode) :writing)\n      (do\n        (write-white-space this)\n        (if suffix\n          (-write (getf :base) suffix))\n        (when-let [cb (getf :logical-block-callback)] (cb :end)))\n      (let [oldpos (getf :pos)\n            newpos (+ oldpos (if suffix (count suffix) 0))]\n        (setf :pos newpos)\n        (add-to-buffer this (make-end-block-t lb oldpos newpos))))\n    (setf :logical-blocks (:parent lb))))\n\n(defn- nl [this type]\n  (setf :mode :buffering)\n  (let [pos (getf :pos)]\n    (add-to-buffer this (make-nl-t type (getf :logical-blocks) pos pos))))\n\n(defn- indent [this relative-to offset]\n  (let [lb (getf :logical-blocks)]\n    (if (\x3d (getf :mode) :writing)\n      (do\n        (write-white-space this)\n        (reset! (:indent lb)\n                (+ offset (condp \x3d relative-to\n                            :block @(:start-col lb)\n                            :current (get-column (getf :base))))))\n      (let [pos (getf :pos)]\n        (add-to-buffer this (make-indent-t lb relative-to offset pos pos))))))\n\n(defn- get-miser-width [this]\n  (getf :miser-width))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; pprint_base.clj\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Variables that control the pretty printer\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n;; *print-length*, *print-level*, *print-namespace-maps* and *print-dup* are defined in cljs.core\n(def ^:dynamic\n ^{:doc "Bind to true if you want write to use pretty printing"}\n *print-pretty* true)\n\n(defonce ^:dynamic\n ^{:doc "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify."\n   :added "1.2"}\n *print-pprint-dispatch* nil)\n\n(def ^:dynamic\n ^{:doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines.",\n   :added "1.2"}\n *print-right-margin* 72)\n\n(def ^:dynamic\n ^{:doc "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting.",\n   :added "1.2"}\n *print-miser-width* 40)\n\n;;; TODO implement output limiting\n(def ^:dynamic\n^{:private true,\n  :doc "Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)"}\n*print-lines* nil)\n\n;;; TODO: implement circle and shared\n(def ^:dynamic\n^{:private true,\n  :doc "Mark circular structures (N.B. This is not yet used)"}\n*print-circle* nil)\n\n;;; TODO: should we just use *print-dup* here?\n(def ^:dynamic\n^{:private true,\n  :doc "Mark repeated structures rather than repeat them (N.B. This is not yet used)"}\n*print-shared* nil)\n\n(def ^:dynamic\n^{:doc "Don\'t print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions"\n  :added "1.2"}\n*print-suppress-namespaces* nil)\n\n;;; TODO: support print-base and print-radix in cl-format\n;;; TODO: support print-base and print-radix in rationals\n(def ^:dynamic\n^{:doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* "\n  :added "1.2"}\n*print-radix* nil)\n\n(def ^:dynamic\n^{:doc "The base to use for printing integers and rationals."\n  :added "1.2"}\n*print-base* 10)\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Internal variables that keep track of where we are in the\n;; structure\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(def ^:dynamic ^{:private true} *current-level* 0)\n\n(def ^:dynamic ^{:private true} *current-length* nil)\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Support for the write function\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(declare ^{:arglists \'([n])} format-simple-number)\n\n;; This map causes var metadata to be included in the compiled output, even\n;; in advanced compilation. See CLJS-1853 - António Monteiro\n;; (def ^{:private true} write-option-table\n;;   {;:array            *print-array*\n;;    :base             #\'cljs.pprint/*print-base*,\n;;    ;;:case             *print-case*,\n;;    :circle           #\'cljs.pprint/*print-circle*,\n;;    ;;:escape           *print-escape*,\n;;    ;;:gensym           *print-gensym*,\n;;    :length           #\'cljs.core/*print-length*,\n;;    :level            #\'cljs.core/*print-level*,\n;;    :lines            #\'cljs.pprint/*print-lines*,\n;;    :miser-width      #\'cljs.pprint/*print-miser-width*,\n;;    :dispatch         #\'cljs.pprint/*print-pprint-dispatch*,\n;;    :pretty           #\'cljs.pprint/*print-pretty*,\n;;    :radix            #\'cljs.pprint/*print-radix*,\n;;    :readably         #\'cljs.core/*print-readably*,\n;;    :right-margin     #\'cljs.pprint/*print-right-margin*,\n;;    :suppress-namespaces #\'cljs.pprint/*print-suppress-namespaces*})\n\n(defn- table-ize [t m]\n  (apply hash-map (mapcat\n                    #(when-let [v (get t (key %))] [v (val %)])\n                    m)))\n\n(defn- pretty-writer?\n  "Return true iff x is a PrettyWriter"\n  [x] (and (satisfies? IDeref x) (:pretty-writer @@x)))\n\n(defn- make-pretty-writer\n  "Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width"\n  [base-writer right-margin miser-width]\n  (pretty-writer base-writer right-margin miser-width))\n\n(defn write-out\n  "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \\"write\\" interface. "\n  [object]\n  (let [length-reached (and *current-length*\n                            *print-length*\n                            (\x3e\x3d *current-length* *print-length*))]\n    (if-not *print-pretty*\n      (pr object)\n      (if length-reached\n        (-write *out* "...") ;;TODO could this (incorrectly) print ... on the next line?\n        (do\n          (if *current-length* (set! *current-length* (inc *current-length*)))\n          (*print-pprint-dispatch* object))))\n    length-reached))\n\n(defn write\n  "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * \x3d not yet supported\n"\n  [object \x26 kw-args]\n  (let [options (merge {:stream true} (apply hash-map kw-args))]\n    ;;TODO rewrite this as a macro\n    (binding [cljs.pprint/*print-base* (:base options cljs.pprint/*print-base*)\n              ;;:case             *print-case*,\n              cljs.pprint/*print-circle* (:circle options cljs.pprint/*print-circle*)\n              ;;:escape           *print-escape*\n              ;;:gensym           *print-gensym*\n              cljs.core/*print-length* (:length options cljs.core/*print-length*)\n              cljs.core/*print-level* (:level options cljs.core/*print-level*)\n              cljs.pprint/*print-lines* (:lines options cljs.pprint/*print-lines*)\n              cljs.pprint/*print-miser-width* (:miser-width options cljs.pprint/*print-miser-width*)\n              cljs.pprint/*print-pprint-dispatch* (:dispatch options cljs.pprint/*print-pprint-dispatch*)\n              cljs.pprint/*print-pretty* (:pretty options cljs.pprint/*print-pretty*)\n              cljs.pprint/*print-radix* (:radix options cljs.pprint/*print-radix*)\n              cljs.core/*print-readably* (:readably options cljs.core/*print-readably*)\n              cljs.pprint/*print-right-margin* (:right-margin options cljs.pprint/*print-right-margin*)\n              cljs.pprint/*print-suppress-namespaces* (:suppress-namespaces options cljs.pprint/*print-suppress-namespaces*)]\n      ;;TODO enable printing base\n      #_[bindings (if (or (not (\x3d *print-base* 10)) *print-radix*)\n                  {#\'pr pr-with-base}\n                  {})]\n      (binding []\n        (let [sb (StringBuffer.)\n              optval (if (contains? options :stream)\n                       (:stream options)\n                       true)\n              base-writer (if (or (true? optval) (nil? optval))\n                            (StringBufferWriter. sb)\n                            optval)]\n          (if *print-pretty*\n            (with-pretty-writer base-writer\n                                (write-out object))\n            (binding [*out* base-writer]\n              (pr object)))\n          (if (true? optval)\n            (string-print (str sb)))\n          (if (nil? optval)\n            (str sb)))))))\n\n(defn pprint\n  ([object]\n   (let [sb (StringBuffer.)]\n     (binding [*out* (StringBufferWriter. sb)]\n       (pprint object *out*)\n       (string-print (str sb)))))\n  ([object writer]\n   (with-pretty-writer writer\n                       (binding [*print-pretty* true]\n                         (write-out object))\n                       (if (not (\x3d 0 (get-column *out*)))\n                         (-write *out* \\newline)))))\n\n(defn set-pprint-dispatch\n  [function]\n  (set! *print-pprint-dispatch* function)\n  nil)\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Support for the functional interface to the pretty printer\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn- check-enumerated-arg [arg choices]\n  (if-not (choices arg)\n    ;; TODO clean up choices string\n    (throw (js/Error. (str "Bad argument: " arg ". It must be one of " choices)))))\n\n(defn- level-exceeded []\n  (and *print-level* (\x3e\x3d *current-level* *print-level*)))\n\n(defn pprint-newline\n  "Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer."\n  [kind]\n  (check-enumerated-arg kind #{:linear :miser :fill :mandatory})\n  (nl *out* kind))\n\n(defn pprint-indent\n  "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer."\n  [relative-to n]\n  (check-enumerated-arg relative-to #{:block :current})\n  (indent *out* relative-to n))\n\n;; TODO a real implementation for pprint-tab\n(defn pprint-tab\n  "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED."\n  {:added "1.2"}\n  [kind colnum colinc]\n  (check-enumerated-arg kind #{:line :section :line-relative :section-relative})\n  (throw (js/Error. "pprint-tab is not yet implemented")))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; cl_format.clj\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n;; Forward references\n(declare ^{:arglists \'([format-str])} compile-format)\n(declare ^{:arglists \'([stream format args] [format args])} execute-format)\n(declare ^{:arglists \'([s])} init-navigator)\n;; End forward references\n\n(defn cl-format\n  "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded \'format directives\'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \\"Common Lisp the\nLanguage, 2nd edition\\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm"\n  {:see-also [["http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000"\n               "Common Lisp the Language"]\n              ["http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm"\n               "Common Lisp HyperSpec"]]}\n  [writer format-in \x26 args]\n  (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n        navigator (init-navigator args)]\n    (execute-format writer compiled-format navigator)))\n\n(def ^:dynamic ^{:private true} *format-str* nil)\n\n(defn- format-error [message offset]\n  (let [full-message (str message \\newline *format-str* \\newline\n                          (apply str (repeat offset \\space)) "^" \\newline)]\n    (throw (js/Error full-message))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Argument navigators manage the argument list\n;; as the format statement moves through the list\n;; (possibly going forwards and backwards as it does so)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defrecord ^{:private true}\n  arg-navigator [seq rest pos])\n\n(defn- init-navigator\n  "Create a new arg-navigator from the sequence with the position set to 0"\n  {:skip-wiki true}\n  [s]\n  (let [s (seq s)]\n    (arg-navigator. s s 0)))\n\n;; TODO call format-error with offset\n(defn- next-arg [navigator]\n  (let [rst (:rest navigator)]\n    (if rst\n      [(first rst) (arg-navigator. (:seq navigator) (next rst) (inc (:pos navigator)))]\n      (throw (js/Error "Not enough arguments for format definition")))))\n\n(defn- next-arg-or-nil [navigator]\n  (let [rst (:rest navigator)]\n    (if rst\n      [(first rst) (arg-navigator. (:seq navigator) (next rst) (inc (:pos navigator)))]\n      [nil navigator])))\n\n;; Get an argument off the arg list and compile it if it\'s not already compiled\n(defn- get-format-arg [navigator]\n  (let [[raw-format navigator] (next-arg navigator)\n        compiled-format (if (string? raw-format)\n                          (compile-format raw-format)\n                          raw-format)]\n    [compiled-format navigator]))\n\n(declare relative-reposition)\n\n(defn- absolute-reposition [navigator position]\n  (if (\x3e\x3d position (:pos navigator))\n    (relative-reposition navigator (- (:pos navigator) position))\n    (arg-navigator. (:seq navigator) (drop position (:seq navigator)) position)))\n\n(defn- relative-reposition [navigator position]\n  (let [newpos (+ (:pos navigator) position)]\n    (if (neg? position)\n      (absolute-reposition navigator newpos)\n      (arg-navigator. (:seq navigator) (drop position (:rest navigator)) newpos))))\n\n(defrecord ^{:private true}\n  compiled-directive [func def params offset])\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; When looking at the parameter list, we may need to manipulate\n;; the argument list as well (for \'V\' and \'#\' parameter types).\n;; We hide all of this behind a function, but clients need to\n;; manage changing arg navigator\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO: validate parameters when they come from arg list\n(defn- realize-parameter [[param [raw-val offset]] navigator]\n  (let [[real-param new-navigator]\n        (cond\n          (contains? #{:at :colon} param) ;pass flags through unchanged - this really isn\'t necessary\n          [raw-val navigator]\n\n          (\x3d raw-val :parameter-from-args)\n          (next-arg navigator)\n\n          (\x3d raw-val :remaining-arg-count)\n          [(count (:rest navigator)) navigator]\n\n          true\n          [raw-val navigator])]\n    [[param [real-param offset]] new-navigator]))\n\n(defn- realize-parameter-list [parameter-map navigator]\n  (let [[pairs new-navigator]\n        (map-passing-context realize-parameter navigator parameter-map)]\n    [(into {} pairs) new-navigator]))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Functions that support individual directives\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Common handling code for ~A and ~S\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare ^{:arglists \'([base val])} opt-base-str)\n\n(def ^{:private true}\n  special-radix-markers {2 "#b" 8 "#o" 16 "#x"})\n\n(defn- format-simple-number [n]\n  (cond\n    (integer? n) (if (\x3d *print-base* 10)\n                   (str n (if *print-radix* "."))\n                   (str\n                     (if *print-radix* (or (get special-radix-markers *print-base*) (str "#" *print-base* "r")))\n                     (opt-base-str *print-base* n)))\n    ;;(ratio? n) ;;no ratio support\n    :else nil))\n\n(defn- format-ascii [print-func params arg-navigator offsets]\n  (let [[arg arg-navigator] (next-arg arg-navigator)\n        base-output (or (format-simple-number arg) (print-func arg))\n        base-width (.-length base-output)\n        min-width (+ base-width (:minpad params))\n        width (if (\x3e\x3d min-width (:mincol params))\n                min-width\n                (+ min-width\n                   (* (+ (quot (- (:mincol params) min-width 1)\n                               (:colinc params))\n                         1)\n                      (:colinc params))))\n        chars (apply str (repeat (- width base-width) (:padchar params)))]\n    (if (:at params)\n      (print (str chars base-output))\n      (print (str base-output chars)))\n    arg-navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for the integer directives ~D, ~X, ~O, ~B and some\n;; of ~R\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- integral?\n  "returns true if a number is actually an integer (that is, has no fractional part)"\n  [x]\n  (cond\n    (integer? x) true\n    ;;(decimal? x) ;;no decimal support\n    (float? x) (\x3d x (Math/floor x))\n    ;;(ratio? x) ;;no ratio support\n    :else false))\n\n(defn- remainders\n  "Return the list of remainders (essentially the \'digits\') of val in the given base"\n  [base val]\n  (reverse\n    (first\n      (consume #(if (pos? %)\n                 [(rem % base) (quot % base)]\n                 [nil nil])\n               val))))\n\n;; TODO: xlated-val does not seem to be used here.\n;; NB\n(defn- base-str\n  "Return val as a string in the given base"\n  [base val]\n  (if (zero? val)\n    "0"\n    (let [xlated-val (cond\n                       ;(float? val) (bigdec val) ;;No bigdec\n                       ;(ratio? val) nil ;;No ratio\n                       :else val)]\n      (apply str\n             (map\n               #(if (\x3c % 10) (char (+ (char-code \\0) %)) (char (+ (char-code \\a) (- % 10))))\n               (remainders base val))))))\n\n;;Not sure if this is accurate or necessary\n(def ^{:private true}\n  javascript-base-formats {8 "%o", 10 "%d", 16 "%x"})\n\n(defn- opt-base-str\n  "Return val as a string in the given base. No cljs format, so no improved performance."\n  [base val]\n  (base-str base val))\n\n(defn- group-by* [unit lis]\n  (reverse\n    (first\n      (consume (fn [x] [(seq (reverse (take unit x))) (seq (drop unit x))]) (reverse lis)))))\n\n(defn- format-integer [base params arg-navigator offsets]\n  (let [[arg arg-navigator] (next-arg arg-navigator)]\n    (if (integral? arg)\n      (let [neg (neg? arg)\n            pos-arg (if neg (- arg) arg)\n            raw-str (opt-base-str base pos-arg)\n            group-str (if (:colon params)\n                        (let [groups (map #(apply str %) (group-by* (:commainterval params) raw-str))\n                              commas (repeat (count groups) (:commachar params))]\n                          (apply str (next (interleave commas groups))))\n                        raw-str)\n            signed-str (cond\n                         neg (str "-" group-str)\n                         (:at params) (str "+" group-str)\n                         true group-str)\n            padded-str (if (\x3c (.-length signed-str) (:mincol params))\n                         (str (apply str (repeat (- (:mincol params) (.-length signed-str))\n                                                 (:padchar params)))\n                              signed-str)\n                         signed-str)]\n        (print padded-str))\n      (format-ascii print-str {:mincol (:mincol params) :colinc 1 :minpad 0\n                               :padchar (:padchar params) :at true}\n                    (init-navigator [arg]) nil))\n    arg-navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for english formats (~R and ~:R)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true}\n     english-cardinal-units\n     ["zero" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"\n      "ten" "eleven" "twelve" "thirteen" "fourteen"\n      "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"])\n\n(def ^{:private true}\n     english-ordinal-units\n     ["zeroth" "first" "second" "third" "fourth" "fifth" "sixth" "seventh" "eighth" "ninth"\n      "tenth" "eleventh" "twelfth" "thirteenth" "fourteenth"\n      "fifteenth" "sixteenth" "seventeenth" "eighteenth" "nineteenth"])\n\n(def ^{:private true}\n     english-cardinal-tens\n     ["" "" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"])\n\n(def ^{:private true}\n     english-ordinal-tens\n     ["" "" "twentieth" "thirtieth" "fortieth" "fiftieth"\n      "sixtieth" "seventieth" "eightieth" "ninetieth"])\n\n;; We use "short scale" for our units (see http://en.wikipedia.org/wiki/Long_and_short_scales)\n;; Number names from http://www.jimloy.com/math/billion.htm\n;; We follow the rules for writing numbers from the Blue Book\n;; (http://www.grammarbook.com/numbers/numbers.asp)\n(def ^{:private true}\n     english-scale-numbers\n     ["" "thousand" "million" "billion" "trillion" "quadrillion" "quintillion"\n      "sextillion" "septillion" "octillion" "nonillion" "decillion"\n      "undecillion" "duodecillion" "tredecillion" "quattuordecillion"\n      "quindecillion" "sexdecillion" "septendecillion"\n      "octodecillion" "novemdecillion" "vigintillion"])\n\n(defn- format-simple-cardinal\n  "Convert a number less than 1000 to a cardinal english string"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n      (if (pos? hundreds) (str (nth english-cardinal-units hundreds) " hundred"))\n      (if (and (pos? hundreds) (pos? tens)) " ")\n      (if (pos? tens)\n        (if (\x3c tens 20)\n          (nth english-cardinal-units tens)\n          (let [ten-digit (quot tens 10)\n                unit-digit (rem tens 10)]\n            (str\n              (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n              (if (and (pos? ten-digit) (pos? unit-digit)) "-")\n              (if (pos? unit-digit) (nth english-cardinal-units unit-digit)))))))))\n\n(defn- add-english-scales\n  "Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\n  offset is a factor of 10^3 to multiply by"\n  [parts offset]\n  (let [cnt (count parts)]\n    (loop [acc []\n           pos (dec cnt)\n           this (first parts)\n           remainder (next parts)]\n      (if (nil? remainder)\n        (str (apply str (interpose ", " acc))\n             (if (and (not (empty? this)) (not (empty? acc))) ", ")\n             this\n             (if (and (not (empty? this)) (pos? (+ pos offset)))\n               (str " " (nth english-scale-numbers (+ pos offset)))))\n        (recur\n          (if (empty? this)\n            acc\n            (conj acc (str this " " (nth english-scale-numbers (+ pos offset)))))\n          (dec pos)\n          (first remainder)\n          (next remainder))))))\n\n(defn- format-cardinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (\x3d 0 arg)\n      (print "zero")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs (is this true?)\n            parts (remainders 1000 abs-arg)]\n        (if (\x3c\x3d (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal parts)\n                full-str (add-english-scales parts-strs 0)]\n            (print (str (if (neg? arg) "minus ") full-str)))\n          (format-integer ;; for numbers \x3e 10^63, we fall back on ~D\n            10\n            {:mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n            (init-navigator [arg])\n            {:mincol 0, :padchar 0, :commachar 0 :commainterval 0}))))\n    navigator))\n\n(defn- format-simple-ordinal\n  "Convert a number less than 1000 to a ordinal english string\n  Note this should only be used for the last one in the sequence"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n      (if (pos? hundreds) (str (nth english-cardinal-units hundreds) " hundred"))\n      (if (and (pos? hundreds) (pos? tens)) " ")\n      (if (pos? tens)\n        (if (\x3c tens 20)\n          (nth english-ordinal-units tens)\n          (let [ten-digit (quot tens 10)\n                unit-digit (rem tens 10)]\n            (if (and (pos? ten-digit) (not (pos? unit-digit)))\n              (nth english-ordinal-tens ten-digit)\n              (str\n                (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n                (if (and (pos? ten-digit) (pos? unit-digit)) "-")\n                (if (pos? unit-digit) (nth english-ordinal-units unit-digit))))))\n        (if (pos? hundreds) "th")))))\n\n(defn- format-ordinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (\x3d 0 arg)\n      (print "zeroth")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs (is this true?)\n            parts (remainders 1000 abs-arg)]\n        (if (\x3c\x3d (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal (drop-last parts))\n                head-str (add-english-scales parts-strs 1)\n                tail-str (format-simple-ordinal (last parts))]\n            (print (str (if (neg? arg) "minus ")\n                        (cond\n                          (and (not (empty? head-str)) (not (empty? tail-str)))\n                          (str head-str ", " tail-str)\n\n                          (not (empty? head-str)) (str head-str "th")\n                          :else tail-str))))\n          (do (format-integer ;for numbers \x3e 10^63, we fall back on ~D\n                10\n                {:mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n                (init-navigator [arg])\n                {:mincol 0, :padchar 0, :commachar 0 :commainterval 0})\n              (let [low-two-digits (rem arg 100)\n                    not-teens (or (\x3c 11 low-two-digits) (\x3e 19 low-two-digits))\n                    low-digit (rem low-two-digits 10)]\n                (print (cond\n                         (and (\x3d\x3d low-digit 1) not-teens) "st"\n                         (and (\x3d\x3d low-digit 2) not-teens) "nd"\n                         (and (\x3d\x3d low-digit 3) not-teens) "rd"\n                         :else "th")))))))\n    navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for roman numeral formats (~@R and ~@:R)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true}\n     old-roman-table\n     [[ "I" "II" "III" "IIII" "V" "VI" "VII" "VIII" "VIIII"]\n      [ "X" "XX" "XXX" "XXXX" "L" "LX" "LXX" "LXXX" "LXXXX"]\n      [ "C" "CC" "CCC" "CCCC" "D" "DC" "DCC" "DCCC" "DCCCC"]\n      [ "M" "MM" "MMM"]])\n\n(def ^{:private true}\n     new-roman-table\n     [[ "I" "II" "III" "IV" "V" "VI" "VII" "VIII" "IX"]\n      [ "X" "XX" "XXX" "XL" "L" "LX" "LXX" "LXXX" "XC"]\n      [ "C" "CC" "CCC" "CD" "D" "DC" "DCC" "DCCC" "CM"]\n      [ "M" "MM" "MMM"]])\n\n(defn- format-roman\n  "Format a roman numeral using the specified look-up table"\n  [table params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (and (number? arg) (\x3e arg 0) (\x3c arg 4000))\n      (let [digits (remainders 10 arg)]\n        (loop [acc []\n               pos (dec (count digits))\n               digits digits]\n          (if (empty? digits)\n            (print (apply str acc))\n            (let [digit (first digits)]\n              (recur (if (\x3d 0 digit)\n                       acc\n                       (conj acc (nth (nth table pos) (dec digit))))\n                     (dec pos)\n                     (next digits))))))\n      (format-integer ; for anything \x3c\x3d 0 or \x3e 3999, we fall back on ~D\n        10\n        {:mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n        (init-navigator [arg])\n        {:mincol 0, :padchar 0, :commachar 0 :commainterval 0}))\n    navigator))\n\n(defn- format-old-roman [params navigator offsets]\n  (format-roman old-roman-table params navigator offsets))\n\n(defn- format-new-roman [params navigator offsets]\n  (format-roman new-roman-table params navigator offsets))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for character formats (~C)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true}\n     special-chars {8 "Backspace", 9 "Tab", 10 "Newline", 13 "Return", 32 "Space"})\n\n(defn- pretty-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)\n        as-int (char-code c)\n        base-char (bit-and as-int 127)\n        meta (bit-and as-int 128)\n        special (get special-chars base-char)]\n    (if (\x3e meta 0) (print "Meta-"))\n    (print (cond\n             special special\n             (\x3c base-char 32) (str "Control-" (char (+ base-char 64)))\n             (\x3d base-char 127) "Control-?"\n             :else (char base-char)))\n    navigator))\n\n(defn- readable-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)]\n    (condp \x3d (:char-format params)\n      \\o (cl-format true "\\\\o~3, \'0o" (char-code c))\n      \\u (cl-format true "\\\\u~4, \'0x" (char-code c))\n      nil (print-char c))\n    navigator))\n\n(defn- plain-character [params navigator offsets]\n  (let [[char navigator] (next-arg navigator)]\n    (print char)\n    navigator))\n\n;; Check to see if a result is an abort (~^) construct\n;; TODO: move these funcs somewhere more appropriate\n(defn- abort? [context]\n  (let [token (first context)]\n    (or (\x3d :up-arrow token) (\x3d :colon-up-arrow token))))\n\n;; Handle the execution of "sub-clauses" in bracket constructions\n(defn- execute-sub-format [format args base-args]\n  (second\n    (map-passing-context\n      (fn [element context]\n        (if (abort? context)\n          [nil context]    ; just keep passing it along\n          (let [[params args] (realize-parameter-list (:params element) context)\n                [params offsets] (unzip-map params)\n                params (assoc params :base-args base-args)]\n            [nil (apply (:func element) [params args offsets])])))\n      args\n      format)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for real number formats\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO - return exponent as int to eliminate double conversion\n(defn- float-parts-base\n  "Produce string parts for the mantissa (normalize 1-9) and exponent"\n  [f]\n  (let [s (string/lower-case (str f))\n        exploc (.indexOf s \\e)\n        dotloc (.indexOf s \\.)]\n    (if (neg? exploc)\n      (if (neg? dotloc)\n        [s (str (dec (count s)))]\n        [(str (subs s 0 dotloc) (subs s (inc dotloc))) (str (dec dotloc))])\n      (if (neg? dotloc)\n        [(subs s 0 exploc) (subs s (inc exploc))]\n        [(str (subs s 0 1) (subs s 2 exploc)) (subs s (inc exploc))]))))\n\n(defn- float-parts\n  "Take care of leading and trailing zeros in decomposed floats"\n  [f]\n  (let [[m e] (float-parts-base f)\n        m1 (rtrim m \\0)\n        m2 (ltrim m1 \\0)\n        delta (- (count m1) (count m2))\n        e (if (and (pos? (count e)) (\x3d (nth e 0) \\+)) (subs e 1) e)]\n    (if (empty? m2)\n      ["0" 0]\n      [m2 (- (js/parseInt e 10) delta)])))\n\n(defn- inc-s\n  "Assumption: The input string consists of one or more decimal digits,\n  and no other characters. Return a string containing one or more\n  decimal digits containing a decimal number one larger than the input\n  string. The output string will always be the same length as the input\n  string, or one character longer."\n  [s]\n  (let [len-1 (dec (count s))]\n    (loop [i (int len-1)]\n      (cond\n        (neg? i) (apply str "1" (repeat (inc len-1) "0"))\n        (\x3d \\9 (.charAt s i)) (recur (dec i))\n        :else (apply str (subs s 0 i)\n                     (char (inc (char-code (.charAt s i))))\n                     (repeat (- len-1 i) "0"))))))\n\n(defn- round-str [m e d w]\n  (if (or d w)\n    (let [len (count m)\n          ;; Every formatted floating point number should include at\n          ;; least one decimal digit and a decimal point.\n          w (if w (max 2 w)\n                  ;;NB: if w doesn\'t exist, it won\'t ever be used because d will\n                  ;; satisfy the cond below. cljs gives a compilation warning if\n                  ;; we don\'t provide a value here.\n                  0)\n          round-pos (cond\n                      ;; If d was given, that forces the rounding\n                      ;; position, regardless of any width that may\n                      ;; have been specified.\n                      d (+ e d 1)\n                      ;; Otherwise w was specified, so pick round-pos\n                      ;; based upon that.\n                      ;; If e\x3e\x3d0, then abs value of number is \x3e\x3d 1.0,\n                      ;; and e+1 is number of decimal digits before the\n                      ;; decimal point when the number is written\n                      ;; without scientific notation. Never round the\n                      ;; number before the decimal point.\n                      (\x3e\x3d e 0) (max (inc e) (dec w))\n                      ;; e \x3c 0, so number abs value \x3c 1.0\n                      :else (+ w e))\n          [m1 e1 round-pos len] (if (\x3d round-pos 0)\n                                  [(str "0" m) (inc e) 1 (inc len)]\n                                  [m e round-pos len])]\n      (if round-pos\n        (if (neg? round-pos)\n          ["0" 0 false]\n          (if (\x3e len round-pos)\n            (let [round-char (nth m1 round-pos)\n                  result (subs m1 0 round-pos)]\n              (if (\x3e\x3d (char-code round-char) (char-code \\5))\n                (let [round-up-result (inc-s result)\n                      expanded (\x3e (count round-up-result) (count result))]\n                  [(if expanded\n                     (subs round-up-result 0 (dec (count round-up-result)))\n                     round-up-result)\n                   e1 expanded])\n                [result e1 false]))\n            [m e false]))\n        [m e false]))\n    [m e false]))\n\n(defn- expand-fixed [m e d]\n  (let [[m1 e1] (if (neg? e)\n                  [(str (apply str (repeat (dec (- e)) \\0)) m) -1]\n                  [m e])\n        len (count m1)\n        target-len (if d (+ e1 d 1) (inc e1))]\n    (if (\x3c len target-len)\n      (str m1 (apply str (repeat (- target-len len) \\0)))\n      m1)))\n\n(defn- insert-decimal\n  "Insert the decimal point at the right spot in the number to match an exponent"\n  [m e]\n  (if (neg? e)\n    (str "." m)\n    (let [loc (inc e)]\n      (str (subs m 0 loc) "." (subs m loc)))))\n\n(defn- get-fixed [m e d]\n  (insert-decimal (expand-fixed m e d) e))\n\n(defn- insert-scaled-decimal\n  "Insert the decimal point at the right spot in the number to match an exponent"\n  [m k]\n  (if (neg? k)\n    (str "." m)\n    (str (subs m 0 k) "." (subs m k))))\n\n;;TODO: No ratio, so not sure what to do here\n(defn- convert-ratio [x]\n  x)\n\n;; the function to render ~F directives\n;; TODO: support rationals. Back off to ~D/~A in the appropriate cases\n(defn- fixed-float [params navigator offsets]\n  (let [w (:w params)\n        d (:d params)\n        [arg navigator] (next-arg navigator)\n        [sign abs] (if (neg? arg) ["-" (- arg)] ["+" arg])\n        abs (convert-ratio abs)\n        [mantissa exp] (float-parts abs)\n        scaled-exp (+ exp (:k params))\n        add-sign (or (:at params) (neg? arg))\n        append-zero (and (not d) (\x3c\x3d (dec (count mantissa)) scaled-exp))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa scaled-exp\n                                                          d (if w (- w (if add-sign 1 0))))\n        fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        fixed-repr (if (and w d\n                            (\x3e\x3d d 1)\n                            (\x3d (.charAt fixed-repr 0) \\0)\n                            (\x3d (.charAt fixed-repr 1) \\.)\n                            (\x3e (count fixed-repr) (- w (if add-sign 1 0))))\n                     (subs fixed-repr 1)    ;chop off leading 0\n                     fixed-repr)\n        prepend-zero (\x3d (first fixed-repr) \\.)]\n    (if w\n      (let [len (count fixed-repr)\n            signed-len (if add-sign (inc len) len)\n            prepend-zero (and prepend-zero (not (\x3e\x3d signed-len w)))\n            append-zero (and append-zero (not (\x3e\x3d signed-len w)))\n            full-len (if (or prepend-zero append-zero)\n                       (inc signed-len)\n                       signed-len)]\n        (if (and (\x3e full-len w) (:overflowchar params))\n          (print (apply str (repeat w (:overflowchar params))))\n          (print (str\n                   (apply str (repeat (- w full-len) (:padchar params)))\n                   (if add-sign sign)\n                   (if prepend-zero "0")\n                   fixed-repr\n                   (if append-zero "0")))))\n      (print (str\n               (if add-sign sign)\n               (if prepend-zero "0")\n               fixed-repr\n               (if append-zero "0"))))\n    navigator))\n\n;; the function to render ~E directives\n;; TODO: support rationals. Back off to ~D/~A in the appropriate cases\n;; TODO: define ~E representation for Infinity\n(defn- exponential-float [params navigator offset]\n  (let [[arg navigator] (next-arg navigator)\n        arg (convert-ratio arg)]\n    (loop [[mantissa exp] (float-parts (if (neg? arg) (- arg) arg))]\n      (let [w (:w params)\n            d (:d params)\n            e (:e params)\n            k (:k params)\n            expchar (or (:exponentchar params) \\E)\n            add-sign (or (:at params) (neg? arg))\n            prepend-zero (\x3c\x3d k 0)\n            scaled-exp (- exp (dec k))\n            scaled-exp-str (str (Math/abs scaled-exp))\n            scaled-exp-str (str expchar (if (neg? scaled-exp) \\- \\+)\n                                (if e (apply str\n                                             (repeat\n                                               (- e\n                                                  (count scaled-exp-str))\n                                               \\0)))\n                                scaled-exp-str)\n            exp-width (count scaled-exp-str)\n            base-mantissa-width (count mantissa)\n            scaled-mantissa (str (apply str (repeat (- k) \\0))\n                                 mantissa\n                                 (if d\n                                   (apply str\n                                          (repeat\n                                            (- d (dec base-mantissa-width)\n                                               (if (neg? k) (- k) 0)) \\0))))\n            w-mantissa (if w (- w exp-width))\n            [rounded-mantissa _ incr-exp] (round-str\n                                            scaled-mantissa 0\n                                            (cond\n                                              (\x3d k 0) (dec d)\n                                              (pos? k) d\n                                              (neg? k) (dec d))\n                                            (if w-mantissa\n                                              (- w-mantissa (if add-sign 1 0))))\n            full-mantissa (insert-scaled-decimal rounded-mantissa k)\n            append-zero (and (\x3d k (count rounded-mantissa)) (nil? d))]\n        (if (not incr-exp)\n          (if w\n            (let [len (+ (count full-mantissa) exp-width)\n                  signed-len (if add-sign (inc len) len)\n                  prepend-zero (and prepend-zero (not (\x3d signed-len w)))\n                  full-len (if prepend-zero (inc signed-len) signed-len)\n                  append-zero (and append-zero (\x3c full-len w))]\n              (if (and (or (\x3e full-len w) (and e (\x3e (- exp-width 2) e)))\n                       (:overflowchar params))\n                (print (apply str (repeat w (:overflowchar params))))\n                (print (str\n                         (apply str\n                                (repeat\n                                  (- w full-len (if append-zero 1 0))\n                                  (:padchar params)))\n                         (if add-sign (if (neg? arg) \\- \\+))\n                         (if prepend-zero "0")\n                         full-mantissa\n                         (if append-zero "0")\n                         scaled-exp-str))))\n            (print (str\n                     (if add-sign (if (neg? arg) \\- \\+))\n                     (if prepend-zero "0")\n                     full-mantissa\n                     (if append-zero "0")\n                     scaled-exp-str)))\n          (recur [rounded-mantissa (inc exp)]))))\n    navigator))\n\n;; the function to render ~G directives\n;; This just figures out whether to pass the request off to ~F or ~E based\n;; on the algorithm in CLtL.\n;; TODO: support rationals. Back off to ~D/~A in the appropriate cases\n;; TODO: refactor so that float-parts isn\'t called twice\n(defn- general-float [params navigator offsets]\n  (let [[arg _] (next-arg navigator)\n        arg (convert-ratio arg)\n        [mantissa exp] (float-parts (if (neg? arg) (- arg) arg))\n        w (:w params)\n        d (:d params)\n        e (:e params)\n        n (if (\x3d arg 0.0) 0 (inc exp))\n        ee (if e (+ e 2) 4)\n        ww (if w (- w ee))\n        d (if d d (max (count mantissa) (min n 7)))\n        dd (- d n)]\n    (if (\x3c\x3d 0 dd d)\n      (let [navigator (fixed-float {:w ww, :d dd, :k 0,\n                                    :overflowchar (:overflowchar params),\n                                    :padchar (:padchar params), :at (:at params)}\n                                   navigator offsets)]\n        (print (apply str (repeat ee \\space)))\n        navigator)\n      (exponential-float params navigator offsets))))\n\n;; the function to render ~$ directives\n;; TODO: support rationals. Back off to ~D/~A in the appropriate cases\n(defn- dollar-float [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)\n        [mantissa exp] (float-parts (Math/abs arg))\n        d (:d params)  ; digits after the decimal\n        n (:n params)  ; minimum digits before the decimal\n        w (:w params)  ; minimum field width\n        add-sign (or (:at params) (neg? arg))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa exp d nil)\n        fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        full-repr (str (apply str (repeat (- n (.indexOf fixed-repr \\.)) \\0)) fixed-repr)\n        full-len (+ (count full-repr) (if add-sign 1 0))]\n    (print (str\n             (if (and (:colon params) add-sign) (if (neg? arg) \\- \\+))\n             (apply str (repeat (- w full-len) (:padchar params)))\n             (if (and (not (:colon params)) add-sign) (if (neg? arg) \\- \\+))\n             full-repr))\n    navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for the \'~[...~]\' conditional construct in its\n;; different flavors\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; ~[...~] without any modifiers chooses one of the clauses based on the param or\n;; next argument\n;; TODO check arg is positive int\n(defn- choice-conditional [params arg-navigator offsets]\n  (let [arg (:selector params)\n        [arg navigator] (if arg [arg arg-navigator] (next-arg arg-navigator))\n        clauses (:clauses params)\n        clause (if (or (neg? arg) (\x3e\x3d arg (count clauses)))\n                 (first (:else params))\n                 (nth clauses arg))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))\n\n;; ~:[...~] with the colon reads the next argument treating it as a truth value\n(defn- boolean-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg\n                 (second clauses)\n                 (first clauses))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))\n\n;; ~@[...~] with the at sign executes the conditional if the next arg is not\n;; nil/false without consuming the arg\n(defn- check-arg-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg (first clauses))]\n    (if arg\n      (if clause\n        (execute-sub-format clause arg-navigator (:base-args params))\n        arg-navigator)\n      navigator)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for the \'~{...~}\' iteration construct in its\n;; different flavors\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; ~{...~} without any modifiers uses the next argument as an argument list that\n;; is consumed by all the iterations\n(defn- iterate-sublist [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])\n        [arg-list navigator] (next-arg navigator)\n        args (init-navigator arg-list)]\n    (loop [count 0\n           args args\n           last-pos (int -1)]\n      (if (and (not max-count) (\x3d (:pos args) last-pos) (\x3e count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (js/Error "%{ construct not consuming any arguments: Infinite loop!")))\n      (if (or (and (empty? (:rest args))\n                   (or (not (:colon (:right-params params))) (\x3e count 0)))\n              (and max-count (\x3e\x3d count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause args (:base-args params))]\n          (if (\x3d :up-arrow (first iter-result))\n            navigator\n            (recur (inc count) iter-result (:pos args))))))))\n\n;; ~:{...~} with the colon treats the next argument as a list of sublists. Each of the\n;; sublists is used as the arglist for a single iteration.\n(defn- iterate-list-of-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])\n        [arg-list navigator] (next-arg navigator)]\n    (loop [count 0\n           arg-list arg-list]\n      (if (or (and (empty? arg-list)\n                   (or (not (:colon (:right-params params))) (\x3e count 0)))\n              (and max-count (\x3e\x3d count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format\n                            clause\n                            (init-navigator (first arg-list))\n                            (init-navigator (next arg-list)))]\n          (if (\x3d :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) (next arg-list))))))))\n\n;; ~@{...~} with the at sign uses the main argument list as the arguments to the iterations\n;; is consumed by all the iterations\n(defn- iterate-main-list [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])]\n    (loop [count 0\n           navigator navigator\n           last-pos (int -1)]\n      (if (and (not max-count) (\x3d (:pos navigator) last-pos) (\x3e count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (js/Error "%@{ construct not consuming any arguments: Infinite loop!")))\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (\x3e count 0)))\n              (and max-count (\x3e\x3d count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause navigator (:base-args params))]\n          (if (\x3d :up-arrow (first iter-result))\n            (second iter-result)\n            (recur\n              (inc count) iter-result (:pos navigator))))))))\n\n;; ~@:{...~} with both colon and at sign uses the main argument list as a set of sublists, one\n;; of which is consumed with each iteration\n(defn- iterate-main-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])]\n    (loop [count 0\n           navigator navigator]\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (\x3e count 0)))\n              (and max-count (\x3e\x3d count max-count)))\n        navigator\n        (let [[sublist navigator] (next-arg-or-nil navigator)\n              iter-result (execute-sub-format clause (init-navigator sublist) navigator)]\n          (if (\x3d :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) navigator)))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; The \'~\x3c directive has two completely different meanings\n;; in the \'~\x3c...~\x3e\' form it does justification, but with\n;; ~\x3c...~:\x3e\' it represents the logical block operation of the\n;; pretty printer.\n;;\n;; Unfortunately, the current architecture decides what function\n;; to call at form parsing time before the sub-clauses have been\n;; folded, so it is left to run-time to make the decision.\n;;\n;; TODO: make it possible to make these decisions at compile-time.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare ^{:arglists \'([params navigator offsets])} format-logical-block)\n(declare ^{:arglists \'([params navigator offsets])} justify-clauses)\n\n(defn- logical-block-or-justify [params navigator offsets]\n  (if (:colon (:right-params params))\n    (format-logical-block params navigator offsets)\n    (justify-clauses params navigator offsets)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for the \'~\x3c...~\x3e\' justification directive\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- render-clauses [clauses navigator base-navigator]\n  (loop [clauses clauses\n         acc []\n         navigator navigator]\n    (if (empty? clauses)\n      [acc navigator]\n      (let [clause (first clauses)\n            [iter-result result-str] (let [sb (StringBuffer.)]\n                                       (binding [*out* (StringBufferWriter. sb)]\n                                         [(execute-sub-format clause navigator base-navigator)\n                                          (str sb)]))]\n        (if (\x3d :up-arrow (first iter-result))\n          [acc (second iter-result)]\n          (recur (next clauses) (conj acc result-str) iter-result))))))\n\n;; TODO support for ~:; constructions\n(defn- justify-clauses [params navigator offsets]\n  (let [[[eol-str] new-navigator] (when-let [else (:else params)]\n                                    (render-clauses else navigator (:base-args params)))\n        navigator (or new-navigator navigator)\n        [else-params new-navigator] (when-let [p (:else-params params)]\n                                      (realize-parameter-list p navigator))\n        navigator (or new-navigator navigator)\n        min-remaining (or (first (:min-remaining else-params)) 0)\n        max-columns (or (first (:max-columns else-params))\n                        (get-max-column *out*))\n        clauses (:clauses params)\n        [strs navigator] (render-clauses clauses navigator (:base-args params))\n        slots (max 1\n                   (+ (dec (count strs)) (if (:colon params) 1 0) (if (:at params) 1 0)))\n        chars (reduce + (map count strs))\n        mincol (:mincol params)\n        minpad (:minpad params)\n        colinc (:colinc params)\n        minout (+ chars (* slots minpad))\n        result-columns (if (\x3c\x3d minout mincol)\n                         mincol\n                         (+ mincol (* colinc\n                                      (+ 1 (quot (- minout mincol 1) colinc)))))\n        total-pad (- result-columns chars)\n        pad (max minpad (quot total-pad slots))\n        extra-pad (- total-pad (* pad slots))\n        pad-str (apply str (repeat pad (:padchar params)))]\n    (if (and eol-str (\x3e (+ (get-column (:base @@*out*)) min-remaining result-columns)\n                        max-columns))\n      (print eol-str))\n    (loop [slots slots\n           extra-pad extra-pad\n           strs strs\n           pad-only (or (:colon params)\n                        (and (\x3d (count strs) 1) (not (:at params))))]\n      (if (seq strs)\n        (do\n          (print (str (if (not pad-only) (first strs))\n                      (if (or pad-only (next strs) (:at params)) pad-str)\n                      (if (pos? extra-pad) (:padchar params))))\n          (recur\n            (dec slots)\n            (dec extra-pad)\n            (if pad-only strs (next strs))\n            false))))\n    navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Support for case modification with ~(...~).\n;;; We do this by wrapping the underlying writer with\n;;; a special writer to do the appropriate modification. This\n;;; allows us to support arbitrary-sized output and sources\n;;; that may block.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- downcase-writer\n  "Returns a proxy that wraps writer, converting all characters to lower case"\n  [writer]\n  (reify\n    IWriter\n    (-flush [_] (-flush writer))\n    (-write\n      ;;no multi-arity, not sure of importance\n      #_([^chars cbuf ^Integer off ^Integer len]\n             (.write writer cbuf off len))\n      [this x]\n      (condp \x3d (type x)\n        js/String\n        (let [s x]\n          (-write writer (string/lower-case s)))\n\n        js/Number\n        (let [c x]\n          ;;TODO need to enforce integers only?\n          (-write writer (string/lower-case (char c))))))))\n\n(defn- upcase-writer\n  "Returns a proxy that wraps writer, converting all characters to upper case"\n  [writer]\n  (reify\n    IWriter\n    (-flush [_] (-flush writer))\n    (-write\n      ;;no multi-arity, not sure of importance\n      #_([^chars cbuf ^Integer off ^Integer len]\n             (.write writer cbuf off len))\n      [this x]\n      (condp \x3d (type x)\n        js/String\n        (let [s x]\n          (-write writer (string/upper-case s)))\n\n        js/Number\n        (let [c x]\n          ;;TODO need to enforce integers only?\n          (-write writer (string/upper-case (char c))))))))\n\n(defn- capitalize-string\n  "Capitalizes the words in a string. If first? is false, don\'t capitalize the\n                                      first character of the string even if it\'s a letter."\n  [s first?]\n  (let [f (first s)\n        s (if (and first? f (gstring/isUnicodeChar f))\n            (str (string/upper-case f) (subs s 1))\n            s)]\n    (apply str\n           (first\n             (consume\n               (fn [s]\n                 (if (empty? s)\n                   [nil nil]\n                   (let [m (.exec (js/RegExp "\\\\W\\\\w" "g") s)\n                         offset (and m (inc (.-index m)))]\n                     (if offset\n                       [(str (subs s 0 offset)\n                             (string/upper-case (nth s offset)))\n                        (subs s (inc offset))]\n                       [s nil]))))\n               s)))))\n\n(defn- capitalize-word-writer\n  "Returns a proxy that wraps writer, capitalizing all words"\n  [writer]\n  (let [last-was-whitespace? (atom true)]\n    (reify\n      IWriter\n      (-flush [_] (-flush writer))\n      (-write\n        ;;no multi-arity\n        #_([^chars cbuf ^Integer off ^Integer len]\n               (.write writer cbuf off len))\n        [this x]\n        (condp \x3d (type x)\n          js/String\n          (let [s x]\n            (-write writer\n                    (capitalize-string (.toLowerCase s) @last-was-whitespace?))\n            (when (pos? (.-length s))\n              (reset! last-was-whitespace? (gstring/isEmptyOrWhitespace (nth s (dec (count s)))))))\n\n          js/Number\n          (let [c (char x)]\n            (let [mod-c (if @last-was-whitespace? (string/upper-case c) c)]\n              (-write writer mod-c)\n              (reset! last-was-whitespace? (gstring/isEmptyOrWhitespace c)))))))))\n\n(defn- init-cap-writer\n  "Returns a proxy that wraps writer, capitalizing the first word"\n  [writer]\n  (let [capped (atom false)]\n    (reify\n      IWriter\n      (-flush [_] (-flush writer))\n      (-write\n        ;;no multi-arity\n        #_([^chars cbuf ^Integer off ^Integer len]\n                    (.write writer cbuf off len))\n        [this x]\n        (condp \x3d (type x)\n          js/String\n          (let [s (string/lower-case x)]\n            (if (not @capped)\n              (let [m (.exec (js/RegExp "\\\\S" "g") s)\n                    offset (and m (.-index m))]\n                (if offset\n                  (do (-write writer\n                              (str (subs s 0 offset)\n                                   (string/upper-case (nth s offset))\n                                   (string/lower-case (subs s (inc offset)))))\n                      (reset! capped true))\n                  (-write writer s)))\n              (-write writer (string/lower-case s))))\n\n          js/Number\n          (let [c (char x)]\n            (if (and (not @capped) (gstring/isUnicodeChar c))\n              (do\n                (reset! capped true)\n                (-write writer (string/upper-case c)))\n              (-write writer (string/lower-case c)))))))))\n\n(defn- modify-case [make-writer params navigator offsets]\n  (let [clause (first (:clauses params))]\n    (binding [*out* (make-writer *out*)]\n      (execute-sub-format clause navigator (:base-args params)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; If necessary, wrap the writer in a PrettyWriter object\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO update this doc string to show correct way to print\n(defn get-pretty-writer\n  "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it\'s\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \\"~4D~7,vT\\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user\x3e (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000"\n  [writer]\n  (if (pretty-writer? writer)\n    writer\n    (pretty-writer writer *print-right-margin* *print-miser-width*)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Support for column-aware operations ~\x26, ~T\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn fresh-line\n  "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline."\n  []\n  (if (satisfies? IDeref *out*)\n    (if (not (\x3d 0 (get-column (:base @@*out*))))\n      (prn))\n    (prn)))\n\n(defn- absolute-tabulation [params navigator offsets]\n  (let [colnum (:colnum params)\n        colinc (:colinc params)\n        current (get-column (:base @@*out*))\n        space-count (cond\n                      (\x3c current colnum) (- colnum current)\n                      (\x3d colinc 0) 0\n                      :else (- colinc (rem (- current colnum) colinc)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)\n\n(defn- relative-tabulation [params navigator offsets]\n  (let [colrel (:colnum params)\n        colinc (:colinc params)\n        start-col (+ colrel (get-column (:base @@*out*)))\n        offset (if (pos? colinc) (rem start-col colinc) 0)\n        space-count (+ colrel (if (\x3d 0 offset) 0 (- colinc offset)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Support for accessing the pretty printer from a format\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO: support ~@; per-line-prefix separator\n;; TODO: get the whole format wrapped so we can start the lb at any column\n(defn- format-logical-block [params navigator offsets]\n  (let [clauses (:clauses params)\n        clause-count (count clauses)\n        prefix (cond\n                 (\x3e clause-count 1) (:string (:params (first (first clauses))))\n                 (:colon params) "(")\n        body (nth clauses (if (\x3e clause-count 1) 1 0))\n        suffix (cond\n                 (\x3e clause-count 2) (:string (:params (first (nth clauses 2))))\n                 (:colon params) ")")\n        [arg navigator] (next-arg navigator)]\n    (pprint-logical-block :prefix prefix :suffix suffix\n      (execute-sub-format\n        body\n        (init-navigator arg)\n        (:base-args params)))\n    navigator))\n\n(defn- set-indent [params navigator offsets]\n  (let [relative-to (if (:colon params) :current :block)]\n    (pprint-indent relative-to (:n params))\n    navigator))\n\n;;; TODO: support ~:T section options for ~T\n(defn- conditional-newline [params navigator offsets]\n  (let [kind (if (:colon params)\n               (if (:at params) :mandatory :fill)\n               (if (:at params) :miser :linear))]\n    (pprint-newline kind)\n    navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; The table of directives we support, each with its params,\n;;; properties, and the compilation function\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defdirectives\n  (\\A\n    [:mincol [0 js/Number] :colinc [1 js/Number] :minpad [0 js/Number] :padchar [\\space js/String]]\n    #{:at :colon :both} {}\n    #(format-ascii print-str %1 %2 %3))\n\n  (\\S\n    [:mincol [0 js/Number] :colinc [1 js/Number] :minpad [0 js/Number] :padchar [\\space js/String]]\n    #{:at :colon :both} {}\n    #(format-ascii pr-str %1 %2 %3))\n\n  (\\D\n    [:mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    #(format-integer 10 %1 %2 %3))\n\n  (\\B\n    [:mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    #(format-integer 2 %1 %2 %3))\n\n  (\\O\n    [:mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    #(format-integer 8 %1 %2 %3))\n\n  (\\X\n    [:mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    #(format-integer 16 %1 %2 %3))\n\n  (\\R\n    [:base [nil js/Number] :mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    (do\n      (cond                          ; ~R is overloaded with bizareness\n        (first (:base params))     #(format-integer (:base %1) %1 %2 %3)\n        (and (:at params) (:colon params))   #(format-old-roman %1 %2 %3)\n        (:at params)               #(format-new-roman %1 %2 %3)\n        (:colon params)            #(format-ordinal-english %1 %2 %3)\n        true                       #(format-cardinal-english %1 %2 %3))))\n\n  (\\P\n    []\n    #{:at :colon :both} {}\n    (fn [params navigator offsets]\n      (let [navigator (if (:colon params) (relative-reposition navigator -1) navigator)\n            strs (if (:at params) ["y" "ies"] ["" "s"])\n            [arg navigator] (next-arg navigator)]\n        (print (if (\x3d arg 1) (first strs) (second strs)))\n        navigator)))\n\n  (\\C\n    [:char-format [nil js/String]]\n    #{:at :colon :both} {}\n    (cond\n      (:colon params) pretty-character\n      (:at params) readable-character\n      :else plain-character))\n\n  (\\F\n    [:w [nil js/Number] :d [nil js/Number] :k [0 js/Number] :overflowchar [nil js/String]\n     :padchar [\\space js/String]]\n    #{:at} {}\n    fixed-float)\n\n  (\\E\n    [:w [nil js/Number] :d [nil js/Number] :e [nil js/Number] :k [1 js/Number]\n     :overflowchar [nil js/String] :padchar [\\space js/String]\n     :exponentchar [nil js/String]]\n    #{:at} {}\n    exponential-float)\n\n  (\\G\n    [:w [nil js/Number] :d [nil js/Number] :e [nil js/Number] :k [1 js/Number]\n     :overflowchar [nil js/String] :padchar [\\space js/String]\n     :exponentchar [nil js/String]]\n    #{:at} {}\n    general-float)\n\n  (\\$\n    [:d [2 js/Number] :n [1 js/Number] :w [0 js/Number] :padchar [\\space js/String]]\n    #{:at :colon :both} {}\n    dollar-float)\n\n  (\\%\n    [:count [1 js/Number]]\n    #{} {}\n    (fn [params arg-navigator offsets]\n      (dotimes [i (:count params)]\n        (prn))\n      arg-navigator))\n\n  (\\\x26\n    [:count [1 js/Number]]\n    #{:pretty} {}\n    (fn [params arg-navigator offsets]\n      (let [cnt (:count params)]\n        (if (pos? cnt) (fresh-line))\n        (dotimes [i (dec cnt)]\n          (prn)))\n      arg-navigator))\n\n  (\\|\n    [:count [1 js/Number]]\n    #{} {}\n    (fn [params arg-navigator offsets]\n      (dotimes [i (:count params)]\n        (print \\formfeed))\n      arg-navigator))\n\n  (\\~\n    [:n [1 js/Number]]\n    #{} {}\n    (fn [params arg-navigator offsets]\n      (let [n (:n params)]\n        (print (apply str (repeat n \\~)))\n        arg-navigator)))\n\n  (\\newline ;; Whitespace supression is handled in the compilation loop\n    []\n    #{:colon :at} {}\n    (fn [params arg-navigator offsets]\n      (if (:at params)\n        (prn))\n      arg-navigator))\n\n  (\\T\n    [:colnum [1 js/Number] :colinc [1 js/Number]]\n    #{:at :pretty} {}\n    (if (:at params)\n      #(relative-tabulation %1 %2 %3)\n      #(absolute-tabulation %1 %2 %3)))\n\n  (\\*\n    [:n [1 js/Number]]\n    #{:colon :at} {}\n    (fn [params navigator offsets]\n      (let [n (:n params)]\n        (if (:at params)\n          (absolute-reposition navigator n)\n          (relative-reposition navigator (if (:colon params) (- n) n))))))\n\n  (\\?\n    []\n    #{:at} {}\n    (if (:at params)\n      (fn [params navigator offsets]     ; args from main arg list\n        (let [[subformat navigator] (get-format-arg navigator)]\n          (execute-sub-format subformat navigator (:base-args params))))\n      (fn [params navigator offsets]     ; args from sub-list\n        (let [[subformat navigator] (get-format-arg navigator)\n              [subargs navigator] (next-arg navigator)\n              sub-navigator (init-navigator subargs)]\n          (execute-sub-format subformat sub-navigator (:base-args params))\n          navigator))))\n\n  (\\(\n    []\n    #{:colon :at :both} {:right \\), :allows-separator nil, :else nil}\n    (let [mod-case-writer (cond\n                            (and (:at params) (:colon params))\n                            upcase-writer\n\n                            (:colon params)\n                            capitalize-word-writer\n\n                            (:at params)\n                            init-cap-writer\n\n                            :else\n                            downcase-writer)]\n      #(modify-case mod-case-writer %1 %2 %3)))\n\n  (\\) [] #{} {} nil)\n\n  (\\[\n    [:selector [nil js/Number]]\n    #{:colon :at} {:right \\], :allows-separator true, :else :last}\n    (cond\n      (:colon params)\n      boolean-conditional\n\n      (:at params)\n      check-arg-conditional\n\n      true\n      choice-conditional))\n\n  (\\; [:min-remaining [nil js/Number] :max-columns [nil js/Number]]\n    #{:colon} {:separator true} nil)\n\n  (\\] [] #{} {} nil)\n\n  (\\{\n    [:max-iterations [nil js/Number]]\n    #{:colon :at :both} {:right \\}, :allows-separator false}\n    (cond\n      (and (:at params) (:colon params))\n      iterate-main-sublists\n\n      (:colon params)\n      iterate-list-of-sublists\n\n      (:at params)\n      iterate-main-list\n\n      true\n      iterate-sublist))\n\n  (\\} [] #{:colon} {} nil)\n\n  (\\\x3c\n    [:mincol [0 js/Number] :colinc [1 js/Number] :minpad [0 js/Number] :padchar [\\space js/String]]\n    #{:colon :at :both :pretty} {:right \\\x3e, :allows-separator true, :else :first}\n    logical-block-or-justify)\n\n  (\\\x3e [] #{:colon} {} nil)\n\n  ;; TODO: detect errors in cases where colon not allowed\n  (\\^ [:arg1 [nil js/Number] :arg2 [nil js/Number] :arg3 [nil js/Number]]\n    #{:colon} {}\n    (fn [params navigator offsets]\n      (let [arg1 (:arg1 params)\n            arg2 (:arg2 params)\n            arg3 (:arg3 params)\n            exit (if (:colon params) :colon-up-arrow :up-arrow)]\n        (cond\n          (and arg1 arg2 arg3)\n          (if (\x3c\x3d arg1 arg2 arg3) [exit navigator] navigator)\n\n          (and arg1 arg2)\n          (if (\x3d arg1 arg2) [exit navigator] navigator)\n\n          arg1\n          (if (\x3d arg1 0) [exit navigator] navigator)\n\n          true     ; TODO: handle looking up the arglist stack for info\n          (if (if (:colon params)\n                (empty? (:rest (:base-args params)))\n                (empty? (:rest navigator)))\n            [exit navigator] navigator)))))\n\n  (\\W\n    []\n    #{:at :colon :both :pretty} {}\n    (if (or (:at params) (:colon params))\n      (let [bindings (concat\n                       (if (:at params) [:level nil :length nil] [])\n                       (if (:colon params) [:pretty true] []))]\n        (fn [params navigator offsets]\n          (let [[arg navigator] (next-arg navigator)]\n            (if (apply write arg bindings)\n              [:up-arrow navigator]\n              navigator))))\n      (fn [params navigator offsets]\n        (let [[arg navigator] (next-arg navigator)]\n          (if (write-out arg)\n            [:up-arrow navigator]\n            navigator)))))\n\n  (\\_\n    []\n    #{:at :colon :both} {}\n    conditional-newline)\n\n  (\\I\n    [:n [0 js/Number]]\n    #{:colon} {}\n    set-indent)\n  )\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Code to manage the parameters and flags associated with each\n;; directive in the format string.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true}\n     param-pattern #"^([vV]|#|(\'.)|([+-]?\\d+)|(?\x3d,))")\n\n(def ^{:private true}\n     special-params #{:parameter-from-args :remaining-arg-count})\n\n(defn- extract-param [[s offset saw-comma]]\n  (let [m (js/RegExp. (.-source param-pattern) "g")\n        param (.exec m s)]\n    (if param\n      (let [token-str (first param)\n            remainder (subs s (.-lastIndex m))\n            new-offset (+ offset (.-lastIndex m))]\n        (if (not (\x3d \\, (nth remainder 0)))\n          [[token-str offset] [remainder new-offset false]]\n          [[token-str offset] [(subs remainder 1) (inc new-offset) true]]))\n      (if saw-comma\n        (format-error "Badly formed parameters in format directive" offset)\n        [nil [s offset]]))))\n\n(defn- extract-params [s offset]\n  (consume extract-param [s offset false]))\n\n(defn- translate-param\n  "Translate the string representation of a param to the internalized\n                                      representation"\n  [[p offset]]\n  [(cond\n     (\x3d (.-length p) 0) nil\n     (and (\x3d (.-length p) 1) (contains? #{\\v \\V} (nth p 0))) :parameter-from-args\n     (and (\x3d (.-length p) 1) (\x3d \\# (nth p 0))) :remaining-arg-count\n     (and (\x3d (.-length p) 2) (\x3d \\\' (nth p 0))) (nth p 1)\n     true (js/parseInt p 10))\n   offset])\n\n(def ^{:private true}\n     flag-defs {\\: :colon, \\@ :at})\n\n(defn- extract-flags [s offset]\n  (consume\n    (fn [[s offset flags]]\n      (if (empty? s)\n        [nil [s offset flags]]\n        (let [flag (get flag-defs (first s))]\n          (if flag\n            (if (contains? flags flag)\n              (format-error\n                (str "Flag \\"" (first s) "\\" appears more than once in a directive")\n                offset)\n              [true [(subs s 1) (inc offset) (assoc flags flag [true offset])]])\n            [nil [s offset flags]]))))\n    [s offset {}]))\n\n(defn- check-flags [def flags]\n  (let [allowed (:flags def)]\n    (if (and (not (:at allowed)) (:at flags))\n      (format-error (str "\\"@\\" is an illegal flag for format directive \\"" (:directive def) "\\"")\n                    (nth (:at flags) 1)))\n    (if (and (not (:colon allowed)) (:colon flags))\n      (format-error (str "\\":\\" is an illegal flag for format directive \\"" (:directive def) "\\"")\n                    (nth (:colon flags) 1)))\n    (if (and (not (:both allowed)) (:at flags) (:colon flags))\n      (format-error (str "Cannot combine \\"@\\" and \\":\\" flags for format directive \\""\n                         (:directive def) "\\"")\n                    (min (nth (:colon flags) 1) (nth (:at flags) 1))))))\n\n(defn- map-params\n  "Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well."\n  [def params flags offset]\n  (check-flags def flags)\n  (if (\x3e (count params) (count (:params def)))\n    (format-error\n      (cl-format\n        nil\n        "Too many parameters for directive \\"~C\\": ~D~:* ~[were~;was~:;were~] specified but only ~D~:* ~[are~;is~:;are~] allowed"\n        (:directive def) (count params) (count (:params def)))\n      (second (first params))))\n  (doall\n    (map #(let [val (first %1)]\n           (if (not (or (nil? val) (contains? special-params val)\n                        (\x3d (second (second %2)) (type val))))\n             (format-error (str "Parameter " (name (first %2))\n                                " has bad type in directive \\"" (:directive def) "\\": "\n                                (type val))\n                           (second %1))) )\n         params (:params def)))\n\n  (merge                                ; create the result map\n    (into (array-map) ; start with the default values, make sure the order is right\n          (reverse (for [[name [default]] (:params def)] [name [default offset]])))\n    (reduce #(apply assoc %1 %2) {} (filter #(first (nth % 1)) (zipmap (keys (:params def)) params))) ; add the specified parameters, filtering out nils\n    flags)); and finally add the flags\n\n(defn- compile-directive [s offset]\n  (let [[raw-params [rest offset]] (extract-params s offset)\n        [_ [rest offset flags]] (extract-flags rest offset)\n        directive (first rest)\n        def (get directive-table (string/upper-case directive))\n        params (if def (map-params def (map translate-param raw-params) flags offset))]\n    (if (not directive)\n      (format-error "Format string ended in the middle of a directive" offset))\n    (if (not def)\n      (format-error (str "Directive \\"" directive "\\" is undefined") offset))\n    [(compiled-directive. ((:generator-fn def) params offset) def params offset)\n     (let [remainder (subs rest 1)\n           offset (inc offset)\n           trim? (and (\x3d \\newline (:directive def))\n                      (not (:colon params)))\n           trim-count (if trim? (prefix-count remainder [\\space \\tab]) 0)\n           remainder (subs remainder trim-count)\n           offset (+ offset trim-count)]\n       [remainder offset])]))\n\n(defn- compile-raw-string [s offset]\n  (compiled-directive. (fn [_ a _] (print s) a) nil {:string s} offset))\n\n(defn- right-bracket [this] (:right (:bracket-info (:def this))))\n\n(defn- separator? [this] (:separator (:bracket-info (:def this))))\n\n(defn- else-separator? [this]\n  (and (:separator (:bracket-info (:def this)))\n       (:colon (:params this))))\n\n(declare ^{:arglists \'([bracket-info offset remainder])} collect-clauses)\n\n(defn- process-bracket [this remainder]\n  (let [[subex remainder] (collect-clauses (:bracket-info (:def this))\n                                           (:offset this) remainder)]\n    [(compiled-directive.\n       (:func this) (:def this)\n       (merge (:params this) (tuple-map subex (:offset this)))\n       (:offset this))\n     remainder]))\n\n(defn- process-clause [bracket-info offset remainder]\n  (consume\n    (fn [remainder]\n      (if (empty? remainder)\n        (format-error "No closing bracket found." offset)\n        (let [this (first remainder)\n              remainder (next remainder)]\n          (cond\n            (right-bracket this)\n            (process-bracket this remainder)\n\n            (\x3d (:right bracket-info) (:directive (:def this)))\n            [ nil [:right-bracket (:params this) nil remainder]]\n\n            (else-separator? this)\n            [nil [:else nil (:params this) remainder]]\n\n            (separator? this)\n            [nil [:separator nil nil remainder]] ;; TODO: check to make sure that there are no params on ~;\n\n            true\n            [this remainder]))))\n    remainder))\n\n(defn- collect-clauses [bracket-info offset remainder]\n  (second\n    (consume\n      (fn [[clause-map saw-else remainder]]\n        (let [[clause [type right-params else-params remainder]]\n              (process-clause bracket-info offset remainder)]\n          (cond\n            (\x3d type :right-bracket)\n            [nil [(merge-with concat clause-map\n                              {(if saw-else :else :clauses) [clause]\n                               :right-params right-params})\n                  remainder]]\n\n            (\x3d type :else)\n            (cond\n              (:else clause-map)\n              (format-error "Two else clauses (\\"~:;\\") inside bracket construction." offset)\n\n              (not (:else bracket-info))\n              (format-error "An else clause (\\"~:;\\") is in a bracket type that doesn\'t support it."\n                            offset)\n\n              (and (\x3d :first (:else bracket-info)) (seq (:clauses clause-map)))\n              (format-error\n                "The else clause (\\"~:;\\") is only allowed in the first position for this directive."\n                offset)\n\n              true         ; if the ~:; is in the last position, the else clause\n              ; is next, this was a regular clause\n              (if (\x3d :first (:else bracket-info))\n                [true [(merge-with concat clause-map {:else [clause] :else-params else-params})\n                       false remainder]]\n                [true [(merge-with concat clause-map {:clauses [clause]})\n                       true remainder]]))\n\n            (\x3d type :separator)\n            (cond\n              saw-else\n              (format-error "A plain clause (with \\"~;\\") follows an else clause (\\"~:;\\") inside bracket construction." offset)\n\n              (not (:allows-separator bracket-info))\n              (format-error "A separator (\\"~;\\") is in a bracket type that doesn\'t support it."\n                            offset)\n\n              true\n              [true [(merge-with concat clause-map {:clauses [clause]})\n                     false remainder]]))))\n      [{:clauses []} false remainder])))\n\n(defn- process-nesting\n  "Take a linearly compiled format and process the bracket directives to give it\n   the appropriate tree structure"\n  [format]\n  (first\n    (consume\n      (fn [remainder]\n        (let [this (first remainder)\n              remainder (next remainder)\n              bracket (:bracket-info (:def this))]\n          (if (:right bracket)\n            (process-bracket this remainder)\n            [this remainder])))\n      format)))\n\n(defn- compile-format\n  "Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved\nperformance when you\'re using the same format string repeatedly"\n  [format-str]\n  (binding [*format-str* format-str]\n    (process-nesting\n      (first\n        (consume\n          (fn [[s offset]]\n            (if (empty? s)\n              [nil s]\n              (let [tilde (.indexOf s \\~)]\n                (cond\n                  (neg? tilde) [(compile-raw-string s offset) ["" (+ offset (.-length s))]]\n                  (zero? tilde) (compile-directive (subs s 1) (inc offset))\n                  true\n                  [(compile-raw-string (subs s 0 tilde) offset) [(subs s tilde) (+ tilde offset)]]))))\n          [format-str 0])))))\n\n(defn- needs-pretty\n  "determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing"\n  [format]\n  (loop [format format]\n    (if (empty? format)\n      false\n      (if (or (:pretty (:flags (:def (first format))))\n              (some needs-pretty (first (:clauses (:params (first format)))))\n              (some needs-pretty (first (:else (:params (first format))))))\n        true\n        (recur (next format))))))\n\n;;NB We depart from the original api. In clj, if execute-format is called multiple times with the same stream or\n;; called on *out*, the results are different than if the same calls are made with different streams or printing\n;; to a string. The reason is that mutating the underlying stream changes the result by changing spacing.\n;;\n;; clj:\n;;  * stream                       \x3d\x3e "1 2  3"\n;;  * true (prints to *out*)       \x3d\x3e "1 2  3"\n;;  * nil (prints to string)       \x3d\x3e "1 2 3"\n;; cljs:\n;;  * stream                       \x3d\x3e "1 2  3"\n;;  * true (prints via *print-fn*) \x3d\x3e "1 2 3"\n;;  * nil (prints to string)       \x3d\x3e "1 2 3"\n(defn- execute-format\n  "Executes the format with the arguments."\n  {:skip-wiki true}\n  ([stream format args]\n   (let [sb (StringBuffer.)\n         real-stream (if (or (not stream) (true? stream))\n                       (StringBufferWriter. sb)\n                       stream)\n         wrapped-stream (if (and (needs-pretty format)\n                                 (not (pretty-writer? real-stream)))\n                          (get-pretty-writer real-stream)\n                          real-stream)]\n     (binding [*out* wrapped-stream]\n       (try\n         (execute-format format args)\n         (finally\n           (if-not (identical? real-stream wrapped-stream)\n             (-flush wrapped-stream))))\n       (cond\n         (not stream) (str sb)\n         (true? stream) (string-print (str sb))\n         :else nil))))\n  ([format args]\n   (map-passing-context\n     (fn [element context]\n       (if (abort? context)\n         [nil context]\n         (let [[params args] (realize-parameter-list\n                               (:params element) context)\n               [params offsets] (unzip-map params)\n               params (assoc params :base-args args)]\n           [nil (apply (:func element) [params args offsets])])))\n     args\n     format)\n   nil))\n\n;;; This is a bad idea, but it prevents us from leaking private symbols\n;;; This should all be replaced by really compiled formats anyway.\n(def ^{:private true} cached-compile (memoize compile-format))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; dispatch.clj\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn- use-method\n  "Installs a function as a new method of multimethod associated with dispatch-value. "\n  [multifn dispatch-val func]\n  (-add-method multifn dispatch-val func))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Implementations of specific dispatch table entries\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; Handle forms that can be "back-translated" to reader macros\n;;; Not all reader macros can be dealt with this way or at all.\n;;; Macros that we can\'t deal with at all are:\n;;; ;  - The comment character is absorbed by the reader and never is part of the form\n;;; `  - Is fully processed at read time into a lisp expression (which will contain concats\n;;;      and regular quotes).\n;;; ~@ - Also fully eaten by the processing of ` and can\'t be used outside.\n;;; ,  - is whitespace and is lost (like all other whitespace). Formats can generate commas\n;;;      where they deem them useful to help readability.\n;;; ^  - Adding metadata completely disappears at read time and the data appears to be\n;;;      completely lost.\n;;;\n;;; Most other syntax stuff is dealt with directly by the formats (like (), [], {}, and #{})\n;;; or directly by printing the objects using Clojure\'s built-in print functions (like\n;;; :keyword, \\char, or ""). The notable exception is #() which is special-cased.\n\n(def ^{:private true} reader-macros\n  {\'quote "\'"\n   \'var "#\'"\n   \'clojure.core/deref "@",\n   \'clojure.core/unquote "~"\n   \'cljs.core/deref "@",\n   \'cljs.core/unquote "~"})\n\n(defn- pprint-reader-macro [alis]\n  (let [macro-char (reader-macros (first alis))]\n    (when (and macro-char (\x3d 2 (count alis)))\n      (-write *out* macro-char)\n      (write-out (second alis))\n      true)))\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Dispatch for the basic data types when interpreted\n;; as data (as opposed to code).\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n;;; TODO: inline these formatter statements into funcs so that we\n;;; are a little easier on the stack. (Or, do "real" compilation, a\n;;; la Common Lisp)\n\n;;; (def pprint-simple-list (formatter-out "~:\x3c~@{~w~^ ~_~}~:\x3e"))\n(defn- pprint-simple-list [alis]\n  (pprint-logical-block :prefix "(" :suffix ")"\n    (print-length-loop [alis (seq alis)]\n      (when alis\n        (write-out (first alis))\n        (when (next alis)\n          (-write *out* " ")\n          (pprint-newline :linear)\n          (recur (next alis)))))))\n\n(defn- pprint-list [alis]\n  (if-not (pprint-reader-macro alis)\n    (pprint-simple-list alis)))\n\n;;; (def pprint-vector (formatter-out "~\x3c[~;~@{~w~^ ~_~}~;]~:\x3e"))\n(defn- pprint-vector [avec]\n  (pprint-logical-block :prefix "[" :suffix "]"\n    (print-length-loop [aseq (seq avec)]\n      (when aseq\n        (write-out (first aseq))\n        (when (next aseq)\n          (-write *out* " ")\n          (pprint-newline :linear)\n          (recur (next aseq)))))))\n\n(def ^{:private true} pprint-array (formatter-out "~\x3c[~;~@{~w~^, ~:_~}~;]~:\x3e"))\n\n;;; (def pprint-map (formatter-out "~\x3c{~;~@{~\x3c~w~^ ~_~w~:\x3e~^, ~_~}~;}~:\x3e"))\n(defn- pprint-map [amap]\n  (let [[ns lift-map] (when (not (record? amap))\n                            (#\'cljs.core/lift-ns amap))\n        amap (or lift-map amap)\n        prefix (if ns (str "#:" ns "{") "{")]\n    (pprint-logical-block :prefix prefix :suffix "}"\n      (print-length-loop [aseq (seq amap)]\n        (when aseq\n          ;;compiler gets confused with nested macro if it isn\'t namespaced\n          ;;it tries to use clojure.pprint/pprint-logical-block for some reason\n          (m/pprint-logical-block\n            (write-out (ffirst aseq))\n            (-write *out* " ")\n            (pprint-newline :linear)\n            (set! *current-length* 0)   ;always print both parts of the [k v] pair\n            (write-out (fnext (first aseq))))\n          (when (next aseq)\n            (-write *out* ", ")\n            (pprint-newline :linear)\n            (recur (next aseq))))))))\n\n(defn- pprint-simple-default [obj]\n  ;;TODO: Update to handle arrays (?) and suppressing namespaces\n  (-write *out* (pr-str obj)))\n\n(def pprint-set (formatter-out "~\x3c#{~;~@{~w~^ ~:_~}~;}~:\x3e"))\n\n(def ^{:private true}\ntype-map {"core$future_call" "Future",\n          "core$promise" "Promise"})\n\n(defn- map-ref-type\n  "Map ugly type names to something simpler"\n  [name]\n  (or (when-let [match (re-find #"^[^$]+\\$[^$]+" name)]\n        (type-map match))\n    name))\n\n(defn- pprint-ideref [o]\n  (let [prefix (str "#\x3c" (map-ref-type (.-name (type o)))\n                    "@" (goog/getUid o) ": ")]\n    (pprint-logical-block  :prefix prefix :suffix "\x3e"\n      (pprint-indent :block (-\x3e (count prefix) (- 2) -))\n      (pprint-newline :linear)\n      (write-out\n        (if (and (satisfies? IPending o) (not (-realized? o)))\n          :not-delivered\n          @o)))))\n\n(def ^{:private true} pprint-pqueue (formatter-out "~\x3c\x3c-(~;~@{~w~^ ~_~}~;)-\x3c~:\x3e"))\n\n(defn- type-dispatcher [obj]\n  (cond\n    (instance? PersistentQueue obj) :queue\n    (satisfies? IDeref obj) :deref\n    (symbol? obj) :symbol\n    (seq? obj) :list\n    (map? obj) :map\n    (vector? obj) :vector\n    (set? obj) :set\n    (nil? obj) nil\n    :default :default))\n\n(defmulti simple-dispatch\n  "The pretty print dispatch function for simple data structure format."\n  type-dispatcher)\n\n(use-method simple-dispatch :list pprint-list)\n(use-method simple-dispatch :vector pprint-vector)\n(use-method simple-dispatch :map pprint-map)\n(use-method simple-dispatch :set pprint-set)\n(use-method simple-dispatch nil #(-write *out* (pr-str nil)))\n(use-method simple-dispatch :default pprint-simple-default)\n\n(set-pprint-dispatch simple-dispatch)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Dispatch for the code table\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare ^{:arglists \'([alis])} pprint-simple-code-list)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format the namespace ("ns") macro. This is quite complicated because of all the\n;;; different forms supported and because programmers can choose lists or vectors\n;;; in various places.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- brackets\n  "Figure out which kind of brackets to use"\n  [form]\n  (if (vector? form)\n    ["[" "]"]\n    ["(" ")"]))\n\n(defn- pprint-ns-reference\n  "Pretty print a single reference (import, use, etc.) from a namespace decl"\n  [reference]\n  (if (sequential? reference)\n    (let [[start end] (brackets reference)\n          [keyw \x26 args] reference]\n      (pprint-logical-block :prefix start :suffix end\n        ((formatter-out "~w~:i") keyw)\n        (loop [args args]\n          (when (seq args)\n            ((formatter-out " "))\n            (let [arg (first args)]\n              (if (sequential? arg)\n                (let [[start end] (brackets arg)]\n                  (pprint-logical-block :prefix start :suffix end\n                    (if (and (\x3d (count arg) 3) (keyword? (second arg)))\n                      (let [[ns kw lis] arg]\n                        ((formatter-out "~w ~w ") ns kw)\n                        (if (sequential? lis)\n                          ((formatter-out (if (vector? lis)\n                                            "~\x3c[~;~@{~w~^ ~:_~}~;]~:\x3e"\n                                            "~\x3c(~;~@{~w~^ ~:_~}~;)~:\x3e"))\n                            lis)\n                          (write-out lis)))\n                      (apply (formatter-out "~w ~:i~@{~w~^ ~:_~}") arg)))\n                  (when (next args)\n                    ((formatter-out "~_"))))\n                (do\n                  (write-out arg)\n                  (when (next args)\n                    ((formatter-out "~:_"))))))\n            (recur (next args))))))\n    (write-out reference)))\n\n(defn- pprint-ns\n  "The pretty print dispatch chunk for the ns macro"\n  [alis]\n  (if (next alis)\n    (let [[ns-sym ns-name \x26 stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map references] (if (map? (first stuff))\n                                  [(first stuff) (next stuff)]\n                                  [nil stuff])]\n      (pprint-logical-block :prefix "(" :suffix ")"\n        ((formatter-out "~w ~1I~@_~w") ns-sym ns-name)\n        (when (or doc-str attr-map (seq references))\n          ((formatter-out "~@:_")))\n        (when doc-str\n          (cl-format true "\\"~a\\"~:[~;~:@_~]" doc-str (or attr-map (seq references))))\n        (when attr-map\n          ((formatter-out "~w~:[~;~:@_~]") attr-map (seq references)))\n        (loop [references references]\n          (pprint-ns-reference (first references))\n          (when-let [references (next references)]\n            (pprint-newline :linear)\n            (recur references)))))\n    (write-out alis)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format something that looks like a simple def (sans metadata, since the reader\n;;; won\'t give it to us now).\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true} pprint-hold-first (formatter-out "~:\x3c~w~^ ~@_~w~^ ~_~@{~w~^ ~_~}~:\x3e"))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format something that looks like a defn or defmacro\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; Format the params and body of a defn with a single arity\n(defn- single-defn [alis has-doc-str?]\n  (if (seq alis)\n    (do\n      (if has-doc-str?\n        ((formatter-out " ~_"))\n        ((formatter-out " ~@_")))\n      ((formatter-out "~{~w~^ ~_~}") alis))))\n\n;;; Format the param and body sublists of a defn with multiple arities\n(defn- multi-defn [alis has-doc-str?]\n  (if (seq alis)\n    ((formatter-out " ~_~{~w~^ ~_~}") alis)))\n\n;;; TODO: figure out how to support capturing metadata in defns (we might need a\n;;; special reader)\n(defn- pprint-defn [alis]\n  (if (next alis)\n    (let [[defn-sym defn-name \x26 stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map stuff] (if (map? (first stuff))\n                             [(first stuff) (next stuff)]\n                             [nil stuff])]\n      (pprint-logical-block :prefix "(" :suffix ")"\n        ((formatter-out "~w ~1I~@_~w") defn-sym defn-name)\n        (if doc-str\n          ((formatter-out " ~_~w") doc-str))\n        (if attr-map\n          ((formatter-out " ~_~w") attr-map))\n        ;; Note: the multi-defn case will work OK for malformed defns too\n        (cond\n          (vector? (first stuff)) (single-defn stuff (or doc-str attr-map))\n          :else (multi-defn stuff (or doc-str attr-map)))))\n    (pprint-simple-code-list alis)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format something with a binding form\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- pprint-binding-form [binding-vec]\n  (pprint-logical-block :prefix "[" :suffix "]"\n    (print-length-loop [binding binding-vec]\n      (when (seq binding)\n        (pprint-logical-block binding\n          (write-out (first binding))\n          (when (next binding)\n            (-write *out* " ")\n            (pprint-newline :miser)\n            (write-out (second binding))))\n        (when (next (rest binding))\n          (-write *out* " ")\n          (pprint-newline :linear)\n          (recur (next (rest binding))))))))\n\n(defn- pprint-let [alis]\n  (let [base-sym (first alis)]\n    (pprint-logical-block :prefix "(" :suffix ")"\n      (if (and (next alis) (vector? (second alis)))\n        (do\n          ((formatter-out "~w ~1I~@_") base-sym)\n          (pprint-binding-form (second alis))\n          ((formatter-out " ~_~{~w~^ ~_~}") (next (rest alis))))\n        (pprint-simple-code-list alis)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format something that looks like "if"\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true} pprint-if (formatter-out "~:\x3c~1I~w~^ ~@_~w~@{ ~_~w~}~:\x3e"))\n\n(defn- pprint-cond [alis]\n  (pprint-logical-block :prefix "(" :suffix ")"\n    (pprint-indent :block 1)\n    (write-out (first alis))\n    (when (next alis)\n      (-write *out* " ")\n      (pprint-newline :linear)\n      (print-length-loop [alis (next alis)]\n        (when alis\n          (pprint-logical-block alis\n            (write-out (first alis))\n            (when (next alis)\n              (-write *out* " ")\n              (pprint-newline :miser)\n              (write-out (second alis))))\n          (when (next (rest alis))\n            (-write *out* " ")\n            (pprint-newline :linear)\n            (recur (next (rest alis)))))))))\n\n(defn- pprint-condp [alis]\n  (if (\x3e (count alis) 3)\n    (pprint-logical-block :prefix "(" :suffix ")"\n      (pprint-indent :block 1)\n      (apply (formatter-out "~w ~@_~w ~@_~w ~_") alis)\n      (print-length-loop [alis (seq (drop 3 alis))]\n        (when alis\n          (pprint-logical-block alis\n            (write-out (first alis))\n            (when (next alis)\n              (-write *out* " ")\n              (pprint-newline :miser)\n              (write-out (second alis))))\n          (when (next (rest alis))\n            (-write *out* " ")\n            (pprint-newline :linear)\n            (recur (next (rest alis)))))))\n    (pprint-simple-code-list alis)))\n\n;;; The map of symbols that are defined in an enclosing #() anonymous function\n(def ^:dynamic ^{:private true} *symbol-map* {})\n\n(defn- pprint-anon-func [alis]\n  (let [args (second alis)\n        nlis (first (rest (rest alis)))]\n    (if (vector? args)\n      (binding [*symbol-map* (if (\x3d 1 (count args))\n                               {(first args) "%"}\n                               (into {}\n                                 (map\n                                   #(vector %1 (str \\% %2))\n                                   args\n                                   (range 1 (inc (count args))))))]\n        ((formatter-out "~\x3c#(~;~@{~w~^ ~_~}~;)~:\x3e") nlis))\n      (pprint-simple-code-list alis))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; The master definitions for formatting lists in code (that is, (fn args...) or\n;;; special forms).\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; This is the equivalent of (formatter-out "~:\x3c~1I~@{~w~^ ~_~}~:\x3e"), but is\n;;; easier on the stack.\n\n(defn- pprint-simple-code-list [alis]\n  (pprint-logical-block :prefix "(" :suffix ")"\n    (pprint-indent :block 1)\n    (print-length-loop [alis (seq alis)]\n      (when alis\n        (write-out (first alis))\n        (when (next alis)\n          (-write *out* " ")\n          (pprint-newline :linear)\n          (recur (next alis)))))))\n\n;;; Take a map with symbols as keys and add versions with no namespace.\n;;; That is, if ns/sym-\x3eval is in the map, add sym-\x3eval to the result.\n(defn- two-forms [amap]\n  (into {}\n    (mapcat\n      identity\n      (for [x amap]\n        [x [(symbol (name (first x))) (second x)]]))))\n\n(defn- add-core-ns [amap]\n  (let [core "clojure.core"]\n    (into {}\n      (map #(let [[s f] %]\n             (if (not (or (namespace s) (special-symbol? s)))\n               [(symbol core (name s)) f]\n               %))\n        amap))))\n\n(def ^:dynamic ^{:private true} *code-table*\n  (two-forms\n    (add-core-ns\n      {\'def pprint-hold-first, \'defonce pprint-hold-first,\n       \'defn pprint-defn, \'defn- pprint-defn, \'defmacro pprint-defn, \'fn pprint-defn,\n       \'let pprint-let, \'loop pprint-let, \'binding pprint-let,\n       \'with-local-vars pprint-let, \'with-open pprint-let, \'when-let pprint-let,\n       \'if-let pprint-let, \'doseq pprint-let, \'dotimes pprint-let,\n       \'when-first pprint-let,\n       \'if pprint-if, \'if-not pprint-if, \'when pprint-if, \'when-not pprint-if,\n       \'cond pprint-cond, \'condp pprint-condp,\n       \'fn* pprint-anon-func,\n       \'. pprint-hold-first, \'.. pprint-hold-first, \'-\x3e pprint-hold-first,\n       \'locking pprint-hold-first, \'struct pprint-hold-first,\n       \'struct-map pprint-hold-first, \'ns pprint-ns\n       })))\n\n(defn- pprint-code-list [alis]\n  (if-not (pprint-reader-macro alis)\n    (if-let [special-form (*code-table* (first alis))]\n      (special-form alis)\n      (pprint-simple-code-list alis))))\n\n(defn- pprint-code-symbol [sym]\n  (if-let [arg-num (sym *symbol-map*)]\n    (print arg-num)\n    (if *print-suppress-namespaces*\n      (print (name sym))\n      (pr sym))))\n\n(defmulti\n  code-dispatch\n  "The pretty print dispatch function for pretty printing Clojure code."\n  {:added "1.2" :arglists \'[[object]]}\n  type-dispatcher)\n\n(use-method code-dispatch :list pprint-code-list)\n(use-method code-dispatch :symbol pprint-code-symbol)\n\n;; The following are all exact copies of simple-dispatch\n(use-method code-dispatch :vector pprint-vector)\n(use-method code-dispatch :map pprint-map)\n(use-method code-dispatch :set pprint-set)\n(use-method code-dispatch :queue pprint-pqueue)\n(use-method code-dispatch :deref pprint-ideref)\n(use-method code-dispatch nil pr)\n(use-method code-dispatch :default pprint-simple-default)\n\n(set-pprint-dispatch simple-dispatch)\n\n;;; For testing\n(comment\n\n  (with-pprint-dispatch code-dispatch\n    (pprint\n      \'(defn cl-format\n         "An implementation of a Common Lisp compatible format function"\n         [stream format-in \x26 args]\n         (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n               navigator (init-navigator args)]\n           (execute-format stream compiled-format navigator)))))\n\n  (with-pprint-dispatch code-dispatch\n    (pprint\n      \'(defn cl-format\n         [stream format-in \x26 args]\n         (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n               navigator (init-navigator args)]\n           (execute-format stream compiled-format navigator)))))\n\n  (with-pprint-dispatch code-dispatch\n    (pprint\n      \'(defn- -write\n         ([this x]\n          (condp \x3d (class x)\n            String\n            (let [s0 (write-initial-lines this x)\n                  s (.replaceFirst s0 "\\\\s+$" "")\n                  white-space (.substring s0 (count s))\n                  mode (getf :mode)]\n              (if (\x3d mode :writing)\n                (dosync\n                  (write-white-space this)\n                  (.col_write this s)\n                  (setf :trailing-white-space white-space))\n                (add-to-buffer this (make-buffer-blob s white-space))))\n\n            Integer\n            (let [c ^Character x]\n              (if (\x3d (getf :mode) :writing)\n                (do\n                  (write-white-space this)\n                  (.col_write this x))\n                (if (\x3d c (int \\newline))\n                  (write-initial-lines this "\\n")\n                  (add-to-buffer this (make-buffer-blob (str (char c)) nil))))))))))\n\n  (with-pprint-dispatch code-dispatch\n    (pprint\n      \'(defn pprint-defn [writer alis]\n         (if (next alis)\n           (let [[defn-sym defn-name \x26 stuff] alis\n                 [doc-str stuff] (if (string? (first stuff))\n                                   [(first stuff) (next stuff)]\n                                   [nil stuff])\n                 [attr-map stuff] (if (map? (first stuff))\n                                    [(first stuff) (next stuff)]\n                                    [nil stuff])]\n             (pprint-logical-block writer :prefix "(" :suffix ")"\n               (cl-format true "~w ~1I~@_~w" defn-sym defn-name)\n               (if doc-str\n                 (cl-format true " ~_~w" doc-str))\n               (if attr-map\n                 (cl-format true " ~_~w" attr-map))\n               ;; Note: the multi-defn case will work OK for malformed defns too\n               (cond\n                 (vector? (first stuff)) (single-defn stuff (or doc-str attr-map))\n                 :else (multi-defn stuff (or doc-str attr-map)))))\n           (pprint-simple-code-list writer alis)))))\n  )\n\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; print_table.clj\n;;\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n(defn- add-padding [width s]\n  (let [padding (max 0 (- width (count s)))]\n    (apply str (clojure.string/join (repeat padding \\space)) s)))\n\n(defn print-table\n  "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows."\n  {:added "1.3"}\n  ([ks rows]\n   (when (seq rows)\n     (let [widths  (map\n                     (fn [k]\n                       (apply max (count (str k)) (map #(count (str (get % k))) rows)))\n                     ks)\n           spacers (map #(apply str (repeat % "-")) widths)\n           fmt-row (fn [leader divider trailer row]\n                     (str leader\n                       (apply str (interpose divider\n                                    (for [[col width] (map vector (map #(get row %) ks) widths)]\n                                      (add-padding width (str col)))))\n                       trailer))]\n       (cljs.core/println)\n       (cljs.core/println (fmt-row "| " " | " " |" (zipmap ks ks)))\n       (cljs.core/println (fmt-row "|-" "-+-" "-|" (zipmap ks spacers)))\n       (doseq [row rows]\n         (cljs.core/println (fmt-row "| " " | " " |" row))))))\n  ([rows] (print-table (keys (first rows)) rows)))\n'],
null),new p(null,3,[Cl,"clojure/data.clj",Xn,"clojure.data",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns \n  ^{:author "Stuart Halloway",\n    :doc "Non-core data functions."}\n  clojure.data\n  (:require [clojure.set :as set]))\n\n(declare diff)\n\n(defn- atom-diff\n  "Internal helper for diff."\n  [a b]\n  (if (\x3d a b) [nil nil a] [a b nil]))\n\n;; for big things a sparse vector class would be better\n(defn- vectorize\n  "Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys"\n  [m]\n  (when (seq m)\n    (reduce\n     (fn [result [k v]] (assoc result k v))\n     (vec (repeat (apply max (keys m))  nil))\n     m)))\n\n(defn- diff-associative-key\n  "Diff associative things a and b, comparing only the key k."\n  [a b k]\n  (let [va (get a k)\n        vb (get b k)\n        [a* b* ab] (diff va vb)\n        in-a (contains? a k)\n        in-b (contains? b k)\n        same (and in-a in-b\n                  (or (not (nil? ab))\n                      (and (nil? va) (nil? vb))))]\n    [(when (and in-a (or (not (nil? a*)) (not same))) {k a*})\n     (when (and in-b (or (not (nil? b*)) (not same))) {k b*})\n     (when same {k ab})\n     ]))\n\n(defn- diff-associative\n  "Diff associative things a and b, comparing only keys in ks."\n  [a b ks]\n  (reduce\n   (fn [diff1 diff2]\n     (doall (map merge diff1 diff2)))\n   [nil nil nil]\n   (map\n    (partial diff-associative-key a b)\n    ks)))\n\n(defn- diff-sequential\n  [a b]\n  (vec (map vectorize (diff-associative\n                       (if (vector? a) a (vec a))\n                       (if (vector? b) b (vec b))\n                       (range (max (count a) (count b)))))))\n\n(defprotocol ^{:added "1.3"} EqualityPartition\n  "Implementation detail. Subject to change."\n  (^{:added "1.3"} equality-partition [x] "Implementation detail. Subject to change."))\n\n(defprotocol ^{:added "1.3"} Diff\n  "Implementation detail. Subject to change."\n  (^{:added "1.3"} diff-similar [a b] "Implementation detail. Subject to change."))\n\n(extend nil\n        Diff\n        {:diff-similar atom-diff})\n\n(extend Object\n        Diff\n        {:diff-similar (fn [a b] ((if (.. a getClass isArray) diff-sequential atom-diff) a b))}\n        EqualityPartition\n        {:equality-partition (fn [x] (if (.. x getClass isArray) :sequential :atom))})\n\n(extend-protocol EqualityPartition\n  nil\n  (equality-partition [x] :atom)\n  \n  java.util.Set\n  (equality-partition [x] :set)\n\n  java.util.List\n  (equality-partition [x] :sequential)\n  \n  java.util.Map\n  (equality-partition [x] :map))\n\n(defn- as-set-value\n  [s]\n  (if (set? s) s (into #{} s)))\n\n(extend-protocol Diff\n  java.util.Set\n  (diff-similar\n   [a b]\n   (let [aval (as-set-value a)\n         bval (as-set-value b)]\n     [(not-empty (set/difference aval bval))\n      (not-empty (set/difference bval aval))\n      (not-empty (set/intersection aval bval))]))\n  \n  java.util.List\n  (diff-similar [a b]\n    (diff-sequential a b))\n  \n  java.util.Map\n  (diff-similar [a b]\n    (diff-associative a b (set/union (keys a) (keys b)))))\n\n(defn diff\n  "Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality."\n  {:added "1.3"}\n  [a b]\n  (if (\x3d a b)\n    [nil nil a]\n    (if (\x3d (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))\n  \n'],
null),new p(null,3,[Cl,"cljs/js.clj",Xn,"cljs.js",nr,";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.js\n  (:require [cljs.env :as env]\n            [cljs.env.macros :as menv]\n            [cljs.analyzer :as ana]\n            [clojure.java.io :as io]))\n\n(defmacro with-state\n  [state \x26 body]\n  `(menv/with-compiler-env ~state\n     ~@body))\n\n(defmacro dump-core []\n  (let [state @env/*compiler*]\n    (if-not (false? (get-in state [:options :dump-core]))\n      `(quote ~(get-in state [::ana/namespaces 'cljs.core]))\n      `(hash-map))))\n"],
null),new p(null,3,[Cl,"clojure/zip.clj",Xn,"clojure.zip",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;functional hierarchical zipper, with navigation, editing and enumeration\n;see Huet\n\n(ns ^{:doc "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet"\n       :author "Rich Hickey"}\n  clojure.zip\n  (:refer-clojure :exclude (replace remove next)))\n\n(defn zipper\n  "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn\'t.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."\n  {:added "1.0"}\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])\n\n(defn seq-zip\n  "Returns a zipper for nested sequences, given a root sequence"\n  {:added "1.0"}\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))\n\n(defn vector-zip\n  "Returns a zipper for nested vectors, given a root vector"\n  {:added "1.0"}\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))\n\n(defn xml-zip\n  "Returns a zipper for xml elements (as from xml/parse),\n  given a root element"\n  {:added "1.0"}\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))\n\n(defn node\n  "Returns the node at loc"\n  {:added "1.0"}\n  [loc] (loc 0))\n\n(defn branch?\n  "Returns true if the node at loc is a branch"\n  {:added "1.0"}\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))\n\n(defn children\n  "Returns a seq of the children of node at loc, which must be a branch"\n  {:added "1.0"}\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw (Exception. "called children on a leaf node"))))\n\n(defn make-node\n  "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."\n  {:added "1.0"}\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))\n\n(defn path\n  "Returns a seq of nodes leading to this loc"\n  {:added "1.0"}\n  [loc]\n    (:pnodes (loc 1)))\n\n(defn lefts\n  "Returns a seq of the left siblings of this loc"\n  {:added "1.0"}\n  [loc]\n    (seq (:l (loc 1))))\n\n(defn rights\n  "Returns a seq of the right siblings of this loc"\n  {:added "1.0"}\n  [loc]\n    (:r (loc 1)))\n\n\n(defn down\n  "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"\n  {:added "1.0"}\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c \x26 cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))\n\n(defn up\n  "Returns the loc of the parent of the node at this loc, or nil if at\n  the top"\n  {:added "1.0"}\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))\n\n(defn root\n  "zips all the way up and returns the root node, reflecting any\n changes."\n  {:added "1.0"}\n  [loc]\n    (if (\x3d :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))\n\n(defn right\n  "Returns the loc of the right sibling of the node at this loc, or nil"\n  {:added "1.0"}\n  [loc]\n    (let [[node {l :l  [r \x26 rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))\n\n(defn rightmost\n  "Returns the loc of the rightmost sibling of the node at this loc, or self"\n  {:added "1.0"}\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))\n\n(defn left\n  "Returns the loc of the left sibling of the node at this loc, or nil"\n  {:added "1.0"}\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))\n\n(defn leftmost\n  "Returns the loc of the leftmost sibling of the node at this loc, or self"\n  {:added "1.0"}\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))\n\n(defn insert-left\n  "Inserts the item as the left sibling of the node at this loc,\n without moving"\n  {:added "1.0"}\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw (new Exception "Insert at top"))\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))\n\n(defn insert-right\n  "Inserts the item as the right sibling of the node at this loc,\n  without moving"\n  {:added "1.0"}\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw (new Exception "Insert at top"))\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))\n\n(defn replace\n  "Replaces the node at this loc, without moving"\n  {:added "1.0"}\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))\n\n(defn edit\n  "Replaces the node at this loc with the value of (f node args)"\n  {:added "1.0"}\n  [loc f \x26 args]\n    (replace loc (apply f (node loc) args)))\n\n(defn insert-child\n  "Inserts the item as the leftmost child of the node at this loc,\n  without moving"\n  {:added "1.0"}\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))\n\n(defn append-child\n  "Inserts the item as the rightmost child of the node at this loc,\n  without moving"\n  {:added "1.0"}\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))\n\n(defn next\n  "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."\n  {:added "1.0"}\n  [loc]\n    (if (\x3d :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))\n\n(defn prev\n  "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."\n  {:added "1.0"}\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))\n\n(defn end?\n  "Returns true if loc represents the end of a depth-first walk"\n  {:added "1.0"}\n  [loc]\n    (\x3d :end (loc 1)))\n\n(defn remove\n  "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."\n  {:added "1.0"}\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw (new Exception "Remove at top"))\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))\n  \n(comment\n\n(load-file "/Users/rich/dev/clojure/src/zip.clj")\n(refer \'zip)\n(def data \'[[a * b] + [c * d]])\n(def dz (vector-zip data))\n\n(right (down (right (right (down dz)))))\n(lefts (right (down (right (right (down dz))))))\n(rights (right (down (right (right (down dz))))))\n(up (up (right (down (right (right (down dz)))))))\n(path (right (down (right (right (down dz))))))\n\n(-\x3e dz down right right down right)\n(-\x3e dz down right right down right (replace \'/) root)\n(-\x3e dz next next (edit str) next next next (replace \'/) root)\n(-\x3e dz next next next next next next next next next remove root)\n(-\x3e dz next next next next next next next next next remove (insert-right \'e) root)\n(-\x3e dz next next next next next next next next next remove up (append-child \'e) root)\n\n(end? (-\x3e dz next next next next next next next next next remove next))\n\n(-\x3e dz next remove next remove root)\n\n(loop [loc dz]\n  (if (end? loc)\n    (root loc)\n    (recur (next (if (\x3d \'* (node loc)) \n                   (replace loc \'/)\n                   loc)))))\n\n(loop [loc dz]\n  (if (end? loc)\n    (root loc)\n    (recur (next (if (\x3d \'* (node loc)) \n                   (remove loc)\n                   loc)))))\n)\n'],
null),new p(null,3,[Cl,"cljs/analyzer/macros.clj",Xn,"cljs.analyzer.macros",nr,";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.analyzer.macros\n  (:refer-clojure :exclude [binding]))\n\n(defmacro with-warning-handlers [handlers \x26 body]\n  `(cljs.core/binding [cljs.analyzer/*cljs-warning-handlers* ~handlers]\n     ~@body))\n\n(defmacro no-warn [\x26 body]\n  `(cljs.core/binding [cljs.analyzer/*cljs-warnings*\n                       (zipmap (keys cljs.analyzer/*cljs-warnings*) (repeat false))]\n     ~@body))\n\n(defmacro with-core-macros\n  [path \x26 body]\n  `(do\n     (when (not\x3d cljs.analyzer/*cljs-macros-path* ~path)\n       (reset! cljs.analyzer/-cljs-macros-loaded false))\n     (cljs.core/binding [cljs.analyzer/*cljs-macros-path* ~path]\n       ~@body)))\n\n(defmacro with-core-macros-file\n  [path \x26 body]\n  `(do\n     (when (not\x3d cljs.analyzer/*cljs-macros-path* ~path)\n       (reset! cljs.analyzer/-cljs-macros-loaded false))\n     (cljs.core/binding [cljs.analyzer/*cljs-macros-path* ~path\n                         cljs.analyzer/*cljs-macros-is-classpath* false]\n       ~@body)))\n\n(defmacro wrapping-errors [env \x26 body]\n  `(try\n     ~@body\n     (catch :default err#\n       (cond\n         (cljs.analyzer/has-error-data? err#) (throw err#)\n         (cljs.analyzer/analysis-error? err#) (throw (ex-info nil (cljs.analyzer/error-data ~env :compilation) err#))\n         :else (throw (ex-info nil (cljs.analyzer/error-data ~env :compilation) (cljs.analyzer/error ~env (.-message err#) err#)))))))\n\n(defmacro disallowing-recur [\x26 body]\n  `(cljs.core/binding [cljs.analyzer/*recur-frames*\n                       (cons nil cljs.analyzer/*recur-frames*)]\n     ~@body))\n\n(defmacro allowing-redef [\x26 body]\n  `(cljs.core/binding [cljs.analyzer/*allow-redef* true]\n     ~@body))\n\n(defmacro disallowing-ns* [\x26 body]\n  `(cljs.core/binding [cljs.analyzer/*allow-ns* false] ~@body))\n"],
null),new p(null,3,[Cl,"clojure/string.clj",Xn,"clojure.string",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc "Clojure String utilities\n\nIt is poor form to (:use clojure.string). Instead, use require\nwith :as to specify a prefix, e.g.\n\n(ns your.namespace.here\n  (:require [clojure.string :as str]))\n\nDesign notes for clojure.string:\n\n1. Strings are objects (as opposed to sequences). As such, the\n   string being manipulated is the first argument to a function;\n   passing nil will result in a NullPointerException unless\n   documented otherwise. If you want sequence-y behavior instead,\n   use a sequence.\n\n2. Functions are generally not lazy, and call straight to host\n   methods where those are available and efficient.\n\n3. Functions take advantage of String implementation details to\n   write high-performing loop/recurs instead of using higher-order\n   functions. (This is not idiomatic in general-purpose application\n   code.)\n\n4. When a function is documented to accept a string argument, it\n   will take any implementation of the correct *interface* on the\n   host platform. In Java, this is CharSequence, which is more\n   general than String. In ordinary usage you will almost always\n   pass concrete strings. If you are doing something unusual,\n   e.g. passing a mutable implementation of CharSequence, then\n   thread-safety is your responsibility."\n      :author "Stuart Sierra, Stuart Halloway, David Liebke"}\n  clojure.string\n  (:refer-clojure :exclude (replace reverse))\n  (:import (java.util.regex Pattern Matcher)\n           clojure.lang.LazilyPersistentVector))\n\n(set! *warn-on-reflection* true)\n\n(defn ^String reverse\n  "Returns s with its characters reversed."\n  {:added "1.2"}\n  [^CharSequence s]\n  (.toString (.reverse (StringBuilder. s))))\n\n(defn ^String re-quote-replacement\n  "Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement."\n  {:added "1.5"}\n  [^CharSequence replacement]\n  (Matcher/quoteReplacement (.toString ^CharSequence replacement)))\n\n(defn- replace-by\n  [^CharSequence s re f]\n  (let [m (re-matcher re s)]\n    (if (.find m)\n      (let [buffer (StringBuffer. (.length s))]\n        (loop [found true]\n          (if found\n            (do (.appendReplacement m buffer (Matcher/quoteReplacement (f (re-groups m))))\n                (recur (.find m)))\n            (do (.appendTail m buffer)\n                (.toString buffer)))))\n      s)))\n\n(defn ^String replace\n  "Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher\'s appendReplacement method.\n\n   Example:\n   (clojure.string/replace \\"Almost Pig Latin\\" #\\"\\\\b(\\\\w)(\\\\w+)\\\\b\\" \\"$2$1ay\\")\n   -\x3e \\"lmostAay igPay atinLay\\""\n  {:added "1.2"}\n  [^CharSequence s match replacement]\n  (let [s (.toString s)]\n    (cond \n     (instance? Character match) (.replace s ^Character match ^Character replacement)\n     (instance? CharSequence match) (.replace s ^CharSequence match ^CharSequence replacement)\n     (instance? Pattern match) (if (instance? CharSequence replacement)\n                                 (.replaceAll (re-matcher ^Pattern match s)\n                                              (.toString ^CharSequence replacement))\n                                 (replace-by s match replacement))\n     :else (throw (IllegalArgumentException. (str "Invalid match arg: " match))))))\n\n(defn- replace-first-by\n  [^CharSequence s ^Pattern re f]\n  (let [m (re-matcher re s)]\n    (if (.find m)\n      (let [buffer (StringBuffer. (.length s))\n            rep (Matcher/quoteReplacement (f (re-groups m)))]\n        (.appendReplacement m buffer rep)\n        (.appendTail m buffer)\n        (str buffer))\n      s)))\n\n(defn- replace-first-char\n  [^CharSequence s ^Character match replace]\n  (let [s (.toString s)\n        i (.indexOf s (int match))]\n    (if (\x3d -1 i)\n      s\n      (str (subs s 0 i) replace (subs s (inc i))))))\n\n(defn- replace-first-str\n  [^CharSequence s ^String match ^String replace]\n  (let [^String s (.toString s)\n        i (.indexOf s match)]\n    (if (\x3d -1 i)\n      s\n      (str (subs s 0 i) replace (subs s (+ i (.length match)))))))\n\n(defn ^String replace-first\n  "Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher\'s appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \\"swap first two words\\"\n                                 #\\"(\\\\w+)(\\\\s+)(\\\\w+)\\" \\"$3$2$1\\")\n   -\x3e \\"first swap two words\\""\n  {:added "1.2"}\n  [^CharSequence s match replacement]\n  (let [s (.toString s)]\n    (cond\n     (instance? Character match)\n     (replace-first-char s match replacement)\n     (instance? CharSequence match)\n     (replace-first-str s (.toString ^CharSequence match)\n                        (.toString ^CharSequence replacement))\n     (instance? Pattern match)\n     (if (instance? CharSequence replacement)\n       (.replaceFirst (re-matcher ^Pattern match s)\n                      (.toString ^CharSequence replacement))\n       (replace-first-by s match replacement))\n     :else (throw (IllegalArgumentException. (str "Invalid match arg: " match))))))\n\n\n(defn ^String join\n  "Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator."\n  {:added "1.2"}\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (loop [sb (StringBuilder. (str (first coll)))\n            more (next coll)\n            sep (str separator)]\n       (if more\n         (recur (-\x3e sb (.append sep) (.append (str (first more))))\n                (next more)\n                sep)\n         (str sb)))))\n\n(defn ^String capitalize\n  "Converts first character of the string to upper-case, all other\n  characters to lower-case."\n  {:added "1.2"}\n  [^CharSequence s]\n  (let [s (.toString s)]\n    (if (\x3c (count s) 2)\n      (.toUpperCase s)\n      (str (.toUpperCase (subs s 0 1))\n           (.toLowerCase (subs s 1))))))\n\n(defn ^String upper-case\n  "Converts string to all upper-case."\n  {:added "1.2"}\n  [^CharSequence s]\n  (.. s toString toUpperCase))\n\n(defn ^String lower-case\n  "Converts string to all lower-case."\n  {:added "1.2"}\n  [^CharSequence s]\n  (.. s toString toLowerCase))\n\n(defn split\n  "Splits string on a regular expression.  Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits."\n  {:added "1.2"}\n  ([^CharSequence s ^Pattern re]\n     (LazilyPersistentVector/createOwning (.split re s)))\n  ([ ^CharSequence s ^Pattern re limit]\n     (LazilyPersistentVector/createOwning (.split re s limit))))\n\n(defn split-lines\n  "Splits s on \\\\n or \\\\r\\\\n."\n  {:added "1.2"}\n  [^CharSequence s]\n  (split s #"\\r?\\n"))\n\n(defn ^String trim\n  "Removes whitespace from both ends of string."\n  {:added "1.2"}\n  [^CharSequence s]\n  (let [len (.length s)]\n    (loop [rindex len]\n      (if (zero? rindex)\n        ""\n        (if (Character/isWhitespace (.charAt s (dec rindex)))\n          (recur (dec rindex))\n          ;; there is at least one non-whitespace char in the string,\n          ;; so no need to check for lindex reaching len.\n          (loop [lindex 0]\n            (if (Character/isWhitespace (.charAt s lindex))\n              (recur (inc lindex))\n              (.. s (subSequence lindex rindex) toString))))))))\n\n(defn ^String triml\n  "Removes whitespace from the left side of string."\n  {:added "1.2"}\n  [^CharSequence s]\n  (let [len (.length s)]\n    (loop [index 0]\n      (if (\x3d len index)\n        ""\n        (if (Character/isWhitespace (.charAt s index))\n          (recur (unchecked-inc index))\n          (.. s (subSequence index len) toString))))))\n\n(defn ^String trimr\n  "Removes whitespace from the right side of string."\n  {:added "1.2"}\n  [^CharSequence s]\n  (loop [index (.length s)]\n    (if (zero? index)\n      ""\n      (if (Character/isWhitespace (.charAt s (unchecked-dec index)))\n        (recur (unchecked-dec index))\n        (.. s (subSequence 0 index) toString)))))\n\n(defn ^String trim-newline\n  "Removes all trailing newline \\\\n or return \\\\r characters from\n  string.  Similar to Perl\'s chomp."\n  {:added "1.2"}\n  [^CharSequence s]\n  (loop [index (.length s)]\n    (if (zero? index)\n      ""\n      (let [ch (.charAt s (dec index))]\n        (if (or (\x3d ch \\newline) (\x3d ch \\return))\n          (recur (dec index))\n          (.. s (subSequence 0 index) toString))))))\n\n(defn blank?\n  "True if s is nil, empty, or contains only whitespace."\n  {:added "1.2"}\n  [^CharSequence s]\n  (if s\n    (loop [index (int 0)]\n      (if (\x3d (.length s) index)\n        true\n        (if (Character/isWhitespace (.charAt s index))\n          (recur (inc index))\n          false)))\n    true))\n\n(defn ^String escape\n  "Return a new string, using cmap to escape each character ch\n   from s as follows:\n   \n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead."\n  {:added "1.2"}\n  [^CharSequence s cmap]\n  (loop [index (int 0)\n         buffer (StringBuilder. (.length s))]\n    (if (\x3d (.length s) index)\n      (.toString buffer)\n      (let [ch (.charAt s index)]\n        (if-let [replacement (cmap ch)]\n          (.append buffer replacement)\n          (.append buffer ch))\n        (recur (inc index) buffer)))))\n\n(defn index-of\n  "Return index of value (string or char) in s, optionally searching\n  forward from from-index. Return nil if value not found."\n  {:added "1.8"}\n  ([^CharSequence s value]\n  (let [result ^long\n        (if (instance? Character value)\n          (.indexOf (.toString s) ^int (.charValue ^Character value))\n          (.indexOf (.toString s) ^String value))]\n    (if (\x3d result -1)\n      nil\n      result)))\n  ([^CharSequence s value ^long from-index]\n  (let [result ^long\n        (if (instance? Character value)\n          (.indexOf (.toString s) ^int (.charValue ^Character value) (unchecked-int from-index))\n          (.indexOf (.toString s) ^String value (unchecked-int from-index)))]\n    (if (\x3d result -1)\n      nil\n      result))))\n\n(defn last-index-of\n  "Return last index of value (string or char) in s, optionally\n  searching backward from from-index. Return nil if value not found."\n  {:added "1.8"}\n  ([^CharSequence s value]\n  (let [result ^long\n        (if (instance? Character value)\n          (.lastIndexOf (.toString s) ^int (.charValue ^Character value))\n          (.lastIndexOf (.toString s) ^String value))]\n    (if (\x3d result -1)\n      nil\n      result)))\n  ([^CharSequence s value ^long from-index]\n  (let [result ^long\n        (if (instance? Character value)\n          (.lastIndexOf (.toString s) ^int (.charValue ^Character value) (unchecked-int from-index))\n          (.lastIndexOf (.toString s) ^String value (unchecked-int from-index)))]\n    (if (\x3d result -1)\n      nil\n      result))))\n\n(defn starts-with?\n  "True if s starts with substr."\n  {:added "1.8"}\n  [^CharSequence s ^String substr]\n  (.startsWith (.toString s) substr))\n\n(defn ends-with?\n  "True if s ends with substr."\n  {:added "1.8"}\n  [^CharSequence s ^String substr]\n  (.endsWith (.toString s) substr))\n\n(defn includes?\n  "True if s includes substr."\n  {:added "1.8"}\n  [^CharSequence s ^CharSequence substr]\n  (.contains (.toString s) substr))\n'],
null),new p(null,3,[Cl,"clojure/test/check/random.clj",Xn,"clojure.test.check.random",nr,";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:author \"Gary Fredericks\"\n      :doc \"Purely functional and splittable pseudo-random number generators.\"}\n clojure.test.check.random\n  (:refer-clojure :exclude [unsigned-bit-shift-right]))\n\n(defprotocol IRandom\n  (rand-long [rng]\n    \"Returns a random long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\")\n  (rand-double [rng]\n    \"Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\")\n  (split [rng]\n    \"Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\")\n  (split-n [rng n]\n    \"Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\"))\n\n;; Immutable version of Java 8's java.util.SplittableRandom\n;;\n;; Meant to give the same results as similar uses of\n;; java.util.SplittableRandom, in particular:\n;;\n;; (\x3d (-\x3e (make-java-util-splittable-random 42)\n;;        (rand-long))\n;;    (.nextLong (SplittableRandom. 42)))\n;;\n;; (\x3d (-\x3e (make-java-util-splittable-random 42)\n;;        (split)\n;;        (first)\n;;        (rand-long))\n;;    (.nextLong (doto (SplittableRandom. 42)\n;;                     (.split))))\n;;\n;; (\x3d (-\x3e (make-java-util-splittable-random 42)\n;;        (split)\n;;        (second)\n;;        (rand-long))\n;;    (.nextLong (.split (SplittableRandom. 42))))\n;;\n;; Also see the spec that checks this equivalency.\n\n\n;; backwards compatibility for clojure 1.5\n(def ^:private old-clojure?\n  (not (resolve 'clojure.core/unsigned-bit-shift-right)))\n(defmacro ^:private unsigned-bit-shift-right\n  [x n]\n  {:pre [(\x3c\x3d 1 n 63)]}\n  (if old-clojure?\n    (let [mask (-\x3e Long/MIN_VALUE\n                   (bit-shift-right (dec n))\n                   (bit-not))]\n      `(-\x3e ~x\n           (bit-shift-right ~n)\n           (bit-and ~mask)))\n    `(clojure.core/unsigned-bit-shift-right ~x ~n)))\n\n(defmacro ^:private longify\n  \"Macro for writing arbitrary longs in the java 0x syntax. E.g.\n  0x9e3779b97f4a7c15 (which is read as a bigint because it's out\n  of range) becomes -7046029254386353131.\"\n  [num]\n  (if (\x3e num Long/MAX_VALUE)\n    (-\x3e num\n        (- 18446744073709551616N)\n        (long)\n        (bit-or -9223372036854775808))\n    num))\n\n(set! *unchecked-math* :warn-on-boxed)\n\n(defmacro ^:private bxoubsr\n  \"Performs (-\x3e x (unsigned-bit-shift-right n) (bit-xor x)).\"\n  [x n]\n  (vary-meta\n   `(let [x# ~x]\n      (-\x3e x# (unsigned-bit-shift-right ~n) (bit-xor x#)))\n   assoc :tag 'long))\n\n(defmacro ^:private mix-64\n  [n]\n  `(-\x3e ~n\n       (bxoubsr 30)\n       (* (longify 0xbf58476d1ce4e5b9))\n       (bxoubsr 27)\n       (* (longify 0x94d049bb133111eb))\n       (bxoubsr 31)))\n\n(defmacro ^:private mix-gamma\n  [n]\n  `(-\x3e ~n\n       (bxoubsr 33)\n       (* (longify 0xff51afd7ed558ccd))\n       (bxoubsr 33)\n       (* (longify 0xc4ceb9fe1a85ec53))\n       (bxoubsr 33)\n       (bit-or 1)\n       (as-\x3e z#\n             (cond-\x3e z#\n               (\x3e 24 (-\x3e z#\n                         (bxoubsr 1)\n                         (Long/bitCount)))\n               (bit-xor (longify 0xaaaaaaaaaaaaaaaa))))))\n\n(def ^:private ^:const double-unit (/ 1.0 (double (bit-set 0 53))))\n;; Java: 0x1.0p-53 or (1.0 / (1L \x3c\x3c 53))\n\n(deftype JavaUtilSplittableRandom [^long gamma ^long state]\n  IRandom\n  (rand-long [_]\n    (-\x3e state (+ gamma) (mix-64)))\n  (rand-double [this]\n    (* double-unit (unsigned-bit-shift-right (long (rand-long this)) 11)))\n  (split [this]\n    (let [state' (+ gamma state)\n          state'' (+ gamma state')\n          gamma' (mix-gamma state'')]\n      [(JavaUtilSplittableRandom. gamma state'')\n       (JavaUtilSplittableRandom. gamma' (mix-64 state'))]))\n  (split-n [this n]\n    ;; immitates a particular series of 2-way splits, but avoids the\n    ;; intermediate allocation. See the `split-n-spec` for a test of\n    ;; the equivalence to 2-way splits.\n    (let [n (long n)]\n      (case n\n        0 []\n        1 [this]\n        (let [n-dec (dec n)]\n          (loop [state state\n                 ret (transient [])]\n            (if (\x3d n-dec (count ret))\n              (-\x3e ret\n                  (conj! (JavaUtilSplittableRandom. gamma state))\n                  (persistent!))\n              (let [state' (+ gamma state)\n                    state'' (+ gamma state')\n                    gamma' (mix-gamma state'')\n                    new-rng (JavaUtilSplittableRandom. gamma' (mix-64 state'))]\n                (recur state'' (conj! ret new-rng))))))))))\n\n(def ^:private golden-gamma\n  (longify 0x9e3779b97f4a7c15))\n\n(defn make-java-util-splittable-random\n  [^long seed]\n  (JavaUtilSplittableRandom. golden-gamma seed))\n\n;; some global state to make sure that seedless calls to make-random\n;; return independent results\n(def ^:private next-rng\n  \"Returns a random-number generator. Successive calls should return\n  independent results.\"\n  (let [a (atom (make-java-util-splittable-random (System/currentTimeMillis)))\n\n        thread-local\n        (proxy [ThreadLocal] []\n          (initialValue []\n            (first (split (swap! a #(second (split %)))))))]\n    (fn []\n      (let [rng (.get thread-local)\n            [rng1 rng2] (split rng)]\n        (.set thread-local rng2)\n        rng1))))\n\n(defn make-random\n  \"Given an optional Long seed, returns an object that satisfies the\n  IRandom protocol.\"\n  ([] (next-rng))\n  ([seed] (make-java-util-splittable-random seed)))\n"],
null),new p(null,3,[Cl,"cljs/tools/reader/reader_types.clj",Xn,"cljs.tools.reader.reader-types",nr,'(ns cljs.tools.reader.reader-types)\n\n(defmacro log-source\n  "If reader is a SourceLoggingPushbackReader, execute body in a source\n  logging context. Otherwise, execute body, returning the result."\n  [reader \x26 body]\n  `(if (and (source-logging-reader? ~reader)\n            (not (cljs.tools.reader.impl.utils/whitespace? (peek-char ~reader))))\n     (log-source* ~reader (^:once fn* [] ~@body))\n     (do ~@body)))'],
null),new p(null,3,[Cl,"cljs/nodejs.cljs",Xn,"cljs.nodejs",nr,";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n; Projects compiled with :target :nodejs can 'require' this namespace\n; to get the nodejs globals loaded into cljs.nodejs and get\n; ClojureScript's 'print' set up correctly.\n(ns cljs.nodejs\n  (:refer-clojure :exclude [require]))\n\n; Define namespaced references to Node's externed globals:\n(def require (js* \"require\"))\n(def process (js* \"process\"))\n\n(defn enable-util-print! []\n  (set! *print-newline* false)\n  (set-print-fn!\n    (fn [\x26 args]\n      (.apply (.-log js/console) js/console (into-array args))))\n  (set-print-err-fn!\n    (fn [\x26 args]\n      (.apply (.-error js/console) js/console (into-array args))))\n  nil)\n"],
null),new p(null,3,[Cl,"clojure/set.cljs",Xn,"clojure.set",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc "Set operations such as union/intersection."\n       :author "Rich Hickey"}\n       clojure.set)\n\n(defn- bubble-max-key [k coll]\n  "Move a maximal element of coll according to fn k (which returns a number) \n   to the front of coll."\n  (let [max (apply max-key k coll)]\n    (cons max (remove #(identical? max %) coll))))\n\n(defn union\n  "Return a set that is the union of the input sets"\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (\x3c (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 \x26 sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn intersection\n  "Return a set that is the intersection of the input sets"\n  ([s1] s1)\n  ([s1 s2]\n     (if (\x3c (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 \x26 sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn difference\n  "Return a set that is the first set without elements of the remaining sets"\n  ([s1] s1)\n  ([s1 s2] \n     (if (\x3c (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 \x26 sets] \n     (reduce difference s1 (conj sets s2))))\n\n\n(defn select\n  "Returns a set of the elements for which pred is true"\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))\n\n(defn project\n  "Returns a rel of the elements of xrel with only the keys in ks"\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))\n\n(defn rename-keys\n  "Returns the map with the keys in kmap renamed to the vals in kmap"\n  [map kmap]\n    (reduce\n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m))\n     (apply dissoc map (keys kmap)) kmap))\n\n(defn rename\n  "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))\n\n(defn index\n  "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks."\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))\n   \n(defn map-invert\n  "Returns the map with the vals mapped to the keys."\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))\n\n(defn join\n  "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys."\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (\x3c\x3d (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (\x3c\x3d (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))\n\n(defn subset? \n  "Is set1 a subset of set2?"\n  [set1 set2]\n  (and (\x3c\x3d (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))\n\n(defn superset? \n  "Is set1 a superset of set2?"\n  [set1 set2]\n  (and (\x3e\x3d (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))\n\n(comment\n(refer \'set)\n(def xs #{{:a 11 :b 1 :c 1 :d 4}\n         {:a 2 :b 12 :c 2 :d 6}\n         {:a 3 :b 3 :c 3 :d 8 :f 42}})\n\n(def ys #{{:a 11 :b 11 :c 11 :e 5}\n         {:a 12 :b 11 :c 12 :e 3}\n         {:a 3 :b 3 :c 3 :e 7 }})\n\n(join xs ys)\n(join xs (rename ys {:b :yb :c :yc}) {:a :a})\n\n(union #{:a :b :c} #{:c :d :e })\n(difference #{:a :b :c} #{:c :d :e})\n(intersection #{:a :b :c} #{:c :d :e})\n\n(index ys [:b]))\n\n'],
null),new p(null,3,[Cl,"cljs/pprint.cljc",Xn,"cljs.pprint",nr,';; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.pprint\n  (:refer-clojure :exclude [deftype #?(:cljs macroexpand)])\n  (:require [clojure.walk :as walk]\n            #?(:cljs [cljs.analyzer :as ana])))\n\n\n;; required the following changes:\n;;  replace .ppflush with -ppflush to switch from Interface to Protocol\n\n(defmacro with-pretty-writer [base-writer \x26 body]\n  `(let [base-writer# ~base-writer\n         new-writer# (not (pretty-writer? base-writer#))]\n     (cljs.core/binding [cljs.core/*out* (if new-writer#\n                         (make-pretty-writer base-writer# *print-right-margin* *print-miser-width*)\n                         base-writer#)]\n       ~@body\n       (-ppflush cljs.core/*out*))))\n\n\n(defmacro getf\n  "Get the value of the field a named by the argument (which should be a keyword)."\n  [sym]\n  `(~sym @@~\'this))\n\n;; change alter to swap!\n\n(defmacro setf\n  "Set the value of the field SYM to NEW-VAL"\n  [sym new-val]\n  `(swap! @~\'this assoc ~sym ~new-val))\n\n(defmacro deftype\n  [type-name \x26 fields]\n  (let [name-str (name type-name)\n        fields (map (comp symbol name) fields)]\n    `(do\n       (defrecord ~type-name [~\'type-tag ~@fields])\n       (defn- ~(symbol (str "make-" name-str))\n         ~(vec fields)\n         (~(symbol (str type-name ".")) ~(keyword name-str) ~@fields))\n       (defn- ~(symbol (str name-str "?")) [x#] (\x3d (:type-tag x#) ~(keyword name-str))))))\n\n(defn- parse-lb-options [opts body]\n  (loop [body body\n         acc []]\n    (if (opts (first body))\n      (recur (drop 2 body) (concat acc (take 2 body)))\n      [(apply hash-map acc) body])))\n\n(defmacro pprint-logical-block\n  "Execute the body as a pretty printing logical block with output to *out* which\n  must be a pretty printing writer. When used from pprint or cl-format, this can be\n  assumed.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Before the body, the caller can optionally specify options: :prefix, :per-line-prefix\n  and :suffix."\n  [\x26 args]\n  (let [[options body] (parse-lb-options #{:prefix :per-line-prefix :suffix} args)]\n    `(do (if (cljs.pprint/level-exceeded)\n           (~\'-write cljs.core/*out* "#")\n           (do\n             (cljs.core/binding [cljs.pprint/*current-level* (inc cljs.pprint/*current-level*)\n                       cljs.pprint/*current-length* 0]\n               (cljs.pprint/start-block cljs.core/*out*\n                                        ~(:prefix options)\n                                        ~(:per-line-prefix options)\n                                        ~(:suffix options))\n               ~@body\n               (cljs.pprint/end-block cljs.core/*out*))))\n         nil)))\n\n#?(:cljs\n   (defn macroexpand [env form]\n     (loop [form form\n            form\' (ana/macroexpand-1 env form)]\n       (if-not (identical? form form\')\n         (recur form\' (ana/macroexpand-1 env form\'))\n         form\'))))\n\n(defn- pll-mod-body [env var-sym body]\n  (letfn [(inner [form]\n                 (if (seq? form)\n                   (let [form #?(:clj  (macroexpand form)\n                                 :cljs (macroexpand env form))]\n                     (condp \x3d (first form)\n                       \'loop* form\n                       \'recur (concat `(recur (inc ~var-sym)) (rest form))\n                       (walk/walk inner identity form)))\n                   form))]\n    (walk/walk inner identity body)))\n\n(defmacro print-length-loop\n  "A version of loop that iterates at most *print-length* times. This is designed\n  for use in pretty-printer dispatch functions."\n  [bindings \x26 body]\n  (let [count-var (gensym "length-count")\n        mod-body (pll-mod-body \x26env count-var body)]\n    `(loop ~(apply vector count-var 0 bindings)\n       (if (or (not cljs.core/*print-length*) (\x3c ~count-var cljs.core/*print-length*))\n         (do ~@mod-body)\n         (~\'-write cljs.core/*out* "...")))))\n\n(defn- process-directive-table-element [[char params flags bracket-info \x26 generator-fn]]\n  [char,\n   {:directive char,\n    :params `(array-map ~@params),\n    :flags flags,\n    :bracket-info bracket-info,\n    :generator-fn (concat \'(fn [params offset]) generator-fn)}])\n\n(defmacro ^{:private true}\n  defdirectives\n  [\x26 directives]\n  `(def ^{:private true}\n        ~\'directive-table (hash-map ~@(mapcat process-directive-table-element directives))))\n\n(defmacro formatter\n  "Makes a function which can directly run format-in. The function is\nfn [stream \x26 args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format."\n  [format-in]\n  `(let [format-in# ~format-in\n         my-c-c# cljs.pprint/cached-compile\n         my-e-f# cljs.pprint/execute-format\n         my-i-n# cljs.pprint/init-navigator\n         cf# (if (string? format-in#) (my-c-c# format-in#) format-in#)]\n     (fn [stream# \x26 args#]\n       (let [navigator# (my-i-n# args#)]\n         (my-e-f# stream# cf# navigator#)))))\n\n(defmacro formatter-out\n  "Makes a function which can directly run format-in. The function is\nfn [\x26 args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format."\n  [format-in]\n  `(let [format-in# ~format-in\n         cf# (if (string? format-in#) (cljs.pprint/cached-compile format-in#) format-in#)]\n     (fn [\x26 args#]\n       (let [navigator# (cljs.pprint/init-navigator args#)]\n         (cljs.pprint/execute-format cf# navigator#)))))\n\n(defmacro with-pprint-dispatch\n  "Execute body with the pretty print dispatch function bound to function."\n  [function \x26 body]\n  `(cljs.core/binding [cljs.pprint/*print-pprint-dispatch* ~function]\n     ~@body))\n\n(defmacro pp\n  "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1)."\n  {:added "1.2"}\n  [] `(cljs.pprint/pprint *1))\n'],
null),new p(null,3,[Cl,"cljs/env.cljc",Xn,"cljs.env",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc "A namespace that exists solely to provide a place for \\"compiler\\"\nstate that is accessed/maintained by many different components."}\n  cljs.env\n  #?(:clj (:require [cljs.js-deps :as deps]\n                    [cljs.externs :as externs]))\n  (:refer-clojure :exclude [ensure]))\n\n;; bit of a misnomer, but: an atom containing a map that serves as the bag of\n;; state for the compiler, writ large (including analyzer, emitter, and\n;; optimization stages). Each namespace has its own local var, to accommodate\n;; multiple (lower-level) entry points.  Any state needed by the compiler across\n;; multiple applications should be put into this map/atom.  Aside from\n;; unfortunate current implementation details (e.g. depending on filesystem\n;; state for certain things), the compiler should be idempotent with regard to\n;; the environment passed to any entry point.\n;;\n;; Known slots in the compiler-env map:\n;;\n;; * :options - the [options] map argument, provided to this fn (defaults to {})\n;; * :js-dependency-index - result from calling cljs.js-deps/js-dependency-index\n;;   with [options]\n;; * :cljs.analyzer/constant-table - map of (currently only keyword) constant\n;;   values to fixed ids\n;; * :cljs.analyzer/namespaces - map of symbols to "namespace" maps\n;; * :cljs.analyzer/data-readers - literal map of symbols, where the first\n;;   symbol in each pair is a tag that will be recognized by the reader. The\n;;   second symbol in the pair is the fully-qualified name of a Var which will\n;;   be invoked by the reader to parse the form following the tag.\n;; * :cljs.compiler/compiled-cljs - cache of intermediate compilation results\n;;   that speeds incremental builds in conjunction with source map generation\n;; * :cljs.closure/compiled-cljs - cache from js file path to map of\n;;   {:file .. :provides .. :requires ..}\n;;\n;; Note that this var is functionally private to the compiler, and contains\n;; implementation-dependent data.\n(def ^:dynamic *compiler* nil)\n\n(defn default-compiler-env* [options]\n  (merge\n    {:cljs.analyzer/namespaces {\'cljs.user {:name \'cljs.user}}\n     :cljs.analyzer/constant-table {}\n     :cljs.analyzer/data-readers {}\n     :cljs.analyzer/externs #?(:clj  (when (:infer-externs options)\n                                       (externs/externs-map (:externs-sources options)))\n                               :cljs nil)\n     :options options}\n    #?@(:clj [(when (\x3d (:target options) :nodejs)\n                {:node-module-index deps/native-node-modules})\n              {:js-dependency-index (deps/js-dependency-index options)}])))\n\n(defn default-compiler-env\n  ([] (default-compiler-env {}))\n  ([options]\n   (atom (default-compiler-env* options))))\n\n#?(:clj\n   (defmacro with-compiler-env\n     "Evaluates [body] with [env] bound as the value of the `*compiler*` var in\n   this namespace."\n     [env \x26 body]\n     `(let [env# ~env\n            env# (cond\n                   (map? env#) (atom env#)\n                   (and (instance? clojure.lang.Atom env#)\n                        (map? @env#)) env#\n                   :default (throw (IllegalArgumentException.\n                                     (str "Compiler environment must be a map or atom containing a map, not "\n                                       (class env#)))))]\n        (binding [*compiler* env#] ~@body))))\n\n#?(:clj\n   (defmacro ensure\n     [\x26 body]\n     `(let [val# *compiler*]\n        (if (nil? val#)\n          (push-thread-bindings\n            (hash-map (var *compiler*) (default-compiler-env))))\n        (try\n          ~@body\n          (finally\n            (if (nil? val#)\n              (pop-thread-bindings)))))))\n'],
null),new p(null,3,[Cl,"clojure/test/check/random.cljs",Xn,"clojure.test.check.random",nr,';   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:author "Gary Fredericks"\n      :doc "Purely functional and splittable pseudo-random number generators."}\n clojure.test.check.random\n  (:refer-clojure :exclude [+ * bit-xor bit-or bit-count\n                            unsigned-bit-shift-right])\n  (:require [clojure.test.check.random.doubles :as doubles]\n            [clojure.test.check.random.longs :as longs\n             :refer [+ * bit-xor bit-or bit-count unsigned-bit-shift-right]]))\n\n(defprotocol IRandom\n  (rand-long [rng]\n    "Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument")\n  (rand-double [rng]\n    "Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument")\n  (split [rng]\n    "Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument")\n  (split-n [rng n]\n    "Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"))\n\n;;\n;; This is a port of the clojure-jvm port of\n;; java.util.SplittableRandom, and should give identical results.\n;;\n\n(defn ^:private hex-long\n  "Helper for defining constants."\n  [s]\n  (longs/from-string s 16))\n\n(defn ^:private bxoubsr\n  "Performs (-\x3e x (unsigned-bit-shift-right n) (bit-xor x))."\n  [x n]\n  (-\x3e x (unsigned-bit-shift-right n) (bit-xor x)))\n\n(def ^:private mix-64-const-1 (hex-long "bf58476d1ce4e5b9"))\n(def ^:private mix-64-const-2 (hex-long "94d049bb133111eb"))\n\n(defn ^:private mix-64\n  [n]\n  (-\x3e n\n      (bxoubsr 30)\n      (* mix-64-const-1)\n      (bxoubsr 27)\n      (* mix-64-const-2)\n      (bxoubsr 31)))\n\n(def ^:private mix-gamma-const-1 (hex-long "ff51afd7ed558ccd"))\n(def ^:private mix-gamma-const-2 (hex-long "c4ceb9fe1a85ec53"))\n(def ^:private mix-gamma-const-3 (hex-long "aaaaaaaaaaaaaaaa"))\n\n(defn ^:private mix-gamma\n  [n]\n  (-\x3e n\n      (bxoubsr 33)\n      (* mix-gamma-const-1)\n      (bxoubsr 33)\n      (* mix-gamma-const-2)\n      (bxoubsr 33)\n      (bit-or longs/ONE)\n      (as-\x3e z\n            (cond-\x3e z\n              (\x3e 24 (-\x3e z\n                        (bxoubsr 1)\n                        (bit-count)))\n              (bit-xor mix-gamma-const-3)))))\n\n(deftype JavaUtilSplittableRandom [gamma state]\n  IRandom\n  (rand-long [_]\n    (-\x3e state (+ gamma) (mix-64)))\n  (rand-double [this]\n    (-\x3e this rand-long doubles/rand-long-\x3erand-double))\n  (split [this]\n    (let [state\' (+ gamma state)\n          state\'\' (+ gamma state\')\n          gamma\' (mix-gamma state\'\')]\n      [(JavaUtilSplittableRandom. gamma state\'\')\n       (JavaUtilSplittableRandom. gamma\' (mix-64 state\'))]))\n  (split-n [this n]\n    (case n\n      0 []\n      1 [this]\n      (let [n-dec (dec n)]\n        (loop [state state\n               ret (transient [])]\n          (if (\x3d n-dec (count ret))\n            (-\x3e ret\n                (conj! (JavaUtilSplittableRandom. gamma state))\n                (persistent!))\n            (let [state\' (+ gamma state)\n                  state\'\' (+ gamma state\')\n                  gamma\' (mix-gamma state\'\')\n                  new-rng (JavaUtilSplittableRandom. gamma\' (mix-64 state\'))]\n              (recur state\'\' (conj! ret new-rng)))))))))\n\n(def ^:private golden-gamma\n  (hex-long "9e3779b97f4a7c15"))\n\n(defn make-java-util-splittable-random\n  [seed]\n  (JavaUtilSplittableRandom. golden-gamma\n                             (or (longs/-\x3elong seed)\n                                 (throw (ex-info "Bad random seed!"\n                                                 {:seed seed})))))\n\n(def ^:private next-rng\n  (let [a (atom {:state\n                 (make-java-util-splittable-random (.valueOf (js/Date.)))})]\n    (fn []\n      (:returned\n       (swap! a (fn [{:keys [state]}]\n                  (let [[r1 r2] (split state)]\n                    {:state r1 :returned r2})))))))\n\n(defn make-random\n  "Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol."\n  ([] (next-rng))\n  ([seed]\n   (make-java-util-splittable-random seed)))\n'],
null),new p(null,3,[Cl,"clojure/test/check/generators.cljc",Xn,"clojure.test.check.generators",nr,';   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check.generators\n  (:refer-clojure :exclude [int vector list hash-map map keyword\n                            char boolean byte bytes sequence\n                            shuffle not-empty symbol namespace\n                            set sorted-set uuid double let])\n  (:require [#?(:clj clojure.core :cljs cljs.core) :as core\n             #?@(:cljs [:include-macros true])]\n            [clojure.string :as string]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.rose-tree :as rose]\n            #?@(:cljs [[goog.string :as gstring]\n                       [clojure.string]]))\n  #?(:cljs (:require-macros [clojure.test.check.generators :refer [let]])))\n\n;; Gen\n;; (internal functions)\n;; ---------------------------------------------------------------------------\n\n(defrecord Generator [gen])\n\n(defn generator?\n  "Test if `x` is a generator. Generators should be treated as opaque values."\n  [x]\n  (instance? Generator x))\n\n(defn- make-gen\n  [generator-fn]\n  (Generator. generator-fn))\n\n(defn call-gen\n  "Internal function."\n  {:no-doc true}\n  [{generator-fn :gen} rnd size]\n  (generator-fn rnd size))\n\n(defn gen-pure\n  "Internal function."\n  {:no-doc true}\n  [value]\n  (make-gen\n   (fn [rnd size]\n     value)))\n\n(defn gen-fmap\n  "Internal function."\n  {:no-doc true}\n  [k {h :gen}]\n  (make-gen\n   (fn [rnd size]\n     (k (h rnd size)))))\n\n(defn gen-bind\n  "Internal function."\n  {:no-doc true}\n  [{h :gen} k]\n  (make-gen\n   (fn [rnd size]\n     (core/let [[r1 r2] (random/split rnd)\n                inner (h r1 size)\n                {result :gen} (k inner)]\n       (result r2 size)))))\n\n(defn lazy-random-states\n  "Internal function.\n\n  Given a random number generator, returns an infinite lazy sequence\n  of random number generators."\n  [rr]\n  (lazy-seq\n   (core/let [[r1 r2] (random/split rr)]\n     (cons r1\n           (lazy-random-states r2)))))\n\n(defn- gen-tuple\n  "Takes a collection of generators and returns a generator of vectors."\n  [gens]\n  (make-gen\n   (fn [rnd size]\n     (mapv #(call-gen % %2 size) gens (random/split-n rnd (count gens))))))\n\n;; Exported generator functions\n;; ---------------------------------------------------------------------------\n\n(defn fmap\n  "Returns a generator like `gen` but with values transformed by `f`.\n  E.g.:\n\n      (gen/sample (gen/fmap str gen/nat))\n      \x3d\x3e (\\"0\\" \\"1\\" \\"0\\" \\"1\\" \\"4\\" \\"3\\" \\"6\\" \\"6\\" \\"4\\" \\"2\\")\n\n  Also see gen/let for a macro with similar functionality."\n  [f gen]\n  (assert (generator? gen) "Second arg to fmap must be a generator")\n  (gen-fmap #(rose/fmap f %) gen))\n\n(defn return\n  "Create a generator that always returns `value`,\n  and never shrinks. You can think of this as\n  the `constantly` of generators. E.g.:\n\n      (gen/sample (gen/return 42))\n      \x3d\x3e (42 42 42 42 42 42 42 42 42 42)"\n  [value]\n  (gen-pure (rose/pure value)))\n\n(defn- bind-helper\n  [f]\n  (fn [rose]\n    (gen-fmap rose/join\n              (make-gen\n               (fn [rnd size]\n                 (rose/fmap #(call-gen (f %) rnd size)\n                            rose))))))\n\n(defn bind\n  "Create a new generator that passes the result of `gen` into function\n  `f`. `f` should return a new generator. This allows you to create new\n  generators that depend on the value of other generators. For example,\n  to create a generator of permutations which first generates a\n  `num-elements` and then generates a shuffling of `(range num-elements)`:\n\n      (gen/bind gen/nat\n                ;; this function takes a value generated by\n                ;; the generator above and returns a new generator\n                ;; which shuffles the collection returned by `range`\n                (fn [num-elements]\n                  (gen/shuffle (range num-elements))))\n\n  Also see gen/let for a macro with similar functionality."\n  [generator f]\n  (assert (generator? generator) "First arg to bind must be a generator")\n  (gen-bind generator (bind-helper f)))\n\n;; Helpers\n;; ---------------------------------------------------------------------------\n\n(defn make-size-range-seq\n  "Internal function."\n  {:no-doc true}\n  [max-size]\n  (cycle (range 0 max-size)))\n\n(defn sample-seq\n  "Return a sequence of realized values from `generator`."\n  ([generator] (sample-seq generator 200))\n  ([generator max-size]\n   (core/let [r (random/make-random)\n              size-seq (make-size-range-seq max-size)]\n     (core/map #(rose/root (call-gen generator %1 %2))\n               (lazy-random-states r)\n               size-seq))))\n\n(defn sample\n  "Return a sequence of `num-samples` (default 10)\n  realized values from `generator`.\n\n  The sequence starts with small values from the generator, which\n  probably do not reflect the variety of values that will be generated\n  during a longer test run.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators."\n  ([generator]\n   (sample generator 10))\n  ([generator num-samples]\n   (assert (generator? generator) "First arg to sample must be a generator")\n   (take num-samples (sample-seq generator))))\n\n(defn generate\n  "Returns a single sample value from the generator.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\n\n  Optional args:\n\n  - size: the abstract size parameter, defaults to 30\n  - seed: the seed for the random number generator, an integer"\n  {:added "0.8.0"}\n  ([generator]\n   (generate generator 30))\n  ([generator size]\n   (core/let [rng (random/make-random)]\n     (rose/root (call-gen generator rng size))))\n  ([generator size seed]\n   (core/let [rng (random/make-random seed)]\n     (rose/root (call-gen generator rng size)))))\n\n;; Internal Helpers\n;; ---------------------------------------------------------------------------\n\n(defn- halfs\n  [n]\n  (take-while #(not\x3d 0 %) (iterate #(quot % 2) n)))\n\n(defn- shrink-int\n  [integer]\n  (core/map #(- integer %) (halfs integer)))\n\n(defn- int-rose-tree\n  [value]\n  (rose/make-rose value (core/map int-rose-tree (shrink-int value))))\n\n;; calc-long is factored out to support testing the surprisingly tricky double math.  Note:\n;; An extreme long value does not have a precision-preserving representation as a double.\n;; Be careful about changing this code unless you understand what\'s happening in these\n;; examples:\n;;\n;; (\x3d (long (- Integer/MAX_VALUE (double (- Integer/MAX_VALUE 10)))) 10)\n;; (\x3d (long (- Long/MAX_VALUE (double (- Long/MAX_VALUE 10)))) 0)\n\n(defn- calc-long\n  [factor lower upper]\n  ;; these pre- and post-conditions are disabled for deployment\n  #_ {:pre [(float? factor) (\x3e\x3d factor 0.0) (\x3c factor 1.0)\n            (integer? lower) (integer? upper) (\x3c\x3d lower upper)]\n      :post [(integer? %)]}\n  ;; Use -\' on width to maintain accuracy with overflow protection.\n  #?(:clj\n     (core/let [width (-\' upper lower -1)]\n       ;; Preserve long precision if the width is in the long range.  Otherwise, we must accept\n       ;; less precision because doubles don\'t have enough bits to preserve long equivalence at\n       ;; extreme values.\n       (if (\x3c width Long/MAX_VALUE)\n         (+ lower (long (Math/floor (* factor width))))\n         ;; Clamp down to upper because double math.\n         (min upper (long (Math/floor (+ lower (* factor width)))))))\n\n     :cljs\n     (long (Math/floor (+ lower (- (* factor (+ 1.0 upper))\n                                   (* factor lower)))))))\n\n(defn- rand-range\n  [rnd lower upper]\n  {:pre [(\x3c\x3d lower upper)]}\n  (calc-long (random/rand-double rnd) lower upper))\n\n(defn sized\n  "Create a generator that depends on the size parameter.\n  `sized-gen` is a function that takes an integer and returns\n  a generator.\n\n      TODO: example"\n  [sized-gen]\n  (make-gen\n   (fn [rnd size]\n     (core/let [sized-gen (sized-gen size)]\n       (call-gen sized-gen rnd size)))))\n\n;; Combinators and helpers\n;; ---------------------------------------------------------------------------\n\n(defn resize\n  "Create a new generator with `size` always bound to `n`.\n\n      (gen/sample (gen/set (gen/resize 200 gen/double)))\n      \x3d\x3e (#{}\n          #{-4.994772362980037E147}\n          #{-4.234418056487335E-146}\n          #{}\n          #{}\n          #{}\n          #{NaN}\n          #{8.142414100982609E-63}\n          #{-3.58429955903876E-159 2.8563794617604296E-154\n            4.1021360195776005E-100 1.9084564045332549E-38}\n          #{-2.1582818131881376E83 -5.8460065493236117E48 9.729260993803226E166})"\n  [n generator]\n  (assert (generator? generator) "Second arg to resize must be a generator")\n  (core/let [{:keys [gen]} generator]\n    (make-gen\n     (fn [rnd _size]\n       (gen rnd n)))))\n\n(defn scale\n  "Create a new generator that modifies the size parameter by the\n  given function. Intended to support generators with sizes that need\n  to grow at different rates compared to the normal linear scaling.\n\n      (gen/sample (gen/tuple (gen/scale #(/ % 10) gen/nat)\n                             gen/nat\n                             (gen/scale #(* % 10) gen/nat)))\n      \x3d\x3e ([0 0 0]  [0 1 2]  [0 2 13] [0 1 6]  [0 1 23]\n          [0 2 42] [0 1 26] [0 1 12] [0 1 12] [0 0 3])"\n  {:added "0.8.0"}\n  ([f generator]\n   (sized (fn [n] (resize (f n) generator)))))\n\n(defn choose\n  #?(:clj\n     "Create a generator that returns long integers in the range\n     `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         \x3d\x3e (331 241 593 339 643 718 688 473 247 694)"\n\n     :cljs\n     "Create a generator that returns integer numbers in the range\n     `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         \x3d\x3e (331 241 593 339 643 718 688 473 247 694)")\n  [lower upper]\n  ;; cast to long to support doubles as arguments per TCHECK-73\n  (core/let #?(:clj\n               [lower (long lower)\n                upper (long upper)]\n\n               :cljs ;; does nothing, no long in cljs\n               [])\n    (make-gen\n     (fn [rnd _size]\n       (core/let [value (rand-range rnd lower upper)]\n         (rose/filter\n          #(and (\x3e\x3d % lower) (\x3c\x3d % upper))\n          (int-rose-tree value)))))))\n\n(defn one-of\n  "Create a generator that randomly chooses a value from the list of\n  provided generators. Shrinks toward choosing an earlier generator,\n  as well as shrinking the value generated by the chosen generator.\n\n      (gen/sample (gen/one-of [gen/int gen/boolean (gen/vector gen/int)]))\n      \x3d\x3e (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"\n  [generators]\n  (assert (every? generator? generators)\n          "Arg to one-of must be a collection of generators")\n  (assert (seq generators)\n          "one-of cannot be called with an empty collection")\n  (bind (choose 0 (dec (count generators)))\n        #(nth generators %)))\n\n(defn- pick\n  "Returns an index into the `likelihoods` sequence."\n  [likelihoods n]\n  (-\x3e\x3e likelihoods\n       (reductions + 0)\n       (rest)\n       (take-while #(\x3c\x3d % n))\n       (count)))\n\n(defn frequency\n  "Create a generator that chooses a generator from `pairs` based on the\n  provided likelihoods. The likelihood of a given generator being chosen is\n  its likelihood divided by the sum of all likelihoods. Shrinks toward\n  choosing an earlier generator, as well as shrinking the value generated\n  by the chosen generator.\n\n  Examples:\n\n      (gen/sample (gen/frequency [[5 gen/int] [3 (gen/vector gen/int)] [2 gen/boolean]]))\n      \x3d\x3e (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"\n  [pairs]\n  (assert (every? (fn [[x g]] (and (number? x) (generator? g)))\n                  pairs)\n          "Arg to frequency must be a list of [num generator] pairs")\n  (core/let [pairs (filter (comp pos? first) pairs)\n             total (apply + (core/map first pairs))]\n    (assert (seq pairs)\n            "frequency must be called with at least one non-zero weight")\n    ;; low-level impl for shrinking control\n    (make-gen\n     (fn [rnd size]\n       (call-gen\n        (gen-bind (choose 0 (dec total))\n                  (fn [x]\n                    (core/let [idx (pick (core/map first pairs) (rose/root x))]\n                      (gen-fmap (fn [rose]\n                                  (rose/make-rose (rose/root rose)\n                                                  (lazy-seq\n                                                   (concat\n                                                    ;; try to shrink to earlier generators first\n                                                    (for [idx (range idx)]\n                                                      (call-gen (second (nth pairs idx))\n                                                                rnd\n                                                                size))\n                                                    (rose/children rose)))))\n                                (second (nth pairs idx))))))\n        rnd size)))))\n\n(defn elements\n  "Create a generator that randomly chooses an element from `coll`.\n\n      (gen/sample (gen/elements [:foo :bar :baz]))\n      \x3d\x3e (:foo :baz :baz :bar :foo :foo :bar :bar :foo :bar)"\n  [coll]\n  (assert (seq coll) "elements cannot be called with an empty collection")\n  (core/let [v (vec coll)]\n    (gen-fmap #(rose/fmap v %)\n              (choose 0 (dec (count v))))))\n\n(defn- such-that-helper\n  [pred gen {:keys [ex-fn max-tries]} rng size]\n  (loop [tries-left max-tries\n         rng rng\n         size size]\n    (if (zero? tries-left)\n      (throw (ex-fn {:pred pred, :gen, gen :max-tries max-tries}))\n      (core/let [[r1 r2] (random/split rng)\n                 value (call-gen gen r1 size)]\n        (if (pred (rose/root value))\n          (rose/filter pred value)\n          (recur (dec tries-left) r2 (inc size)))))))\n\n(def ^:private\n  default-such-that-opts\n  {:ex-fn (fn [{:keys [max-tries] :as arg}]\n            (ex-info (str "Couldn\'t satisfy such-that predicate after "\n                          max-tries " tries.")\n                     arg))\n   :max-tries 10})\n\n(defn such-that\n  "Create a generator that generates values from `gen` that satisfy predicate\n  `pred`. Care is needed to ensure there is a high chance `gen` will satisfy\n  `pred`. By default, `such-that` will try 10 times to generate a value that\n  satisfies the predicate. If no value passes this predicate after this number\n  of iterations, a runtime exception will be thrown. Note also that each\n  time such-that retries, it will increase the size parameter.\n\n  Examples:\n\n      ;; generate non-empty vectors of integers\n      ;; (note, gen/not-empty does exactly this)\n      (gen/such-that not-empty (gen/vector gen/int))\n\n  You can customize `such-that` by passing an optional third argument, which can\n  either be an integer representing the maximum number of times test.check\n  will try to generate a value matching the predicate, or a map:\n\n      :max-tries  positive integer, the maximum number of tries (default 10)\n      :ex-fn      a function of one arg that will be called if test.check cannot\n                  generate a matching value; it will be passed a map with `:gen`,\n                  `:pred`, and `:max-tries` and should return an exception"\n  ([pred gen]\n   (such-that pred gen 10))\n  ([pred gen max-tries-or-opts]\n   (core/let [opts (cond (integer? max-tries-or-opts)\n                         {:max-tries max-tries-or-opts}\n\n                         (map? max-tries-or-opts)\n                         max-tries-or-opts\n\n                         :else\n                         (throw (ex-info "Bad argument to such-that!" {:max-tries-or-opts\n                                                                       max-tries-or-opts})))\n              opts (merge default-such-that-opts opts)]\n     (assert (generator? gen) "Second arg to such-that must be a generator")\n     (make-gen\n      (fn [rand-seed size]\n        (such-that-helper pred gen opts rand-seed size))))))\n\n(defn not-empty\n  "Modifies a generator so that it doesn\'t generate empty collections.\n\n  Examples:\n\n      ;; generate a vector of booleans, but never the empty vector\n      (gen/sample (gen/not-empty (gen/vector gen/boolean)))\n      \x3d\x3e ([false]\n          [false false]\n          [false false]\n          [false false false]\n          [false false false false]\n          [false true true]\n          [true false false false]\n          [true]\n          [true true true false false true false]\n          [false true true true false true true true false])"\n  [gen]\n  (assert (generator? gen) "Arg to not-empty must be a generator")\n  (such-that core/not-empty gen))\n\n(defn no-shrink\n  "Create a new generator that is just like `gen`, except does not shrink\n  at all. This can be useful when shrinking is taking a long time or is not\n  applicable to the domain."\n  [gen]\n  (assert (generator? gen) "Arg to no-shrink must be a generator")\n  (gen-fmap (fn [rose]\n              (rose/make-rose (rose/root rose) []))\n            gen))\n\n(defn shrink-2\n  "Create a new generator like `gen`, but will consider nodes for shrinking\n  even if their parent passes the test (up to one additional level)."\n  [gen]\n  (assert (generator? gen) "Arg to shrink-2 must be a generator")\n  (gen-fmap rose/collapse gen))\n\n(def boolean\n  "Generates one of `true` or `false`. Shrinks to `false`."\n  (elements [false true]))\n\n(defn tuple\n  "Create a generator that returns a vector, whose elements are chosen\n  from the generators in the same position. The individual elements shrink\n  according to their generator, but the value will never shrink in count.\n\n  Examples:\n\n      (def t (tuple gen/int gen/boolean))\n      (sample t)\n      ;; \x3d\x3e ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]\n      ;; \x3d\x3e  [3 true] [-4 false] [9 true]))"\n  [\x26 generators]\n  (assert (every? generator? generators)\n          "Args to tuple must be generators")\n  (gen-fmap (fn [roses]\n              (rose/zip core/vector roses))\n            (gen-tuple generators)))\n\n(def int\n  "Generates a positive or negative integer bounded by the generator\'s\n  `size` parameter."\n  (sized (fn [size] (choose (- size) size))))\n\n(def nat\n  "Generates non-negative integers bounded by the generator\'s `size`\n  parameter. Shrinks to zero."\n  (fmap #(Math/abs (long %)) int))\n\n(def pos-int\n  "Generate positive integers bounded by the generator\'s `size` parameter."\n  nat)\n\n(def neg-int\n  "Generate negative integers bounded by the generator\'s `size` parameter."\n  (fmap #(* -1 %) nat))\n\n(def s-pos-int\n  "Generate strictly positive integers bounded by the generator\'s `size` + 1"\n  (fmap inc nat))\n\n(def s-neg-int\n  "Generate strictly negative integers bounded by the generator\'s `size` + 1"\n  (fmap dec neg-int))\n\n(defn vector\n  "Create a generator of vectors whose elements are chosen from\n  `generator`. The count of the vector will be bounded by the `size`\n  generator parameter."\n  ([generator]\n   (assert (generator? generator) "Arg to vector must be a generator")\n   (gen-bind\n    (sized #(choose 0 %))\n    (fn [num-elements-rose]\n      (gen-fmap (fn [roses]\n                  (rose/shrink-vector core/vector\n                                      roses))\n                (gen-tuple (repeat (rose/root num-elements-rose)\n                                   generator))))))\n  ([generator num-elements]\n   (assert (generator? generator) "First arg to vector must be a generator")\n   (apply tuple (repeat num-elements generator)))\n  ([generator min-elements max-elements]\n   (assert (generator? generator) "First arg to vector must be a generator")\n   (gen-bind\n    (choose min-elements max-elements)\n    (fn [num-elements-rose]\n      (gen-fmap (fn [roses]\n                  (rose/filter\n                   (fn [v] (and (\x3e\x3d (count v) min-elements)\n                                (\x3c\x3d (count v) max-elements)))\n                   (rose/shrink-vector core/vector\n                                       roses)))\n                (gen-tuple (repeat (rose/root num-elements-rose)\n                                   generator)))))))\n\n(defn list\n  "Like `vector`, but generates lists."\n  [generator]\n  (assert (generator? generator) "First arg to list must be a generator")\n  (gen-bind (sized #(choose 0 %))\n            (fn [num-elements-rose]\n              (gen-fmap (fn [roses]\n                          (rose/shrink-vector core/list\n                                              roses))\n                        (gen-tuple (repeat (rose/root num-elements-rose)\n                                           generator))))))\n\n(defn- swap\n  [coll [i1 i2]]\n  (assoc coll i2 (coll i1) i1 (coll i2)))\n\n(defn\n  ^{:added "0.6.0"}\n  shuffle\n  "Create a generator that generates random permutations of\n  `coll`. Shrinks toward the original collection: `coll`. `coll` will\n  be coerced to a vector."\n  [coll]\n  (core/let [coll (if (vector? coll) coll (vec coll))\n             index-gen (choose 0 (dec (count coll)))]\n    (fmap #(reduce swap coll %)\n          ;; a vector of swap instructions, with count between\n          ;; zero and 2 * count. This means that the average number\n          ;; of instructions is count, which should provide sufficient\n          ;; (though perhaps not \'perfect\') shuffling. This still gives us\n          ;; nice, relatively quick shrinks.\n          (vector (tuple index-gen index-gen) 0 (* 2 (count coll))))))\n\n;; NOTE cljs: Comment out for now - David\n\n#?(:clj\n   (def byte\n     "Generates `java.lang.Byte`s, using the full byte-range."\n     (fmap core/byte (choose Byte/MIN_VALUE Byte/MAX_VALUE))))\n\n#?(:clj\n   (def bytes\n     "Generates byte-arrays."\n     (fmap core/byte-array (vector byte))))\n\n(defn hash-map\n  "Like clojure.core/hash-map, except the values are generators.\n   Returns a generator that makes maps with the supplied keys and\n   values generated using the supplied generators.\n\n       (gen/sample (gen/hash-map :a gen/boolean :b gen/nat))\n       \x3d\x3e ({:a false, :b 0}\n           {:a true,  :b 1}\n           {:a false, :b 2}\n           {:a true,  :b 2}\n           {:a false, :b 4}\n           {:a false, :b 2}\n           {:a true,  :b 3}\n           {:a true,  :b 4}\n           {:a false, :b 1}\n           {:a false, :b 0})"\n  [\x26 kvs]\n  (assert (even? (count kvs)))\n  (core/let [ks (take-nth 2 kvs)\n             vs (take-nth 2 (rest kvs))]\n    (assert (every? generator? vs)\n            "Value args to hash-map must be generators")\n    (fmap #(zipmap ks %)\n          (apply tuple vs))))\n\n;; Collections of distinct elements\n;; (has to be done in a low-level way (instead of with combinators)\n;;  and is subject to the same kind of failure as such-that)\n;; ---------------------------------------------------------------------------\n\n(defn ^:private transient-set-contains?\n  [s k]\n  #? (:clj\n      (.contains ^clojure.lang.ITransientSet s k)\n      :cljs\n      (some? (-lookup s k))))\n\n(defn ^:private coll-distinct-by*\n  "Returns a rose tree."\n  [empty-coll key-fn shuffle-fn gen rng size num-elements min-elements max-tries ex-fn]\n  {:pre [gen (:gen gen)]}\n  (loop [rose-trees (transient [])\n         s (transient #{})\n         rng rng\n         size size\n         tries 0]\n    (cond (and (\x3d max-tries tries)\n               (\x3c (count rose-trees) min-elements))\n          (throw (ex-fn {:gen gen\n                         :max-tries max-tries\n                         :num-elements num-elements}))\n\n          (or (\x3d max-tries tries)\n              (\x3d (count rose-trees) num-elements))\n          (-\x3e\x3e (persistent! rose-trees)\n               ;; we shuffle the rose trees so that we aren\'t biased\n               ;; toward generating "smaller" elements earlier in the\n               ;; collection (only applies to ordered collections)\n               ;;\n               ;; shuffling the rose trees is more efficient than\n               ;; (bind ... shuffle) because we only perform the\n               ;; shuffling once and we have no need to shrink the\n               ;; shufling.\n               (shuffle-fn rng)\n               (rose/shrink-vector #(into empty-coll %\x26)))\n\n          :else\n          (core/let [[rng1 rng2] (random/split rng)\n                     rose (call-gen gen rng1 size)\n                     root (rose/root rose)\n                     k (key-fn root)]\n            (if (transient-set-contains? s k)\n              (recur rose-trees s rng2 (inc size) (inc tries))\n              (recur (conj! rose-trees rose)\n                     (conj! s k)\n                     rng2\n                     size\n                     0))))))\n\n(defn ^:private distinct-by?\n  "Like clojure.core/distinct? but takes a collection instead of varargs,\n  and returns true for empty collections."\n  [f coll]\n  (or (empty? coll)\n      (apply distinct? (core/map f coll))))\n\n(defn ^:private the-shuffle-fn\n  "Returns a shuffled version of coll according to the rng.\n\n  Note that this is not a generator, it is just a utility function."\n  [rng coll]\n  (core/let [empty-coll (empty coll)\n             v (vec coll)\n             card (count coll)\n             dec-card (dec card)]\n    (into empty-coll\n          (first\n           (reduce (fn [[v rng] idx]\n                     (core/let [[rng1 rng2] (random/split rng)\n                                swap-idx (rand-range rng1 idx dec-card)]\n                       [(swap v [idx swap-idx]) rng2]))\n                   [v rng]\n                   (range card))))))\n\n(defn ^:private coll-distinct-by\n  [empty-coll key-fn allows-dupes? ordered? gen\n   {:keys [num-elements min-elements max-elements max-tries ex-fn]\n    :or {max-tries 10\n         ex-fn #(ex-info "Couldn\'t generate enough distinct elements!" %)}}]\n  (core/let [shuffle-fn (if ordered?\n                          the-shuffle-fn\n                          (fn [_rng coll] coll))\n             hard-min-elements (or num-elements min-elements 1)]\n    (if num-elements\n      (core/let [size-pred #(\x3d num-elements (count %))]\n        (assert (and (nil? min-elements) (nil? max-elements)))\n        (make-gen\n         (fn [rng gen-size]\n           (rose/filter\n            (if allows-dupes?\n              ;; is there a smarter way to do the shrinking than checking\n              ;; the distinctness of the entire collection at each\n              ;; step?\n              (every-pred size-pred #(distinct-by? key-fn %))\n              size-pred)\n            (coll-distinct-by* empty-coll key-fn shuffle-fn gen rng gen-size\n                               num-elements hard-min-elements max-tries ex-fn)))))\n      (core/let [min-elements (or min-elements 0)\n                 size-pred (if max-elements\n                             #(\x3c\x3d min-elements (count %) max-elements)\n                             #(\x3c\x3d min-elements (count %)))]\n        (gen-bind\n         (if max-elements\n           (choose min-elements max-elements)\n           (sized #(choose min-elements (+ min-elements %))))\n         (fn [num-elements-rose]\n           (core/let [num-elements (rose/root num-elements-rose)]\n             (make-gen\n              (fn [rng gen-size]\n                (rose/filter\n                 (if allows-dupes?\n                   ;; same comment as above\n                   (every-pred size-pred #(distinct-by? key-fn %))\n                   size-pred)\n                 (coll-distinct-by* empty-coll key-fn shuffle-fn gen rng gen-size\n                                    num-elements hard-min-elements max-tries ex-fn)))))))))))\n\n;; I tried to reduce the duplication in these docstrings with a macro,\n;; but couldn\'t make it work in cljs.\n\n(defn vector-distinct\n  "Generates a vector of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"\n  {:added "0.9.0"}\n  ([gen] (vector-distinct gen {}))\n  ([gen opts]\n   (assert (generator? gen) "First arg to vector-distinct must be a generator!")\n   (coll-distinct-by [] identity true true gen opts)))\n\n(defn list-distinct\n  "Generates a list of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"\n  {:added "0.9.0"}\n  ([gen] (list-distinct gen {}))\n  ([gen opts]\n   (assert (generator? gen) "First arg to list-distinct must be a generator!")\n   (coll-distinct-by () identity true true gen opts)))\n\n(defn vector-distinct-by\n  "Generates a vector of elements from the given generator, with the\n  guarantee that (map key-fn the-vector) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"\n  {:added "0.9.0"}\n  ([key-fn gen] (vector-distinct-by key-fn gen {}))\n  ([key-fn gen opts]\n   (assert (generator? gen) "Second arg to vector-distinct-by must be a generator!")\n   (coll-distinct-by [] key-fn true true gen opts)))\n\n(defn list-distinct-by\n  "Generates a list of elements from the given generator, with the\n  guarantee that (map key-fn the-list) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"\n  {:added "0.9.0"}\n  ([key-fn gen] (list-distinct-by key-fn gen {}))\n  ([key-fn gen opts]\n   (assert (generator? gen) "Second arg to list-distinct-by must be a generator!")\n   (coll-distinct-by () key-fn true true gen opts)))\n\n(defn set\n  "Generates a set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"\n  {:added "0.9.0"}\n  ([gen] (set gen {}))\n  ([gen opts]\n   (assert (generator? gen) "First arg to set must be a generator!")\n   (coll-distinct-by #{} identity false false gen opts)))\n\n(defn sorted-set\n  "Generates a sorted set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"\n  {:added "0.9.0"}\n  ([gen] (sorted-set gen {}))\n  ([gen opts]\n   (assert (generator? gen) "First arg to sorted-set must be a generator!")\n   (coll-distinct-by (core/sorted-set) identity false false gen opts)))\n\n(defn map\n  "Create a generator that generates maps, with keys chosen from\n  `key-gen` and values chosen from `val-gen`.\n\n  If the key generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated maps\n    :min-elements  the min size of generated maps\n    :max-elements  the max size of generated maps\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct keys; it will be passed a map with\n                   `:gen` (the key-gen), `:num-elements`, and `:max-tries` and\n                   should return an exception"\n  ([key-gen val-gen] (map key-gen val-gen {}))\n  ([key-gen val-gen opts]\n   (coll-distinct-by {} first false false (tuple key-gen val-gen) opts)))\n\n;; large integers\n;; ---------------------------------------------------------------------------\n\n;; This approach has a few distribution edge cases, but is pretty good\n;; for expected uses and is way better than nothing.\n\n(def ^:private gen-raw-long\n  "Generates a single uniformly random long, does not shrink."\n  (make-gen (fn [rnd _size]\n              (rose/pure (random/rand-long rnd)))))\n\n(def ^:private MAX_INTEGER\n  #?(:clj Long/MAX_VALUE :cljs (dec (apply * (repeat 53 2)))))\n(def ^:private MIN_INTEGER\n  #?(:clj Long/MIN_VALUE :cljs (- MAX_INTEGER)))\n\n(defn ^:private abs\n  [x]\n  #?(:clj (Math/abs (long x)) :cljs (Math/abs x)))\n\n(defn ^:private long-\x3elarge-integer\n  [bit-count x min max]\n  (loop [res (-\x3e x\n                 (#?(:clj bit-shift-right :cljs .shiftRight)\n                  (- 64 bit-count))\n                 #?(:cljs .toNumber)\n                 ;; so we don\'t get into an infinite loop bit-shifting\n                 ;; -1\n                 (cond-\x3e (zero? min) (abs)))]\n    (if (\x3c\x3d min res max)\n      res\n      (core/let [res\' (- res)]\n        (if (\x3c\x3d min res\' max)\n          res\'\n          (recur #?(:clj (bit-shift-right res 1)\n                    ;; emulating bit-shift-right\n                    :cljs (-\x3e res\n                              (cond-\x3e (odd? res)\n                                ((if (neg? res) inc dec)))\n                              (/ 2)))))))))\n\n(defn ^:private large-integer**\n  "Like large-integer*, but assumes range includes zero."\n  [min max]\n  (sized (fn [size]\n           (core/let [size (core/max size 1) ;; no need to worry about size\x3d0\n                      max-bit-count (core/min size #?(:clj 64 :cljs 54))]\n             (gen-fmap (fn [rose]\n                         (core/let [[bit-count x] (rose/root rose)]\n                           (int-rose-tree (long-\x3elarge-integer bit-count x min max))))\n                       (tuple (choose 1 max-bit-count)\n                              gen-raw-long))))))\n\n(defn large-integer*\n  "Like large-integer, but accepts options:\n\n    :min  the minimum integer (inclusive)\n    :max  the maximum integer (inclusive)\n\n  Both :min and :max are optional.\n\n      (gen/sample (gen/large-integer* {:min 9000 :max 10000}))\n      \x3d\x3e (9000 9001 9001 9002 9000 9003 9006 9030 9005 9044)"\n  {:added "0.9.0"}\n  [{:keys [min max]}]\n  (core/let [min (or min MIN_INTEGER)\n             max (or max MAX_INTEGER)]\n    (assert (\x3c\x3d min max))\n    (such-that #(\x3c\x3d min % max)\n               (if (\x3c\x3d min 0 max)\n                 (large-integer** min max)\n                 (if (\x3c max 0)\n                   (fmap #(+ max %) (large-integer** (- min max) 0))\n                   (fmap #(+ min %) (large-integer** 0 (- max min))))))))\n\n(def ^{:added "0.9.0"} large-integer\n  "Generates a platform-native integer from the full available range\n  (in clj, 64-bit Longs, and in cljs, numbers between -(2^53 - 1) and\n  (2^53 - 1)).\n\n  Use large-integer* for more control."\n  (large-integer* {}))\n\n;; doubles\n;; ---------------------------------------------------------------------------\n\n\n;; This code is a lot more complex than any reasonable person would\n;; expect, for two reasons:\n;;\n;; 1) I wanted the generator to start with simple values and grow with\n;; the size parameter, as well as shrink back to simple values. I\n;; decided to define "simple" as numbers with simpler (closer to 0)\n;; exponents, with simpler fractional parts (fewer lower-level bits\n;; set), and with positive being simpler than negative. I also wanted\n;; to take optional min/max parameters, which complicates the hell out\n;; of things.\n;;\n;; 2) It works in CLJS as well, which has fewer utility functions for\n;; doubles, and I wanted it to work exactly the same way in CLJS just\n;; to validate the whole cross-platform situation. It should generate\n;; the exact same numbers on both platforms.\n;;\n;; Some of the lower level stuff could probably be less messy and\n;; faster, especially for CLJS.\n\n(def ^:private POS_INFINITY #?(:clj Double/POSITIVE_INFINITY, :cljs (.-POSITIVE_INFINITY js/Number)))\n(def ^:private NEG_INFINITY #?(:clj Double/NEGATIVE_INFINITY, :cljs (.-NEGATIVE_INFINITY js/Number)))\n(def ^:private MAX_POS_VALUE #?(:clj Double/MAX_VALUE, :cljs (.-MAX_VALUE js/Number)))\n(def ^:private MIN_NEG_VALUE (- MAX_POS_VALUE))\n(def ^:private NAN #?(:clj Double/NaN, :cljs (.-NaN js/Number)))\n\n(defn ^:private uniform-integer\n  "Generates an integer uniformly in the range 0..(2^bit-count-1)."\n  [bit-count]\n  {:assert [(\x3c\x3d 0 bit-count 52)]}\n  (if (\x3c\x3d bit-count 32)\n    ;; the case here is just for cljs\n    (choose 0 (case (long bit-count)\n                32 0xffffffff\n                31 0x7fffffff\n                (-\x3e 1 (bit-shift-left bit-count) dec)))\n    (fmap (fn [[upper lower]]\n            #? (:clj\n                (-\x3e upper (bit-shift-left 32) (+ lower))\n\n                :cljs\n                (-\x3e upper (* 0x100000000) (+ lower))))\n          (tuple (uniform-integer (- bit-count 32))\n                 (uniform-integer 32)))))\n\n(defn ^:private scalb\n  [x exp]\n  #?(:clj (Math/scalb ^double x ^int exp)\n     :cljs (* x (.pow js/Math 2 exp))))\n\n(defn ^:private fifty-two-bit-reverse\n  "Bit-reverses an integer in the range [0, 2^52)."\n  [n]\n  #? (:clj\n      (-\x3e n (Long/reverse) (unsigned-bit-shift-right 12))\n\n      :cljs\n      (loop [out 0\n             n n\n             out-shifter (Math/pow 2 52)]\n        (if (\x3c n 1)\n          (* out out-shifter)\n          (recur (-\x3e out (* 2) (+ (bit-and n 1)))\n                 (/ n 2)\n                 (/ out-shifter 2))))))\n\n(def ^:private backwards-shrinking-significand\n  "Generates a 52-bit non-negative integer that shrinks toward having\n  fewer lower-order bits (and shrinks to 0 if possible)."\n  (fmap fifty-two-bit-reverse\n        (sized (fn [size]\n                 (gen-bind (choose 0 (min size 52))\n                           (fn [rose]\n                             (uniform-integer (rose/root rose))))))))\n\n(defn ^:private get-exponent\n  [x]\n  #? (:clj\n      (Math/getExponent ^Double x)\n\n      :cljs\n      (if (zero? x)\n        -1023\n        (core/let [x (Math/abs x)\n\n                   res\n                   (Math/floor (* (Math/log x) (.-LOG2E js/Math)))\n\n                   t (scalb x (- res))]\n          (cond (\x3c t 1) (dec res)\n                (\x3c\x3d 2 t) (inc res)\n                :else res)))))\n\n(defn ^:private double-exp-and-sign\n  "Generates [exp sign], where exp is in [-1023, 1023] and sign is 1\n  or -1. Only generates values for exp and sign for which there are\n  doubles within the given bounds."\n  [lower-bound upper-bound]\n  (letfn [(gen-exp [lb ub]\n            (sized (fn [size]\n                     (core/let [qs8 (bit-shift-left 1 (quot (min 200 size) 8))]\n                       (cond (\x3c\x3d lb 0 ub)\n                             (choose (max lb (- qs8)) (min ub qs8))\n\n                             (\x3c ub 0)\n                             (choose (max lb (- ub qs8)) ub)\n\n                             :else\n                             (choose lb (min ub (+ lb qs8))))))))]\n    (if (and (nil? lower-bound)\n             (nil? upper-bound))\n      (tuple (gen-exp -1023 1023)\n             (elements [1.0 -1.0]))\n      (core/let [lower-bound (or lower-bound MIN_NEG_VALUE)\n                 upper-bound (or upper-bound MAX_POS_VALUE)\n                 lbexp (max -1023 (get-exponent lower-bound))\n                 ubexp (max -1023 (get-exponent upper-bound))]\n        (cond (\x3c\x3d 0.0 lower-bound)\n              (tuple (gen-exp lbexp ubexp)\n                     (return 1.0))\n\n              (\x3c\x3d upper-bound 0.0)\n              (tuple (gen-exp ubexp lbexp)\n                     (return -1.0))\n\n              :else\n              (fmap (fn [[exp sign :as pair]]\n                      (if (or (and (neg? sign) (\x3c lbexp exp))\n                              (and (pos? sign) (\x3c ubexp exp)))\n                        [exp (- sign)]\n                        pair))\n                    (tuple\n                     (gen-exp -1023 (max ubexp lbexp))\n                     (elements [1.0 -1.0]))))))))\n\n(defn ^:private block-bounds\n  "Returns [low high], the smallest and largest numbers in the given\n  range."\n  [exp sign]\n  (if (neg? sign)\n    (core/let [[low high] (block-bounds exp (- sign))]\n      [(- high) (- low)])\n    (if (\x3d -1023 exp)\n      [0.0 (-\x3e 1.0 (scalb 52) dec (scalb -1074))]\n      [(scalb 1.0 exp)\n       (-\x3e 1.0 (scalb 52) dec (scalb (- exp 51)))])))\n\n(defn ^:private double-finite\n  [lower-bound upper-bound]\n  {:pre [(or (nil? lower-bound)\n             (nil? upper-bound)\n             (\x3c\x3d lower-bound upper-bound))]}\n  (core/let [pred (if lower-bound\n                    (if upper-bound\n                      #(\x3c\x3d lower-bound % upper-bound)\n                      #(\x3c\x3d lower-bound %))\n                    (if upper-bound\n                      #(\x3c\x3d % upper-bound)))\n\n             gen\n             (fmap (fn [[[exp sign] significand]]\n                     (core/let [;; 1.0 \x3c\x3d base \x3c 2.0\n                                base (inc (/ significand (Math/pow 2 52)))\n                                x (-\x3e base (scalb exp) (* sign))]\n                       (if (or (nil? pred) (pred x))\n                         x\n                         ;; Scale things a bit when we have a partial range\n                         ;; to deal with. It won\'t be great for generating\n                         ;; simple numbers, but oh well.\n                         (core/let [[low high] (block-bounds exp sign)\n\n                                    block-lb (cond-\x3e low  lower-bound (max lower-bound))\n                                    block-ub (cond-\x3e high upper-bound (min upper-bound))\n                                    x (+ block-lb (* (- block-ub block-lb) (- base 1)))]\n                           (-\x3e x (min block-ub) (max block-lb))))))\n                   (tuple (double-exp-and-sign lower-bound upper-bound)\n                          backwards-shrinking-significand))]\n    ;; wrapping in the such-that is necessary for staying in bounds\n    ;; during shrinking\n    (cond-\x3e\x3e gen pred (such-that pred))))\n\n(defn double*\n  "Generates a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity can be generated (default true)\n    :NaN?      - whether NaN can be generated (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\n\n  Note that the min/max options must be finite numbers. Supplying a\n  min precludes -Infinity, and supplying a max precludes +Infinity."\n  {:added "0.9.0"}\n  [{:keys [infinite? NaN? min max]\n    :or {infinite? true, NaN? true}}]\n  (core/let [frequency-arg (cond-\x3e [[95 (double-finite min max)]]\n\n                             (if (nil? min)\n                               (or (nil? max) (\x3c\x3d 0.0 max))\n                               (if (nil? max)\n                                 (\x3c\x3d min 0.0)\n                                 (\x3c\x3d min 0.0 max)))\n                             (conj\n                              ;; Add zeros here as a special case, since\n                              ;; the `finite` code considers zeros rather\n                              ;; complex (as they have a -1023 exponent)\n                              ;;\n                              ;; I think most uses can\'t distinguish 0.0\n                              ;; from -0.0, but seems worth throwing both\n                              ;; in just in case.\n                              [1 (return 0.0)]\n                              [1 (return -0.0)])\n\n                             (and infinite? (nil? max))\n                             (conj [1 (return POS_INFINITY)])\n\n                             (and infinite? (nil? min))\n                             (conj [1 (return NEG_INFINITY)])\n\n                             NaN? (conj [1 (return NAN)]))]\n    (if (\x3d 1 (count frequency-arg))\n      (-\x3e frequency-arg first second)\n      (frequency frequency-arg))))\n\n(def ^{:added "0.9.0"} double\n  "Generates 64-bit floating point numbers from the entire range,\n  including +/- infinity and NaN. Use double* for more control."\n  (double* {}))\n\n;; Characters \x26 Strings\n;; ---------------------------------------------------------------------------\n\n(def char\n  "Generates character from 0-255."\n  (fmap core/char (choose 0 255)))\n\n(def char-ascii\n  "Generate only ascii character."\n  (fmap core/char (choose 32 126)))\n\n(def char-alphanumeric\n  "Generate alphanumeric characters."\n  (fmap core/char\n        (one-of [(choose 48 57)\n                 (choose 65 90)\n                 (choose 97 122)])))\n\n(def ^{:deprecated "0.6.0"}\n  char-alpha-numeric\n  "Deprecated - use char-alphanumeric instead.\n\n  Generate alphanumeric characters."\n  char-alphanumeric)\n\n(def char-alpha\n  "Generate alpha characters."\n  (fmap core/char\n        (one-of [(choose 65 90)\n                 (choose 97 122)])))\n\n(def ^:private char-symbol-special\n  "Generate non-alphanumeric characters that can be in a symbol."\n  (elements [\\* \\+ \\! \\- \\_ \\? \\.]))\n\n(def ^:private char-symbol-noninitial\n  "Generate characters that can be the char following first of a keyword or symbol."\n  (frequency [[14 char-alphanumeric]\n              [7 char-symbol-special]\n              [1 (return \\:)]]))\n\n(def ^:private char-symbol-initial\n  "Generate characters that can be the first char of a keyword or symbol."\n  (frequency [[2 char-alpha]\n              [1 char-symbol-special]]))\n\n(def string\n  "Generate strings. May generate unprintable characters."\n  (fmap clojure.string/join (vector char)))\n\n(def string-ascii\n  "Generate ascii strings."\n  (fmap clojure.string/join (vector char-ascii)))\n\n(def string-alphanumeric\n  "Generate alphanumeric strings."\n  (fmap clojure.string/join (vector char-alphanumeric)))\n\n(def ^{:deprecated "0.6.0"}\n  string-alpha-numeric\n  "Deprecated - use string-alphanumeric instead.\n\n  Generate alphanumeric strings."\n  string-alphanumeric)\n\n(defn- digit?\n  [d]\n  #?(:clj  (Character/isDigit ^Character d)\n     :cljs (gstring/isNumeric d)))\n\n(defn- +-or---digit?\n  "Returns true if c is \\\\+ or \\\\- and d is non-nil and a digit.\n\n  Symbols that start with +3 or -2 are not readable because they look\n  like numbers."\n  [c d]\n  (core/boolean (and d\n                     (or (#?(:clj \x3d :cljs identical?) \\+ c)\n                         (#?(:clj \x3d :cljs identical?) \\- c))\n                     (digit? d))))\n\n(def ^:private symbol-name-or-namespace\n  "Generates a namespace string for a symbol/keyword."\n  (-\x3e\x3e (tuple char-symbol-initial (vector char-symbol-noninitial))\n       (such-that (fn [[c [d]]] (not (+-or---digit? c d))))\n       (fmap (fn [[c cs]]\n               (core/let [s (clojure.string/join (cons c cs))]\n                 (-\x3e s\n                     (string/replace #":{2,}" ":")\n                     (string/replace #":$" "")))))))\n\n(defn ^:private resize-symbolish-generator\n  "Scales the sizing down on a keyword or symbol generator so as to\n  make it reasonable."\n  [g]\n  ;; function chosen by ad-hoc experimentation\n  (scale #(long (Math/pow % 0.60)) g))\n\n(def keyword\n  "Generate keywords without namespaces."\n  (frequency [[100\n               (-\x3e\x3e symbol-name-or-namespace\n                    (fmap core/keyword)\n                    (resize-symbolish-generator))]\n              [1 (return :/)]]))\n\n(def\n  ^{:added "0.5.9"}\n  keyword-ns\n  "Generate keywords with namespaces."\n  (-\x3e\x3e (tuple symbol-name-or-namespace symbol-name-or-namespace)\n       (fmap (fn [[ns name]] (core/keyword ns name)))\n       (resize-symbolish-generator)))\n\n(def symbol\n  "Generate symbols without namespaces."\n  (frequency [[100\n               (-\x3e\x3e symbol-name-or-namespace\n                    (fmap core/symbol)\n                    (resize-symbolish-generator))]\n              [1 (return \'/)]]))\n\n(def\n  ^{:added "0.5.9"}\n  symbol-ns\n  "Generate symbols with namespaces."\n  (-\x3e\x3e (tuple symbol-name-or-namespace symbol-name-or-namespace)\n       (fmap (fn [[ns name]] (core/symbol ns name)))\n       (resize-symbolish-generator)))\n\n(def ratio\n  "Generates a `clojure.lang.Ratio`. Shrinks toward 0. Not all values generated\n  will be ratios, as many values returned by `/` are not ratios."\n  (fmap\n   (fn [[a b]] (/ a b))\n   (tuple int\n          (such-that (complement zero?) int))))\n\n(def ^{:added "0.9.0"} uuid\n  "Generates a random type-4 UUID. Does not shrink."\n  (no-shrink\n   #?(:clj\n      ;; this could be done with combinators, but doing it low-level\n      ;; seems to be 10x faster\n      (make-gen\n       (fn [rng _size]\n         (core/let [[r1 r2] (random/split rng)\n                    x1 (-\x3e (random/rand-long r1)\n                           (bit-and -45057)\n                           (bit-or 0x4000))\n                    x2 (-\x3e (random/rand-long r2)\n                           (bit-or -9223372036854775808)\n                           (bit-and -4611686018427387905))]\n           (rose/make-rose\n            (java.util.UUID. x1 x2)\n            []))))\n\n      :cljs\n      ;; this could definitely be optimized so that it doesn\'t require\n      ;; generating 31 numbers\n      (fmap (fn [nibbles]\n              (letfn [(hex [idx] (.toString (nibbles idx) 16))]\n                (core/let [rhex (-\x3e (nibbles 15) (bit-and 3) (+ 8) (.toString 16))]\n                  (core/uuid (str (hex 0)  (hex 1)  (hex 2)  (hex 3)\n                                  (hex 4)  (hex 5)  (hex 6)  (hex 7)  "-"\n                                  (hex 8)  (hex 9)  (hex 10) (hex 11) "-"\n                                  "4"      (hex 12) (hex 13) (hex 14) "-"\n                                  rhex     (hex 16) (hex 17) (hex 18) "-"\n                                  (hex 19) (hex 20) (hex 21) (hex 22)\n                                  (hex 23) (hex 24) (hex 25) (hex 26)\n                                  (hex 27) (hex 28) (hex 29) (hex 30))))))\n            (vector (choose 0 15) 31)))))\n\n(def simple-type\n  (one-of [int large-integer double char string ratio boolean keyword\n           keyword-ns symbol symbol-ns uuid]))\n\n(def simple-type-printable\n  (one-of [int large-integer double char-ascii string-ascii ratio boolean\n           keyword keyword-ns symbol symbol-ns uuid]))\n\n#?(:cljs\n;; http://dev.clojure.org/jira/browse/CLJS-1594\n   (defn ^:private hashable?\n     [x]\n     (if (number? x)\n       (not (or (js/isNaN x)\n                (\x3d NEG_INFINITY x)\n                (\x3d POS_INFINITY x)))\n       true)))\n\n(defn container-type\n  [inner-type]\n  (one-of [(vector inner-type)\n           (list inner-type)\n           (set #?(:clj inner-type\n                   :cljs (such-that hashable? inner-type)))\n           ;; scaling this by half since it naturally generates twice\n           ;; as many elements\n           (scale #(quot % 2)\n                  (map #?(:clj inner-type\n                          :cljs (such-that hashable? inner-type))\n                       inner-type))]))\n\n;; A few helpers for recursive-gen\n\n(defn ^:private size-\x3emax-leaf-count\n  [size]\n  ;; chosen so that recursive-gen (with the assumptions mentioned in\n  ;; the comment below) will generate structures with leaf-node-counts\n  ;; not greater than the `size` ~99% of the time.\n  (long (Math/pow size 1.1)))\n\n(core/let [log2 (Math/log 2)]\n  (defn ^:private random-pseudofactoring\n    "Returns (not generates) a random collection of integers `xs`\n  greater than 1 such that (\x3c\x3d (apply * xs) n)."\n    [n rng]\n    (if (\x3c\x3d n 2)\n      [n]\n      (core/let [log (Math/log n)\n                 [r1 r2] (random/split rng)\n                 n1 (-\x3e (random/rand-double r1)\n                        (* (- log log2))\n                        (+ log2)\n                        (Math/exp)\n                        (long))\n                 n2 (quot n n1)]\n        (if (and (\x3c 1 n1) (\x3c 1 n2))\n          (cons n1 (random-pseudofactoring n2 r2))\n          [n])))))\n\n(defn ^:private randomized\n  "Like sized, but passes an rng instead of a size."\n  [func]\n  (make-gen (fn [rng size]\n              (core/let [[r1 r2] (random/split rng)]\n                (call-gen\n                 (func r1)\n                 r2\n                 size)))))\n\n(defn\n  ^{:added "0.5.9"}\n  recursive-gen\n  "This is a helper for writing recursive (tree-shaped) generators. The first\n  argument should be a function that takes a generator as an argument, and\n  produces another generator that \'contains\' that generator. The vector function\n  in this namespace is a simple example. The second argument is a scalar\n  generator, like boolean. For example, to produce a tree of booleans:\n\n    (gen/recursive-gen gen/vector gen/boolean)\n\n  Vectors or maps either recurring or containing booleans or integers:\n\n    (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)\n                                                (gen/map inner inner)]))\n                       (gen/one-of [gen/boolean gen/int]))\n\n  Note that raw scalar values will be generated as well. To prevent this, you\n  can wrap the returned generator with the function passed as the first arg,\n  e.g.:\n\n    (gen/vector (gen/recursive-gen gen/vector gen/boolean))"\n  [container-gen-fn scalar-gen]\n  (assert (generator? scalar-gen)\n          "Second arg to recursive-gen must be a generator")\n  ;; The trickiest part about this is sizing. The strategy here is to\n  ;; assume that the container generators will (like the normal\n  ;; collection generators in this namespace) have a size bounded by\n  ;; the `size` parameter, and with that assumption we can give an\n  ;; upper bound to the total number of leaf nodes in the generated\n  ;; structure.\n  ;;\n  ;; So we first pick an upper bound, and pick it to be somewhat\n  ;; larger than the real `size` since on average they will be rather\n  ;; smaller. Then we factor that upper bound into integers to give us\n  ;; the size to use at each depth, assuming that the total size\n  ;; should sort of be the product of the factored sizes.\n  ;;\n  ;; This is all a bit weird and hard to explain precisely but I think\n  ;; it works reasonably and definitely better than the old code.\n  (sized (fn [size]\n           (bind (choose 0 (size-\x3emax-leaf-count size))\n                 (fn [max-leaf-count]\n                   (randomized\n                    (fn [rng]\n                      (core/let [sizes (random-pseudofactoring max-leaf-count rng)\n                                 sized-scalar-gen (resize size scalar-gen)]\n                        (reduce (fn [g size]\n                                  (bind (choose 0 10)\n                                        (fn [x]\n                                          (if (zero? x)\n                                            sized-scalar-gen\n                                            (resize size\n                                                    (container-gen-fn g))))))\n                                sized-scalar-gen\n                                sizes)))))))))\n\n(def any\n  "A recursive generator that will generate many different, often nested, values"\n  (recursive-gen container-type simple-type))\n\n(def any-printable\n  "Like any, but avoids characters that the shell will interpret as actions,\n  like 7 and 14 (bell and alternate character set command)"\n  (recursive-gen container-type simple-type-printable))\n\n;; Macros\n;; ---------------------------------------------------------------------------\n\n(defmacro let\n  "Macro for building generators using values from other generators.\n  Uses a binding vector with the same syntax as clojure.core/let,\n  where the right-hand side of the binding pairs are generators, and\n  the left-hand side are names (or destructuring forms) for generated\n  values.\n\n  Subsequent generator expressions can refer to the previously bound\n  values, in the same way as clojure.core/let.\n\n  The body of the let can be either a value or a generator, and does\n  the expected thing in either case. In this way let provides the\n  functionality of both `bind` and `fmap`.\n\n  Examples:\n\n    (gen/let [strs (gen/not-empty (gen/list gen/string))\n              s (gen/elements strs)]\n      {:some-strings strs\n       :one-of-those-strings s})\n\n    ;; generates collections of \\"users\\" that have integer IDs\n    ;; from 0...N-1, but are in a random order\n    (gen/let [users (gen/list (gen/hash-map :name gen/string-ascii\n                                            :age gen/nat))]\n      (-\x3e\x3e users\n           (map #(assoc %2 :id %1) (range))\n           (gen/shuffle)))"\n  {:added "0.9.0"}\n  [bindings \x26 body]\n  (assert (vector? bindings)\n          "First arg to gen/let must be a vector of bindings.")\n  (assert (even? (count bindings))\n          "gen/let requires an even number of forms in binding vector")\n  (if (empty? bindings)\n    `(core/let [val# (do ~@body)]\n       (if (clojure.test.check.generators/generator? val#)\n         val#\n         (return val#)))\n    (core/let [[binding gen \x26 more] bindings]\n      `(clojure.test.check.generators/bind ~gen (fn [~binding] (let [~@more] ~@body))))))\n'],
null),new p(null,3,[Cl,"clojure/data.cljs",Xn,"clojure.data",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns \n  ^{:author "Stuart Halloway",\n    :doc "Non-core data functions."}\n  clojure.data\n  (:require [clojure.set :as set]))\n\n(declare ^{:arglists \'([a b])} diff)\n\n(defn- atom-diff\n  "Internal helper for diff."\n  [a b]\n  (if (\x3d a b) [nil nil a] [a b nil]))\n\n;; for big things a sparse vector class would be better\n(defn- vectorize\n  "Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys"\n  [m]\n  (when (seq m)\n    (reduce\n     (fn [result [k v]] (assoc result k v))\n     (vec (repeat (apply max (keys m))  nil))\n     m)))\n\n(defn- diff-associative-key\n  "Diff associative things a and b, comparing only the key k."\n  [a b k]\n  (let [va (get a k)\n        vb (get b k)\n        [a* b* ab] (diff va vb)\n        in-a (contains? a k)\n        in-b (contains? b k)\n        same (and in-a in-b\n                  (or (not (nil? ab))\n                      (and (nil? va) (nil? vb))))]\n    [(when (and in-a (or (not (nil? a*)) (not same))) {k a*})\n     (when (and in-b (or (not (nil? b*)) (not same))) {k b*})\n     (when same {k ab})\n     ]))\n\n(defn- diff-associative\n  "Diff associative things a and b, comparing only keys in ks (if supplied)."\n  ([a b]\n     (diff-associative a b (set/union (keys a) (keys b))))\n  ([a b ks]\n     (reduce\n      (fn [diff1 diff2]\n        (doall (map merge diff1 diff2)))\n      [nil nil nil]\n      (map\n       (partial diff-associative-key a b)\n       ks))))\n\n(defn- diff-sequential\n  [a b]\n  (vec (map vectorize (diff-associative\n                       (if (vector? a) a (vec a))\n                       (if (vector? b) b (vec b))\n                       (range (max (count a) (count b)))))))\n\n(defn- diff-set\n  [a b]\n  [(not-empty (set/difference a b))\n   (not-empty (set/difference b a))\n   (not-empty (set/intersection a b))])\n\n(defprotocol EqualityPartition\n  "Implementation detail. Subject to change."\n  (equality-partition [x] "Implementation detail. Subject to change."))\n\n(defprotocol Diff\n  "Implementation detail. Subject to change."\n  (diff-similar [a b] "Implementation detail. Subject to change."))\n\n(extend-protocol EqualityPartition\n  nil\n  (equality-partition [x] :atom)\n\n  string\n  (equality-partition [x] :atom)\n\n  number\n  (equality-partition [x] :atom)\n\n  array\n  (equality-partition [x] :sequential)\n\n  function\n  (equality-partition [x] :atom)\n\n  boolean\n  (equality-partition [x] :atom)\n\n  default\n  (equality-partition [x]\n    (cond\n     (satisfies? IMap x) :map\n     (satisfies? ISet x) :set\n     (satisfies? ISequential x) :sequential\n     :default :atom)))\n\n(extend-protocol Diff\n  nil\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  string\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  number\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  array\n  (diff-similar [a b]\n    (diff-sequential a b))\n\n  function\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  boolean\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  default\n  (diff-similar [a b]\n    ((case (equality-partition a)\n       :atom atom-diff\n       :set diff-set\n       :sequential diff-sequential\n       :map diff-associative)\n     a b)))\n\n(defn diff\n  "Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality."\n  [a b]\n  (if (\x3d a b)\n    [nil nil a]\n    (if (\x3d (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))\n  \n'],
null),new p(null,3,[Cl,"cljs/env/macros.clj",Xn,"cljs.env.macros",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.env.macros\n  (:refer-clojure :exclude [binding ensure]))\n\n(defmacro with-compiler-env\n   "Evaluates [body] with [env] bound as the value of the `*compiler*` var in\n this namespace."\n  [env \x26 body]\n   `(let [env# ~env\n          env# (cond\n                 (map? env#) (atom env#)\n                 (and (instance? cljs.core/Atom env#) (map? @env#)) env#\n                 :default\n                 (throw\n                   (js/Error.\n                     (str "Compiler environment must be a map or atom containing a map, not "\n                       (type env#)))))]\n      (cljs.core/binding [cljs.env/*compiler* env#]\n        ~@body)))\n\n(defmacro ensure\n  [\x26 body]\n  `(let [val# cljs.env/*compiler*]\n     (when (nil? val#)\n       (set! cljs.env/*compiler* (cljs.env/default-compiler-env)))\n     (try\n       ~@body\n       (finally\n         (when (nil? val#)\n           (set! cljs.env/*compiler* nil))))))\n'],
null),new p(null,3,[Cl,"clojure/core/reducers.cljs",Xn,"clojure.core.reducers",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc\n      "A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure\'s pom.xml for the\n      dependency info."\n      :author "Rich Hickey"}\n  clojure.core.reducers\n  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten cat])\n  (:require [cljs.core :as core]))\n\n;;;;;;;;;;;;;; some fj stuff ;;;;;;;;;;\n(defn- fjtask [f]\n  f)\n\n(defn- fjinvoke [f]\n  (f))\n\n(defn- fjfork [task]\n  task)\n\n(defn- fjjoin [task]\n  (task))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn reduce\n  "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv"\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (map? coll)\n       (-kv-reduce coll f init)\n       (cond\n         (nil? coll) init\n         (array? coll) (#\'array-reduce coll f init)\n         :else (-reduce coll f init)))))\n\n(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))\n\n(defn fold\n  "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented."\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))\n\n(defn reducer\n  "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [this f1]\n         (-reduce this f1 (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init)))))\n\n(defn folder\n  "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [_ f1]\n         (-reduce coll (xf f1) (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init))\n\n       CollFold\n       (coll-fold [_ n combinef reducef]\n         (coll-fold coll n combinef (xf reducef))))))\n\n(defcurried map\n  "Applies f to every value in the reduction of coll. Foldable."\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))\n\n(defcurried mapcat\n  "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))\n\n(defcurried filter\n  "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."\n  {}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))\n\n(defcurried flatten\n  "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."\n  {}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))\n\n(defcurried remove\n  "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."\n  {}\n  [pred coll]\n  (filter (complement pred) coll))\n\n(defcurried take-while\n  "Ends the reduction of coll when (pred val) returns logical false."\n  {}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))\n\n(defcurried take\n  "Ends the reduction of coll after consuming n values."\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))\n\n(defcurried drop\n  "Elides the first n values from the reduction of coll."\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))\n\n;;do not construct this directly, use cat\n(deftype Cat [cnt left right]\n  cljs.core/ICounted\n  (-count [_] cnt)\n\n  cljs.core/ISeqable\n  (-seq [_] (concat (seq left) (seq right)))\n\n  cljs.core/IReduce\n  (-reduce [this f1] (-reduce this f1 (f1)))\n  (-reduce\n    [_  f1 init]\n    (-reduce\n     right f1\n     (-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n    [this n combinef reducef]\n    (-reduce this reducef)))\n\n(defn cat\n  "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat."\n  ([] (array))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n       (zero? (count left)) right\n       (zero? (count right)) left\n       :else\n       (Cat. (+ (count left) (count right)) left right))))\n\n(defn append!\n  ".adds x to acc and returns acc"\n  [acc x]\n  (doto acc (.push x)))\n\n(defn foldcat\n  "Equivalent to (fold cat append! coll)"\n  [coll]\n  (fold cat append! coll))\n\n(defn monoid\n  "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it."\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(comment\n(require \'[clojure.core.reduce :as r])\n(def v (take 1000000 (range)))\n(reduce + 0 (r/map inc [1 2 3 4]))\n(into [] (r/take 12 (range 100)))\n(into [] (r/drop 12 (range 100)))\n(reduce + 0 (r/filter even? [1 2 3 4]))\n(into [] (r/filter even? [1 2 3 4]))\n(reduce + (filter even? [1 2 3 4]))\n(dotimes [_ 10] (time (reduce + 0 (r/map inc v))))\n(dotimes [_ 10] (time (reduce + 0 (map inc v))))\n(dotimes [_ 100] (time (reduce + 0 v)))\n(dotimes [_ 100] (time (reduce + 0 v)))\n(dotimes [_ 20] (time (reduce + 0 (r/map inc (r/filter even? v)))))\n(dotimes [_ 20] (time (reduce + 0 (map inc (filter even? v)))))\n(reduce + 0 (r/take-while even? [2 4 3]))\n(into [] (r/filter even? (r/flatten (r/remove #{4} [[1 2 3] 4 [5 [6 7 8]] [9] 10]))))\n(into [] (r/flatten nil))\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fold impls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn- foldvec\n  [v n combinef reducef]\n  (cond\n   (empty? v) (combinef)\n   (\x3c\x3d (count v) n) (reduce reducef (combinef) v)\n   :else\n   (let [split (quot (count v) 2)\n         v1 (subvec v 0 split)\n         v2 (subvec v split (count v))\n         fc (fn [child] #(foldvec child n combinef reducef))]\n     (fjinvoke\n      #(let [f1 (fc v1)\n             t2 (fjtask (fc v2))]\n         (fjfork t2)\n         (combinef (f1) (fjjoin t2)))))))\n\n(extend-protocol CollFold\n nil\n (coll-fold\n  [coll n combinef reducef]\n  (combinef))\n\n object\n (coll-fold\n  [coll n combinef reducef]\n  ;;can\'t fold, single reduce\n  (reduce reducef (combinef) coll))\n\n cljs.core/PersistentVector\n (coll-fold\n  [v n combinef reducef]\n  (foldvec v n combinef reducef))\n\n #_\n cljs.core/PersistentHashMap\n #_\n (coll-fold\n  [m n combinef reducef]\n  (.fold m n combinef reducef fjinvoke fjtask fjfork fjjoin)))\n\n'],
null),new p(null,3,[Cl,"cljs/tools/reader/reader_types.cljs",Xn,"cljs.tools.reader.reader-types",nr,';;   Copyright (c) Nicola Mometto, Rich Hickey \x26 contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc "Protocols and default Reader types implementation"\n      :author "Bronsa"}\n  cljs.tools.reader.reader-types\n  (:refer-clojure :exclude [char read-line])\n  (:require [cljs.tools.reader.impl.utils :refer [char whitespace? newline?]]\n            [goog.string])\n  (:import goog.string.StringBuffer))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; reader protocols\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defprotocol Reader\n  (read-char [reader]\n    "Returns the next char from the Reader, nil if the end of stream has been reached")\n  (peek-char [reader]\n    "Returns the next char from the Reader without removing it from the reader stream"))\n\n(defprotocol IPushbackReader\n  (unread [reader ch]\n    "Pushes back a single character on to the stream"))\n\n(defprotocol IndexingReader\n  (get-line-number [reader]\n    "Returns the line number of the next character to be read from the stream")\n  (get-column-number [reader]\n    "Returns the column number of the next character to be read from the stream")\n  (get-file-name [reader]\n    "Returns the file name the reader is reading from, or nil"))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; reader deftypes\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(deftype StringReader\n    [s s-len ^:mutable s-pos]\n  Reader\n  (read-char [reader]\n    (when (\x3e s-len s-pos)\n      (let [r (.charAt s s-pos)]\n        (set! s-pos (inc s-pos))\n        r)))\n  (peek-char [reader]\n    (when (\x3e s-len s-pos)\n      (.charAt s s-pos))))\n\n(deftype NodeReadableReader [readable ^:mutable buf]\n  Reader\n  (read-char [reader]\n    (if buf\n      (let [c (aget buf 0)]\n        (set! buf nil)\n        (char c))\n      (let [c (str (.read readable 1))]\n        (when c\n          (char c)))))\n  (peek-char [reader]\n    (when-not buf\n      (set! buf (str (.read readable 1))))\n    (when buf\n      (char (aget buf 0)))))\n\n(deftype PushbackReader\n  [^not-native rdr buf buf-len ^:mutable buf-pos]\n  Reader\n  (read-char [reader]\n    (let [c (if (\x3c buf-pos buf-len)\n              (aget buf buf-pos)\n              (read-char rdr))]\n      (when (\x3c buf-pos buf-len)\n        (set! buf-pos (inc buf-pos)))\n      (char c)))\n  (peek-char [reader]\n    (let [c (if (\x3c buf-pos buf-len)\n              (aget buf buf-pos)\n              (peek-char rdr))]\n      (char c)))\n  IPushbackReader\n  (unread [reader ch]\n    (when ch\n      (if (zero? buf-pos) (throw (js/Error. "Pushback buffer is full")))\n      (set! buf-pos (dec buf-pos))\n      (aset buf buf-pos ch))))\n\n(defn- normalize-newline [^not-native rdr ch]\n  (if (identical? \\return ch)\n    (let [c (peek-char rdr)]\n      (when (or (identical? \\formfeed c)\n                (identical? \\newline c))\n        (read-char rdr))\n      \\newline)\n    ch))\n\n(deftype IndexingPushbackReader\n    [^not-native rdr ^:mutable line ^:mutable column\n     ^:mutable line-start? ^:mutable prev\n     ^:mutable prev-column file-name]\n  Reader\n  (read-char [reader]\n    (when-let [ch (read-char rdr)]\n      (let [ch (normalize-newline rdr ch)]\n        (set! prev line-start?)\n        (set! line-start? (newline? ch))\n        (when line-start?\n          (set! prev-column column)\n          (set! column 0)\n          (set! line (inc line)))\n        (set! column (inc column))\n        ch)))\n\n  (peek-char [reader]\n    (peek-char rdr))\n\n  IPushbackReader\n  (unread [reader ch]\n    (if line-start?\n      (do (set! line (dec line))\n          (set! column prev-column))\n      (set! column (dec column)))\n    (set! line-start? prev)\n    (unread rdr ch))\n\n  IndexingReader\n  (get-line-number [reader] (int line))\n  (get-column-number [reader] (int column))\n  (get-file-name [reader] file-name))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Source Logging support\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn merge-meta\n  "Returns an object of the same type and value as `obj`, with its\nmetadata merged over `m`."\n  [obj m]\n  (let [orig-meta (meta obj)]\n    (with-meta obj (merge m (dissoc orig-meta :source)))))\n\n(defn- peek-source-log\n  "Returns a string containing the contents of the top most source\nlogging frame."\n  [frames]\n  (subs (str (:buffer frames)) (first (:offset frames))))\n\n(defn- log-source-char\n  "Logs `char` to all currently active source logging frames."\n  [frames char]\n  (when-let [buffer (:buffer frames)]\n    (.append buffer char)))\n\n(defn- drop-last-logged-char\n  "Removes the last logged character from all currently active source\nlogging frames. Called when pushing a character back."\n  [frames]\n  (when-let [buffer (:buffer frames)]\n    (.set buffer (subs (str buffer) 0 (dec (.getLength buffer))))))\n\n(deftype SourceLoggingPushbackReader\n    [^not-native rdr ^:mutable line ^:mutable column\n     ^:mutable line-start? ^:mutable prev\n     ^:mutable prev-column file-name frames]\n  Reader\n  (read-char [reader]\n    (when-let [ch (read-char rdr)]\n      (let [ch (normalize-newline rdr ch)]\n        (set! prev line-start?)\n        (set! line-start? (newline? ch))\n        (when line-start?\n          (set! prev-column column)\n          (set! column 0)\n          (set! line (inc line)))\n        (set! column (inc column))\n        (log-source-char @frames ch)\n        ch)))\n\n  (peek-char [reader]\n    (peek-char rdr))\n\n  IPushbackReader\n  (unread [reader ch]\n    (if line-start?\n      (do (set! line (dec line))\n          (set! column prev-column))\n      (set! column (dec column)))\n    (set! line-start? prev)\n    (when ch\n      (drop-last-logged-char @frames))\n    (unread rdr ch))\n\n  IndexingReader\n  (get-line-number [reader] (int line))\n  (get-column-number [reader] (int column))\n  (get-file-name [reader] file-name))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Public API\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; fast check for provided implementations\n(defn indexing-reader?\n  "Returns true if the reader satisfies IndexingReader"\n  [rdr]\n  (implements? IndexingReader rdr))\n\n(defn string-reader\n  "Creates a StringReader from a given string"\n  ([s]\n     (StringReader. s (count s) 0)))\n\n(defn string-push-back-reader\n  "Creates a PushbackReader from a given string"\n  ([s]\n     (string-push-back-reader s 1))\n  ([s buf-len]\n     (PushbackReader. (string-reader s) (object-array buf-len) buf-len buf-len)))\n\n(defn node-readable-push-back-reader [readable]\n  (PushbackReader. (NodeReadableReader. readable nil) (object-array 1) 1 1))\n\n(defn indexing-push-back-reader\n  "Creates an IndexingPushbackReader from a given string or PushbackReader"\n  ([s-or-rdr]\n     (indexing-push-back-reader s-or-rdr 1))\n  ([s-or-rdr buf-len]\n     (indexing-push-back-reader s-or-rdr buf-len nil))\n  ([s-or-rdr buf-len file-name]\n     (IndexingPushbackReader.\n      (if (string? s-or-rdr) (string-push-back-reader s-or-rdr buf-len) s-or-rdr) 1 1 true nil 0 file-name)))\n\n(defn source-logging-push-back-reader\n  "Creates a SourceLoggingPushbackReader from a given string or PushbackReader"\n  ([s-or-rdr]\n     (source-logging-push-back-reader s-or-rdr 1))\n  ([s-or-rdr buf-len]\n     (source-logging-push-back-reader s-or-rdr buf-len nil))\n  ([s-or-rdr buf-len file-name]\n     (SourceLoggingPushbackReader.\n      (if (string? s-or-rdr) (string-push-back-reader s-or-rdr buf-len) s-or-rdr)\n      1\n      1\n      true\n      nil\n      0\n      file-name\n      (atom {:buffer (StringBuffer.) :offset \'(0)}))))\n\n(defn read-line\n  "Reads a line from the reader or from *in* if no reader is specified"\n  ([^not-native rdr]\n     (loop [c (read-char rdr) s (StringBuffer.)]\n       (if (newline? c)\n         (str s)\n         (recur (read-char rdr) (.append s c))))))\n\n(defn ^boolean source-logging-reader?\n  [rdr]\n  (instance? SourceLoggingPushbackReader rdr))\n\n(defn ^boolean line-start?\n  "Returns true if rdr is an IndexingReader and the current char starts a new line"\n  [^not-native rdr]\n  (when (indexing-reader? rdr)\n    (\x3d\x3d 1 (get-column-number rdr))))\n\n(defn log-source*\n  [reader f]\n  (let [buffer (:buffer @(.-frames reader))]\n    (try\n      (swap! (.-frames reader) update-in [:offset] conj (.getLength buffer))\n      (let [ret (f)]\n        (if (implements? IMeta ret)\n          (merge-meta ret {:source (peek-source-log @ (.-frames reader))})\n          ret))\n      (finally\n        (swap! (.-frames reader) update-in [:offset] rest)))))\n\n'],
null),new p(null,3,[Cl,"cljs/analyzer/api.cljc",Xn,"cljs.analyzer.api",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.analyzer.api\n  "This is intended to be a stable api for those who need programmatic access\n  to the analyzer."\n  (:refer-clojure :exclude [all-ns ns-interns ns-resolve resolve find-ns\n                            ns-publics remove-ns])\n  (:require [cljs.env :as env]\n            [cljs.analyzer :as ana]))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Useful Utilities\n\n(defn empty-state\n  "Creates an empty compilation state Atom\x3cMap\x3e."\n  []\n  (env/default-compiler-env))\n\n(defmacro with-state\n  "Run the body with the given compilation state Atom\x3cMap\x3e."\n  [state body]\n  `(env/with-compiler-env ~state\n     ~@body))\n\n(defn empty-env\n  "Creates an empty analysis environment."\n  []\n  (ana/empty-env))\n\n(defmacro no-warn\n  "Disable analyzer warnings for any analysis executed in body."\n  [\x26 body]\n  (let [no-warnings (zipmap (keys ana/*cljs-warnings*) (repeat false))]\n    `(binding [ana/*cljs-warnings* ~no-warnings]\n       ~@body)))\n\n(defn warning-enabled?\n  "Test if the given warning-type is enabled."\n  [warning-type]\n  (ana/*cljs-warnings* warning-type))\n\n(defn default-warning-handler\n  "The default warning handler.\n\n   Outputs the warning messages to *err*."\n  [warning-type env extra]\n  (ana/default-warning-handler warning-type env extra))\n\n(defn get-options\n  "Return the compiler options from compiler state."\n  ([] (get-options env/*compiler*))\n  ([state]\n   (get @state :options)))\n\n(defn get-js-index\n  "Return the currently computed Google Closure js dependency index from the\n  compiler state."\n  ([] (get-options env/*compiler*))\n  ([state]\n   (get @state :js-dependency-index)))\n\n#?(:clj\n   (defn analyze\n     "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n     (one of :statement, :expr, :return), :ns (a symbol naming the\n     compilation ns)}, and form, returns an expression object (a map\n     containing at least :form, :op and :env keys). If expr has any (immediately)\n     nested exprs, must have :children entry. This must be a vector of keywords naming\n     the immediately nested fields mapped to an expr or vector of exprs. This will\n     facilitate code walking without knowing the details of the op set."\n     ([env form] (analyze env form nil))\n     ([env form name] (analyze env form name nil))\n     ([env form name opts]\n      (analyze\n        (if-not (nil? env/*compiler*)\n          env/*compiler*\n          (env/default-compiler-env opts))\n        env form name opts))\n     ([state env form name opts]\n      (env/with-compiler-env state\n        (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n          (ana/analyze env form name opts))))))\n\n#?(:clj\n   (defn forms-seq\n     "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\n     accepts a filename argument which will be used in any emitted errors."\n     ([rdr] (ana/forms-seq* rdr nil))\n     ([rdr filename] (ana/forms-seq* rdr filename))))\n\n#?(:clj\n   (defn parse-ns\n     "Helper for parsing only the essential namespace information from a\n      ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n      map _not_ a namespace AST node.\n   \n      By default does not load macros or perform any analysis of dependencies. If\n      opts parameter provided :analyze-deps and :load-macros keys their values will\n      be used for *analyze-deps* and *load-macros* bindings respectively. This\n      function does _not_ side-effect the ambient compilation environment unless\n      requested via opts where :restore is false."\n     ([src] (parse-ns src nil nil))\n     ([src opts] (parse-ns src nil opts))\n     ([src dest opts]\n      (parse-ns\n        (if-not (nil? env/*compiler*)\n          env/*compiler*\n          (env/default-compiler-env opts))\n        src dest opts))\n     ([state src dest opts]\n      (env/with-compiler-env state\n        (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n          (ana/parse-ns src dest opts))))))\n#?(:clj\n   (defn analyze-file\n     "Given a java.io.File, java.net.URL or a string identifying a resource on the\n      classpath attempt to analyze it.\n   \n      This function side-effects the ambient compilation environment\n      `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n      compiler options, if :cache-analysis true will cache analysis to\n      \\":output-dir/some/ns/foo.cljs.cache.edn\\". This function does not return a\n      meaningful value."\n     ([f] (analyze-file f nil))\n     ([f opts]\n      (analyze-file\n        (if-not (nil? env/*compiler*)\n          env/*compiler*\n          (env/default-compiler-env opts))\n        f opts))\n     ([state f opts]\n      (env/with-compiler-env state\n        (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n          (ana/analyze-file f opts))))))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Main API\n\n(defn resolve\n  "Given an analysis environment resolve a var. Analogous to\n   clojure.core/resolve"\n  [env sym]\n  {:pre [(map? env) (symbol? sym)]}\n  (try\n    (binding [ana/*private-var-access-nowarn* true]\n      (ana/resolve-var env sym\n        (ana/confirm-var-exists-throw)))\n    (catch #?(:clj Exception :cljs :default) e\n      (ana/resolve-macro-var env sym))))\n\n(defn all-ns\n  "Return all namespaces. Analagous to clojure.core/all-ns but\n  returns symbols identifying namespaces not Namespace instances."\n  ([]\n   (all-ns env/*compiler*))\n  ([state]\n   (keys (get @state ::ana/namespaces))))\n\n(defn find-ns\n  "Given a namespace return the corresponding namespace analysis map. Analagous\n  to clojure.core/find-ns."\n  ([sym]\n   (find-ns env/*compiler* sym))\n  ([state sym]\n   {:pre [(symbol? sym)]}\n   (get-in @state [::ana/namespaces sym])))\n\n(defn ns-interns\n  "Given a namespace return all the var analysis maps. Analagous to\n  clojure.core/ns-interns but returns var analysis maps not vars."\n  ([ns]\n   (ns-interns env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (merge\n     (get-in @state [::ana/namespaces ns :macros])\n     (get-in @state [::ana/namespaces ns :defs]))))\n\n(defn ns-publics\n  "Given a namespace return all the public var analysis maps. Analagous to\n  clojure.core/ns-publics but returns var analysis maps not vars."\n  ([ns]\n   (ns-publics env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (-\x3e\x3e (merge\n          (get-in @state [::ana/namespaces ns :macros])\n          (get-in @state [::ana/namespaces ns :defs]))\n        (remove (fn [[k v]] (:private v)))\n        (into {}))))\n\n(defn ns-resolve\n  "Given a namespace and a symbol return the corresponding var analysis map.\n  Analagous to clojure.core/ns-resolve but returns var analysis map not Var."\n  ([ns sym]\n   (ns-resolve env/*compiler* ns sym))\n  ([state ns sym]\n   {:pre [(symbol? ns) (symbol? sym)]}\n   (get-in @state [::ana/namespaces ns :defs sym])))\n\n(defn remove-ns\n  "Removes the namespace named by the symbol."\n  ([ns]\n   (remove-ns env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (swap! state update-in [::ana/namespaces] dissoc ns)))\n\n(defmacro in-cljs-user\n  "Binds cljs.analyzer/*cljs-ns* to \'cljs.user and uses the given compilation\n  environment atom and runs body."\n  [env \x26 body]\n  `(binding [cljs.analyzer/*cljs-ns* \'cljs.user]\n     (cljs.env/with-compiler-env ~env\n       ~@body)))\n'],
null),new p(null,3,[Cl,"cljs/spec/test/alpha.cljc",Xn,"cljs.spec.test.alpha",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.test.alpha\n  (:require\n    [cljs.analyzer :as ana]\n    [cljs.analyzer.api :as ana-api]\n    [clojure.string :as string]\n    [cljs.spec.alpha :as s]\n    [cljs.spec.gen.alpha :as gen]))\n\n(defonce ^:private instrumented-vars (atom #{}))\n\n(defn- collectionize\n  [x]\n  (if (symbol? x)\n    (list x)\n    x))\n\n(defn- enumerate-namespace* [sym-or-syms]\n  (into #{}\n    (mapcat\n      (fn [sym]\n        (-\x3e\x3e (vals (ana-api/ns-interns sym))\n          (map :name)\n          (map\n            (fn [name-sym]\n              (symbol (name sym) (name name-sym)))))))\n    (collectionize sym-or-syms)))\n\n(defmacro enumerate-namespace\n  "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses."\n  [ns-sym-or-syms]\n  `\'~(enumerate-namespace* (eval ns-sym-or-syms)))\n\n(defn- fn-spec-name?\n  [s]\n  (symbol? s))\n\n(defmacro with-instrument-disabled\n  "Disables instrument\'s checking of calls, within a scope."\n  [\x26 body]\n  ;; Note: In order to read the value of this private var, we employ interop\n  ;; rather than derefing a var special. This eases specing core functions\n  ;; (and infinite recursion) by avoiding code generated by the var special,\n  ;; and also produces more compact / efficient code.\n  `(let [orig# (.-*instrument-enabled* js/cljs.spec.test.alpha)]\n     (set! *instrument-enabled* nil)\n     (try\n       ~@body\n       (finally\n         (set! *instrument-enabled* orig#)))))\n\n(defmacro instrument-1\n  [[quote s] opts]\n  (when-let [v (ana-api/resolve \x26env s)]\n    (let [var-name (:name v)]\n      (when (and (nil? (:const v))\n                 #?(:cljs (nil? (:macro v)))\n                 (contains? #?(:clj (s/speced-vars)\n                               :cljs (cljs.spec.alpha$macros/speced-vars))\n                            var-name))\n        (swap! instrumented-vars conj var-name)\n        `(let [checked# (#\'instrument-1* \'~s (var ~s) ~opts)]\n           (when checked# (set! ~s checked#))\n           \'~var-name)))))\n\n(defmacro unstrument-1\n  [[quote s]]\n  (when-let [v (ana-api/resolve \x26env s)]\n    (when (@instrumented-vars (:name v))\n      (swap! instrumented-vars disj (:name v))\n      `(let [raw# (#\'unstrument-1* \'~s (var ~s))]\n         (when raw# (set! ~s raw#))\n         \'~(:name v)))))\n\n(defn- sym-or-syms-\x3esyms [sym-or-syms]\n  (into []\n    (mapcat\n      (fn [sym]\n        (if (and (string/includes? (str sym) ".")\n                 (ana-api/find-ns sym))\n          (-\x3e\x3e (vals (ana-api/ns-interns sym))\n            (filter #(not (:macro %)))\n            (map :name)\n            (map\n              (fn [name-sym]\n                (symbol (name sym) (name name-sym)))))\n          [sym])))\n    (collectionize sym-or-syms)))\n\n(defn- form-\x3esym-or-syms\n  "Helper for extracting a symbol or symbols from a (potentially\n  user-supplied) quoted form. In the case that the form has ::no-eval meta, we\n  know it was generated by us and we directly extract the result, assuming the\n  shape of the form. This avoids applying eval to extremely large forms in the\n  latter case."\n  [sym-or-syms]\n  (if (::no-eval (meta sym-or-syms))\n    (second sym-or-syms)\n    (eval sym-or-syms)))\n\n(defmacro instrument\n  "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var\'s root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec\'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented."\n  ([]\n   `(instrument ^::no-eval \'[~@(#?(:clj  s/speced-vars\n                                   :cljs cljs.spec.alpha$macros/speced-vars))]))\n  ([xs]\n   `(instrument ~xs nil))\n  ([sym-or-syms opts]\n   (let [syms (sym-or-syms-\x3esyms (form-\x3esym-or-syms sym-or-syms))\n         opts-sym (gensym "opts")]\n     `(let [~opts-sym ~opts]\n        (reduce\n          (fn [ret# [_# f#]]\n            (let [sym# (f#)]\n              (cond-\x3e ret# sym# (conj sym#))))\n          []\n          (-\x3e\x3e (zipmap \'~syms\n                 [~@(map\n                      (fn [sym]\n                        `(fn [] (instrument-1 \'~sym ~opts-sym)))\n                      syms)])\n            (filter #((instrumentable-syms ~opts-sym) (first %)))\n            (distinct-by first)))))))\n\n(defmacro unstrument\n  "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented."\n  ([]\n   `(unstrument ^::no-eval \'[~@(deref instrumented-vars)]))\n  ([sym-or-syms]\n   (let [syms (sym-or-syms-\x3esyms (form-\x3esym-or-syms sym-or-syms))]\n     `(reduce\n        (fn [ret# f#]\n          (let [sym# (f#)]\n            (cond-\x3e ret# sym# (conj sym#))))\n        []\n        [~@(-\x3e\x3e syms\n             (map\n               (fn [sym]\n                 (when (symbol? sym)\n                   `(fn []\n                      (unstrument-1 \'~sym)))))\n             (remove nil?))]))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; testing  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defmacro check-1\n  [[quote s :as qs] f spec opts]\n  (let [{:keys [name] :as v} (when qs (ana-api/resolve \x26env s))]\n    `(let [s#        \'~name\n           v#        ~(when v `(var ~name))\n           spec#     (or ~spec ~(when v `(s/get-spec (var ~name))))\n           re-inst?# (and v# (seq (unstrument \'~name)) true)\n           f#        (or ~f (when v# @v#))\n           opts#     ~opts\n           old-tc-ns# "clojure.test.check"\n           old-tc-opts-key# (keyword old-tc-ns# "opts")\n           [tc-ns# opts#] (if-let [old-tc-opts# (get opts# old-tc-opts-key#)]\n                            [old-tc-ns# (assoc opts# :clojure.spec.test.check/opts\n                                               old-tc-opts#)]\n                            ["clojure.spec.test.check" opts#])]\n       (try\n         (cond\n           (nil? f#)\n           {:failure (ex-info "No fn to spec" {::s/failure :no-fn})\n            :sym     s# :spec spec#}\n\n           (:args spec#)\n           (let [tcret# (#\'quick-check f# spec# opts#)]\n             (#\'make-check-result s# spec# tcret#\n                                  (keyword tc-ns# "ret")))\n\n           :default\n           {:failure (ex-info "No :args spec" {::s/failure :no-args-spec})\n            :sym     s# :spec spec#})\n         (finally\n           (when re-inst?# (instrument \'~name)))))))\n\n(defmacro check-fn\n  "Runs generative tests for fn f using spec and opts. See\n\'check\' for options and return."\n  ([f spec]\n   `(check-fn ~f ~spec nil))\n  ([f spec opts]\n   `(let [opts# ~opts]\n      (validate-check-opts opts#)\n      (check-1 nil ~f ~spec opts#))))\n\n(defn- registry-ref []\n  #?(:clj  @#\'s/registry-ref\n     :cljs cljs.spec.alpha$macros/registry-ref))\n\n(defn checkable-syms*\n  ([]\n    (checkable-syms* nil))\n  ([opts]\n   (reduce into #{}\n     [(filter fn-spec-name? (keys @(registry-ref)))\n      (keys (:spec opts))])))\n\n(defmacro checkable-syms\n  "Given an opts map as per check, returns the set of syms that\ncan be checked."\n  ([]\n   `(checkable-syms nil))\n  ([opts]\n   `(let [opts# ~opts]\n      (validate-check-opts opts#)\n      (reduce conj #{}\n        \'[~@(filter fn-spec-name? (keys @(registry-ref)))\n          ~@(keys (:spec opts))]))))\n\n(defmacro check\n  "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n"\n  ([]\n   `(check ^::no-eval \'~(checkable-syms*)))\n  ([sym-or-syms]\n   `(check ~sym-or-syms nil))\n  ([sym-or-syms opts]\n   (let [syms (sym-or-syms-\x3esyms (form-\x3esym-or-syms sym-or-syms))\n         opts-sym (gensym "opts")]\n     `(if (and (cljs.core/exists? clojure.test.check)\n               (cljs.core/exists? clojure.test.check.properties))\n        (let [~opts-sym ~opts]\n          [~@(-\x3e\x3e syms\n                  (filter (checkable-syms* opts))\n                  (map\n                   (fn [sym]\n                     (do `(check-1 \'~sym nil nil ~opts-sym)))))])\n        (throw\n         (js/Error. (str "Require clojure.test.check and "\n                         "clojure.test.check.properties before calling check.")))))))\n\n(defmacro ^:private maybe-setup-static-dispatch [f ret conform! arity]\n  (let [arity-accessor (symbol (str ".-cljs$core$IFn$_invoke$arity$" arity))\n        argv (mapv #(symbol (str "arg" %)) (range arity))]\n    `(when-some [ac# (~arity-accessor ~f)]\n       (set! (~arity-accessor ~ret)\n             (fn ~argv\n               (if *instrument-enabled*\n                 (with-instrument-disabled\n                   (~conform! ~argv)\n                   (binding [*instrument-enabled* true]\n                     (ac# ~@argv)))\n                 (ac# ~@argv)))))))\n\n(defmacro ^:private setup-static-dispatches [f ret conform! max-arity]\n  ;; ret is for when we don\'t have arity info\n  `(do\n     ~@(mapv (fn [arity]\n               `(maybe-setup-static-dispatch ~f ~ret ~conform! ~arity))\n         (range (inc max-arity)))))\n'],
null),new p(null,3,[Cl,"cljs/core.js",Xn,"cljs/core.js",nr,'// Compiled by ClojureScript 1.10.520 {:static-fns true, :optimize-constants true}\ngoog.provide(\'cljs.core\');\ngoog.require(\'goog.math.Long\');\ngoog.require(\'goog.math.Integer\');\ngoog.require(\'goog.string\');\ngoog.require(\'goog.object\');\ngoog.require(\'goog.array\');\ngoog.require(\'goog.Uri\');\ngoog.require(\'goog.string.StringBuffer\');\ncljs.core._STAR_clojurescript_version_STAR_ \x3d "1.10.520";\ncljs.core._STAR_unchecked_if_STAR_ \x3d false;\ncljs.core._STAR_unchecked_arrays_STAR_ \x3d false;\ncljs.core._STAR_warn_on_infer_STAR_ \x3d false;\nif((typeof cljs !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core.PROTOCOL_SENTINEL !\x3d\x3d \'undefined\')){\n} else {\ncljs.core.PROTOCOL_SENTINEL \x3d ({});\n}\ncljs.core.MODULE_URIS \x3d null;\ncljs.core.MODULE_INFOS \x3d null;\n\n/** @define {string} */\ngoog.define("cljs.core._STAR_target_STAR_","default");\n/**\n * Var bound to the current namespace. Only used for bootstrapping.\n * @type {*}\n */\ncljs.core._STAR_ns_STAR_ \x3d null;\n/**\n * @type {*}\n */\ncljs.core._STAR_out_STAR_ \x3d null;\ncljs.core._STAR_assert_STAR_ \x3d true;\nif((typeof cljs !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core._STAR_print_fn_STAR_ !\x3d\x3d \'undefined\')){\n} else {\n/**\n * Each runtime environment provides a different way to print output.\n *   Whatever function *print-fn* is bound to will be passed any\n *   Strings which should be printed.\n */\ncljs.core._STAR_print_fn_STAR_ \x3d null;\n}\n/**\n * Arranges to have tap functions executed via the supplied f, a\n *   function of no arguments. Returns true if successful, false otherwise.\n */\ncljs.core._STAR_exec_tap_fn_STAR_ \x3d (function cljs$core$_STAR_exec_tap_fn_STAR_(f){\nvar and__4120__auto__ \x3d (typeof setTimeout !\x3d\x3d \'undefined\');\nif(and__4120__auto__){\nvar and__4120__auto____$1 \x3d setTimeout(f,(0));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn true;\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});\nif((typeof cljs !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core._STAR_print_err_fn_STAR_ !\x3d\x3d \'undefined\')){\n} else {\n/**\n * Each runtime environment provides a different way to print error output.\n *   Whatever function *print-err-fn* is bound to will be passed any\n *   Strings which should be printed.\n */\ncljs.core._STAR_print_err_fn_STAR_ \x3d null;\n}\n/**\n * Set *print-fn* to f.\n */\ncljs.core.set_print_fn_BANG_ \x3d (function cljs$core$set_print_fn_BANG_(f){\nreturn cljs.core._STAR_print_fn_STAR_ \x3d f;\n});\n/**\n * Set *print-err-fn* to f.\n */\ncljs.core.set_print_err_fn_BANG_ \x3d (function cljs$core$set_print_err_fn_BANG_(f){\nreturn cljs.core._STAR_print_err_fn_STAR_ \x3d f;\n});\n/**\n * When set to true, output will be flushed whenever a newline is printed.\n * \n *   Defaults to true.\n */\ncljs.core._STAR_flush_on_newline_STAR_ \x3d true;\n/**\n * When set to logical false will drop newlines from printing calls.\n *   This is to work around the implicit newlines emitted by standard JavaScript\n *   console objects.\n */\ncljs.core._STAR_print_newline_STAR_ \x3d true;\n/**\n * When set to logical false, strings and characters will be printed with\n *   non-alphanumeric characters converted to the appropriate escape sequences.\n * \n *   Defaults to true\n */\ncljs.core._STAR_print_readably_STAR_ \x3d true;\n/**\n * If set to logical true, when printing an object, its metadata will also\n *   be printed in a form that can be read back by the reader.\n * \n *   Defaults to false.\n */\ncljs.core._STAR_print_meta_STAR_ \x3d false;\n/**\n * When set to logical true, objects will be printed in a way that preserves\n *   their type when read in later.\n * \n *   Defaults to false.\n */\ncljs.core._STAR_print_dup_STAR_ \x3d false;\n/**\n * *print-namespace-maps* controls whether the printer will print\n *   namespace map literal syntax.\n * \n *   Defaults to false, but the REPL binds it to true.\n */\ncljs.core._STAR_print_namespace_maps_STAR_ \x3d false;\n/**\n * *print-length* controls how many items of each collection the\n *   printer will print. If it is bound to logical false, there is no\n *   limit. Otherwise, it must be bound to an integer indicating the maximum\n *   number of items of each collection to print. If a collection contains\n *   more items, the printer will print items up to the limit followed by\n *   \'...\' to represent the remaining items. The root binding is nil\n *   indicating no limit.\n * @type {null|number}\n */\ncljs.core._STAR_print_length_STAR_ \x3d null;\n/**\n * *print-level* controls how many levels deep the printer will\n *   print nested objects. If it is bound to logical false, there is no\n *   limit. Otherwise, it must be bound to an integer indicating the maximum\n *   level to print. Each argument to print is at level 0; if an argument is a\n *   collection, its items are at level 1; and so on. If an object is a\n *   collection and is at a level greater than or equal to the value bound to\n *   *print-level*, the printer prints \'#\' to represent it. The root binding\n *   is nil indicating no limit.\n * @type {null|number}\n */\ncljs.core._STAR_print_level_STAR_ \x3d null;\n/**\n * *print-fns-bodies* controls whether functions print their source or\n *  only their names.\n */\ncljs.core._STAR_print_fn_bodies_STAR_ \x3d false;\nif((typeof cljs !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core._STAR_loaded_libs_STAR_ !\x3d\x3d \'undefined\')){\n} else {\n/**\n * @type {*}\n */\ncljs.core._STAR_loaded_libs_STAR_ \x3d null;\n}\ncljs.core.pr_opts \x3d (function cljs$core$pr_opts(){\nreturn new cljs.core.PersistentArrayMap(null, 5, [cljs.core.cst$kw$flush_DASH_on_DASH_newline,cljs.core._STAR_flush_on_newline_STAR_,cljs.core.cst$kw$readably,cljs.core._STAR_print_readably_STAR_,cljs.core.cst$kw$meta,cljs.core._STAR_print_meta_STAR_,cljs.core.cst$kw$dup,cljs.core._STAR_print_dup_STAR_,cljs.core.cst$kw$print_DASH_length,cljs.core._STAR_print_length_STAR_], null);\n});\n/**\n * Set *print-fn* to console.log\n */\ncljs.core.enable_console_print_BANG_ \x3d (function cljs$core$enable_console_print_BANG_(){\ncljs.core._STAR_print_newline_STAR_ \x3d false;\n\ncljs.core.set_print_fn_BANG_((function (){\nvar xs \x3d arguments;\nreturn console.log.apply(console,goog.array.clone(xs));\n}));\n\ncljs.core.set_print_err_fn_BANG_((function (){\nvar xs \x3d arguments;\nreturn console.error.apply(console,goog.array.clone(xs));\n}));\n\nreturn null;\n});\n/**\n * Internal - do not use!\n */\ncljs.core.truth_ \x3d (function cljs$core$truth_(x){\nreturn (x !\x3d null \x26\x26 x !\x3d\x3d false);\n});\ncljs.core.not_native \x3d null;\n\n/**\n * Tests if 2 arguments are the same object\n */\ncljs.core.identical_QMARK_ \x3d (function cljs$core$identical_QMARK_(x,y){\nreturn (x \x3d\x3d\x3d y);\n});\n/**\n * Returns true if x is nil, false otherwise.\n */\ncljs.core.nil_QMARK_ \x3d (function cljs$core$nil_QMARK_(x){\nreturn (x \x3d\x3d null);\n});\n/**\n * Returns true if x is a JavaScript array.\n */\ncljs.core.array_QMARK_ \x3d (function cljs$core$array_QMARK_(x){\nif((cljs.core._STAR_target_STAR_ \x3d\x3d\x3d "nodejs")){\nreturn Array.isArray(x);\n} else {\nreturn (x instanceof Array);\n}\n});\n/**\n * Returns true if x is a JavaScript number.\n */\ncljs.core.number_QMARK_ \x3d (function cljs$core$number_QMARK_(x){\nreturn typeof x \x3d\x3d\x3d \'number\';\n});\n/**\n * Returns true if x is logical false, false otherwise.\n */\ncljs.core.not \x3d (function cljs$core$not(x){\nif((x \x3d\x3d null)){\nreturn true;\n} else {\nif(x \x3d\x3d\x3d false){\nreturn true;\n} else {\nreturn false;\n\n}\n}\n});\n/**\n * Returns true if x is not nil, false otherwise.\n */\ncljs.core.some_QMARK_ \x3d (function cljs$core$some_QMARK_(x){\nreturn (!((x \x3d\x3d null)));\n});\n/**\n * Returns true if x\'s constructor is Object\n */\ncljs.core.object_QMARK_ \x3d (function cljs$core$object_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nreturn (x.constructor \x3d\x3d\x3d Object);\n} else {\nreturn false;\n}\n});\n/**\n * Returns true if x is a JavaScript string.\n */\ncljs.core.string_QMARK_ \x3d (function cljs$core$string_QMARK_(x){\nreturn goog.isString(x);\n});\n/**\n * Returns true if x is a JavaScript string of length one.\n */\ncljs.core.char_QMARK_ \x3d (function cljs$core$char_QMARK_(x){\nreturn ((typeof x \x3d\x3d\x3d \'string\') \x26\x26 (((1) \x3d\x3d\x3d x.length)));\n});\n/**\n * Returns true if given any argument.\n */\ncljs.core.any_QMARK_ \x3d (function cljs$core$any_QMARK_(x){\nreturn true;\n});\n/**\n * Internal - do not use!\n */\ncljs.core.native_satisfies_QMARK_ \x3d (function cljs$core$native_satisfies_QMARK_(p,x){\nvar x__$1 \x3d (((x \x3d\x3d null))?null:x);\nif((p[goog.typeOf(x__$1)])){\nreturn true;\n} else {\nif((p["_"])){\nreturn true;\n} else {\nreturn false;\n\n}\n}\n});\ncljs.core.is_proto_ \x3d (function cljs$core$is_proto_(x){\nreturn (x.constructor.prototype \x3d\x3d\x3d x);\n});\n/**\n * When compiled for a command-line target, whatever function\n *   *main-cli-fn* is set to will be called with the command-line\n *   argv as arguments\n */\ncljs.core._STAR_main_cli_fn_STAR_ \x3d null;\n/**\n * A sequence of the supplied command line arguments, or nil if\n *   none were supplied\n */\ncljs.core._STAR_command_line_args_STAR_ \x3d null;\n/**\n * Return x\'s constructor.\n */\ncljs.core.type \x3d (function cljs$core$type(x){\nif((x \x3d\x3d null)){\nreturn null;\n} else {\nreturn x.constructor;\n}\n});\ncljs.core.missing_protocol \x3d (function cljs$core$missing_protocol(proto,obj){\nvar ty \x3d cljs.core.type(obj);\nvar ty__$1 \x3d (cljs.core.truth_((function (){var and__4120__auto__ \x3d ty;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn ty.cljs$lang$type;\n} else {\nreturn and__4120__auto__;\n}\n})())?ty.cljs$lang$ctorStr:goog.typeOf(obj));\nreturn (new Error(["No protocol method ",proto," defined for type ",ty__$1,": ",obj].join("")));\n});\ncljs.core.type__GT_str \x3d (function cljs$core$type__GT_str(ty){\nvar temp__5718__auto__ \x3d ty.cljs$lang$ctorStr;\nif(cljs.core.truth_(temp__5718__auto__)){\nvar s \x3d temp__5718__auto__;\nreturn s;\n} else {\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(ty);\n}\n});\ncljs.core.load_file \x3d (function cljs$core$load_file(file){\nif(cljs.core.truth_(COMPILED)){\nreturn null;\n} else {\nreturn goog.nodeGlobalRequire(file);\n}\n});\nif((((typeof Symbol !\x3d\x3d \'undefined\')) \x26\x26 ((goog.typeOf(Symbol) \x3d\x3d\x3d "function")))){\ncljs.core.ITER_SYMBOL \x3d Symbol.iterator;\n} else {\ncljs.core.ITER_SYMBOL \x3d "@@iterator";\n}\n/**\n * @enum {string}\n */\ncljs.core.CHAR_MAP \x3d ({"]": "_RBRACK_", "\'": "_SINGLEQUOTE_", "\x3d": "_EQ_", "\\"": "_DOUBLEQUOTE_", "!": "_BANG_", "*": "_STAR_", "%": "_PERCENT_", "|": "_BAR_", "~": "_TILDE_", "/": "_SLASH_", "\\\\": "_BSLASH_", "-": "_", "?": "_QMARK_", "\x26": "_AMPERSAND_", ":": "_COLON_", "\x3c": "_LT_", "{": "_LBRACE_", "}": "_RBRACE_", "[": "_LBRACK_", "#": "_SHARP_", "^": "_CARET_", "+": "_PLUS_", "@": "_CIRCA_", "\x3e": "_GT_"});\n/**\n * @enum {string}\n */\ncljs.core.DEMUNGE_MAP \x3d ({"_RBRACE_": "}", "_COLON_": ":", "_BANG_": "!", "_QMARK_": "?", "_BSLASH_": "\\\\\\\\", "_SLASH_": "/", "_PERCENT_": "%", "_PLUS_": "+", "_SHARP_": "#", "_LBRACE_": "{", "_BAR_": "|", "_LBRACK_": "[", "_EQ_": "\x3d", "_": "-", "_TILDE_": "~", "_RBRACK_": "]", "_GT_": "\x3e", "_SINGLEQUOTE_": "\'", "_CIRCA_": "@", "_AMPERSAND_": "\x26", "_DOUBLEQUOTE_": "\\\\\\"", "_CARET_": "^", "_LT_": "\x3c", "_STAR_": "*"});\ncljs.core.DEMUNGE_PATTERN \x3d null;\n/**\n * Returns highest resolution time offered by host in milliseconds.\n */\ncljs.core.system_time \x3d (function cljs$core$system_time(){\nif((((typeof performance !\x3d\x3d \'undefined\')) \x26\x26 ((!((performance.now \x3d\x3d null)))))){\nreturn performance.now();\n} else {\nif((((typeof process !\x3d\x3d \'undefined\')) \x26\x26 ((!((process.hrtime \x3d\x3d null)))))){\nvar t \x3d process.hrtime();\nreturn ((((t[(0)]) * 1.0E9) + (t[(1)])) / 1000000.0);\n} else {\nreturn (new Date()).getTime();\n\n}\n}\n});\n/**\n * Construct a JavaScript array of the specified dimensions. Accepts ignored\n *   type argument for compatibility with Clojure. Note that there is no efficient\n *   way to allocate multi-dimensional arrays in JavaScript; as such, this function\n *   will run in polynomial time when called with 3 or more arguments.\n */\ncljs.core.make_array \x3d (function cljs$core$make_array(var_args){\nvar G__9290 \x3d arguments.length;\nswitch (G__9290) {\ncase 1:\nreturn cljs.core.make_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.make_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9292 \x3d arguments.length;\nvar i__4731__auto___9293 \x3d (0);\nwhile(true){\nif((i__4731__auto___9293 \x3c len__4730__auto___9292)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9293]));\n\nvar G__9294 \x3d (i__4731__auto___9293 + (1));\ni__4731__auto___9293 \x3d G__9294;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.make_array.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.make_array.cljs$core$IFn$_invoke$arity$1 \x3d (function (size){\nreturn (new Array(size));\n});\n\ncljs.core.make_array.cljs$core$IFn$_invoke$arity$2 \x3d (function (type,size){\nreturn (new Array(size));\n});\n\ncljs.core.make_array.cljs$core$IFn$_invoke$arity$variadic \x3d (function (type,size,more_sizes){\nvar dims \x3d more_sizes;\nvar dimarray \x3d (new Array(size));\nvar n__4607__auto___9295 \x3d dimarray.length;\nvar i_9296 \x3d (0);\nwhile(true){\nif((i_9296 \x3c n__4607__auto___9295)){\n(dimarray[i_9296] \x3d cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.make_array,null,dims));\n\nvar G__9297 \x3d (i_9296 + (1));\ni_9296 \x3d G__9297;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn dimarray;\n});\n\n/** @this {Function} */\ncljs.core.make_array.cljs$lang$applyTo \x3d (function (seq9287){\nvar G__9288 \x3d cljs.core.first(seq9287);\nvar seq9287__$1 \x3d cljs.core.next(seq9287);\nvar G__9289 \x3d cljs.core.first(seq9287__$1);\nvar seq9287__$2 \x3d cljs.core.next(seq9287__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9288,G__9289,seq9287__$2);\n});\n\ncljs.core.make_array.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns a javascript array, cloned from the passed in array\n */\ncljs.core.aclone \x3d (function cljs$core$aclone(arr){\nvar len \x3d arr.length;\nvar new_arr \x3d (new Array(len));\nvar n__4607__auto___9298 \x3d len;\nvar i_9299 \x3d (0);\nwhile(true){\nif((i_9299 \x3c n__4607__auto___9298)){\n(new_arr[i_9299] \x3d (arr[i_9299]));\n\nvar G__9300 \x3d (i_9299 + (1));\ni_9299 \x3d G__9300;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn new_arr;\n});\n/**\n * Creates a new javascript array.\n * @param {...*} var_args\n */\ncljs.core.array \x3d (function cljs$core$array(var_args){\nvar a \x3d (new Array(arguments.length));\nvar i \x3d (0);\nwhile(true){\nif((i \x3c a.length)){\n(a[i] \x3d (arguments[i]));\n\nvar G__9301 \x3d (i + (1));\ni \x3d G__9301;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n});\ncljs.core.maybe_warn \x3d (function cljs$core$maybe_warn(e){\nif(cljs.core.truth_(cljs.core._STAR_print_err_fn_STAR_)){\nreturn (cljs.core._STAR_print_err_fn_STAR_.cljs$core$IFn$_invoke$arity$1 ? cljs.core._STAR_print_err_fn_STAR_.cljs$core$IFn$_invoke$arity$1(e) : cljs.core._STAR_print_err_fn_STAR_.call(null,e));\n} else {\nreturn null;\n}\n});\ncljs.core.checked_aget \x3d (function cljs$core$checked_aget(var_args){\nvar G__9306 \x3d arguments.length;\nswitch (G__9306) {\ncase 2:\nreturn cljs.core.checked_aget.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9309 \x3d arguments.length;\nvar i__4731__auto___9310 \x3d (0);\nwhile(true){\nif((i__4731__auto___9310 \x3c len__4730__auto___9309)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9310]));\n\nvar G__9311 \x3d (i__4731__auto___9310 + (1));\ni__4731__auto___9310 \x3d G__9311;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.checked_aget.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.checked_aget.cljs$core$IFn$_invoke$arity$2 \x3d (function (array,idx){\ntry{if(cljs.core.truth_((function (){var or__4131__auto__ \x3d cljs.core.array_QMARK_(array);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.isArrayLike(array);\n}\n})())){\n} else {\nthrow (new Error("Assert failed: (or (array? array) (goog/isArrayLike array))"));\n}\n\nif(typeof idx \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? idx)"));\n}\n\nif((!((idx \x3c (0))))){\n} else {\nthrow (new Error("Assert failed: (not (neg? idx))"));\n}\n\nif((idx \x3c array.length)){\n} else {\nthrow (new Error("Assert failed: (\x3c idx (alength array))"));\n}\n}catch (e9307){var e_9312 \x3d e9307;\ncljs.core.maybe_warn(e_9312);\n}\nreturn (array[idx]);\n});\n\ncljs.core.checked_aget.cljs$core$IFn$_invoke$arity$variadic \x3d (function (array,idx,idxs){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.checked_aget,cljs.core.checked_aget.cljs$core$IFn$_invoke$arity$2(array,idx),idxs);\n});\n\n/** @this {Function} */\ncljs.core.checked_aget.cljs$lang$applyTo \x3d (function (seq9303){\nvar G__9304 \x3d cljs.core.first(seq9303);\nvar seq9303__$1 \x3d cljs.core.next(seq9303);\nvar G__9305 \x3d cljs.core.first(seq9303__$1);\nvar seq9303__$2 \x3d cljs.core.next(seq9303__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9304,G__9305,seq9303__$2);\n});\n\ncljs.core.checked_aget.cljs$lang$maxFixedArity \x3d (2);\n\ncljs.core.checked_aset \x3d (function cljs$core$checked_aset(var_args){\nvar G__9318 \x3d arguments.length;\nswitch (G__9318) {\ncase 3:\nreturn cljs.core.checked_aset.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9321 \x3d arguments.length;\nvar i__4731__auto___9322 \x3d (0);\nwhile(true){\nif((i__4731__auto___9322 \x3c len__4730__auto___9321)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9322]));\n\nvar G__9323 \x3d (i__4731__auto___9322 + (1));\ni__4731__auto___9322 \x3d G__9323;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.checked_aset.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.checked_aset.cljs$core$IFn$_invoke$arity$3 \x3d (function (array,idx,val){\ntry{if(cljs.core.truth_((function (){var or__4131__auto__ \x3d cljs.core.array_QMARK_(array);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.isArrayLike(array);\n}\n})())){\n} else {\nthrow (new Error("Assert failed: (or (array? array) (goog/isArrayLike array))"));\n}\n\nif(typeof idx \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? idx)"));\n}\n\nif((!((idx \x3c (0))))){\n} else {\nthrow (new Error("Assert failed: (not (neg? idx))"));\n}\n\nif((idx \x3c array.length)){\n} else {\nthrow (new Error("Assert failed: (\x3c idx (alength array))"));\n}\n}catch (e9319){var e_9324 \x3d e9319;\ncljs.core.maybe_warn(e_9324);\n}\nreturn (array[idx] \x3d val);\n});\n\ncljs.core.checked_aset.cljs$core$IFn$_invoke$arity$variadic \x3d (function (array,idx,idx2,idxv){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core.checked_aset,cljs.core.checked_aget.cljs$core$IFn$_invoke$arity$2(array,idx),idx2,idxv);\n});\n\n/** @this {Function} */\ncljs.core.checked_aset.cljs$lang$applyTo \x3d (function (seq9314){\nvar G__9315 \x3d cljs.core.first(seq9314);\nvar seq9314__$1 \x3d cljs.core.next(seq9314);\nvar G__9316 \x3d cljs.core.first(seq9314__$1);\nvar seq9314__$2 \x3d cljs.core.next(seq9314__$1);\nvar G__9317 \x3d cljs.core.first(seq9314__$2);\nvar seq9314__$3 \x3d cljs.core.next(seq9314__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9315,G__9316,G__9317,seq9314__$3);\n});\n\ncljs.core.checked_aset.cljs$lang$maxFixedArity \x3d (3);\n\ncljs.core.checked_aget_SINGLEQUOTE_ \x3d (function cljs$core$checked_aget_SINGLEQUOTE_(var_args){\nvar G__9329 \x3d arguments.length;\nswitch (G__9329) {\ncase 2:\nreturn cljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9331 \x3d arguments.length;\nvar i__4731__auto___9332 \x3d (0);\nwhile(true){\nif((i__4731__auto___9332 \x3c len__4730__auto___9331)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9332]));\n\nvar G__9333 \x3d (i__4731__auto___9332 + (1));\ni__4731__auto___9332 \x3d G__9333;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2 \x3d (function (array,idx){\nif(cljs.core.truth_((function (){var or__4131__auto__ \x3d cljs.core.array_QMARK_(array);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.isArrayLike(array);\n}\n})())){\n} else {\nthrow (new Error("Assert failed: (or (array? array) (goog/isArrayLike array))"));\n}\n\nif(typeof idx \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? idx)"));\n}\n\nif((!((idx \x3c (0))))){\n} else {\nthrow (new Error("Assert failed: (not (neg? idx))"));\n}\n\nif((idx \x3c array.length)){\n} else {\nthrow (new Error("Assert failed: (\x3c idx (alength array))"));\n}\n\nreturn (array[idx]);\n});\n\ncljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (array,idx,idxs){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.checked_aget_SINGLEQUOTE_,cljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2(array,idx),idxs);\n});\n\n/** @this {Function} */\ncljs.core.checked_aget_SINGLEQUOTE_.cljs$lang$applyTo \x3d (function (seq9326){\nvar G__9327 \x3d cljs.core.first(seq9326);\nvar seq9326__$1 \x3d cljs.core.next(seq9326);\nvar G__9328 \x3d cljs.core.first(seq9326__$1);\nvar seq9326__$2 \x3d cljs.core.next(seq9326__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9327,G__9328,seq9326__$2);\n});\n\ncljs.core.checked_aget_SINGLEQUOTE_.cljs$lang$maxFixedArity \x3d (2);\n\ncljs.core.checked_aset_SINGLEQUOTE_ \x3d (function cljs$core$checked_aset_SINGLEQUOTE_(var_args){\nvar G__9339 \x3d arguments.length;\nswitch (G__9339) {\ncase 3:\nreturn cljs.core.checked_aset_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9341 \x3d arguments.length;\nvar i__4731__auto___9342 \x3d (0);\nwhile(true){\nif((i__4731__auto___9342 \x3c len__4730__auto___9341)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9342]));\n\nvar G__9343 \x3d (i__4731__auto___9342 + (1));\ni__4731__auto___9342 \x3d G__9343;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.checked_aset_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.checked_aset_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3 \x3d (function (array,idx,val){\nif(cljs.core.truth_((function (){var or__4131__auto__ \x3d cljs.core.array_QMARK_(array);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.isArrayLike(array);\n}\n})())){\n} else {\nthrow (new Error("Assert failed: (or (array? array) (goog/isArrayLike array))"));\n}\n\nif(typeof idx \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? idx)"));\n}\n\nif((!((idx \x3c (0))))){\n} else {\nthrow (new Error("Assert failed: (not (neg? idx))"));\n}\n\nif((idx \x3c array.length)){\n} else {\nthrow (new Error("Assert failed: (\x3c idx (alength array))"));\n}\n\nreturn (array[idx] \x3d val);\n});\n\ncljs.core.checked_aset_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (array,idx,idx2,idxv){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core.checked_aset_SINGLEQUOTE_,cljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2(array,idx),idx2,idxv);\n});\n\n/** @this {Function} */\ncljs.core.checked_aset_SINGLEQUOTE_.cljs$lang$applyTo \x3d (function (seq9335){\nvar G__9336 \x3d cljs.core.first(seq9335);\nvar seq9335__$1 \x3d cljs.core.next(seq9335);\nvar G__9337 \x3d cljs.core.first(seq9335__$1);\nvar seq9335__$2 \x3d cljs.core.next(seq9335__$1);\nvar G__9338 \x3d cljs.core.first(seq9335__$2);\nvar seq9335__$3 \x3d cljs.core.next(seq9335__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9336,G__9337,G__9338,seq9335__$3);\n});\n\ncljs.core.checked_aset_SINGLEQUOTE_.cljs$lang$maxFixedArity \x3d (3);\n\n/**\n * Returns the value at the index/indices. Works on JavaScript arrays.\n */\ncljs.core.aget \x3d (function cljs$core$aget(var_args){\nvar G__9348 \x3d arguments.length;\nswitch (G__9348) {\ncase 2:\nreturn cljs.core.aget.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9350 \x3d arguments.length;\nvar i__4731__auto___9351 \x3d (0);\nwhile(true){\nif((i__4731__auto___9351 \x3c len__4730__auto___9350)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9351]));\n\nvar G__9352 \x3d (i__4731__auto___9351 + (1));\ni__4731__auto___9351 \x3d G__9352;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.aget.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.aget.cljs$core$IFn$_invoke$arity$2 \x3d (function (array,idx){\nreturn (array[idx]);\n});\n\ncljs.core.aget.cljs$core$IFn$_invoke$arity$variadic \x3d (function (array,idx,idxs){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.aget,(array[idx]),idxs);\n});\n\n/** @this {Function} */\ncljs.core.aget.cljs$lang$applyTo \x3d (function (seq9345){\nvar G__9346 \x3d cljs.core.first(seq9345);\nvar seq9345__$1 \x3d cljs.core.next(seq9345);\nvar G__9347 \x3d cljs.core.first(seq9345__$1);\nvar seq9345__$2 \x3d cljs.core.next(seq9345__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9346,G__9347,seq9345__$2);\n});\n\ncljs.core.aget.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Sets the value at the index/indices. Works on JavaScript arrays.\n *   Returns val.\n */\ncljs.core.aset \x3d (function cljs$core$aset(var_args){\nvar G__9358 \x3d arguments.length;\nswitch (G__9358) {\ncase 3:\nreturn cljs.core.aset.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9360 \x3d arguments.length;\nvar i__4731__auto___9361 \x3d (0);\nwhile(true){\nif((i__4731__auto___9361 \x3c len__4730__auto___9360)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9361]));\n\nvar G__9362 \x3d (i__4731__auto___9361 + (1));\ni__4731__auto___9361 \x3d G__9362;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.aset.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.aset.cljs$core$IFn$_invoke$arity$3 \x3d (function (array,idx,val){\nreturn (array[idx] \x3d val);\n});\n\ncljs.core.aset.cljs$core$IFn$_invoke$arity$variadic \x3d (function (array,idx,idx2,idxv){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core.aset,(array[idx]),idx2,idxv);\n});\n\n/** @this {Function} */\ncljs.core.aset.cljs$lang$applyTo \x3d (function (seq9354){\nvar G__9355 \x3d cljs.core.first(seq9354);\nvar seq9354__$1 \x3d cljs.core.next(seq9354);\nvar G__9356 \x3d cljs.core.first(seq9354__$1);\nvar seq9354__$2 \x3d cljs.core.next(seq9354__$1);\nvar G__9357 \x3d cljs.core.first(seq9354__$2);\nvar seq9354__$3 \x3d cljs.core.next(seq9354__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9355,G__9356,G__9357,seq9354__$3);\n});\n\ncljs.core.aset.cljs$lang$maxFixedArity \x3d (3);\n\n/**\n * Returns the length of the array. Works on arrays of all types.\n */\ncljs.core.alength \x3d (function cljs$core$alength(array){\nreturn array.length;\n});\n/**\n * Returns an array with components set to the values in aseq. Optional type\n *   argument accepted for compatibility with Clojure.\n */\ncljs.core.into_array \x3d (function cljs$core$into_array(var_args){\nvar G__9364 \x3d arguments.length;\nswitch (G__9364) {\ncase 1:\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.into_array.cljs$core$IFn$_invoke$arity$1 \x3d (function (aseq){\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$2(null,aseq);\n});\n\ncljs.core.into_array.cljs$core$IFn$_invoke$arity$2 \x3d (function (type,aseq){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (a,x){\na.push(x);\n\nreturn a;\n}),[],aseq);\n});\n\ncljs.core.into_array.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Invoke JavaScript object method via string. Needed when the\n *   string is not a valid unquoted property name.\n */\ncljs.core.js_invoke \x3d (function cljs$core$js_invoke(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___9369 \x3d arguments.length;\nvar i__4731__auto___9370 \x3d (0);\nwhile(true){\nif((i__4731__auto___9370 \x3c len__4730__auto___9369)){\nargs__4736__auto__.push((arguments[i__4731__auto___9370]));\n\nvar G__9371 \x3d (i__4731__auto___9370 + (1));\ni__4731__auto___9370 \x3d G__9371;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((2) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((2)),(0),null)):null);\nreturn cljs.core.js_invoke.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4737__auto__);\n});\n\ncljs.core.js_invoke.cljs$core$IFn$_invoke$arity$variadic \x3d (function (obj,s,args){\nreturn (obj[s]).apply(obj,cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(args));\n});\n\ncljs.core.js_invoke.cljs$lang$maxFixedArity \x3d (2);\n\n/** @this {Function} */\ncljs.core.js_invoke.cljs$lang$applyTo \x3d (function (seq9366){\nvar G__9367 \x3d cljs.core.first(seq9366);\nvar seq9366__$1 \x3d cljs.core.next(seq9366);\nvar G__9368 \x3d cljs.core.first(seq9366__$1);\nvar seq9366__$2 \x3d cljs.core.next(seq9366__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9367,G__9368,seq9366__$2);\n});\n\n\n/**\n * Marker protocol\n * @interface\n */\ncljs.core.Fn \x3d function(){};\n\n\n/**\n * Protocol for adding the ability to invoke an object as a function.\n *   For example, a vector can also be used to look up a value:\n *   ([1 2 3 4] 1) \x3d\x3e 2\n * @interface\n */\ncljs.core.IFn \x3d function(){};\n\ncljs.core._invoke \x3d (function cljs$core$_invoke(var_args){\nvar G__9373 \x3d arguments.length;\nswitch (G__9373) {\ncase 1:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ncase 7:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$7((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]));\n\nbreak;\ncase 8:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase 9:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ncase 10:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$10((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]));\n\nbreak;\ncase 11:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ncase 12:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ncase 13:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$13((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]));\n\nbreak;\ncase 14:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$14((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]));\n\nbreak;\ncase 15:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$15((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]));\n\nbreak;\ncase 16:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$16((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]));\n\nbreak;\ncase 17:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$17((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]));\n\nbreak;\ncase 18:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$18((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]));\n\nbreak;\ncase 19:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$19((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]),(arguments[(18)]));\n\nbreak;\ncase 20:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$20((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]),(arguments[(18)]),(arguments[(19)]));\n\nbreak;\ncase 21:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$21((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]),(arguments[(18)]),(arguments[(19)]),(arguments[(20)]));\n\nbreak;\ncase 22:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$22((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]),(arguments[(18)]),(arguments[(19)]),(arguments[(20)]),(arguments[(21)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$1 \x3d (function (this$){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$1 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$1(this$);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__4434__auto__.call(null,this$));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__4431__auto__.call(null,this$));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$2 \x3d (function (this$,a){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$2 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$2(this$,a);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(this$,a) : m__4434__auto__.call(null,this$,a));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(this$,a) : m__4431__auto__.call(null,this$,a));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$3 \x3d (function (this$,a,b){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$3 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$3(this$,a,b);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(this$,a,b) : m__4434__auto__.call(null,this$,a,b));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(this$,a,b) : m__4431__auto__.call(null,this$,a,b));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$4 \x3d (function (this$,a,b,c){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$4 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$4(this$,a,b,c);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$4(this$,a,b,c) : m__4434__auto__.call(null,this$,a,b,c));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$4(this$,a,b,c) : m__4431__auto__.call(null,this$,a,b,c));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$5 \x3d (function (this$,a,b,c,d){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$5 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$5(this$,a,b,c,d);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$5 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$5(this$,a,b,c,d) : m__4434__auto__.call(null,this$,a,b,c,d));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$5 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$5(this$,a,b,c,d) : m__4431__auto__.call(null,this$,a,b,c,d));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$6 \x3d (function (this$,a,b,c,d,e){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$6 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$6(this$,a,b,c,d,e);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$6 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$6(this$,a,b,c,d,e) : m__4434__auto__.call(null,this$,a,b,c,d,e));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$6 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$6(this$,a,b,c,d,e) : m__4431__auto__.call(null,this$,a,b,c,d,e));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$7 \x3d (function (this$,a,b,c,d,e,f){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$7 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$7(this$,a,b,c,d,e,f);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$7 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$7(this$,a,b,c,d,e,f) : m__4434__auto__.call(null,this$,a,b,c,d,e,f));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$7 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$7(this$,a,b,c,d,e,f) : m__4431__auto__.call(null,this$,a,b,c,d,e,f));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$8 \x3d (function (this$,a,b,c,d,e,f,g){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$8 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$8(this$,a,b,c,d,e,f,g);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$8 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$8(this$,a,b,c,d,e,f,g) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$8 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$8(this$,a,b,c,d,e,f,g) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$9 \x3d (function (this$,a,b,c,d,e,f,g,h){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$9 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$9(this$,a,b,c,d,e,f,g,h);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$9 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$9(this$,a,b,c,d,e,f,g,h) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$9 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$9(this$,a,b,c,d,e,f,g,h) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$10 \x3d (function (this$,a,b,c,d,e,f,g,h,i){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$10 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$10(this$,a,b,c,d,e,f,g,h,i);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$10 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$10(this$,a,b,c,d,e,f,g,h,i) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$10 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$10(this$,a,b,c,d,e,f,g,h,i) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$11 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$11 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$11(this$,a,b,c,d,e,f,g,h,i,j);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$11 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$11(this$,a,b,c,d,e,f,g,h,i,j) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$11 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$11(this$,a,b,c,d,e,f,g,h,i,j) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$12 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$12 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$12(this$,a,b,c,d,e,f,g,h,i,j,k);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$12 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$12(this$,a,b,c,d,e,f,g,h,i,j,k) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$12 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$12(this$,a,b,c,d,e,f,g,h,i,j,k) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$13 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$13 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$13(this$,a,b,c,d,e,f,g,h,i,j,k,l);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$13 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$13(this$,a,b,c,d,e,f,g,h,i,j,k,l) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$13 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$13(this$,a,b,c,d,e,f,g,h,i,j,k,l) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$14 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$14 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$14(this$,a,b,c,d,e,f,g,h,i,j,k,l,m);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$14 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$14(this$,a,b,c,d,e,f,g,h,i,j,k,l,m) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$14 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$14(this$,a,b,c,d,e,f,g,h,i,j,k,l,m) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$15 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$15 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$15(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$15 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$15(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$15 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$15(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$16 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$16 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$16(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$16 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$16(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$16 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$16(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$17 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$17 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$17(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$17 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$17(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$17 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$17(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$18 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$18 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$18(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$18 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$18(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$18 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$18(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$19 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$19 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$19(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$19 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$19(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$19 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$19(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$20 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$20 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$20(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$20 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$20(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$20 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$20(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$21 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$21 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$21(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$21 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$21(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$21 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$21(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$22 \x3d (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IFn$_invoke$arity$22 \x3d\x3d null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$22(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$22 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$22(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._invoke["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$22 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$22(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest));\n} else {\nthrow cljs.core.missing_protocol("IFn.-invoke",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$lang$maxFixedArity \x3d 22;\n\n\n\n/**\n * Protocol for cloning a value.\n * @interface\n */\ncljs.core.ICloneable \x3d function(){};\n\n/**\n * Creates a clone of value.\n */\ncljs.core._clone \x3d (function cljs$core$_clone(value){\nif((((!((value \x3d\x3d null)))) \x26\x26 ((!((value.cljs$core$ICloneable$_clone$arity$1 \x3d\x3d null)))))){\nreturn value.cljs$core$ICloneable$_clone$arity$1(value);\n} else {\nvar x__4433__auto__ \x3d (((value \x3d\x3d null))?null:value);\nvar m__4434__auto__ \x3d (cljs.core._clone[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(value) : m__4434__auto__.call(null,value));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._clone["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(value) : m__4431__auto__.call(null,value));\n} else {\nthrow cljs.core.missing_protocol("ICloneable.-clone",value);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding the ability to count a collection in constant time.\n * @interface\n */\ncljs.core.ICounted \x3d function(){};\n\n/**\n * Calculates the count of coll in constant time. Used by cljs.core/count.\n */\ncljs.core._count \x3d (function cljs$core$_count(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$ICounted$_count$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$ICounted$_count$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._count[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._count["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("ICounted.-count",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for creating an empty collection.\n * @interface\n */\ncljs.core.IEmptyableCollection \x3d function(){};\n\n/**\n * Returns an empty collection of the same category as coll. Used\n *   by cljs.core/empty.\n */\ncljs.core._empty \x3d (function cljs$core$_empty(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IEmptyableCollection$_empty$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._empty[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._empty["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IEmptyableCollection.-empty",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding to a collection.\n * @interface\n */\ncljs.core.ICollection \x3d function(){};\n\n/**\n * Returns a new collection of coll with o added to it. The new item\n *   should be added to the most efficient place, e.g.\n *   (conj [1 2 3 4] 5) \x3d\x3e [1 2 3 4 5]\n *   (conj \'(2 3 4 5) 1) \x3d\x3e \'(1 2 3 4 5)\n */\ncljs.core._conj \x3d (function cljs$core$_conj(coll,o){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$ICollection$_conj$arity$2 \x3d\x3d null)))))){\nreturn coll.cljs$core$ICollection$_conj$arity$2(coll,o);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._conj[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,o) : m__4434__auto__.call(null,coll,o));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._conj["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,o) : m__4431__auto__.call(null,coll,o));\n} else {\nthrow cljs.core.missing_protocol("ICollection.-conj",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for collections to provide indexed-based access to their items.\n * @interface\n */\ncljs.core.IIndexed \x3d function(){};\n\n/**\n * Returns the value at the index n in the collection coll.\n *   Returns not-found if index n is out of bounds and not-found is supplied.\n */\ncljs.core._nth \x3d (function cljs$core$_nth(var_args){\nvar G__9376 \x3d arguments.length;\nswitch (G__9376) {\ncase 2:\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core._nth.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,n){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IIndexed$_nth$arity$2 \x3d\x3d null)))))){\nreturn coll.cljs$core$IIndexed$_nth$arity$2(coll,n);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._nth[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,n) : m__4434__auto__.call(null,coll,n));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._nth["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,n) : m__4431__auto__.call(null,coll,n));\n} else {\nthrow cljs.core.missing_protocol("IIndexed.-nth",coll);\n}\n}\n}\n});\n\ncljs.core._nth.cljs$core$IFn$_invoke$arity$3 \x3d (function (coll,n,not_found){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IIndexed$_nth$arity$3 \x3d\x3d null)))))){\nreturn coll.cljs$core$IIndexed$_nth$arity$3(coll,n,not_found);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._nth[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,n,not_found) : m__4434__auto__.call(null,coll,n,not_found));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._nth["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,n,not_found) : m__4431__auto__.call(null,coll,n,not_found));\n} else {\nthrow cljs.core.missing_protocol("IIndexed.-nth",coll);\n}\n}\n}\n});\n\ncljs.core._nth.cljs$lang$maxFixedArity \x3d 3;\n\n\n\n/**\n * Marker protocol indicating an array sequence.\n * @interface\n */\ncljs.core.ASeq \x3d function(){};\n\n\n/**\n * Protocol for collections to provide access to their items as sequences.\n * @interface\n */\ncljs.core.ISeq \x3d function(){};\n\n/**\n * Returns the first item in the collection coll. Used by cljs.core/first.\n */\ncljs.core._first \x3d (function cljs$core$_first(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$ISeq$_first$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$ISeq$_first$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._first[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._first["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("ISeq.-first",coll);\n}\n}\n}\n});\n\n/**\n * Returns a new collection of coll without the first item. It should\n *   always return a seq, e.g.\n *   (rest []) \x3d\x3e ()\n *   (rest nil) \x3d\x3e ()\n */\ncljs.core._rest \x3d (function cljs$core$_rest(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$ISeq$_rest$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$ISeq$_rest$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._rest[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._rest["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("ISeq.-rest",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing the next items of a collection.\n * @interface\n */\ncljs.core.INext \x3d function(){};\n\n/**\n * Returns a new collection of coll without the first item. In contrast to\n *   rest, it should return nil if there are no more items, e.g.\n *   (next []) \x3d\x3e nil\n *   (next nil) \x3d\x3e nil\n */\ncljs.core._next \x3d (function cljs$core$_next(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$INext$_next$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$INext$_next$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._next[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._next["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("INext.-next",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for looking up a value in a data structure.\n * @interface\n */\ncljs.core.ILookup \x3d function(){};\n\n/**\n * Use k to look up a value in o. If not-found is supplied and k is not\n *   a valid value that can be used for look up, not-found is returned.\n */\ncljs.core._lookup \x3d (function cljs$core$_lookup(var_args){\nvar G__9379 \x3d arguments.length;\nswitch (G__9379) {\ncase 2:\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core._lookup.cljs$core$IFn$_invoke$arity$2 \x3d (function (o,k){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$ILookup$_lookup$arity$2 \x3d\x3d null)))))){\nreturn o.cljs$core$ILookup$_lookup$arity$2(o,k);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._lookup[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,k) : m__4434__auto__.call(null,o,k));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._lookup["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,k) : m__4431__auto__.call(null,o,k));\n} else {\nthrow cljs.core.missing_protocol("ILookup.-lookup",o);\n}\n}\n}\n});\n\ncljs.core._lookup.cljs$core$IFn$_invoke$arity$3 \x3d (function (o,k,not_found){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$ILookup$_lookup$arity$3 \x3d\x3d null)))))){\nreturn o.cljs$core$ILookup$_lookup$arity$3(o,k,not_found);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._lookup[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(o,k,not_found) : m__4434__auto__.call(null,o,k,not_found));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._lookup["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(o,k,not_found) : m__4431__auto__.call(null,o,k,not_found));\n} else {\nthrow cljs.core.missing_protocol("ILookup.-lookup",o);\n}\n}\n}\n});\n\ncljs.core._lookup.cljs$lang$maxFixedArity \x3d 3;\n\n\n\n/**\n * Protocol for adding associativity to collections.\n * @interface\n */\ncljs.core.IAssociative \x3d function(){};\n\n/**\n * Returns true if k is a key in coll.\n */\ncljs.core._contains_key_QMARK_ \x3d (function cljs$core$_contains_key_QMARK_(coll,k){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 \x3d\x3d null)))))){\nreturn coll.cljs$core$IAssociative$_contains_key_QMARK_$arity$2(coll,k);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._contains_key_QMARK_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4434__auto__.call(null,coll,k));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._contains_key_QMARK_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4431__auto__.call(null,coll,k));\n} else {\nthrow cljs.core.missing_protocol("IAssociative.-contains-key?",coll);\n}\n}\n}\n});\n\n/**\n * Returns a new collection of coll with a mapping from key k to\n *   value v added to it.\n */\ncljs.core._assoc \x3d (function cljs$core$_assoc(coll,k,v){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IAssociative$_assoc$arity$3 \x3d\x3d null)))))){\nreturn coll.cljs$core$IAssociative$_assoc$arity$3(coll,k,v);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._assoc[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,k,v) : m__4434__auto__.call(null,coll,k,v));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._assoc["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,k,v) : m__4431__auto__.call(null,coll,k,v));\n} else {\nthrow cljs.core.missing_protocol("IAssociative.-assoc",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for implementing entry finding in collections.\n * @interface\n */\ncljs.core.IFind \x3d function(){};\n\n/**\n * Returns the map entry for key, or nil if key not present.\n */\ncljs.core._find \x3d (function cljs$core$_find(coll,k){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IFind$_find$arity$2 \x3d\x3d null)))))){\nreturn coll.cljs$core$IFind$_find$arity$2(coll,k);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._find[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4434__auto__.call(null,coll,k));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._find["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4431__auto__.call(null,coll,k));\n} else {\nthrow cljs.core.missing_protocol("IFind.-find",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding mapping functionality to collections.\n * @interface\n */\ncljs.core.IMap \x3d function(){};\n\n/**\n * Returns a new collection of coll without the mapping for key k.\n */\ncljs.core._dissoc \x3d (function cljs$core$_dissoc(coll,k){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IMap$_dissoc$arity$2 \x3d\x3d null)))))){\nreturn coll.cljs$core$IMap$_dissoc$arity$2(coll,k);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._dissoc[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4434__auto__.call(null,coll,k));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._dissoc["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4431__auto__.call(null,coll,k));\n} else {\nthrow cljs.core.missing_protocol("IMap.-dissoc",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for examining a map entry.\n * @interface\n */\ncljs.core.IMapEntry \x3d function(){};\n\n/**\n * Returns the key of the map entry.\n */\ncljs.core._key \x3d (function cljs$core$_key(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IMapEntry$_key$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IMapEntry$_key$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._key[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._key["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IMapEntry.-key",coll);\n}\n}\n}\n});\n\n/**\n * Returns the value of the map entry.\n */\ncljs.core._val \x3d (function cljs$core$_val(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IMapEntry$_val$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IMapEntry$_val$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._val[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._val["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IMapEntry.-val",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding set functionality to a collection.\n * @interface\n */\ncljs.core.ISet \x3d function(){};\n\n/**\n * Returns a new collection of coll that does not contain v.\n */\ncljs.core._disjoin \x3d (function cljs$core$_disjoin(coll,v){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$ISet$_disjoin$arity$2 \x3d\x3d null)))))){\nreturn coll.cljs$core$ISet$_disjoin$arity$2(coll,v);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._disjoin[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,v) : m__4434__auto__.call(null,coll,v));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._disjoin["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,v) : m__4431__auto__.call(null,coll,v));\n} else {\nthrow cljs.core.missing_protocol("ISet.-disjoin",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for collections to provide access to their items as stacks. The top\n *   of the stack should be accessed in the most efficient way for the different\n *   data structures.\n * @interface\n */\ncljs.core.IStack \x3d function(){};\n\n/**\n * Returns the item from the top of the stack. Is used by cljs.core/peek.\n */\ncljs.core._peek \x3d (function cljs$core$_peek(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IStack$_peek$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IStack$_peek$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._peek[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._peek["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IStack.-peek",coll);\n}\n}\n}\n});\n\n/**\n * Returns a new stack without the item on top of the stack. Is used\n *   by cljs.core/pop.\n */\ncljs.core._pop \x3d (function cljs$core$_pop(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IStack$_pop$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IStack$_pop$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._pop[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._pop["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IStack.-pop",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding vector functionality to collections.\n * @interface\n */\ncljs.core.IVector \x3d function(){};\n\n/**\n * Returns a new vector with value val added at position n.\n */\ncljs.core._assoc_n \x3d (function cljs$core$_assoc_n(coll,n,val){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IVector$_assoc_n$arity$3 \x3d\x3d null)))))){\nreturn coll.cljs$core$IVector$_assoc_n$arity$3(coll,n,val);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._assoc_n[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,n,val) : m__4434__auto__.call(null,coll,n,val));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._assoc_n["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,n,val) : m__4431__auto__.call(null,coll,n,val));\n} else {\nthrow cljs.core.missing_protocol("IVector.-assoc-n",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding dereference functionality to a reference.\n * @interface\n */\ncljs.core.IDeref \x3d function(){};\n\n/**\n * Returns the value of the reference o.\n */\ncljs.core._deref \x3d (function cljs$core$_deref(o){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$IDeref$_deref$arity$1 \x3d\x3d null)))))){\nreturn o.cljs$core$IDeref$_deref$arity$1(o);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._deref[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4434__auto__.call(null,o));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._deref["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4431__auto__.call(null,o));\n} else {\nthrow cljs.core.missing_protocol("IDeref.-deref",o);\n}\n}\n}\n});\n\n\n/**\n * @interface\n */\ncljs.core.IDerefWithTimeout \x3d function(){};\n\ncljs.core._deref_with_timeout \x3d (function cljs$core$_deref_with_timeout(o,msec,timeout_val){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$IDerefWithTimeout$_deref_with_timeout$arity$3 \x3d\x3d null)))))){\nreturn o.cljs$core$IDerefWithTimeout$_deref_with_timeout$arity$3(o,msec,timeout_val);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._deref_with_timeout[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(o,msec,timeout_val) : m__4434__auto__.call(null,o,msec,timeout_val));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._deref_with_timeout["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(o,msec,timeout_val) : m__4431__auto__.call(null,o,msec,timeout_val));\n} else {\nthrow cljs.core.missing_protocol("IDerefWithTimeout.-deref-with-timeout",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing the metadata of an object.\n * @interface\n */\ncljs.core.IMeta \x3d function(){};\n\n/**\n * Returns the metadata of object o.\n */\ncljs.core._meta \x3d (function cljs$core$_meta(o){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$IMeta$_meta$arity$1 \x3d\x3d null)))))){\nreturn o.cljs$core$IMeta$_meta$arity$1(o);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._meta[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4434__auto__.call(null,o));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._meta["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4431__auto__.call(null,o));\n} else {\nthrow cljs.core.missing_protocol("IMeta.-meta",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding metadata to an object.\n * @interface\n */\ncljs.core.IWithMeta \x3d function(){};\n\n/**\n * Returns a new object with value of o and metadata meta added to it.\n */\ncljs.core._with_meta \x3d (function cljs$core$_with_meta(o,meta){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$IWithMeta$_with_meta$arity$2 \x3d\x3d null)))))){\nreturn o.cljs$core$IWithMeta$_with_meta$arity$2(o,meta);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._with_meta[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,meta) : m__4434__auto__.call(null,o,meta));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._with_meta["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,meta) : m__4431__auto__.call(null,o,meta));\n} else {\nthrow cljs.core.missing_protocol("IWithMeta.-with-meta",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for seq types that can reduce themselves.\n *   Called by cljs.core/reduce.\n * @interface\n */\ncljs.core.IReduce \x3d function(){};\n\n/**\n * f should be a function of 2 arguments. If start is not supplied,\n *   returns the result of applying f to the first 2 items in coll, then\n *   applying f to that result and the 3rd item, etc.\n */\ncljs.core._reduce \x3d (function cljs$core$_reduce(var_args){\nvar G__9382 \x3d arguments.length;\nswitch (G__9382) {\ncase 2:\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core._reduce.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,f){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IReduce$_reduce$arity$2 \x3d\x3d null)))))){\nreturn coll.cljs$core$IReduce$_reduce$arity$2(coll,f);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._reduce[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,f) : m__4434__auto__.call(null,coll,f));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._reduce["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,f) : m__4431__auto__.call(null,coll,f));\n} else {\nthrow cljs.core.missing_protocol("IReduce.-reduce",coll);\n}\n}\n}\n});\n\ncljs.core._reduce.cljs$core$IFn$_invoke$arity$3 \x3d (function (coll,f,start){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IReduce$_reduce$arity$3 \x3d\x3d null)))))){\nreturn coll.cljs$core$IReduce$_reduce$arity$3(coll,f,start);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._reduce[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,f,start) : m__4434__auto__.call(null,coll,f,start));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._reduce["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,f,start) : m__4431__auto__.call(null,coll,f,start));\n} else {\nthrow cljs.core.missing_protocol("IReduce.-reduce",coll);\n}\n}\n}\n});\n\ncljs.core._reduce.cljs$lang$maxFixedArity \x3d 3;\n\n\n\n/**\n * Protocol for associative types that can reduce themselves\n *   via a function of key and val. Called by cljs.core/reduce-kv.\n * @interface\n */\ncljs.core.IKVReduce \x3d function(){};\n\n/**\n * Reduces an associative collection and returns the result. f should be\n *   a function that takes three arguments.\n */\ncljs.core._kv_reduce \x3d (function cljs$core$_kv_reduce(coll,f,init){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IKVReduce$_kv_reduce$arity$3 \x3d\x3d null)))))){\nreturn coll.cljs$core$IKVReduce$_kv_reduce$arity$3(coll,f,init);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._kv_reduce[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,f,init) : m__4434__auto__.call(null,coll,f,init));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._kv_reduce["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,f,init) : m__4431__auto__.call(null,coll,f,init));\n} else {\nthrow cljs.core.missing_protocol("IKVReduce.-kv-reduce",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding value comparison functionality to a type.\n * @interface\n */\ncljs.core.IEquiv \x3d function(){};\n\n/**\n * Returns true if o and other are equal, false otherwise.\n */\ncljs.core._equiv \x3d (function cljs$core$_equiv(o,other){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$IEquiv$_equiv$arity$2 \x3d\x3d null)))))){\nreturn o.cljs$core$IEquiv$_equiv$arity$2(o,other);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._equiv[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,other) : m__4434__auto__.call(null,o,other));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._equiv["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,other) : m__4431__auto__.call(null,o,other));\n} else {\nthrow cljs.core.missing_protocol("IEquiv.-equiv",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding hashing functionality to a type.\n * @interface\n */\ncljs.core.IHash \x3d function(){};\n\n/**\n * Returns the hash code of o.\n */\ncljs.core._hash \x3d (function cljs$core$_hash(o){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$IHash$_hash$arity$1 \x3d\x3d null)))))){\nreturn o.cljs$core$IHash$_hash$arity$1(o);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._hash[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4434__auto__.call(null,o));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._hash["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4431__auto__.call(null,o));\n} else {\nthrow cljs.core.missing_protocol("IHash.-hash",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding the ability to a type to be transformed into a sequence.\n * @interface\n */\ncljs.core.ISeqable \x3d function(){};\n\n/**\n * Returns a seq of o, or nil if o is empty.\n */\ncljs.core._seq \x3d (function cljs$core$_seq(o){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$ISeqable$_seq$arity$1 \x3d\x3d null)))))){\nreturn o.cljs$core$ISeqable$_seq$arity$1(o);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._seq[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4434__auto__.call(null,o));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._seq["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4431__auto__.call(null,o));\n} else {\nthrow cljs.core.missing_protocol("ISeqable.-seq",o);\n}\n}\n}\n});\n\n\n/**\n * Marker interface indicating a persistent collection of sequential items\n * @interface\n */\ncljs.core.ISequential \x3d function(){};\n\n\n/**\n * Marker interface indicating a persistent list\n * @interface\n */\ncljs.core.IList \x3d function(){};\n\n\n/**\n * Marker interface indicating a record object\n * @interface\n */\ncljs.core.IRecord \x3d function(){};\n\n\n/**\n * Protocol for reversing a seq.\n * @interface\n */\ncljs.core.IReversible \x3d function(){};\n\n/**\n * Returns a seq of the items in coll in reversed order.\n */\ncljs.core._rseq \x3d (function cljs$core$_rseq(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IReversible$_rseq$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IReversible$_rseq$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._rseq[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._rseq["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IReversible.-rseq",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for a collection which can represent their items\n *   in a sorted manner. \n * @interface\n */\ncljs.core.ISorted \x3d function(){};\n\n/**\n * Returns a sorted seq from coll in either ascending or descending order.\n */\ncljs.core._sorted_seq \x3d (function cljs$core$_sorted_seq(coll,ascending_QMARK_){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$ISorted$_sorted_seq$arity$2 \x3d\x3d null)))))){\nreturn coll.cljs$core$ISorted$_sorted_seq$arity$2(coll,ascending_QMARK_);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._sorted_seq[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,ascending_QMARK_) : m__4434__auto__.call(null,coll,ascending_QMARK_));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._sorted_seq["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,ascending_QMARK_) : m__4431__auto__.call(null,coll,ascending_QMARK_));\n} else {\nthrow cljs.core.missing_protocol("ISorted.-sorted-seq",coll);\n}\n}\n}\n});\n\n/**\n * Returns a sorted seq from coll in either ascending or descending order.\n *   If ascending is true, the result should contain all items which are \x3e or \x3e\x3d\n *   than k. If ascending is false, the result should contain all items which\n *   are \x3c or \x3c\x3d than k, e.g.\n *   (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) \x3d\x3e (3 4 5)\n *   (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) \x3d\x3e (3 2 1)\n */\ncljs.core._sorted_seq_from \x3d (function cljs$core$_sorted_seq_from(coll,k,ascending_QMARK_){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$ISorted$_sorted_seq_from$arity$3 \x3d\x3d null)))))){\nreturn coll.cljs$core$ISorted$_sorted_seq_from$arity$3(coll,k,ascending_QMARK_);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._sorted_seq_from[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,k,ascending_QMARK_) : m__4434__auto__.call(null,coll,k,ascending_QMARK_));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._sorted_seq_from["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,k,ascending_QMARK_) : m__4431__auto__.call(null,coll,k,ascending_QMARK_));\n} else {\nthrow cljs.core.missing_protocol("ISorted.-sorted-seq-from",coll);\n}\n}\n}\n});\n\n/**\n * Returns the key for entry.\n */\ncljs.core._entry_key \x3d (function cljs$core$_entry_key(coll,entry){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$ISorted$_entry_key$arity$2 \x3d\x3d null)))))){\nreturn coll.cljs$core$ISorted$_entry_key$arity$2(coll,entry);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._entry_key[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,entry) : m__4434__auto__.call(null,coll,entry));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._entry_key["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,entry) : m__4431__auto__.call(null,coll,entry));\n} else {\nthrow cljs.core.missing_protocol("ISorted.-entry-key",coll);\n}\n}\n}\n});\n\n/**\n * Returns the comparator for coll.\n */\ncljs.core._comparator \x3d (function cljs$core$_comparator(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$ISorted$_comparator$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$ISorted$_comparator$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._comparator[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._comparator["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("ISorted.-comparator",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for writing. Currently only implemented by StringBufferWriter.\n * @interface\n */\ncljs.core.IWriter \x3d function(){};\n\n/**\n * Writes s with writer and returns the result.\n */\ncljs.core._write \x3d (function cljs$core$_write(writer,s){\nif((((!((writer \x3d\x3d null)))) \x26\x26 ((!((writer.cljs$core$IWriter$_write$arity$2 \x3d\x3d null)))))){\nreturn writer.cljs$core$IWriter$_write$arity$2(writer,s);\n} else {\nvar x__4433__auto__ \x3d (((writer \x3d\x3d null))?null:writer);\nvar m__4434__auto__ \x3d (cljs.core._write[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(writer,s) : m__4434__auto__.call(null,writer,s));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._write["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(writer,s) : m__4431__auto__.call(null,writer,s));\n} else {\nthrow cljs.core.missing_protocol("IWriter.-write",writer);\n}\n}\n}\n});\n\n/**\n * Flush writer.\n */\ncljs.core._flush \x3d (function cljs$core$_flush(writer){\nif((((!((writer \x3d\x3d null)))) \x26\x26 ((!((writer.cljs$core$IWriter$_flush$arity$1 \x3d\x3d null)))))){\nreturn writer.cljs$core$IWriter$_flush$arity$1(writer);\n} else {\nvar x__4433__auto__ \x3d (((writer \x3d\x3d null))?null:writer);\nvar m__4434__auto__ \x3d (cljs.core._flush[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(writer) : m__4434__auto__.call(null,writer));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._flush["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(writer) : m__4431__auto__.call(null,writer));\n} else {\nthrow cljs.core.missing_protocol("IWriter.-flush",writer);\n}\n}\n}\n});\n\n\n/**\n * The old IPrintable protocol\'s implementation consisted of building a giant\n * list of strings to concatenate.  This involved lots of concat calls,\n * intermediate vectors, and lazy-seqs, and was very slow in some older JS\n * engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n * be implemented efficiently in terms of e.g. a StringBuffer append.\n * @interface\n */\ncljs.core.IPrintWithWriter \x3d function(){};\n\ncljs.core._pr_writer \x3d (function cljs$core$_pr_writer(o,writer,opts){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d\x3d null)))))){\nreturn o.cljs$core$IPrintWithWriter$_pr_writer$arity$3(o,writer,opts);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._pr_writer[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(o,writer,opts) : m__4434__auto__.call(null,o,writer,opts));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._pr_writer["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(o,writer,opts) : m__4431__auto__.call(null,o,writer,opts));\n} else {\nthrow cljs.core.missing_protocol("IPrintWithWriter.-pr-writer",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for types which can have a deferred realization. Currently only\n *   implemented by Delay and LazySeq.\n * @interface\n */\ncljs.core.IPending \x3d function(){};\n\n/**\n * Returns true if a value for x has been produced, false otherwise.\n */\ncljs.core._realized_QMARK_ \x3d (function cljs$core$_realized_QMARK_(x){\nif((((!((x \x3d\x3d null)))) \x26\x26 ((!((x.cljs$core$IPending$_realized_QMARK_$arity$1 \x3d\x3d null)))))){\nreturn x.cljs$core$IPending$_realized_QMARK_$arity$1(x);\n} else {\nvar x__4433__auto__ \x3d (((x \x3d\x3d null))?null:x);\nvar m__4434__auto__ \x3d (cljs.core._realized_QMARK_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._realized_QMARK_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol("IPending.-realized?",x);\n}\n}\n}\n});\n\n\n/**\n * Protocol for types that can be watched. Currently only implemented by Atom.\n * @interface\n */\ncljs.core.IWatchable \x3d function(){};\n\n/**\n * Calls all watchers with this, oldval and newval.\n */\ncljs.core._notify_watches \x3d (function cljs$core$_notify_watches(this$,oldval,newval){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IWatchable$_notify_watches$arity$3 \x3d\x3d null)))))){\nreturn this$.cljs$core$IWatchable$_notify_watches$arity$3(this$,oldval,newval);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._notify_watches[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(this$,oldval,newval) : m__4434__auto__.call(null,this$,oldval,newval));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._notify_watches["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(this$,oldval,newval) : m__4431__auto__.call(null,this$,oldval,newval));\n} else {\nthrow cljs.core.missing_protocol("IWatchable.-notify-watches",this$);\n}\n}\n}\n});\n\n/**\n * Adds a watcher function f to this. Keys must be unique per reference,\n *   and can be used to remove the watch with -remove-watch.\n */\ncljs.core._add_watch \x3d (function cljs$core$_add_watch(this$,key,f){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IWatchable$_add_watch$arity$3 \x3d\x3d null)))))){\nreturn this$.cljs$core$IWatchable$_add_watch$arity$3(this$,key,f);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._add_watch[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(this$,key,f) : m__4434__auto__.call(null,this$,key,f));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._add_watch["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(this$,key,f) : m__4431__auto__.call(null,this$,key,f));\n} else {\nthrow cljs.core.missing_protocol("IWatchable.-add-watch",this$);\n}\n}\n}\n});\n\n/**\n * Removes watcher that corresponds to key from this.\n */\ncljs.core._remove_watch \x3d (function cljs$core$_remove_watch(this$,key){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.cljs$core$IWatchable$_remove_watch$arity$2 \x3d\x3d null)))))){\nreturn this$.cljs$core$IWatchable$_remove_watch$arity$2(this$,key);\n} else {\nvar x__4433__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__4434__auto__ \x3d (cljs.core._remove_watch[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(this$,key) : m__4434__auto__.call(null,this$,key));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._remove_watch["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(this$,key) : m__4431__auto__.call(null,this$,key));\n} else {\nthrow cljs.core.missing_protocol("IWatchable.-remove-watch",this$);\n}\n}\n}\n});\n\n\n/**\n * Protocol for collections which can transformed to transients.\n * @interface\n */\ncljs.core.IEditableCollection \x3d function(){};\n\n/**\n * Returns a new, transient version of the collection, in constant time.\n */\ncljs.core._as_transient \x3d (function cljs$core$_as_transient(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IEditableCollection$_as_transient$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IEditableCollection$_as_transient$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._as_transient[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._as_transient["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IEditableCollection.-as-transient",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding basic functionality to transient collections.\n * @interface\n */\ncljs.core.ITransientCollection \x3d function(){};\n\n/**\n * Adds value val to tcoll and returns tcoll.\n */\ncljs.core._conj_BANG_ \x3d (function cljs$core$_conj_BANG_(tcoll,val){\nif((((!((tcoll \x3d\x3d null)))) \x26\x26 ((!((tcoll.cljs$core$ITransientCollection$_conj_BANG_$arity$2 \x3d\x3d null)))))){\nreturn tcoll.cljs$core$ITransientCollection$_conj_BANG_$arity$2(tcoll,val);\n} else {\nvar x__4433__auto__ \x3d (((tcoll \x3d\x3d null))?null:tcoll);\nvar m__4434__auto__ \x3d (cljs.core._conj_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,val) : m__4434__auto__.call(null,tcoll,val));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._conj_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,val) : m__4431__auto__.call(null,tcoll,val));\n} else {\nthrow cljs.core.missing_protocol("ITransientCollection.-conj!",tcoll);\n}\n}\n}\n});\n\n/**\n * Creates a persistent data structure from tcoll and returns it.\n */\ncljs.core._persistent_BANG_ \x3d (function cljs$core$_persistent_BANG_(tcoll){\nif((((!((tcoll \x3d\x3d null)))) \x26\x26 ((!((tcoll.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 \x3d\x3d null)))))){\nreturn tcoll.cljs$core$ITransientCollection$_persistent_BANG_$arity$1(tcoll);\n} else {\nvar x__4433__auto__ \x3d (((tcoll \x3d\x3d null))?null:tcoll);\nvar m__4434__auto__ \x3d (cljs.core._persistent_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(tcoll) : m__4434__auto__.call(null,tcoll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._persistent_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(tcoll) : m__4431__auto__.call(null,tcoll));\n} else {\nthrow cljs.core.missing_protocol("ITransientCollection.-persistent!",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding associativity to transient collections.\n * @interface\n */\ncljs.core.ITransientAssociative \x3d function(){};\n\n/**\n * Returns a new transient collection of tcoll with a mapping from key to\n *   val added to it.\n */\ncljs.core._assoc_BANG_ \x3d (function cljs$core$_assoc_BANG_(tcoll,key,val){\nif((((!((tcoll \x3d\x3d null)))) \x26\x26 ((!((tcoll.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 \x3d\x3d null)))))){\nreturn tcoll.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3(tcoll,key,val);\n} else {\nvar x__4433__auto__ \x3d (((tcoll \x3d\x3d null))?null:tcoll);\nvar m__4434__auto__ \x3d (cljs.core._assoc_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(tcoll,key,val) : m__4434__auto__.call(null,tcoll,key,val));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._assoc_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(tcoll,key,val) : m__4431__auto__.call(null,tcoll,key,val));\n} else {\nthrow cljs.core.missing_protocol("ITransientAssociative.-assoc!",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding mapping functionality to transient collections.\n * @interface\n */\ncljs.core.ITransientMap \x3d function(){};\n\n/**\n * Returns a new transient collection of tcoll without the mapping for key.\n */\ncljs.core._dissoc_BANG_ \x3d (function cljs$core$_dissoc_BANG_(tcoll,key){\nif((((!((tcoll \x3d\x3d null)))) \x26\x26 ((!((tcoll.cljs$core$ITransientMap$_dissoc_BANG_$arity$2 \x3d\x3d null)))))){\nreturn tcoll.cljs$core$ITransientMap$_dissoc_BANG_$arity$2(tcoll,key);\n} else {\nvar x__4433__auto__ \x3d (((tcoll \x3d\x3d null))?null:tcoll);\nvar m__4434__auto__ \x3d (cljs.core._dissoc_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,key) : m__4434__auto__.call(null,tcoll,key));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._dissoc_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,key) : m__4431__auto__.call(null,tcoll,key));\n} else {\nthrow cljs.core.missing_protocol("ITransientMap.-dissoc!",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding vector functionality to transient collections.\n * @interface\n */\ncljs.core.ITransientVector \x3d function(){};\n\n/**\n * Returns tcoll with value val added at position n.\n */\ncljs.core._assoc_n_BANG_ \x3d (function cljs$core$_assoc_n_BANG_(tcoll,n,val){\nif((((!((tcoll \x3d\x3d null)))) \x26\x26 ((!((tcoll.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3 \x3d\x3d null)))))){\nreturn tcoll.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3(tcoll,n,val);\n} else {\nvar x__4433__auto__ \x3d (((tcoll \x3d\x3d null))?null:tcoll);\nvar m__4434__auto__ \x3d (cljs.core._assoc_n_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(tcoll,n,val) : m__4434__auto__.call(null,tcoll,n,val));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._assoc_n_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(tcoll,n,val) : m__4431__auto__.call(null,tcoll,n,val));\n} else {\nthrow cljs.core.missing_protocol("ITransientVector.-assoc-n!",tcoll);\n}\n}\n}\n});\n\n/**\n * Returns tcoll with the last item removed from it.\n */\ncljs.core._pop_BANG_ \x3d (function cljs$core$_pop_BANG_(tcoll){\nif((((!((tcoll \x3d\x3d null)))) \x26\x26 ((!((tcoll.cljs$core$ITransientVector$_pop_BANG_$arity$1 \x3d\x3d null)))))){\nreturn tcoll.cljs$core$ITransientVector$_pop_BANG_$arity$1(tcoll);\n} else {\nvar x__4433__auto__ \x3d (((tcoll \x3d\x3d null))?null:tcoll);\nvar m__4434__auto__ \x3d (cljs.core._pop_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(tcoll) : m__4434__auto__.call(null,tcoll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._pop_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(tcoll) : m__4431__auto__.call(null,tcoll));\n} else {\nthrow cljs.core.missing_protocol("ITransientVector.-pop!",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding set functionality to a transient collection.\n * @interface\n */\ncljs.core.ITransientSet \x3d function(){};\n\n/**\n * Returns tcoll without v.\n */\ncljs.core._disjoin_BANG_ \x3d (function cljs$core$_disjoin_BANG_(tcoll,v){\nif((((!((tcoll \x3d\x3d null)))) \x26\x26 ((!((tcoll.cljs$core$ITransientSet$_disjoin_BANG_$arity$2 \x3d\x3d null)))))){\nreturn tcoll.cljs$core$ITransientSet$_disjoin_BANG_$arity$2(tcoll,v);\n} else {\nvar x__4433__auto__ \x3d (((tcoll \x3d\x3d null))?null:tcoll);\nvar m__4434__auto__ \x3d (cljs.core._disjoin_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,v) : m__4434__auto__.call(null,tcoll,v));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._disjoin_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,v) : m__4431__auto__.call(null,tcoll,v));\n} else {\nthrow cljs.core.missing_protocol("ITransientSet.-disjoin!",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for values that can be compared.\n * @interface\n */\ncljs.core.IComparable \x3d function(){};\n\n/**\n * Returns a negative number, zero, or a positive number when x is logically\n *   \'less than\', \'equal to\', or \'greater than\' y.\n */\ncljs.core._compare \x3d (function cljs$core$_compare(x,y){\nif((((!((x \x3d\x3d null)))) \x26\x26 ((!((x.cljs$core$IComparable$_compare$arity$2 \x3d\x3d null)))))){\nreturn x.cljs$core$IComparable$_compare$arity$2(x,y);\n} else {\nvar x__4433__auto__ \x3d (((x \x3d\x3d null))?null:x);\nvar m__4434__auto__ \x3d (cljs.core._compare[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(x,y) : m__4434__auto__.call(null,x,y));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._compare["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(x,y) : m__4431__auto__.call(null,x,y));\n} else {\nthrow cljs.core.missing_protocol("IComparable.-compare",x);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing the items of a chunk.\n * @interface\n */\ncljs.core.IChunk \x3d function(){};\n\n/**\n * Return a new chunk of coll with the first item removed.\n */\ncljs.core._drop_first \x3d (function cljs$core$_drop_first(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IChunk$_drop_first$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IChunk$_drop_first$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._drop_first[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._drop_first["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IChunk.-drop-first",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing a collection as sequential chunks.\n * @interface\n */\ncljs.core.IChunkedSeq \x3d function(){};\n\n/**\n * Returns the first chunk in coll.\n */\ncljs.core._chunked_first \x3d (function cljs$core$_chunked_first(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IChunkedSeq$_chunked_first$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IChunkedSeq$_chunked_first$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._chunked_first[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._chunked_first["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IChunkedSeq.-chunked-first",coll);\n}\n}\n}\n});\n\n/**\n * Return a new collection of coll with the first chunk removed.\n */\ncljs.core._chunked_rest \x3d (function cljs$core$_chunked_rest(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IChunkedSeq$_chunked_rest$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IChunkedSeq$_chunked_rest$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._chunked_rest[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._chunked_rest["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IChunkedSeq.-chunked-rest",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing the chunks of a collection.\n * @interface\n */\ncljs.core.IChunkedNext \x3d function(){};\n\n/**\n * Returns a new collection of coll without the first chunk.\n */\ncljs.core._chunked_next \x3d (function cljs$core$_chunked_next(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IChunkedNext$_chunked_next$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IChunkedNext$_chunked_next$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._chunked_next[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._chunked_next["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IChunkedNext.-chunked-next",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding a name.\n * @interface\n */\ncljs.core.INamed \x3d function(){};\n\n/**\n * Returns the name String of x.\n */\ncljs.core._name \x3d (function cljs$core$_name(x){\nif((((!((x \x3d\x3d null)))) \x26\x26 ((!((x.cljs$core$INamed$_name$arity$1 \x3d\x3d null)))))){\nreturn x.cljs$core$INamed$_name$arity$1(x);\n} else {\nvar x__4433__auto__ \x3d (((x \x3d\x3d null))?null:x);\nvar m__4434__auto__ \x3d (cljs.core._name[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._name["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol("INamed.-name",x);\n}\n}\n}\n});\n\n/**\n * Returns the namespace String of x.\n */\ncljs.core._namespace \x3d (function cljs$core$_namespace(x){\nif((((!((x \x3d\x3d null)))) \x26\x26 ((!((x.cljs$core$INamed$_namespace$arity$1 \x3d\x3d null)))))){\nreturn x.cljs$core$INamed$_namespace$arity$1(x);\n} else {\nvar x__4433__auto__ \x3d (((x \x3d\x3d null))?null:x);\nvar m__4434__auto__ \x3d (cljs.core._namespace[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._namespace["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol("INamed.-namespace",x);\n}\n}\n}\n});\n\n\n/**\n * Marker protocol indicating an atom.\n * @interface\n */\ncljs.core.IAtom \x3d function(){};\n\n\n/**\n * Protocol for adding resetting functionality.\n * @interface\n */\ncljs.core.IReset \x3d function(){};\n\n/**\n * Sets the value of o to new-value.\n */\ncljs.core._reset_BANG_ \x3d (function cljs$core$_reset_BANG_(o,new_value){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$IReset$_reset_BANG_$arity$2 \x3d\x3d null)))))){\nreturn o.cljs$core$IReset$_reset_BANG_$arity$2(o,new_value);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._reset_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,new_value) : m__4434__auto__.call(null,o,new_value));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._reset_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,new_value) : m__4431__auto__.call(null,o,new_value));\n} else {\nthrow cljs.core.missing_protocol("IReset.-reset!",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding swapping functionality.\n * @interface\n */\ncljs.core.ISwap \x3d function(){};\n\n/**\n * Swaps the value of o to be (apply f current-value-of-atom args).\n */\ncljs.core._swap_BANG_ \x3d (function cljs$core$_swap_BANG_(var_args){\nvar G__9385 \x3d arguments.length;\nswitch (G__9385) {\ncase 2:\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$2 \x3d (function (o,f){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$ISwap$_swap_BANG_$arity$2 \x3d\x3d null)))))){\nreturn o.cljs$core$ISwap$_swap_BANG_$arity$2(o,f);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._swap_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,f) : m__4434__auto__.call(null,o,f));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._swap_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,f) : m__4431__auto__.call(null,o,f));\n} else {\nthrow cljs.core.missing_protocol("ISwap.-swap!",o);\n}\n}\n}\n});\n\ncljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$3 \x3d (function (o,f,a){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$ISwap$_swap_BANG_$arity$3 \x3d\x3d null)))))){\nreturn o.cljs$core$ISwap$_swap_BANG_$arity$3(o,f,a);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._swap_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(o,f,a) : m__4434__auto__.call(null,o,f,a));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._swap_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(o,f,a) : m__4431__auto__.call(null,o,f,a));\n} else {\nthrow cljs.core.missing_protocol("ISwap.-swap!",o);\n}\n}\n}\n});\n\ncljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$4 \x3d (function (o,f,a,b){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$ISwap$_swap_BANG_$arity$4 \x3d\x3d null)))))){\nreturn o.cljs$core$ISwap$_swap_BANG_$arity$4(o,f,a,b);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._swap_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$4(o,f,a,b) : m__4434__auto__.call(null,o,f,a,b));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._swap_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$4(o,f,a,b) : m__4431__auto__.call(null,o,f,a,b));\n} else {\nthrow cljs.core.missing_protocol("ISwap.-swap!",o);\n}\n}\n}\n});\n\ncljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$5 \x3d (function (o,f,a,b,xs){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$ISwap$_swap_BANG_$arity$5 \x3d\x3d null)))))){\nreturn o.cljs$core$ISwap$_swap_BANG_$arity$5(o,f,a,b,xs);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._swap_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$5 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$5(o,f,a,b,xs) : m__4434__auto__.call(null,o,f,a,b,xs));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._swap_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$5 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$5(o,f,a,b,xs) : m__4431__auto__.call(null,o,f,a,b,xs));\n} else {\nthrow cljs.core.missing_protocol("ISwap.-swap!",o);\n}\n}\n}\n});\n\ncljs.core._swap_BANG_.cljs$lang$maxFixedArity \x3d 5;\n\n\n\n/**\n * Protocol for adding volatile functionality.\n * @interface\n */\ncljs.core.IVolatile \x3d function(){};\n\n/**\n * Sets the value of volatile o to new-value without regard for the\n *   current value. Returns new-value.\n */\ncljs.core._vreset_BANG_ \x3d (function cljs$core$_vreset_BANG_(o,new_value){\nif((((!((o \x3d\x3d null)))) \x26\x26 ((!((o.cljs$core$IVolatile$_vreset_BANG_$arity$2 \x3d\x3d null)))))){\nreturn o.cljs$core$IVolatile$_vreset_BANG_$arity$2(o,new_value);\n} else {\nvar x__4433__auto__ \x3d (((o \x3d\x3d null))?null:o);\nvar m__4434__auto__ \x3d (cljs.core._vreset_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,new_value) : m__4434__auto__.call(null,o,new_value));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._vreset_BANG_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,new_value) : m__4431__auto__.call(null,o,new_value));\n} else {\nthrow cljs.core.missing_protocol("IVolatile.-vreset!",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for iterating over a collection.\n * @interface\n */\ncljs.core.IIterable \x3d function(){};\n\n/**\n * Returns an iterator for coll.\n */\ncljs.core._iterator \x3d (function cljs$core$_iterator(coll){\nif((((!((coll \x3d\x3d null)))) \x26\x26 ((!((coll.cljs$core$IIterable$_iterator$arity$1 \x3d\x3d null)))))){\nreturn coll.cljs$core$IIterable$_iterator$arity$1(coll);\n} else {\nvar x__4433__auto__ \x3d (((coll \x3d\x3d null))?null:coll);\nvar m__4434__auto__ \x3d (cljs.core._iterator[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._iterator["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol("IIterable.-iterator",coll);\n}\n}\n}\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IWriter}\n*/\ncljs.core.StringBufferWriter \x3d (function (sb){\nthis.sb \x3d sb;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 1073741824;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.StringBufferWriter.prototype.cljs$core$IWriter$_write$arity$2 \x3d (function (_,s){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.sb.append(s);\n});\n\ncljs.core.StringBufferWriter.prototype.cljs$core$IWriter$_flush$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn null;\n});\n\ncljs.core.StringBufferWriter.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$sb], null);\n});\n\ncljs.core.StringBufferWriter.cljs$lang$type \x3d true;\n\ncljs.core.StringBufferWriter.cljs$lang$ctorStr \x3d "cljs.core/StringBufferWriter";\n\ncljs.core.StringBufferWriter.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/StringBufferWriter");\n});\n\n/**\n * Positional factory function for cljs.core/StringBufferWriter.\n */\ncljs.core.__GT_StringBufferWriter \x3d (function cljs$core$__GT_StringBufferWriter(sb){\nreturn (new cljs.core.StringBufferWriter(sb));\n});\n\n/**\n * Support so that collections can implement toString without\n * loading all the printing machinery.\n */\ncljs.core.pr_str_STAR_ \x3d (function cljs$core$pr_str_STAR_(obj){\nvar sb \x3d (new goog.string.StringBuffer());\nvar writer \x3d (new cljs.core.StringBufferWriter(sb));\nobj.cljs$core$IPrintWithWriter$_pr_writer$arity$3(null,writer,cljs.core.pr_opts());\n\nwriter.cljs$core$IWriter$_flush$arity$1(null);\n\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(sb);\n});\ncljs.core.int_rotate_left \x3d (function cljs$core$int_rotate_left(x,n){\nreturn ((x \x3c\x3c n) | (x \x3e\x3e\x3e (- n)));\n});\nif((((typeof Math !\x3d\x3d \'undefined\') \x26\x26 (typeof Math.imul !\x3d\x3d \'undefined\')) \x26\x26 ((!((Math.imul((4294967295),(5)) \x3d\x3d\x3d (0))))))){\ncljs.core.imul \x3d (function cljs$core$imul(a,b){\nreturn Math.imul(a,b);\n});\n} else {\ncljs.core.imul \x3d (function cljs$core$imul(a,b){\nvar ah \x3d ((a \x3e\x3e\x3e (16)) \x26 (65535));\nvar al \x3d (a \x26 (65535));\nvar bh \x3d ((b \x3e\x3e\x3e (16)) \x26 (65535));\nvar bl \x3d (b \x26 (65535));\nreturn (((al * bl) + ((((ah * bl) + (al * bh)) \x3c\x3c (16)) \x3e\x3e\x3e (0))) | (0));\n});\n}\ncljs.core.m3_seed \x3d (0);\ncljs.core.m3_C1 \x3d ((3432918353) | (0));\ncljs.core.m3_C2 \x3d ((461845907) | (0));\ncljs.core.m3_mix_K1 \x3d (function cljs$core$m3_mix_K1(k1){\nreturn cljs.core.imul(cljs.core.int_rotate_left(cljs.core.imul((k1 | (0)),cljs.core.m3_C1),(15)),cljs.core.m3_C2);\n});\ncljs.core.m3_mix_H1 \x3d (function cljs$core$m3_mix_H1(h1,k1){\nreturn ((cljs.core.imul(cljs.core.int_rotate_left(((h1 | (0)) ^ (k1 | (0))),(13)),(5)) + ((3864292196) | (0))) | (0));\n});\ncljs.core.m3_fmix \x3d (function cljs$core$m3_fmix(h1,len){\nvar h1__$1 \x3d (h1 | (0));\nvar h1__$2 \x3d (h1__$1 ^ len);\nvar h1__$3 \x3d (h1__$2 ^ (h1__$2 \x3e\x3e\x3e (16)));\nvar h1__$4 \x3d cljs.core.imul(h1__$3,((2246822507) | (0)));\nvar h1__$5 \x3d (h1__$4 ^ (h1__$4 \x3e\x3e\x3e (13)));\nvar h1__$6 \x3d cljs.core.imul(h1__$5,((3266489909) | (0)));\nreturn (h1__$6 ^ (h1__$6 \x3e\x3e\x3e (16)));\n});\ncljs.core.m3_hash_int \x3d (function cljs$core$m3_hash_int(in$){\nif((in$ \x3d\x3d\x3d (0))){\nreturn in$;\n} else {\nvar k1 \x3d cljs.core.m3_mix_K1(in$);\nvar h1 \x3d cljs.core.m3_mix_H1(cljs.core.m3_seed,k1);\nreturn cljs.core.m3_fmix(h1,(4));\n}\n});\ncljs.core.m3_hash_unencoded_chars \x3d (function cljs$core$m3_hash_unencoded_chars(in$){\nvar h1 \x3d (function (){var i \x3d (1);\nvar h1 \x3d cljs.core.m3_seed;\nwhile(true){\nif((i \x3c in$.length)){\nvar G__9387 \x3d (i + (2));\nvar G__9388 \x3d cljs.core.m3_mix_H1(h1,cljs.core.m3_mix_K1((in$.charCodeAt((i - (1))) | (in$.charCodeAt(i) \x3c\x3c (16)))));\ni \x3d G__9387;\nh1 \x3d G__9388;\ncontinue;\n} else {\nreturn h1;\n}\nbreak;\n}\n})();\nvar h1__$1 \x3d ((((in$.length \x26 (1)) \x3d\x3d\x3d (1)))?(h1 ^ cljs.core.m3_mix_K1(in$.charCodeAt((in$.length - (1))))):h1);\nreturn cljs.core.m3_fmix(h1__$1,cljs.core.imul((2),in$.length));\n});\n\n\n\ncljs.core.string_hash_cache \x3d ({});\ncljs.core.string_hash_cache_count \x3d (0);\ncljs.core.hash_string_STAR_ \x3d (function cljs$core$hash_string_STAR_(s){\nif((!((s \x3d\x3d null)))){\nvar len \x3d s.length;\nif((len \x3e (0))){\nvar i \x3d (0);\nvar hash \x3d (0);\nwhile(true){\nif((i \x3c len)){\nvar G__9391 \x3d (i + (1));\nvar G__9392 \x3d (cljs.core.imul((31),hash) + s.charCodeAt(i));\ni \x3d G__9391;\nhash \x3d G__9392;\ncontinue;\n} else {\nreturn hash;\n}\nbreak;\n}\n} else {\nreturn (0);\n}\n} else {\nreturn (0);\n}\n});\ncljs.core.add_to_string_hash_cache \x3d (function cljs$core$add_to_string_hash_cache(k){\nvar h \x3d cljs.core.hash_string_STAR_(k);\ngoog.object.set(cljs.core.string_hash_cache,k,h);\n\ncljs.core.string_hash_cache_count \x3d (cljs.core.string_hash_cache_count + (1));\n\nreturn h;\n});\ncljs.core.hash_string \x3d (function cljs$core$hash_string(k){\nif((cljs.core.string_hash_cache_count \x3e (255))){\ncljs.core.string_hash_cache \x3d ({});\n\ncljs.core.string_hash_cache_count \x3d (0);\n} else {\n}\n\nif((k \x3d\x3d null)){\nreturn (0);\n} else {\nvar h \x3d (cljs.core.string_hash_cache[k]);\nif(typeof h \x3d\x3d\x3d \'number\'){\nreturn h;\n} else {\nreturn cljs.core.add_to_string_hash_cache(k);\n}\n}\n});\n/**\n * Returns the hash code of its argument. Note this is the hash code\n * consistent with \x3d.\n */\ncljs.core.hash \x3d (function cljs$core$hash(o){\nif((((!((o \x3d\x3d null))))?(((((o.cljs$lang$protocol_mask$partition0$ \x26 (4194304))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d o.cljs$core$IHash$))))?true:false):false)){\nreturn (cljs.core._hash(o) ^ (0));\n} else {\nif(typeof o \x3d\x3d\x3d \'number\'){\nif(cljs.core.truth_(isFinite(o))){\nreturn (Math.floor(o) % (2147483647));\n} else {\nvar G__9396 \x3d o;\nswitch (G__9396) {\ncase Infinity:\nreturn (2146435072);\n\nbreak;\ncase -Infinity:\nreturn (-1048576);\n\nbreak;\ndefault:\nreturn (2146959360);\n\n}\n}\n} else {\nif(o \x3d\x3d\x3d true){\nreturn (1231);\n} else {\nif(o \x3d\x3d\x3d false){\nreturn (1237);\n} else {\nif(typeof o \x3d\x3d\x3d \'string\'){\nreturn cljs.core.m3_hash_int(cljs.core.hash_string(o));\n} else {\nif((o instanceof Date)){\nreturn (o.valueOf() ^ (0));\n} else {\nif((o \x3d\x3d null)){\nreturn (0);\n} else {\nreturn (cljs.core._hash(o) ^ (0));\n\n}\n}\n}\n}\n}\n}\n}\n});\ncljs.core.hash_combine \x3d (function cljs$core$hash_combine(seed,hash){\nreturn (seed ^ (((hash + (2654435769)) + (seed \x3c\x3c (6))) + (seed \x3e\x3e (2))));\n});\n/**\n * Evaluates x and tests if it is an instance of the type\n *   c. Returns true or false\n */\ncljs.core.instance_QMARK_ \x3d (function cljs$core$instance_QMARK_(c,x){\nreturn (x instanceof c);\n});\n/**\n * Return true if x is a Symbol\n */\ncljs.core.symbol_QMARK_ \x3d (function cljs$core$symbol_QMARK_(x){\nreturn (x instanceof cljs.core.Symbol);\n});\ncljs.core.hash_symbol \x3d (function cljs$core$hash_symbol(sym){\nreturn cljs.core.hash_combine(cljs.core.m3_hash_unencoded_chars(sym.name),cljs.core.hash_string(sym.ns));\n});\ncljs.core.compare_symbols \x3d (function cljs$core$compare_symbols(a,b){\nif((a.str \x3d\x3d\x3d b.str)){\nreturn (0);\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ \x3d cljs.core.not(a.ns);\nif(and__4120__auto__){\nreturn b.ns;\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn (-1);\n} else {\nif(cljs.core.truth_(a.ns)){\nif(cljs.core.not(b.ns)){\nreturn (1);\n} else {\nvar nsc \x3d (function (){var G__9398 \x3d a.ns;\nvar G__9399 \x3d b.ns;\nreturn goog.array.defaultCompare(G__9398,G__9399);\n})();\nif(((0) \x3d\x3d\x3d nsc)){\nvar G__9400 \x3d a.name;\nvar G__9401 \x3d b.name;\nreturn goog.array.defaultCompare(G__9400,G__9401);\n} else {\nreturn nsc;\n}\n}\n} else {\nvar G__9402 \x3d a.name;\nvar G__9403 \x3d b.name;\nreturn goog.array.defaultCompare(G__9402,G__9403);\n\n}\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.INamed}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.Symbol \x3d (function (ns,name,str,_hash,_meta){\nthis.ns \x3d ns;\nthis.name \x3d name;\nthis.str \x3d str;\nthis._hash \x3d _hash;\nthis._meta \x3d _meta;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 2154168321;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 4096;\n});\ncljs.core.Symbol.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn self__.str;\n});\n\ncljs.core.Symbol.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Symbol.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (_,other){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nif((other instanceof cljs.core.Symbol)){\nreturn (self__.str \x3d\x3d\x3d other.str);\n} else {\nreturn false;\n}\n});\n\ncljs.core.Symbol.prototype.call \x3d (function() {\nvar G__9405 \x3d null;\nvar G__9405__2 \x3d (function (self__,coll){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar sym \x3d self____$1;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,sym);\n});\nvar G__9405__3 \x3d (function (self__,coll,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar sym \x3d self____$1;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,sym,not_found);\n});\nG__9405 \x3d function(self__,coll,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__9405__2.call(this,self__,coll);\ncase 3:\nreturn G__9405__3.call(this,self__,coll,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__9405.cljs$core$IFn$_invoke$arity$2 \x3d G__9405__2;\nG__9405.cljs$core$IFn$_invoke$arity$3 \x3d G__9405__3;\nreturn G__9405;\n})()\n;\n\ncljs.core.Symbol.prototype.apply \x3d (function (self__,args9404){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args9404)));\n});\n\ncljs.core.Symbol.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar sym \x3d this;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,sym);\n});\n\ncljs.core.Symbol.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,not_found){\nvar self__ \x3d this;\nvar sym \x3d this;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,sym,not_found);\n});\n\ncljs.core.Symbol.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__._meta;\n});\n\ncljs.core.Symbol.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (_,new_meta){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.Symbol(self__.ns,self__.name,self__.str,self__._hash,new_meta));\n});\n\ncljs.core.Symbol.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (sym){\nvar self__ \x3d this;\nvar sym__$1 \x3d this;\nvar h__4243__auto__ \x3d self__._hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_symbol(sym__$1);\nself__._hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Symbol.prototype.cljs$core$INamed$_name$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.name;\n});\n\ncljs.core.Symbol.prototype.cljs$core$INamed$_namespace$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.ns;\n});\n\ncljs.core.Symbol.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (o,writer,_){\nvar self__ \x3d this;\nvar o__$1 \x3d this;\nreturn cljs.core._write(writer,self__.str);\n});\n\ncljs.core.Symbol.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$ns,cljs.core.cst$sym$name,cljs.core.cst$sym$str,cljs.core.with_meta(cljs.core.cst$sym$_hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.cst$sym$_meta], null);\n});\n\ncljs.core.Symbol.cljs$lang$type \x3d true;\n\ncljs.core.Symbol.cljs$lang$ctorStr \x3d "cljs.core/Symbol";\n\ncljs.core.Symbol.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Symbol");\n});\n\n/**\n * Positional factory function for cljs.core/Symbol.\n */\ncljs.core.__GT_Symbol \x3d (function cljs$core$__GT_Symbol(ns,name,str,_hash,_meta){\nreturn (new cljs.core.Symbol(ns,name,str,_hash,_meta));\n});\n\n/**\n * Returns true if v is of type cljs.core.Var\n */\ncljs.core.var_QMARK_ \x3d (function cljs$core$var_QMARK_(v){\nreturn (v instanceof cljs.core.Var);\n});\n/**\n * Returns a Symbol with the given namespace and name. Arity-1 works\n *   on strings, keywords, and vars.\n */\ncljs.core.symbol \x3d (function cljs$core$symbol(var_args){\nvar G__9407 \x3d arguments.length;\nswitch (G__9407) {\ncase 1:\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.symbol.cljs$core$IFn$_invoke$arity$1 \x3d (function (name){\nwhile(true){\nif((name instanceof cljs.core.Symbol)){\nreturn name;\n} else {\nif(typeof name \x3d\x3d\x3d \'string\'){\nvar idx \x3d name.indexOf("/");\nif((idx \x3c (1))){\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(null,name);\n} else {\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(name.substring((0),idx),name.substring((idx + (1)),name.length));\n}\n} else {\nif(cljs.core.var_QMARK_(name)){\nreturn name.sym;\n} else {\nif((name instanceof cljs.core.Keyword)){\nvar G__9409 \x3d name.fqn;\nname \x3d G__9409;\ncontinue;\n} else {\nthrow (new Error("no conversion to symbol"));\n\n}\n}\n}\n}\nbreak;\n}\n});\n\ncljs.core.symbol.cljs$core$IFn$_invoke$arity$2 \x3d (function (ns,name){\nvar sym_str \x3d (((!((ns \x3d\x3d null))))?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns),"/",cljs.core.str.cljs$core$IFn$_invoke$arity$1(name)].join(\'\'):name);\nreturn (new cljs.core.Symbol(ns,name,sym_str,null,null));\n});\n\ncljs.core.symbol.cljs$lang$maxFixedArity \x3d 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.Fn}\n * @implements {cljs.core.IDeref}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.Var \x3d (function (val,sym,_meta){\nthis.val \x3d val;\nthis.sym \x3d sym;\nthis._meta \x3d _meta;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 6717441;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.Var.prototype.isMacro \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null)).cljs$lang$macro;\n});\n\ncljs.core.Var.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn ["#\'",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.sym)].join(\'\');\n});\n\ncljs.core.Var.prototype.cljs$core$IDeref$_deref$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\n});\n\ncljs.core.Var.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__._meta;\n});\n\ncljs.core.Var.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (_,new_meta){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.Var(self__.val,self__.sym,new_meta));\n});\n\ncljs.core.Var.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (this$,other){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nif((other instanceof cljs.core.Var)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this$__$1.sym,other.sym);\n} else {\nreturn false;\n}\n});\n\ncljs.core.Var.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn cljs.core.hash_symbol(self__.sym);\n});\n\ncljs.core.Var.prototype.cljs$core$Fn$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Var.prototype.call \x3d (function() {\nvar G__9453 \x3d null;\nvar G__9453__1 \x3d (function (self__){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9411 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9411.cljs$core$IFn$_invoke$arity$0 ? fexpr__9411.cljs$core$IFn$_invoke$arity$0() : fexpr__9411.call(null));\n});\nvar G__9453__2 \x3d (function (self__,a){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9412 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9412.cljs$core$IFn$_invoke$arity$1 ? fexpr__9412.cljs$core$IFn$_invoke$arity$1(a) : fexpr__9412.call(null,a));\n});\nvar G__9453__3 \x3d (function (self__,a,b){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9413 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9413.cljs$core$IFn$_invoke$arity$2 ? fexpr__9413.cljs$core$IFn$_invoke$arity$2(a,b) : fexpr__9413.call(null,a,b));\n});\nvar G__9453__4 \x3d (function (self__,a,b,c){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9414 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9414.cljs$core$IFn$_invoke$arity$3 ? fexpr__9414.cljs$core$IFn$_invoke$arity$3(a,b,c) : fexpr__9414.call(null,a,b,c));\n});\nvar G__9453__5 \x3d (function (self__,a,b,c,d){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9415 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9415.cljs$core$IFn$_invoke$arity$4 ? fexpr__9415.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : fexpr__9415.call(null,a,b,c,d));\n});\nvar G__9453__6 \x3d (function (self__,a,b,c,d,e){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9416 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9416.cljs$core$IFn$_invoke$arity$5 ? fexpr__9416.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : fexpr__9416.call(null,a,b,c,d,e));\n});\nvar G__9453__7 \x3d (function (self__,a,b,c,d,e,f){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9417 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9417.cljs$core$IFn$_invoke$arity$6 ? fexpr__9417.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : fexpr__9417.call(null,a,b,c,d,e,f));\n});\nvar G__9453__8 \x3d (function (self__,a,b,c,d,e,f,g){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9418 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9418.cljs$core$IFn$_invoke$arity$7 ? fexpr__9418.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : fexpr__9418.call(null,a,b,c,d,e,f,g));\n});\nvar G__9453__9 \x3d (function (self__,a,b,c,d,e,f,g,h){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9419 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9419.cljs$core$IFn$_invoke$arity$8 ? fexpr__9419.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : fexpr__9419.call(null,a,b,c,d,e,f,g,h));\n});\nvar G__9453__10 \x3d (function (self__,a,b,c,d,e,f,g,h,i){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9420 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9420.cljs$core$IFn$_invoke$arity$9 ? fexpr__9420.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : fexpr__9420.call(null,a,b,c,d,e,f,g,h,i));\n});\nvar G__9453__11 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9421 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9421.cljs$core$IFn$_invoke$arity$10 ? fexpr__9421.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : fexpr__9421.call(null,a,b,c,d,e,f,g,h,i,j));\n});\nvar G__9453__12 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9422 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9422.cljs$core$IFn$_invoke$arity$11 ? fexpr__9422.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : fexpr__9422.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\nvar G__9453__13 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9423 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9423.cljs$core$IFn$_invoke$arity$12 ? fexpr__9423.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : fexpr__9423.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\nvar G__9453__14 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9424 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9424.cljs$core$IFn$_invoke$arity$13 ? fexpr__9424.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : fexpr__9424.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\nvar G__9453__15 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9425 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9425.cljs$core$IFn$_invoke$arity$14 ? fexpr__9425.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : fexpr__9425.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\nvar G__9453__16 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9426 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9426.cljs$core$IFn$_invoke$arity$15 ? fexpr__9426.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : fexpr__9426.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\nvar G__9453__17 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9427 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9427.cljs$core$IFn$_invoke$arity$16 ? fexpr__9427.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : fexpr__9427.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\nvar G__9453__18 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9428 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9428.cljs$core$IFn$_invoke$arity$17 ? fexpr__9428.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : fexpr__9428.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\nvar G__9453__19 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9429 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9429.cljs$core$IFn$_invoke$arity$18 ? fexpr__9429.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : fexpr__9429.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\nvar G__9453__20 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9430 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9430.cljs$core$IFn$_invoke$arity$19 ? fexpr__9430.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : fexpr__9430.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\nvar G__9453__21 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nvar fexpr__9431 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9431.cljs$core$IFn$_invoke$arity$20 ? fexpr__9431.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : fexpr__9431.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\nvar G__9453__22 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic((self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null)),a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\nG__9453 \x3d function(self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nswitch(arguments.length){\ncase 1:\nreturn G__9453__1.call(this,self__);\ncase 2:\nreturn G__9453__2.call(this,self__,a);\ncase 3:\nreturn G__9453__3.call(this,self__,a,b);\ncase 4:\nreturn G__9453__4.call(this,self__,a,b,c);\ncase 5:\nreturn G__9453__5.call(this,self__,a,b,c,d);\ncase 6:\nreturn G__9453__6.call(this,self__,a,b,c,d,e);\ncase 7:\nreturn G__9453__7.call(this,self__,a,b,c,d,e,f);\ncase 8:\nreturn G__9453__8.call(this,self__,a,b,c,d,e,f,g);\ncase 9:\nreturn G__9453__9.call(this,self__,a,b,c,d,e,f,g,h);\ncase 10:\nreturn G__9453__10.call(this,self__,a,b,c,d,e,f,g,h,i);\ncase 11:\nreturn G__9453__11.call(this,self__,a,b,c,d,e,f,g,h,i,j);\ncase 12:\nreturn G__9453__12.call(this,self__,a,b,c,d,e,f,g,h,i,j,k);\ncase 13:\nreturn G__9453__13.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l);\ncase 14:\nreturn G__9453__14.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m);\ncase 15:\nreturn G__9453__15.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n);\ncase 16:\nreturn G__9453__16.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);\ncase 17:\nreturn G__9453__17.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);\ncase 18:\nreturn G__9453__18.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);\ncase 19:\nreturn G__9453__19.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r);\ncase 20:\nreturn G__9453__20.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s);\ncase 21:\nreturn G__9453__21.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t);\ncase 22:\nreturn G__9453__22.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__9453.cljs$core$IFn$_invoke$arity$1 \x3d G__9453__1;\nG__9453.cljs$core$IFn$_invoke$arity$2 \x3d G__9453__2;\nG__9453.cljs$core$IFn$_invoke$arity$3 \x3d G__9453__3;\nG__9453.cljs$core$IFn$_invoke$arity$4 \x3d G__9453__4;\nG__9453.cljs$core$IFn$_invoke$arity$5 \x3d G__9453__5;\nG__9453.cljs$core$IFn$_invoke$arity$6 \x3d G__9453__6;\nG__9453.cljs$core$IFn$_invoke$arity$7 \x3d G__9453__7;\nG__9453.cljs$core$IFn$_invoke$arity$8 \x3d G__9453__8;\nG__9453.cljs$core$IFn$_invoke$arity$9 \x3d G__9453__9;\nG__9453.cljs$core$IFn$_invoke$arity$10 \x3d G__9453__10;\nG__9453.cljs$core$IFn$_invoke$arity$11 \x3d G__9453__11;\nG__9453.cljs$core$IFn$_invoke$arity$12 \x3d G__9453__12;\nG__9453.cljs$core$IFn$_invoke$arity$13 \x3d G__9453__13;\nG__9453.cljs$core$IFn$_invoke$arity$14 \x3d G__9453__14;\nG__9453.cljs$core$IFn$_invoke$arity$15 \x3d G__9453__15;\nG__9453.cljs$core$IFn$_invoke$arity$16 \x3d G__9453__16;\nG__9453.cljs$core$IFn$_invoke$arity$17 \x3d G__9453__17;\nG__9453.cljs$core$IFn$_invoke$arity$18 \x3d G__9453__18;\nG__9453.cljs$core$IFn$_invoke$arity$19 \x3d G__9453__19;\nG__9453.cljs$core$IFn$_invoke$arity$20 \x3d G__9453__20;\nG__9453.cljs$core$IFn$_invoke$arity$21 \x3d G__9453__21;\nG__9453.cljs$core$IFn$_invoke$arity$22 \x3d G__9453__22;\nreturn G__9453;\n})()\n;\n\ncljs.core.Var.prototype.apply \x3d (function (self__,args9410){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args9410)));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9432 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9432.cljs$core$IFn$_invoke$arity$0 ? fexpr__9432.cljs$core$IFn$_invoke$arity$0() : fexpr__9432.call(null));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (a){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9433 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9433.cljs$core$IFn$_invoke$arity$1 ? fexpr__9433.cljs$core$IFn$_invoke$arity$1(a) : fexpr__9433.call(null,a));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (a,b){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9434 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9434.cljs$core$IFn$_invoke$arity$2 ? fexpr__9434.cljs$core$IFn$_invoke$arity$2(a,b) : fexpr__9434.call(null,a,b));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$3 \x3d (function (a,b,c){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9435 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9435.cljs$core$IFn$_invoke$arity$3 ? fexpr__9435.cljs$core$IFn$_invoke$arity$3(a,b,c) : fexpr__9435.call(null,a,b,c));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$4 \x3d (function (a,b,c,d){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9436 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9436.cljs$core$IFn$_invoke$arity$4 ? fexpr__9436.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : fexpr__9436.call(null,a,b,c,d));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$5 \x3d (function (a,b,c,d,e){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9437 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9437.cljs$core$IFn$_invoke$arity$5 ? fexpr__9437.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : fexpr__9437.call(null,a,b,c,d,e));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$6 \x3d (function (a,b,c,d,e,f){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9438 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9438.cljs$core$IFn$_invoke$arity$6 ? fexpr__9438.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : fexpr__9438.call(null,a,b,c,d,e,f));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$7 \x3d (function (a,b,c,d,e,f,g){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9439 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9439.cljs$core$IFn$_invoke$arity$7 ? fexpr__9439.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : fexpr__9439.call(null,a,b,c,d,e,f,g));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$8 \x3d (function (a,b,c,d,e,f,g,h){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9440 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9440.cljs$core$IFn$_invoke$arity$8 ? fexpr__9440.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : fexpr__9440.call(null,a,b,c,d,e,f,g,h));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$9 \x3d (function (a,b,c,d,e,f,g,h,i){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9441 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9441.cljs$core$IFn$_invoke$arity$9 ? fexpr__9441.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : fexpr__9441.call(null,a,b,c,d,e,f,g,h,i));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$10 \x3d (function (a,b,c,d,e,f,g,h,i,j){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9442 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9442.cljs$core$IFn$_invoke$arity$10 ? fexpr__9442.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : fexpr__9442.call(null,a,b,c,d,e,f,g,h,i,j));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$11 \x3d (function (a,b,c,d,e,f,g,h,i,j,k){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9443 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9443.cljs$core$IFn$_invoke$arity$11 ? fexpr__9443.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : fexpr__9443.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$12 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9444 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9444.cljs$core$IFn$_invoke$arity$12 ? fexpr__9444.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : fexpr__9444.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$13 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9445 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9445.cljs$core$IFn$_invoke$arity$13 ? fexpr__9445.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : fexpr__9445.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$14 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9446 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9446.cljs$core$IFn$_invoke$arity$14 ? fexpr__9446.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : fexpr__9446.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$15 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9447 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9447.cljs$core$IFn$_invoke$arity$15 ? fexpr__9447.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : fexpr__9447.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$16 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9448 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9448.cljs$core$IFn$_invoke$arity$16 ? fexpr__9448.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : fexpr__9448.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$17 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9449 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9449.cljs$core$IFn$_invoke$arity$17 ? fexpr__9449.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : fexpr__9449.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$18 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9450 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9450.cljs$core$IFn$_invoke$arity$18 ? fexpr__9450.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : fexpr__9450.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$19 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9451 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9451.cljs$core$IFn$_invoke$arity$19 ? fexpr__9451.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : fexpr__9451.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$20 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar fexpr__9452 \x3d (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__9452.cljs$core$IFn$_invoke$arity$20 ? fexpr__9452.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : fexpr__9452.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$21 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic((self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null)),a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\n\ncljs.core.Var.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$val,cljs.core.cst$sym$sym,cljs.core.cst$sym$_meta], null);\n});\n\ncljs.core.Var.cljs$lang$type \x3d true;\n\ncljs.core.Var.cljs$lang$ctorStr \x3d "cljs.core/Var";\n\ncljs.core.Var.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Var");\n});\n\n/**\n * Positional factory function for cljs.core/Var.\n */\ncljs.core.__GT_Var \x3d (function cljs$core$__GT_Var(val,sym,_meta){\nreturn (new cljs.core.Var(val,sym,_meta));\n});\n\n\n\n/**\n * Return true if x implements IIterable protocol.\n */\ncljs.core.iterable_QMARK_ \x3d (function cljs$core$iterable_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition1$ \x26 (131072))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IIterable$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition1$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IIterable,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IIterable,x);\n}\n});\n/**\n * Clone the supplied value which must implement ICloneable.\n */\ncljs.core.clone \x3d (function cljs$core$clone(value){\nreturn cljs.core._clone(value);\n});\n/**\n * Return true if x implements ICloneable protocol.\n */\ncljs.core.cloneable_QMARK_ \x3d (function cljs$core$cloneable_QMARK_(value){\nif((!((value \x3d\x3d null)))){\nif((((value.cljs$lang$protocol_mask$partition1$ \x26 (8192))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d value.cljs$core$ICloneable$)))){\nreturn true;\n} else {\nif((!value.cljs$lang$protocol_mask$partition1$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICloneable,value);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICloneable,value);\n}\n});\n/**\n * Returns a seq on the collection. If the collection is\n *   empty, returns nil.  (seq nil) returns nil. seq also works on\n *   Strings.\n */\ncljs.core.seq \x3d (function cljs$core$seq(coll){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (8388608))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ISeqable$))))?true:false):false)){\nreturn cljs.core._seq(coll);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nif((coll.length \x3d\x3d\x3d (0))){\nreturn null;\n} else {\nreturn (new cljs.core.IndexedSeq(coll,(0),null));\n}\n} else {\nif(typeof coll \x3d\x3d\x3d \'string\'){\nif((coll.length \x3d\x3d\x3d (0))){\nreturn null;\n} else {\nreturn (new cljs.core.IndexedSeq(coll,(0),null));\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.ISeqable,coll)){\nreturn cljs.core._seq(coll);\n} else {\nthrow (new Error([cljs.core.str.cljs$core$IFn$_invoke$arity$1(coll)," is not ISeqable"].join(\'\')));\n\n}\n}\n}\n}\n}\n});\n/**\n * Returns the first item in the collection. Calls seq on its\n *   argument. If coll is nil, returns nil.\n */\ncljs.core.first \x3d (function cljs$core$first(coll){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (64))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ISeq$))))?true:false):false)){\nreturn cljs.core._first(coll);\n} else {\nvar s \x3d cljs.core.seq(coll);\nif((s \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core._first(s);\n}\n}\n}\n});\n/**\n * Returns a possibly empty seq of the items after the first. Calls seq on its\n *   argument.\n */\ncljs.core.rest \x3d (function cljs$core$rest(coll){\nif((!((coll \x3d\x3d null)))){\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (64))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ISeq$))))?true:false):false)){\nreturn cljs.core._rest(coll);\n} else {\nvar s \x3d cljs.core.seq(coll);\nif(s){\nreturn s.cljs$core$ISeq$_rest$arity$1(null);\n} else {\nreturn cljs.core.List.EMPTY;\n}\n}\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n/**\n * Returns a seq of the items after the first. Calls seq on its\n *   argument.  If there are no more items, returns nil\n */\ncljs.core.next \x3d (function cljs$core$next(coll){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (128))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$INext$))))?true:false):false)){\nreturn cljs.core._next(coll);\n} else {\nreturn cljs.core.seq(cljs.core.rest(coll));\n}\n}\n});\n/**\n * Equality. Returns true if x equals y, false if not. Compares\n *   numbers and collections in a type-independent manner.  Clojure\'s immutable data\n *   structures define -equiv (and thus \x3d) as a value, not an identity,\n *   comparison.\n */\ncljs.core._EQ_ \x3d (function cljs$core$_EQ_(var_args){\nvar G__9464 \x3d arguments.length;\nswitch (G__9464) {\ncase 1:\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9466 \x3d arguments.length;\nvar i__4731__auto___9467 \x3d (0);\nwhile(true){\nif((i__4731__auto___9467 \x3c len__4730__auto___9466)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9467]));\n\nvar G__9468 \x3d (i__4731__auto___9467 + (1));\ni__4731__auto___9467 \x3d G__9468;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._EQ_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn true;\n});\n\ncljs.core._EQ_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nif((x \x3d\x3d null)){\nreturn (y \x3d\x3d null);\n} else {\nreturn (((x \x3d\x3d\x3d y)) || (cljs.core._equiv(x,y)));\n}\n});\n\ncljs.core._EQ_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nwhile(true){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)){\nif(cljs.core.next(more)){\nvar G__9469 \x3d y;\nvar G__9470 \x3d cljs.core.first(more);\nvar G__9471 \x3d cljs.core.next(more);\nx \x3d G__9469;\ny \x3d G__9470;\nmore \x3d G__9471;\ncontinue;\n} else {\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(y,cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._EQ_.cljs$lang$applyTo \x3d (function (seq9461){\nvar G__9462 \x3d cljs.core.first(seq9461);\nvar seq9461__$1 \x3d cljs.core.next(seq9461);\nvar G__9463 \x3d cljs.core.first(seq9461__$1);\nvar seq9461__$2 \x3d cljs.core.next(seq9461__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9462,G__9463,seq9461__$2);\n});\n\ncljs.core._EQ_.cljs$lang$maxFixedArity \x3d (2);\n\n\n/**\n* @constructor\n*/\ncljs.core.ES6Iterator \x3d (function (s){\nthis.s \x3d s;\n});\ncljs.core.ES6Iterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nif((!((self__.s \x3d\x3d null)))){\nvar x \x3d cljs.core.first(self__.s);\nself__.s \x3d cljs.core.next(self__.s);\n\nreturn ({"value": x, "done": false});\n} else {\nreturn ({"value": null, "done": true});\n}\n});\n\ncljs.core.ES6Iterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$s,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ES6Iterator.cljs$lang$type \x3d true;\n\ncljs.core.ES6Iterator.cljs$lang$ctorStr \x3d "cljs.core/ES6Iterator";\n\ncljs.core.ES6Iterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ES6Iterator");\n});\n\n/**\n * Positional factory function for cljs.core/ES6Iterator.\n */\ncljs.core.__GT_ES6Iterator \x3d (function cljs$core$__GT_ES6Iterator(s){\nreturn (new cljs.core.ES6Iterator(s));\n});\n\n/**\n * EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\n */\ncljs.core.es6_iterator \x3d (function cljs$core$es6_iterator(coll){\nreturn (new cljs.core.ES6Iterator(cljs.core.seq(coll)));\n});\n\n/**\n* @constructor\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.ISeqable}\n*/\ncljs.core.ES6IteratorSeq \x3d (function (value,iter,_rest){\nthis.value \x3d value;\nthis.iter \x3d iter;\nthis._rest \x3d _rest;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 8388672;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.ES6IteratorSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn this$__$1;\n});\n\ncljs.core.ES6IteratorSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.value;\n});\n\ncljs.core.ES6IteratorSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nif((self__._rest \x3d\x3d null)){\nself__._rest \x3d cljs.core.es6_iterator_seq(self__.iter);\n} else {\n}\n\nreturn self__._rest;\n});\n\ncljs.core.ES6IteratorSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$value,cljs.core.cst$sym$iter,cljs.core.with_meta(cljs.core.cst$sym$_rest,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ES6IteratorSeq.cljs$lang$type \x3d true;\n\ncljs.core.ES6IteratorSeq.cljs$lang$ctorStr \x3d "cljs.core/ES6IteratorSeq";\n\ncljs.core.ES6IteratorSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ES6IteratorSeq");\n});\n\n/**\n * Positional factory function for cljs.core/ES6IteratorSeq.\n */\ncljs.core.__GT_ES6IteratorSeq \x3d (function cljs$core$__GT_ES6IteratorSeq(value,iter,_rest){\nreturn (new cljs.core.ES6IteratorSeq(value,iter,_rest));\n});\n\n/**\n * EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\n */\ncljs.core.es6_iterator_seq \x3d (function cljs$core$es6_iterator_seq(iter){\nvar v \x3d iter.next();\nif(cljs.core.truth_(v.done)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn (new cljs.core.ES6IteratorSeq(v.value,iter,null));\n}\n});\n/**\n * Mix final collection hash for ordered or unordered collections.\n * hash-basis is the combined collection hash, count is the number\n * of elements included in the basis. Note this is the hash code\n * consistent with \x3d, different from .hashCode.\n * See http://clojure.org/data_structures#hash for full algorithms.\n */\ncljs.core.mix_collection_hash \x3d (function cljs$core$mix_collection_hash(hash_basis,count){\nvar h1 \x3d cljs.core.m3_seed;\nvar k1 \x3d cljs.core.m3_mix_K1(hash_basis);\nvar h1__$1 \x3d cljs.core.m3_mix_H1(h1,k1);\nreturn cljs.core.m3_fmix(h1__$1,count);\n});\n/**\n * Returns the hash code, consistent with \x3d, for an external ordered\n * collection implementing Iterable.\n * See http://clojure.org/data_structures#hash for full algorithms.\n */\ncljs.core.hash_ordered_coll \x3d (function cljs$core$hash_ordered_coll(coll){\nvar n \x3d (0);\nvar hash_code \x3d (1);\nvar coll__$1 \x3d cljs.core.seq(coll);\nwhile(true){\nif((!((coll__$1 \x3d\x3d null)))){\nvar G__9472 \x3d (n + (1));\nvar G__9473 \x3d ((cljs.core.imul((31),hash_code) + cljs.core.hash(cljs.core.first(coll__$1))) | (0));\nvar G__9474 \x3d cljs.core.next(coll__$1);\nn \x3d G__9472;\nhash_code \x3d G__9473;\ncoll__$1 \x3d G__9474;\ncontinue;\n} else {\nreturn cljs.core.mix_collection_hash(hash_code,n);\n}\nbreak;\n}\n});\ncljs.core.empty_ordered_hash \x3d cljs.core.mix_collection_hash((1),(0));\n/**\n * Returns the hash code, consistent with \x3d, for an external unordered\n * collection implementing Iterable. For maps, the iterator should\n * return map entries whose hash is computed as\n *   (hash-ordered-coll [k v]).\n * See http://clojure.org/data_structures#hash for full algorithms.\n */\ncljs.core.hash_unordered_coll \x3d (function cljs$core$hash_unordered_coll(coll){\nvar n \x3d (0);\nvar hash_code \x3d (0);\nvar coll__$1 \x3d cljs.core.seq(coll);\nwhile(true){\nif((!((coll__$1 \x3d\x3d null)))){\nvar G__9475 \x3d (n + (1));\nvar G__9476 \x3d ((hash_code + cljs.core.hash(cljs.core.first(coll__$1))) | (0));\nvar G__9477 \x3d cljs.core.next(coll__$1);\nn \x3d G__9475;\nhash_code \x3d G__9476;\ncoll__$1 \x3d G__9477;\ncontinue;\n} else {\nreturn cljs.core.mix_collection_hash(hash_code,n);\n}\nbreak;\n}\n});\ncljs.core.empty_unordered_hash \x3d cljs.core.mix_collection_hash((0),(0));\n\n\ngoog.object.set(cljs.core.ICounted,"null",true);\n\nvar G__9478_9481 \x3d cljs.core._count;\nvar G__9479_9482 \x3d "null";\nvar G__9480_9483 \x3d ((function (G__9478_9481,G__9479_9482){\nreturn (function (_){\nreturn (0);\n});})(G__9478_9481,G__9479_9482))\n;\ngoog.object.set(G__9478_9481,G__9479_9482,G__9480_9483);\nDate.prototype.cljs$core$IEquiv$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\nDate.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (o,other){\nvar o__$1 \x3d this;\nreturn (((other instanceof Date)) \x26\x26 ((o__$1.valueOf() \x3d\x3d\x3d other.valueOf())));\n});\n\nDate.prototype.cljs$core$IComparable$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\nDate.prototype.cljs$core$IComparable$_compare$arity$2 \x3d (function (this$,other){\nvar this$__$1 \x3d this;\nif((other instanceof Date)){\nvar G__9484 \x3d this$__$1.valueOf();\nvar G__9485 \x3d other.valueOf();\nreturn goog.array.defaultCompare(G__9484,G__9485);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(this$__$1)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(other)].join(\'\')));\n}\n});\n\n/**\n * @interface\n */\ncljs.core.Inst \x3d function(){};\n\ncljs.core.inst_ms_STAR_ \x3d (function cljs$core$inst_ms_STAR_(inst){\nif((((!((inst \x3d\x3d null)))) \x26\x26 ((!((inst.cljs$core$Inst$inst_ms_STAR_$arity$1 \x3d\x3d null)))))){\nreturn inst.cljs$core$Inst$inst_ms_STAR_$arity$1(inst);\n} else {\nvar x__4433__auto__ \x3d (((inst \x3d\x3d null))?null:inst);\nvar m__4434__auto__ \x3d (cljs.core.inst_ms_STAR_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(inst) : m__4434__auto__.call(null,inst));\n} else {\nvar m__4431__auto__ \x3d (cljs.core.inst_ms_STAR_["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(inst) : m__4431__auto__.call(null,inst));\n} else {\nthrow cljs.core.missing_protocol("Inst.inst-ms*",inst);\n}\n}\n}\n});\n\nDate.prototype.cljs$core$Inst$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\nDate.prototype.cljs$core$Inst$inst_ms_STAR_$arity$1 \x3d (function (inst){\nvar inst__$1 \x3d this;\nreturn inst__$1.getTime();\n});\n/**\n * Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\n */\ncljs.core.inst_ms \x3d (function cljs$core$inst_ms(inst){\nreturn cljs.core.inst_ms_STAR_(inst);\n});\n/**\n * Return true if x satisfies Inst\n */\ncljs.core.inst_QMARK_ \x3d (function cljs$core$inst_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$Inst$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.Inst,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.Inst,x);\n}\n});\ngoog.object.set(cljs.core.IEquiv,"number",true);\n\nvar G__9487_9490 \x3d cljs.core._equiv;\nvar G__9488_9491 \x3d "number";\nvar G__9489_9492 \x3d ((function (G__9487_9490,G__9488_9491){\nreturn (function (x,o){\nreturn (x \x3d\x3d\x3d o);\n});})(G__9487_9490,G__9488_9491))\n;\ngoog.object.set(G__9487_9490,G__9488_9491,G__9489_9492);\ngoog.object.set(cljs.core.Fn,"function",true);\n\ngoog.object.set(cljs.core.IMeta,"function",true);\n\nvar G__9493_9496 \x3d cljs.core._meta;\nvar G__9494_9497 \x3d "function";\nvar G__9495_9498 \x3d ((function (G__9493_9496,G__9494_9497){\nreturn (function (_){\nreturn null;\n});})(G__9493_9496,G__9494_9497))\n;\ngoog.object.set(G__9493_9496,G__9494_9497,G__9495_9498);\ngoog.object.set(cljs.core.IHash,"_",true);\n\nvar G__9499_9502 \x3d cljs.core._hash;\nvar G__9500_9503 \x3d "_";\nvar G__9501_9504 \x3d ((function (G__9499_9502,G__9500_9503){\nreturn (function (o){\nreturn goog.getUid(o);\n});})(G__9499_9502,G__9500_9503))\n;\ngoog.object.set(G__9499_9502,G__9500_9503,G__9501_9504);\n/**\n * Returns a number one greater than num.\n */\ncljs.core.inc \x3d (function cljs$core$inc(x){\nreturn (x + (1));\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IDeref}\n*/\ncljs.core.Reduced \x3d (function (val){\nthis.val \x3d val;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32768;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.Reduced.prototype.cljs$core$IDeref$_deref$arity$1 \x3d (function (o){\nvar self__ \x3d this;\nvar o__$1 \x3d this;\nreturn self__.val;\n});\n\ncljs.core.Reduced.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$val], null);\n});\n\ncljs.core.Reduced.cljs$lang$type \x3d true;\n\ncljs.core.Reduced.cljs$lang$ctorStr \x3d "cljs.core/Reduced";\n\ncljs.core.Reduced.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Reduced");\n});\n\n/**\n * Positional factory function for cljs.core/Reduced.\n */\ncljs.core.__GT_Reduced \x3d (function cljs$core$__GT_Reduced(val){\nreturn (new cljs.core.Reduced(val));\n});\n\n/**\n * Wraps x in a way such that a reduce will terminate with the value x\n */\ncljs.core.reduced \x3d (function cljs$core$reduced(x){\nreturn (new cljs.core.Reduced(x));\n});\n/**\n * Returns true if x is the result of a call to reduced\n */\ncljs.core.reduced_QMARK_ \x3d (function cljs$core$reduced_QMARK_(r){\nreturn (r instanceof cljs.core.Reduced);\n});\n/**\n * If x is already reduced?, returns it, else returns (reduced x)\n */\ncljs.core.ensure_reduced \x3d (function cljs$core$ensure_reduced(x){\nif(cljs.core.reduced_QMARK_(x)){\nreturn x;\n} else {\nreturn cljs.core.reduced(x);\n}\n});\n/**\n * If x is reduced?, returns (deref x), else returns x\n */\ncljs.core.unreduced \x3d (function cljs$core$unreduced(x){\nif(cljs.core.reduced_QMARK_(x)){\nreturn cljs.core.deref(x);\n} else {\nreturn x;\n}\n});\n/**\n * Also reader macro: @var/@atom/@delay. Returns the\n * most-recently-committed value of ref. When applied to a var\n * or atom, returns its current state. When applied to a delay, forces\n * it if not already forced. See also - realized?.\n */\ncljs.core.deref \x3d (function cljs$core$deref(o){\nreturn cljs.core._deref(o);\n});\n/**\n * Accepts any collection which satisfies the ICount and IIndexed protocols and\n * reduces them without incurring seq initialization\n */\ncljs.core.ci_reduce \x3d (function cljs$core$ci_reduce(var_args){\nvar G__9506 \x3d arguments.length;\nswitch (G__9506) {\ncase 2:\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2 \x3d (function (cicoll,f){\nvar cnt \x3d cljs.core._count(cicoll);\nif((cnt \x3d\x3d\x3d (0))){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n} else {\nvar val \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(cicoll,(0));\nvar n \x3d (1);\nwhile(true){\nif((n \x3c cnt)){\nvar nval \x3d (function (){var G__9507 \x3d val;\nvar G__9508 \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(cicoll,n);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__9507,G__9508) : f.call(null,G__9507,G__9508));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__9514 \x3d nval;\nvar G__9515 \x3d (n + (1));\nval \x3d G__9514;\nn \x3d G__9515;\ncontinue;\n}\n} else {\nreturn val;\n}\nbreak;\n}\n}\n});\n\ncljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3 \x3d (function (cicoll,f,val){\nvar cnt \x3d cljs.core._count(cicoll);\nvar val__$1 \x3d val;\nvar n \x3d (0);\nwhile(true){\nif((n \x3c cnt)){\nvar nval \x3d (function (){var G__9509 \x3d val__$1;\nvar G__9510 \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(cicoll,n);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__9509,G__9510) : f.call(null,G__9509,G__9510));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__9516 \x3d nval;\nvar G__9517 \x3d (n + (1));\nval__$1 \x3d G__9516;\nn \x3d G__9517;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$4 \x3d (function (cicoll,f,val,idx){\nvar cnt \x3d cljs.core._count(cicoll);\nvar val__$1 \x3d val;\nvar n \x3d idx;\nwhile(true){\nif((n \x3c cnt)){\nvar nval \x3d (function (){var G__9511 \x3d val__$1;\nvar G__9512 \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(cicoll,n);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__9511,G__9512) : f.call(null,G__9511,G__9512));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__9518 \x3d nval;\nvar G__9519 \x3d (n + (1));\nval__$1 \x3d G__9518;\nn \x3d G__9519;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.ci_reduce.cljs$lang$maxFixedArity \x3d 4;\n\ncljs.core.array_reduce \x3d (function cljs$core$array_reduce(var_args){\nvar G__9521 \x3d arguments.length;\nswitch (G__9521) {\ncase 2:\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.array_reduce.cljs$core$IFn$_invoke$arity$2 \x3d (function (arr,f){\nvar cnt \x3d arr.length;\nif((arr.length \x3d\x3d\x3d (0))){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n} else {\nvar val \x3d (arr[(0)]);\nvar n \x3d (1);\nwhile(true){\nif((n \x3c cnt)){\nvar nval \x3d (function (){var G__9522 \x3d val;\nvar G__9523 \x3d (arr[n]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__9522,G__9523) : f.call(null,G__9522,G__9523));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__9529 \x3d nval;\nvar G__9530 \x3d (n + (1));\nval \x3d G__9529;\nn \x3d G__9530;\ncontinue;\n}\n} else {\nreturn val;\n}\nbreak;\n}\n}\n});\n\ncljs.core.array_reduce.cljs$core$IFn$_invoke$arity$3 \x3d (function (arr,f,val){\nvar cnt \x3d arr.length;\nvar val__$1 \x3d val;\nvar n \x3d (0);\nwhile(true){\nif((n \x3c cnt)){\nvar nval \x3d (function (){var G__9524 \x3d val__$1;\nvar G__9525 \x3d (arr[n]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__9524,G__9525) : f.call(null,G__9524,G__9525));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__9531 \x3d nval;\nvar G__9532 \x3d (n + (1));\nval__$1 \x3d G__9531;\nn \x3d G__9532;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4 \x3d (function (arr,f,val,idx){\nvar cnt \x3d arr.length;\nvar val__$1 \x3d val;\nvar n \x3d idx;\nwhile(true){\nif((n \x3c cnt)){\nvar nval \x3d (function (){var G__9526 \x3d val__$1;\nvar G__9527 \x3d (arr[n]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__9526,G__9527) : f.call(null,G__9526,G__9527));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__9533 \x3d nval;\nvar G__9534 \x3d (n + (1));\nval__$1 \x3d G__9533;\nn \x3d G__9534;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.array_reduce.cljs$lang$maxFixedArity \x3d 4;\n\n\n\n\n\n\n\n/**\n * Returns true if coll implements count in constant time\n */\ncljs.core.counted_QMARK_ \x3d (function cljs$core$counted_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (2))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$ICounted$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICounted,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICounted,x);\n}\n});\n/**\n * Returns true if coll implements nth in constant time\n */\ncljs.core.indexed_QMARK_ \x3d (function cljs$core$indexed_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (16))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IIndexed$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IIndexed,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IIndexed,x);\n}\n});\ncljs.core._indexOf \x3d (function cljs$core$_indexOf(var_args){\nvar G__9538 \x3d arguments.length;\nswitch (G__9538) {\ncase 2:\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core._indexOf.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,x){\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\n\ncljs.core._indexOf.cljs$core$IFn$_invoke$arity$3 \x3d (function (coll,x,start){\nvar len \x3d cljs.core.count(coll);\nif((start \x3e\x3d len)){\nreturn (-1);\n} else {\nvar idx \x3d (((start \x3e (0)))?start:(((start \x3c (0)))?(function (){var x__4219__auto__ \x3d (0);\nvar y__4220__auto__ \x3d (start + len);\nreturn ((x__4219__auto__ \x3e y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})():start\n));\nwhile(true){\nif((idx \x3c len)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(coll,idx),x)){\nreturn idx;\n} else {\nvar G__9540 \x3d (idx + (1));\nidx \x3d G__9540;\ncontinue;\n}\n} else {\nreturn (-1);\n}\nbreak;\n}\n}\n});\n\ncljs.core._indexOf.cljs$lang$maxFixedArity \x3d 3;\n\ncljs.core._lastIndexOf \x3d (function cljs$core$_lastIndexOf(var_args){\nvar G__9542 \x3d arguments.length;\nswitch (G__9542) {\ncase 2:\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,x){\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\n\ncljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3 \x3d (function (coll,x,start){\nvar len \x3d cljs.core.count(coll);\nif((len \x3d\x3d\x3d (0))){\nreturn (-1);\n} else {\nvar idx \x3d (((start \x3e (0)))?(function (){var x__4222__auto__ \x3d (len - (1));\nvar y__4223__auto__ \x3d start;\nreturn ((x__4222__auto__ \x3c y__4223__auto__) ? x__4222__auto__ : y__4223__auto__);\n})():(((start \x3c (0)))?(len + start):start\n));\nwhile(true){\nif((idx \x3e\x3d (0))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(coll,idx),x)){\nreturn idx;\n} else {\nvar G__9544 \x3d (idx - (1));\nidx \x3d G__9544;\ncontinue;\n}\n} else {\nreturn (-1);\n}\nbreak;\n}\n}\n});\n\ncljs.core._lastIndexOf.cljs$lang$maxFixedArity \x3d 3;\n\n\n/**\n* @constructor\n*/\ncljs.core.IndexedSeqIterator \x3d (function (arr,i){\nthis.arr \x3d arr;\nthis.i \x3d i;\n});\ncljs.core.IndexedSeqIterator.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.i \x3c self__.arr.length);\n});\n\ncljs.core.IndexedSeqIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar ret \x3d (self__.arr[self__.i]);\nself__.i \x3d (self__.i + (1));\n\nreturn ret;\n});\n\ncljs.core.IndexedSeqIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$arr,cljs.core.with_meta(cljs.core.cst$sym$i,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.IndexedSeqIterator.cljs$lang$type \x3d true;\n\ncljs.core.IndexedSeqIterator.cljs$lang$ctorStr \x3d "cljs.core/IndexedSeqIterator";\n\ncljs.core.IndexedSeqIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/IndexedSeqIterator");\n});\n\n/**\n * Positional factory function for cljs.core/IndexedSeqIterator.\n */\ncljs.core.__GT_IndexedSeqIterator \x3d (function cljs$core$__GT_IndexedSeqIterator(arr,i){\nreturn (new cljs.core.IndexedSeqIterator(arr,i));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.IndexedSeq \x3d (function (arr,i,meta){\nthis.arr \x3d arr;\nthis.i \x3d i;\nthis.meta \x3d meta;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 166592766;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 139264;\n});\ncljs.core.IndexedSeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.IndexedSeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.IndexedSeq.prototype.indexOf \x3d (function() {\nvar G__9545 \x3d null;\nvar G__9545__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__9545__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__9545 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__9545__1.call(this,x);\ncase 2:\nreturn G__9545__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__9545.cljs$core$IFn$_invoke$arity$1 \x3d G__9545__1;\nG__9545.cljs$core$IFn$_invoke$arity$2 \x3d G__9545__2;\nreturn G__9545;\n})()\n;\n\ncljs.core.IndexedSeq.prototype.lastIndexOf \x3d (function() {\nvar G__9546 \x3d null;\nvar G__9546__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__9546__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__9546 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__9546__1.call(this,x);\ncase 2:\nreturn G__9546__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__9546.cljs$core$IFn$_invoke$arity$1 \x3d G__9546__1;\nG__9546.cljs$core$IFn$_invoke$arity$2 \x3d G__9546__2;\nreturn G__9546;\n})()\n;\n\ncljs.core.IndexedSeq.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (coll,n){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar i__$1 \x3d (n + self__.i);\nif(((((0) \x3c\x3d i__$1)) \x26\x26 ((i__$1 \x3c self__.arr.length)))){\nreturn (self__.arr[i__$1]);\n} else {\nthrow (new Error("Index out of bounds"));\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (coll,n,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar i__$1 \x3d (n + self__.i);\nif(((((0) \x3c\x3d i__$1)) \x26\x26 ((i__$1 \x3c self__.arr.length)))){\nreturn (self__.arr[i__$1]);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.IndexedSeqIterator(self__.arr,self__.i));\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.IndexedSeq(self__.arr,self__.i,self__.meta));\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nif(((self__.i + (1)) \x3c self__.arr.length)){\nreturn (new cljs.core.IndexedSeq(self__.arr,(self__.i + (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nvar x__4219__auto__ \x3d (0);\nvar y__4220__auto__ \x3d (self__.arr.length - self__.i);\nreturn ((x__4219__auto__ \x3e y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IReversible$_rseq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar c \x3d coll__$1.cljs$core$ICounted$_count$arity$1(null);\nif((c \x3e (0))){\nreturn (new cljs.core.RSeq(coll__$1,(c - (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4(self__.arr,f,(self__.arr[self__.i]),(self__.i + (1)));\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4(self__.arr,f,start,self__.i);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (self__.arr[self__.i]);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nif(((self__.i + (1)) \x3c self__.arr.length)){\nreturn (new cljs.core.IndexedSeq(self__.arr,(self__.i + (1)),null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nif((self__.i \x3c self__.arr.length)){\nreturn this$__$1;\n} else {\nreturn null;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.IndexedSeq(self__.arr,self__.i,new_meta));\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.IndexedSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$arr,cljs.core.cst$sym$i,cljs.core.cst$sym$meta], null);\n});\n\ncljs.core.IndexedSeq.cljs$lang$type \x3d true;\n\ncljs.core.IndexedSeq.cljs$lang$ctorStr \x3d "cljs.core/IndexedSeq";\n\ncljs.core.IndexedSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/IndexedSeq");\n});\n\n/**\n * Positional factory function for cljs.core/IndexedSeq.\n */\ncljs.core.__GT_IndexedSeq \x3d (function cljs$core$__GT_IndexedSeq(arr,i,meta){\nreturn (new cljs.core.IndexedSeq(arr,i,meta));\n});\n\nvar G__9547_9550 \x3d cljs.core.IndexedSeq.prototype;\nvar G__9548_9551 \x3d cljs.core.ITER_SYMBOL;\nvar G__9549_9552 \x3d ((function (G__9547_9550,G__9548_9551){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__9547_9550,G__9548_9551))\n;\ngoog.object.set(G__9547_9550,G__9548_9551,G__9549_9552);\n/**\n * Create seq from a primitive JavaScript Array-like.\n */\ncljs.core.prim_seq \x3d (function cljs$core$prim_seq(var_args){\nvar G__9554 \x3d arguments.length;\nswitch (G__9554) {\ncase 1:\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.prim_seq.cljs$core$IFn$_invoke$arity$1 \x3d (function (prim){\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(prim,(0));\n});\n\ncljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2 \x3d (function (prim,i){\nif((i \x3c prim.length)){\nreturn (new cljs.core.IndexedSeq(prim,i,null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.prim_seq.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Create a seq from a JavaScript array.\n */\ncljs.core.array_seq \x3d (function cljs$core$array_seq(var_args){\nvar G__9557 \x3d arguments.length;\nswitch (G__9557) {\ncase 1:\nreturn cljs.core.array_seq.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.array_seq.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.array_seq.cljs$core$IFn$_invoke$arity$1 \x3d (function (array){\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(array,(0));\n});\n\ncljs.core.array_seq.cljs$core$IFn$_invoke$arity$2 \x3d (function (array,i){\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(array,i);\n});\n\ncljs.core.array_seq.cljs$lang$maxFixedArity \x3d 2;\n\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.RSeq \x3d (function (ci,i,meta){\nthis.ci \x3d ci;\nthis.i \x3d i;\nthis.meta \x3d meta;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32374990;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 8192;\n});\ncljs.core.RSeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.RSeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.RSeq.prototype.indexOf \x3d (function() {\nvar G__9559 \x3d null;\nvar G__9559__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__9559__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__9559 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__9559__1.call(this,x);\ncase 2:\nreturn G__9559__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__9559.cljs$core$IFn$_invoke$arity$1 \x3d G__9559__1;\nG__9559.cljs$core$IFn$_invoke$arity$2 \x3d G__9559__2;\nreturn G__9559;\n})()\n;\n\ncljs.core.RSeq.prototype.lastIndexOf \x3d (function() {\nvar G__9560 \x3d null;\nvar G__9560__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__9560__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__9560 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__9560__1.call(this,x);\ncase 2:\nreturn G__9560__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__9560.cljs$core$IFn$_invoke$arity$1 \x3d G__9560__1;\nG__9560.cljs$core$IFn$_invoke$arity$2 \x3d G__9560__2;\nreturn G__9560;\n})()\n;\n\ncljs.core.RSeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.RSeq.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.RSeq(self__.ci,self__.i,self__.meta));\n});\n\ncljs.core.RSeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.i \x3e (0))){\nreturn (new cljs.core.RSeq(self__.ci,(self__.i - (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.RSeq.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (self__.i + (1));\n});\n\ncljs.core.RSeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.RSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.RSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.RSeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (col,f){\nvar self__ \x3d this;\nvar col__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,col__$1);\n});\n\ncljs.core.RSeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (col,f,start){\nvar self__ \x3d this;\nvar col__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,col__$1);\n});\n\ncljs.core.RSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.ci,self__.i);\n});\n\ncljs.core.RSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.i \x3e (0))){\nreturn (new cljs.core.RSeq(self__.ci,(self__.i - (1)),null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.RSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.RSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.RSeq(self__.ci,self__.i,new_meta));\n}\n});\n\ncljs.core.RSeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.RSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$ci,cljs.core.cst$sym$i,cljs.core.cst$sym$meta], null);\n});\n\ncljs.core.RSeq.cljs$lang$type \x3d true;\n\ncljs.core.RSeq.cljs$lang$ctorStr \x3d "cljs.core/RSeq";\n\ncljs.core.RSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/RSeq");\n});\n\n/**\n * Positional factory function for cljs.core/RSeq.\n */\ncljs.core.__GT_RSeq \x3d (function cljs$core$__GT_RSeq(ci,i,meta){\nreturn (new cljs.core.RSeq(ci,i,meta));\n});\n\nvar G__9561_9564 \x3d cljs.core.RSeq.prototype;\nvar G__9562_9565 \x3d cljs.core.ITER_SYMBOL;\nvar G__9563_9566 \x3d ((function (G__9561_9564,G__9562_9565){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__9561_9564,G__9562_9565))\n;\ngoog.object.set(G__9561_9564,G__9562_9565,G__9563_9566);\n/**\n * Same as (first (next x))\n */\ncljs.core.second \x3d (function cljs$core$second(coll){\nreturn cljs.core.first(cljs.core.next(coll));\n});\n/**\n * Same as (first (first x))\n */\ncljs.core.ffirst \x3d (function cljs$core$ffirst(coll){\nreturn cljs.core.first(cljs.core.first(coll));\n});\n/**\n * Same as (next (first x))\n */\ncljs.core.nfirst \x3d (function cljs$core$nfirst(coll){\nreturn cljs.core.next(cljs.core.first(coll));\n});\n/**\n * Same as (first (next x))\n */\ncljs.core.fnext \x3d (function cljs$core$fnext(coll){\nreturn cljs.core.first(cljs.core.next(coll));\n});\n/**\n * Same as (next (next x))\n */\ncljs.core.nnext \x3d (function cljs$core$nnext(coll){\nreturn cljs.core.next(cljs.core.next(coll));\n});\n/**\n * Return the last item in coll, in linear time\n */\ncljs.core.last \x3d (function cljs$core$last(s){\nwhile(true){\nvar sn \x3d cljs.core.next(s);\nif((!((sn \x3d\x3d null)))){\nvar G__9567 \x3d sn;\ns \x3d G__9567;\ncontinue;\n} else {\nreturn cljs.core.first(s);\n}\nbreak;\n}\n});\ngoog.object.set(cljs.core.IEquiv,"_",true);\n\nvar G__9568_9571 \x3d cljs.core._equiv;\nvar G__9569_9572 \x3d "_";\nvar G__9570_9573 \x3d ((function (G__9568_9571,G__9569_9572){\nreturn (function (x,o){\nreturn (x \x3d\x3d\x3d o);\n});})(G__9568_9571,G__9569_9572))\n;\ngoog.object.set(G__9568_9571,G__9569_9572,G__9570_9573);\n/**\n * conj[oin]. Returns a new collection with the xs\n *   \'added\'. (conj nil item) returns (item).  The \'addition\' may\n *   happen at different \'places\' depending on the concrete type.\n */\ncljs.core.conj \x3d (function cljs$core$conj(var_args){\nvar G__9578 \x3d arguments.length;\nswitch (G__9578) {\ncase 0:\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9580 \x3d arguments.length;\nvar i__4731__auto___9581 \x3d (0);\nwhile(true){\nif((i__4731__auto___9581 \x3c len__4730__auto___9580)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9581]));\n\nvar G__9582 \x3d (i__4731__auto___9581 + (1));\ni__4731__auto___9581 \x3d G__9582;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.conj.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.PersistentVector.EMPTY;\n});\n\ncljs.core.conj.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nreturn coll;\n});\n\ncljs.core.conj.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,x){\nif((!((coll \x3d\x3d null)))){\nreturn cljs.core._conj(coll,x);\n} else {\nreturn (new cljs.core.List(null,x,null,(1),null));\n}\n});\n\ncljs.core.conj.cljs$core$IFn$_invoke$arity$variadic \x3d (function (coll,x,xs){\nwhile(true){\nif(cljs.core.truth_(xs)){\nvar G__9583 \x3d cljs.core.conj.cljs$core$IFn$_invoke$arity$2(coll,x);\nvar G__9584 \x3d cljs.core.first(xs);\nvar G__9585 \x3d cljs.core.next(xs);\ncoll \x3d G__9583;\nx \x3d G__9584;\nxs \x3d G__9585;\ncontinue;\n} else {\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(coll,x);\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.conj.cljs$lang$applyTo \x3d (function (seq9575){\nvar G__9576 \x3d cljs.core.first(seq9575);\nvar seq9575__$1 \x3d cljs.core.next(seq9575);\nvar G__9577 \x3d cljs.core.first(seq9575__$1);\nvar seq9575__$2 \x3d cljs.core.next(seq9575__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9576,G__9577,seq9575__$2);\n});\n\ncljs.core.conj.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns an empty collection of the same category as coll, or nil\n */\ncljs.core.empty \x3d (function cljs$core$empty(coll){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (4))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$IEmptyableCollection$))))?true:false):false)){\nreturn cljs.core._empty(coll);\n} else {\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (4))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$IEmptyableCollection$))))?true:(((!coll.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.IEmptyableCollection,coll):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IEmptyableCollection,coll))){\nreturn cljs.core._empty(coll);\n} else {\nreturn null;\n\n}\n}\n}\n});\ncljs.core.accumulating_seq_count \x3d (function cljs$core$accumulating_seq_count(coll){\nvar s \x3d cljs.core.seq(coll);\nvar acc \x3d (0);\nwhile(true){\nif(cljs.core.counted_QMARK_(s)){\nreturn (acc + cljs.core._count(s));\n} else {\nvar G__9588 \x3d cljs.core.next(s);\nvar G__9589 \x3d (acc + (1));\ns \x3d G__9588;\nacc \x3d G__9589;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Returns the number of items in the collection. (count nil) returns\n *   0.  Also works on strings, arrays, and Maps\n */\ncljs.core.count \x3d (function cljs$core$count(coll){\nif((!((coll \x3d\x3d null)))){\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (2))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ICounted$))))?true:false):false)){\nreturn cljs.core._count(coll);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn coll.length;\n} else {\nif(typeof coll \x3d\x3d\x3d \'string\'){\nreturn coll.length;\n} else {\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (8388608))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ISeqable$))))?true:false):false)){\nreturn cljs.core.accumulating_seq_count(coll);\n} else {\nreturn cljs.core._count(coll);\n\n}\n}\n}\n}\n} else {\nreturn (0);\n}\n});\ncljs.core.linear_traversal_nth \x3d (function cljs$core$linear_traversal_nth(var_args){\nvar G__9593 \x3d arguments.length;\nswitch (G__9593) {\ncase 2:\nreturn cljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,n){\nwhile(true){\nif((coll \x3d\x3d null)){\nthrow (new Error("Index out of bounds"));\n} else {\nif((n \x3d\x3d\x3d (0))){\nif(cljs.core.seq(coll)){\nreturn cljs.core.first(coll);\n} else {\nthrow (new Error("Index out of bounds"));\n}\n} else {\nif(cljs.core.indexed_QMARK_(coll)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(coll,n);\n} else {\nif(cljs.core.seq(coll)){\nvar G__9595 \x3d cljs.core.next(coll);\nvar G__9596 \x3d (n - (1));\ncoll \x3d G__9595;\nn \x3d G__9596;\ncontinue;\n} else {\nthrow (new Error("Index out of bounds"));\n\n}\n}\n}\n}\nbreak;\n}\n});\n\ncljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$3 \x3d (function (coll,n,not_found){\nwhile(true){\nif((coll \x3d\x3d null)){\nreturn not_found;\n} else {\nif((n \x3d\x3d\x3d (0))){\nif(cljs.core.seq(coll)){\nreturn cljs.core.first(coll);\n} else {\nreturn not_found;\n}\n} else {\nif(cljs.core.indexed_QMARK_(coll)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3(coll,n,not_found);\n} else {\nif(cljs.core.seq(coll)){\nvar G__9597 \x3d cljs.core.next(coll);\nvar G__9598 \x3d (n - (1));\nvar G__9599 \x3d not_found;\ncoll \x3d G__9597;\nn \x3d G__9598;\nnot_found \x3d G__9599;\ncontinue;\n} else {\nreturn not_found;\n\n}\n}\n}\n}\nbreak;\n}\n});\n\ncljs.core.linear_traversal_nth.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Returns the value at the index. get returns nil if index out of\n *   bounds, nth throws an exception unless not-found is supplied.  nth\n *   also works for strings, arrays, regex Matchers and Lists, and,\n *   in O(n) time, for sequences.\n */\ncljs.core.nth \x3d (function cljs$core$nth(var_args){\nvar G__9601 \x3d arguments.length;\nswitch (G__9601) {\ncase 2:\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.nth.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,n){\nif((!(typeof n \x3d\x3d\x3d \'number\'))){\nthrow (new Error("Index argument to nth must be a number"));\n} else {\nif((coll \x3d\x3d null)){\nreturn coll;\n} else {\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (16))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$IIndexed$))))?true:false):false)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(coll,n);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nif(((((-1) \x3c n)) \x26\x26 ((n \x3c coll.length)))){\nreturn (coll[(n | (0))]);\n} else {\nthrow (new Error("Index out of bounds"));\n}\n} else {\nif(typeof coll \x3d\x3d\x3d \'string\'){\nif(((((-1) \x3c n)) \x26\x26 ((n \x3c coll.length)))){\nreturn coll.charAt((n | (0)));\n} else {\nthrow (new Error("Index out of bounds"));\n}\n} else {\nif((function (){var or__4131__auto__ \x3d (((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (64))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ISeq$))))?true:false):false);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nif((!((coll \x3d\x3d null)))){\nif((((coll.cljs$lang$protocol_mask$partition0$ \x26 (16777216))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ISequential$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n}\n})()){\nif((n \x3c (0))){\nthrow (new Error("Index out of bounds"));\n} else {\nreturn cljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$2(coll,n);\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.IIndexed,coll)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(coll,n);\n} else {\nthrow (new Error(["nth not supported on this type ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.type__GT_str(cljs.core.type(coll)))].join(\'\')));\n\n}\n}\n}\n}\n}\n}\n}\n});\n\ncljs.core.nth.cljs$core$IFn$_invoke$arity$3 \x3d (function (coll,n,not_found){\nif((!(typeof n \x3d\x3d\x3d \'number\'))){\nthrow (new Error("Index argument to nth must be a number."));\n} else {\nif((coll \x3d\x3d null)){\nreturn not_found;\n} else {\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (16))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$IIndexed$))))?true:false):false)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3(coll,n,not_found);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nif(((((-1) \x3c n)) \x26\x26 ((n \x3c coll.length)))){\nreturn (coll[(n | (0))]);\n} else {\nreturn not_found;\n}\n} else {\nif(typeof coll \x3d\x3d\x3d \'string\'){\nif(((((-1) \x3c n)) \x26\x26 ((n \x3c coll.length)))){\nreturn coll.charAt((n | (0)));\n} else {\nreturn not_found;\n}\n} else {\nif((function (){var or__4131__auto__ \x3d (((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (64))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ISeq$))))?true:false):false);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nif((!((coll \x3d\x3d null)))){\nif((((coll.cljs$lang$protocol_mask$partition0$ \x26 (16777216))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ISequential$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n}\n})()){\nif((n \x3c (0))){\nreturn not_found;\n} else {\nreturn cljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$3(coll,n,not_found);\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.IIndexed,coll)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3(coll,n,not_found);\n} else {\nthrow (new Error(["nth not supported on this type ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.type__GT_str(cljs.core.type(coll)))].join(\'\')));\n\n}\n}\n}\n}\n}\n}\n}\n});\n\ncljs.core.nth.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Returns the nth rest of coll, coll when n is 0.\n */\ncljs.core.nthrest \x3d (function cljs$core$nthrest(coll,n){\nvar n__$1 \x3d n;\nvar xs \x3d coll;\nwhile(true){\nvar temp__5718__auto__ \x3d (((n__$1 \x3e (0))) \x26\x26 (cljs.core.seq(xs)));\nif(temp__5718__auto__){\nvar xs__$1 \x3d temp__5718__auto__;\nvar G__9611 \x3d (n__$1 - (1));\nvar G__9612 \x3d cljs.core.rest(xs__$1);\nn__$1 \x3d G__9611;\nxs \x3d G__9612;\ncontinue;\n} else {\nreturn xs;\n}\nbreak;\n}\n});\n/**\n * Returns the value mapped to key, not-found or nil if key not present.\n */\ncljs.core.get \x3d (function cljs$core$get(var_args){\nvar G__9614 \x3d arguments.length;\nswitch (G__9614) {\ncase 2:\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.get.cljs$core$IFn$_invoke$arity$2 \x3d (function (o,k){\nif((o \x3d\x3d null)){\nreturn null;\n} else {\nif((((!((o \x3d\x3d null))))?(((((o.cljs$lang$protocol_mask$partition0$ \x26 (256))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d o.cljs$core$ILookup$))))?true:false):false)){\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$2(o,k);\n} else {\nif(cljs.core.array_QMARK_(o)){\nif((((!((k \x3d\x3d null)))) \x26\x26 ((k \x3c o.length)))){\nreturn (o[(k | (0))]);\n} else {\nreturn null;\n}\n} else {\nif(typeof o \x3d\x3d\x3d \'string\'){\nif((((!((k \x3d\x3d null)))) \x26\x26 ((k \x3c o.length)))){\nreturn o.charAt((k | (0)));\n} else {\nreturn null;\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.ILookup,o)){\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$2(o,k);\n} else {\nreturn null;\n\n}\n}\n}\n}\n}\n});\n\ncljs.core.get.cljs$core$IFn$_invoke$arity$3 \x3d (function (o,k,not_found){\nif((!((o \x3d\x3d null)))){\nif((((!((o \x3d\x3d null))))?(((((o.cljs$lang$protocol_mask$partition0$ \x26 (256))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d o.cljs$core$ILookup$))))?true:false):false)){\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(o,k,not_found);\n} else {\nif(cljs.core.array_QMARK_(o)){\nif((((!((k \x3d\x3d null)))) \x26\x26 (((((-1) \x3c k)) \x26\x26 ((k \x3c o.length)))))){\nreturn (o[(k | (0))]);\n} else {\nreturn not_found;\n}\n} else {\nif(typeof o \x3d\x3d\x3d \'string\'){\nif((((!((k \x3d\x3d null)))) \x26\x26 (((((-1) \x3c k)) \x26\x26 ((k \x3c o.length)))))){\nreturn o.charAt((k | (0)));\n} else {\nreturn not_found;\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.ILookup,o)){\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(o,k,not_found);\n} else {\nreturn not_found;\n\n}\n}\n}\n}\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.get.cljs$lang$maxFixedArity \x3d 3;\n\n\n\n/**\n * assoc[iate]. When applied to a map, returns a new map of the\n * same (hashed/sorted) type, that contains the mapping of key(s) to\n * val(s). When applied to a vector, returns a new vector that\n * contains val at index.\n */\ncljs.core.assoc \x3d (function cljs$core$assoc(var_args){\nvar G__9623 \x3d arguments.length;\nswitch (G__9623) {\ncase 3:\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9625 \x3d arguments.length;\nvar i__4731__auto___9626 \x3d (0);\nwhile(true){\nif((i__4731__auto___9626 \x3c len__4730__auto___9625)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9626]));\n\nvar G__9627 \x3d (i__4731__auto___9626 + (1));\ni__4731__auto___9626 \x3d G__9627;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.assoc.cljs$core$IFn$_invoke$arity$3 \x3d (function (coll,k,v){\nif((!((coll \x3d\x3d null)))){\nreturn cljs.core._assoc(coll,k,v);\n} else {\nreturn cljs.core.PersistentArrayMap.createAsIfByAssoc([k,v]);\n}\n});\n\ncljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic \x3d (function (coll,k,v,kvs){\nwhile(true){\nvar ret \x3d cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(coll,k,v);\nif(cljs.core.truth_(kvs)){\nvar G__9628 \x3d ret;\nvar G__9629 \x3d cljs.core.first(kvs);\nvar G__9630 \x3d cljs.core.second(kvs);\nvar G__9631 \x3d cljs.core.nnext(kvs);\ncoll \x3d G__9628;\nk \x3d G__9629;\nv \x3d G__9630;\nkvs \x3d G__9631;\ncontinue;\n} else {\nreturn ret;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.assoc.cljs$lang$applyTo \x3d (function (seq9619){\nvar G__9620 \x3d cljs.core.first(seq9619);\nvar seq9619__$1 \x3d cljs.core.next(seq9619);\nvar G__9621 \x3d cljs.core.first(seq9619__$1);\nvar seq9619__$2 \x3d cljs.core.next(seq9619__$1);\nvar G__9622 \x3d cljs.core.first(seq9619__$2);\nvar seq9619__$3 \x3d cljs.core.next(seq9619__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9620,G__9621,G__9622,seq9619__$3);\n});\n\ncljs.core.assoc.cljs$lang$maxFixedArity \x3d (3);\n\n/**\n * dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n *   that does not contain a mapping for key(s).\n */\ncljs.core.dissoc \x3d (function cljs$core$dissoc(var_args){\nvar G__9636 \x3d arguments.length;\nswitch (G__9636) {\ncase 1:\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9638 \x3d arguments.length;\nvar i__4731__auto___9639 \x3d (0);\nwhile(true){\nif((i__4731__auto___9639 \x3c len__4730__auto___9638)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9639]));\n\nvar G__9640 \x3d (i__4731__auto___9639 + (1));\ni__4731__auto___9639 \x3d G__9640;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.dissoc.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nreturn coll;\n});\n\ncljs.core.dissoc.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,k){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core._dissoc(coll,k);\n}\n});\n\ncljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic \x3d (function (coll,k,ks){\nwhile(true){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nvar ret \x3d cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(coll,k);\nif(cljs.core.truth_(ks)){\nvar G__9641 \x3d ret;\nvar G__9642 \x3d cljs.core.first(ks);\nvar G__9643 \x3d cljs.core.next(ks);\ncoll \x3d G__9641;\nk \x3d G__9642;\nks \x3d G__9643;\ncontinue;\n} else {\nreturn ret;\n}\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.dissoc.cljs$lang$applyTo \x3d (function (seq9633){\nvar G__9634 \x3d cljs.core.first(seq9633);\nvar seq9633__$1 \x3d cljs.core.next(seq9633);\nvar G__9635 \x3d cljs.core.first(seq9633__$1);\nvar seq9633__$2 \x3d cljs.core.next(seq9633__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9634,G__9635,seq9633__$2);\n});\n\ncljs.core.dissoc.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Return true if f is a JavaScript function or satisfies the Fn protocol.\n */\ncljs.core.fn_QMARK_ \x3d (function cljs$core$fn_QMARK_(f){\nvar or__4131__auto__ \x3d goog.isFunction(f);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nif((!((f \x3d\x3d null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d f.cljs$core$Fn$)))){\nreturn true;\n} else {\nif((!f.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.Fn,f);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.Fn,f);\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.Fn}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.MetaFn \x3d (function (afn,meta){\nthis.afn \x3d afn;\nthis.meta \x3d meta;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 393217;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.MetaFn.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (_,new_meta){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.MetaFn(self__.afn,new_meta));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$Fn$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.MetaFn.prototype.call \x3d (function() {\nvar G__9647 \x3d null;\nvar G__9647__1 \x3d (function (self__){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$0 ? self__.afn.cljs$core$IFn$_invoke$arity$0() : self__.afn.call(null));\n});\nvar G__9647__2 \x3d (function (self__,a){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$1 ? self__.afn.cljs$core$IFn$_invoke$arity$1(a) : self__.afn.call(null,a));\n});\nvar G__9647__3 \x3d (function (self__,a,b){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$2 ? self__.afn.cljs$core$IFn$_invoke$arity$2(a,b) : self__.afn.call(null,a,b));\n});\nvar G__9647__4 \x3d (function (self__,a,b,c){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$3 ? self__.afn.cljs$core$IFn$_invoke$arity$3(a,b,c) : self__.afn.call(null,a,b,c));\n});\nvar G__9647__5 \x3d (function (self__,a,b,c,d){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$4 ? self__.afn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : self__.afn.call(null,a,b,c,d));\n});\nvar G__9647__6 \x3d (function (self__,a,b,c,d,e){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$5 ? self__.afn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : self__.afn.call(null,a,b,c,d,e));\n});\nvar G__9647__7 \x3d (function (self__,a,b,c,d,e,f){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$6 ? self__.afn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : self__.afn.call(null,a,b,c,d,e,f));\n});\nvar G__9647__8 \x3d (function (self__,a,b,c,d,e,f,g){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$7 ? self__.afn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : self__.afn.call(null,a,b,c,d,e,f,g));\n});\nvar G__9647__9 \x3d (function (self__,a,b,c,d,e,f,g,h){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$8 ? self__.afn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : self__.afn.call(null,a,b,c,d,e,f,g,h));\n});\nvar G__9647__10 \x3d (function (self__,a,b,c,d,e,f,g,h,i){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$9 ? self__.afn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : self__.afn.call(null,a,b,c,d,e,f,g,h,i));\n});\nvar G__9647__11 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$10 ? self__.afn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j));\n});\nvar G__9647__12 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$11 ? self__.afn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\nvar G__9647__13 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$12 ? self__.afn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\nvar G__9647__14 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$13 ? self__.afn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\nvar G__9647__15 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$14 ? self__.afn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\nvar G__9647__16 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$15 ? self__.afn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\nvar G__9647__17 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$16 ? self__.afn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\nvar G__9647__18 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$17 ? self__.afn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\nvar G__9647__19 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$18 ? self__.afn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\nvar G__9647__20 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$19 ? self__.afn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\nvar G__9647__21 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$20 ? self__.afn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\nvar G__9647__22 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar _ \x3d self____$1;\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(self__.afn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\nG__9647 \x3d function(self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nswitch(arguments.length){\ncase 1:\nreturn G__9647__1.call(this,self__);\ncase 2:\nreturn G__9647__2.call(this,self__,a);\ncase 3:\nreturn G__9647__3.call(this,self__,a,b);\ncase 4:\nreturn G__9647__4.call(this,self__,a,b,c);\ncase 5:\nreturn G__9647__5.call(this,self__,a,b,c,d);\ncase 6:\nreturn G__9647__6.call(this,self__,a,b,c,d,e);\ncase 7:\nreturn G__9647__7.call(this,self__,a,b,c,d,e,f);\ncase 8:\nreturn G__9647__8.call(this,self__,a,b,c,d,e,f,g);\ncase 9:\nreturn G__9647__9.call(this,self__,a,b,c,d,e,f,g,h);\ncase 10:\nreturn G__9647__10.call(this,self__,a,b,c,d,e,f,g,h,i);\ncase 11:\nreturn G__9647__11.call(this,self__,a,b,c,d,e,f,g,h,i,j);\ncase 12:\nreturn G__9647__12.call(this,self__,a,b,c,d,e,f,g,h,i,j,k);\ncase 13:\nreturn G__9647__13.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l);\ncase 14:\nreturn G__9647__14.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m);\ncase 15:\nreturn G__9647__15.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n);\ncase 16:\nreturn G__9647__16.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);\ncase 17:\nreturn G__9647__17.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);\ncase 18:\nreturn G__9647__18.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);\ncase 19:\nreturn G__9647__19.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r);\ncase 20:\nreturn G__9647__20.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s);\ncase 21:\nreturn G__9647__21.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t);\ncase 22:\nreturn G__9647__22.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__9647.cljs$core$IFn$_invoke$arity$1 \x3d G__9647__1;\nG__9647.cljs$core$IFn$_invoke$arity$2 \x3d G__9647__2;\nG__9647.cljs$core$IFn$_invoke$arity$3 \x3d G__9647__3;\nG__9647.cljs$core$IFn$_invoke$arity$4 \x3d G__9647__4;\nG__9647.cljs$core$IFn$_invoke$arity$5 \x3d G__9647__5;\nG__9647.cljs$core$IFn$_invoke$arity$6 \x3d G__9647__6;\nG__9647.cljs$core$IFn$_invoke$arity$7 \x3d G__9647__7;\nG__9647.cljs$core$IFn$_invoke$arity$8 \x3d G__9647__8;\nG__9647.cljs$core$IFn$_invoke$arity$9 \x3d G__9647__9;\nG__9647.cljs$core$IFn$_invoke$arity$10 \x3d G__9647__10;\nG__9647.cljs$core$IFn$_invoke$arity$11 \x3d G__9647__11;\nG__9647.cljs$core$IFn$_invoke$arity$12 \x3d G__9647__12;\nG__9647.cljs$core$IFn$_invoke$arity$13 \x3d G__9647__13;\nG__9647.cljs$core$IFn$_invoke$arity$14 \x3d G__9647__14;\nG__9647.cljs$core$IFn$_invoke$arity$15 \x3d G__9647__15;\nG__9647.cljs$core$IFn$_invoke$arity$16 \x3d G__9647__16;\nG__9647.cljs$core$IFn$_invoke$arity$17 \x3d G__9647__17;\nG__9647.cljs$core$IFn$_invoke$arity$18 \x3d G__9647__18;\nG__9647.cljs$core$IFn$_invoke$arity$19 \x3d G__9647__19;\nG__9647.cljs$core$IFn$_invoke$arity$20 \x3d G__9647__20;\nG__9647.cljs$core$IFn$_invoke$arity$21 \x3d G__9647__21;\nG__9647.cljs$core$IFn$_invoke$arity$22 \x3d G__9647__22;\nreturn G__9647;\n})()\n;\n\ncljs.core.MetaFn.prototype.apply \x3d (function (self__,args9646){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args9646)));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$0 ? self__.afn.cljs$core$IFn$_invoke$arity$0() : self__.afn.call(null));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (a){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$1 ? self__.afn.cljs$core$IFn$_invoke$arity$1(a) : self__.afn.call(null,a));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (a,b){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$2 ? self__.afn.cljs$core$IFn$_invoke$arity$2(a,b) : self__.afn.call(null,a,b));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$3 \x3d (function (a,b,c){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$3 ? self__.afn.cljs$core$IFn$_invoke$arity$3(a,b,c) : self__.afn.call(null,a,b,c));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$4 \x3d (function (a,b,c,d){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$4 ? self__.afn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : self__.afn.call(null,a,b,c,d));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$5 \x3d (function (a,b,c,d,e){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$5 ? self__.afn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : self__.afn.call(null,a,b,c,d,e));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$6 \x3d (function (a,b,c,d,e,f){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$6 ? self__.afn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : self__.afn.call(null,a,b,c,d,e,f));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$7 \x3d (function (a,b,c,d,e,f,g){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$7 ? self__.afn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : self__.afn.call(null,a,b,c,d,e,f,g));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$8 \x3d (function (a,b,c,d,e,f,g,h){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$8 ? self__.afn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : self__.afn.call(null,a,b,c,d,e,f,g,h));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$9 \x3d (function (a,b,c,d,e,f,g,h,i){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$9 ? self__.afn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : self__.afn.call(null,a,b,c,d,e,f,g,h,i));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$10 \x3d (function (a,b,c,d,e,f,g,h,i,j){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$10 ? self__.afn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$11 \x3d (function (a,b,c,d,e,f,g,h,i,j,k){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$11 ? self__.afn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$12 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$12 ? self__.afn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$13 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$13 ? self__.afn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$14 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$14 ? self__.afn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$15 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$15 ? self__.afn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$16 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$16 ? self__.afn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$17 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$17 ? self__.afn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$18 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$18 ? self__.afn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$19 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$19 ? self__.afn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$20 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$20 ? self__.afn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$21 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(self__.afn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\n\ncljs.core.MetaFn.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$afn,cljs.core.cst$sym$meta], null);\n});\n\ncljs.core.MetaFn.cljs$lang$type \x3d true;\n\ncljs.core.MetaFn.cljs$lang$ctorStr \x3d "cljs.core/MetaFn";\n\ncljs.core.MetaFn.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/MetaFn");\n});\n\n/**\n * Positional factory function for cljs.core/MetaFn.\n */\ncljs.core.__GT_MetaFn \x3d (function cljs$core$__GT_MetaFn(afn,meta){\nreturn (new cljs.core.MetaFn(afn,meta));\n});\n\n/**\n * Returns an object of the same type and value as obj, with\n *   map m as its metadata.\n */\ncljs.core.with_meta \x3d (function cljs$core$with_meta(o,meta){\nif(goog.isFunction(o)){\nreturn (new cljs.core.MetaFn(o,meta));\n} else {\nif((o \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core._with_meta(o,meta);\n}\n}\n});\n/**\n * Returns the metadata of obj, returns nil if there is no metadata.\n */\ncljs.core.meta \x3d (function cljs$core$meta(o){\nif((function (){var and__4120__auto__ \x3d (!((o \x3d\x3d null)));\nif(and__4120__auto__){\nif((!((o \x3d\x3d null)))){\nif((((o.cljs$lang$protocol_mask$partition0$ \x26 (131072))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d o.cljs$core$IMeta$)))){\nreturn true;\n} else {\nif((!o.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IMeta,o);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IMeta,o);\n}\n} else {\nreturn and__4120__auto__;\n}\n})()){\nreturn cljs.core._meta(o);\n} else {\nreturn null;\n}\n});\n/**\n * For a list or queue, same as first, for a vector, same as, but much\n *   more efficient than, last. If the collection is empty, returns nil.\n */\ncljs.core.peek \x3d (function cljs$core$peek(coll){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core._peek(coll);\n}\n});\n/**\n * For a list or queue, returns a new list/queue without the first\n *   item, for a vector, returns a new vector without the last item.\n *   Note - not the same as next/butlast.\n */\ncljs.core.pop \x3d (function cljs$core$pop(coll){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core._pop(coll);\n}\n});\n/**\n * disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n *   does not contain key(s).\n */\ncljs.core.disj \x3d (function cljs$core$disj(var_args){\nvar G__9654 \x3d arguments.length;\nswitch (G__9654) {\ncase 1:\nreturn cljs.core.disj.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.disj.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9656 \x3d arguments.length;\nvar i__4731__auto___9657 \x3d (0);\nwhile(true){\nif((i__4731__auto___9657 \x3c len__4730__auto___9656)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9657]));\n\nvar G__9658 \x3d (i__4731__auto___9657 + (1));\ni__4731__auto___9657 \x3d G__9658;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.disj.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.disj.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nreturn coll;\n});\n\ncljs.core.disj.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,k){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core._disjoin(coll,k);\n}\n});\n\ncljs.core.disj.cljs$core$IFn$_invoke$arity$variadic \x3d (function (coll,k,ks){\nwhile(true){\nif((coll \x3d\x3d null)){\nreturn null;\n} else {\nvar ret \x3d cljs.core.disj.cljs$core$IFn$_invoke$arity$2(coll,k);\nif(cljs.core.truth_(ks)){\nvar G__9659 \x3d ret;\nvar G__9660 \x3d cljs.core.first(ks);\nvar G__9661 \x3d cljs.core.next(ks);\ncoll \x3d G__9659;\nk \x3d G__9660;\nks \x3d G__9661;\ncontinue;\n} else {\nreturn ret;\n}\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.disj.cljs$lang$applyTo \x3d (function (seq9651){\nvar G__9652 \x3d cljs.core.first(seq9651);\nvar seq9651__$1 \x3d cljs.core.next(seq9651);\nvar G__9653 \x3d cljs.core.first(seq9651__$1);\nvar seq9651__$2 \x3d cljs.core.next(seq9651__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9652,G__9653,seq9651__$2);\n});\n\ncljs.core.disj.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns true if coll has no items - same as (not (seq coll)).\n *   Please use the idiom (seq x) rather than (not (empty? x))\n */\ncljs.core.empty_QMARK_ \x3d (function cljs$core$empty_QMARK_(coll){\nreturn (((coll \x3d\x3d null)) || (cljs.core.not(cljs.core.seq(coll))));\n});\n/**\n * Returns true if x satisfies ICollection\n */\ncljs.core.coll_QMARK_ \x3d (function cljs$core$coll_QMARK_(x){\nif((x \x3d\x3d null)){\nreturn false;\n} else {\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (8))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$ICollection$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICollection,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICollection,x);\n}\n}\n});\n/**\n * Returns true if x satisfies ISet\n */\ncljs.core.set_QMARK_ \x3d (function cljs$core$set_QMARK_(x){\nif((x \x3d\x3d null)){\nreturn false;\n} else {\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (4096))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$ISet$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISet,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISet,x);\n}\n}\n});\n/**\n * Returns true if coll implements IAssociative\n */\ncljs.core.associative_QMARK_ \x3d (function cljs$core$associative_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (512))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IAssociative$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IAssociative,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IAssociative,x);\n}\n});\n/**\n * Returns true if coll implements IFind\n */\ncljs.core.ifind_QMARK_ \x3d (function cljs$core$ifind_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IFind$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IFind,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IFind,x);\n}\n});\n/**\n * Returns true if coll satisfies ISequential\n */\ncljs.core.sequential_QMARK_ \x3d (function cljs$core$sequential_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (16777216))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$ISequential$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISequential,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISequential,x);\n}\n});\n/**\n * Returns true if coll satisfies ISorted\n */\ncljs.core.sorted_QMARK_ \x3d (function cljs$core$sorted_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (268435456))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$ISorted$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISorted,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISorted,x);\n}\n});\n/**\n * Returns true if coll satisfies IReduce\n */\ncljs.core.reduceable_QMARK_ \x3d (function cljs$core$reduceable_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (524288))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IReduce$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IReduce,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IReduce,x);\n}\n});\n/**\n * Return true if x satisfies IMap\n */\ncljs.core.map_QMARK_ \x3d (function cljs$core$map_QMARK_(x){\nif((x \x3d\x3d null)){\nreturn false;\n} else {\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (1024))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IMap$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IMap,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IMap,x);\n}\n}\n});\n/**\n * Return true if x satisfies IRecord\n */\ncljs.core.record_QMARK_ \x3d (function cljs$core$record_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (67108864))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IRecord$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IRecord,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IRecord,x);\n}\n});\n/**\n * Return true if x satisfies IVector\n */\ncljs.core.vector_QMARK_ \x3d (function cljs$core$vector_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (16384))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IVector$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IVector,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IVector,x);\n}\n});\n\n/**\n * Return true if x is satisfies IChunkedSeq.\n */\ncljs.core.chunked_seq_QMARK_ \x3d (function cljs$core$chunked_seq_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition1$ \x26 (512))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IChunkedSeq$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n});\n/**\n * Create JavaSript object from an even number arguments representing\n *   interleaved keys and values.\n */\ncljs.core.js_obj \x3d (function cljs$core$js_obj(var_args){\nvar G__9675 \x3d arguments.length;\nswitch (G__9675) {\ncase 0:\nreturn cljs.core.js_obj.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9679 \x3d arguments.length;\nvar i__4731__auto___9680 \x3d (0);\nwhile(true){\nif((i__4731__auto___9680 \x3c len__4730__auto___9679)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9680]));\n\nvar G__9681 \x3d (i__4731__auto___9680 + (1));\ni__4731__auto___9680 \x3d G__9681;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((0)),(0),null));\nreturn cljs.core.js_obj.cljs$core$IFn$_invoke$arity$variadic(argseq__4752__auto__);\n\n}\n});\n\ncljs.core.js_obj.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn ({});\n});\n\ncljs.core.js_obj.cljs$core$IFn$_invoke$arity$variadic \x3d (function (keyvals){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(goog.object.create,keyvals);\n});\n\n/** @this {Function} */\ncljs.core.js_obj.cljs$lang$applyTo \x3d (function (seq9674){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq9674));\n});\n\ncljs.core.js_obj.cljs$lang$maxFixedArity \x3d (0);\n\n/**\n * Return the JavaScript keys for an object.\n */\ncljs.core.js_keys \x3d (function cljs$core$js_keys(obj){\nreturn goog.object.getKeys(obj);\n});\n/**\n * Delete a property from a JavaScript object.\n *   Returns true upon success, false otherwise.\n */\ncljs.core.js_delete \x3d (function cljs$core$js_delete(obj,key){\nreturn delete obj[key];\n});\ncljs.core.array_copy \x3d (function cljs$core$array_copy(from,i,to,j,len){\nvar i__$1 \x3d i;\nvar j__$1 \x3d j;\nvar len__$1 \x3d len;\nwhile(true){\nif((len__$1 \x3d\x3d\x3d (0))){\nreturn to;\n} else {\n(to[j__$1] \x3d (from[i__$1]));\n\nvar G__9682 \x3d (i__$1 + (1));\nvar G__9683 \x3d (j__$1 + (1));\nvar G__9684 \x3d (len__$1 - (1));\ni__$1 \x3d G__9682;\nj__$1 \x3d G__9683;\nlen__$1 \x3d G__9684;\ncontinue;\n}\nbreak;\n}\n});\ncljs.core.array_copy_downward \x3d (function cljs$core$array_copy_downward(from,i,to,j,len){\nvar i__$1 \x3d (i + (len - (1)));\nvar j__$1 \x3d (j + (len - (1)));\nvar len__$1 \x3d len;\nwhile(true){\nif((len__$1 \x3d\x3d\x3d (0))){\nreturn to;\n} else {\n(to[j__$1] \x3d (from[i__$1]));\n\nvar G__9685 \x3d (i__$1 - (1));\nvar G__9686 \x3d (j__$1 - (1));\nvar G__9687 \x3d (len__$1 - (1));\ni__$1 \x3d G__9685;\nj__$1 \x3d G__9686;\nlen__$1 \x3d G__9687;\ncontinue;\n}\nbreak;\n}\n});\ncljs.core.lookup_sentinel \x3d ({});\n/**\n * Returns true if x is the value false, false otherwise.\n */\ncljs.core.false_QMARK_ \x3d (function cljs$core$false_QMARK_(x){\nreturn x \x3d\x3d\x3d false;\n});\n/**\n * Returns true if x is the value true, false otherwise.\n */\ncljs.core.true_QMARK_ \x3d (function cljs$core$true_QMARK_(x){\nreturn x \x3d\x3d\x3d true;\n});\n/**\n * Return true if x is a Boolean\n */\ncljs.core.boolean_QMARK_ \x3d (function cljs$core$boolean_QMARK_(x){\nreturn ((x \x3d\x3d\x3d true) || (x \x3d\x3d\x3d false));\n});\n/**\n * Returns true if x identical to the JavaScript undefined value.\n */\ncljs.core.undefined_QMARK_ \x3d (function cljs$core$undefined_QMARK_(x){\nreturn (void 0 \x3d\x3d\x3d x);\n});\n/**\n * Return true if s satisfies ISeq\n */\ncljs.core.seq_QMARK_ \x3d (function cljs$core$seq_QMARK_(s){\nif((s \x3d\x3d null)){\nreturn false;\n} else {\nif((!((s \x3d\x3d null)))){\nif((((s.cljs$lang$protocol_mask$partition0$ \x26 (64))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d s.cljs$core$ISeq$)))){\nreturn true;\n} else {\nif((!s.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISeq,s);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISeq,s);\n}\n}\n});\n/**\n * Return true if the seq function is supported for s\n */\ncljs.core.seqable_QMARK_ \x3d (function cljs$core$seqable_QMARK_(s){\nvar or__4131__auto__ \x3d (s \x3d\x3d null);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (((!((s \x3d\x3d null))))?(((((s.cljs$lang$protocol_mask$partition0$ \x26 (8388608))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d s.cljs$core$ISeqable$))))?true:(((!s.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.ISeqable,s):false)):cljs.core.native_satisfies_QMARK_(cljs.core.ISeqable,s));\nif(or__4131__auto____$1){\nreturn or__4131__auto____$1;\n} else {\nreturn ((cljs.core.array_QMARK_(s)) || (typeof s \x3d\x3d\x3d \'string\'));\n}\n}\n});\n/**\n * Coerce to boolean\n */\ncljs.core.boolean$ \x3d (function cljs$core$boolean(x){\nif((x \x3d\x3d null)){\nreturn false;\n} else {\nif(x \x3d\x3d\x3d false){\nreturn false;\n} else {\nreturn true;\n\n}\n}\n});\n/**\n * Returns true if f returns true for fn? or satisfies IFn.\n */\ncljs.core.ifn_QMARK_ \x3d (function cljs$core$ifn_QMARK_(f){\nvar or__4131__auto__ \x3d cljs.core.fn_QMARK_(f);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nif((!((f \x3d\x3d null)))){\nif((((f.cljs$lang$protocol_mask$partition0$ \x26 (1))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d f.cljs$core$IFn$)))){\nreturn true;\n} else {\nif((!f.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IFn,f);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IFn,f);\n}\n}\n});\n/**\n * Returns true if n is a JavaScript number with no decimal part.\n */\ncljs.core.integer_QMARK_ \x3d (function cljs$core$integer_QMARK_(n){\nreturn ((typeof n \x3d\x3d\x3d \'number\') \x26\x26 ((!(isNaN(n)))) \x26\x26 ((!((n \x3d\x3d\x3d Infinity)))) \x26\x26 ((parseFloat(n) \x3d\x3d\x3d parseInt(n,(10)))));\n});\n/**\n * Return true if x satisfies integer? or is an instance of goog.math.Integer\n * or goog.math.Long.\n */\ncljs.core.int_QMARK_ \x3d (function cljs$core$int_QMARK_(x){\nreturn ((cljs.core.integer_QMARK_(x)) || ((x instanceof goog.math.Integer)) || ((x instanceof goog.math.Long)));\n});\n/**\n * Return true if x satisfies int? and is positive.\n */\ncljs.core.pos_int_QMARK_ \x3d (function cljs$core$pos_int_QMARK_(x){\nif(cljs.core.integer_QMARK_(x)){\nreturn (x \x3e (0));\n} else {\nif((x instanceof goog.math.Integer)){\nreturn ((cljs.core.not(x.isNegative())) \x26\x26 (cljs.core.not(x.isZero())));\n} else {\nif((x instanceof goog.math.Long)){\nreturn ((cljs.core.not(x.isNegative())) \x26\x26 (cljs.core.not(x.isZero())));\n} else {\nreturn false;\n\n}\n}\n}\n});\n/**\n * Return true if x satisfies int? and is negative.\n */\ncljs.core.neg_int_QMARK_ \x3d (function cljs$core$neg_int_QMARK_(x){\nif(cljs.core.integer_QMARK_(x)){\nreturn (x \x3c (0));\n} else {\nif((x instanceof goog.math.Integer)){\nreturn x.isNegative();\n} else {\nif((x instanceof goog.math.Long)){\nreturn x.isNegative();\n} else {\nreturn false;\n\n}\n}\n}\n});\n/**\n * Return true if x satisfies int? and is a natural integer value.\n */\ncljs.core.nat_int_QMARK_ \x3d (function cljs$core$nat_int_QMARK_(x){\nif(cljs.core.integer_QMARK_(x)){\nreturn (!((x \x3c (0))));\n} else {\nif((x instanceof goog.math.Integer)){\nreturn cljs.core.not(x.isNegative());\n} else {\nif((x instanceof goog.math.Long)){\nreturn cljs.core.not(x.isNegative());\n} else {\nreturn false;\n\n}\n}\n}\n});\n/**\n * Returns true for JavaScript numbers, false otherwise.\n */\ncljs.core.float_QMARK_ \x3d (function cljs$core$float_QMARK_(x){\nreturn typeof x \x3d\x3d\x3d \'number\';\n});\n/**\n * Returns true for JavaScript numbers, false otherwise.\n */\ncljs.core.double_QMARK_ \x3d (function cljs$core$double_QMARK_(x){\nreturn typeof x \x3d\x3d\x3d \'number\';\n});\n/**\n * Returns true for Infinity and -Infinity values.\n */\ncljs.core.infinite_QMARK_ \x3d (function cljs$core$infinite_QMARK_(x){\nreturn (((x \x3d\x3d\x3d Number.POSITIVE_INFINITY)) || ((x \x3d\x3d\x3d Number.NEGATIVE_INFINITY)));\n});\n/**\n * Returns true if key is present in the given collection, otherwise\n *   returns false.  Note that for numerically indexed collections like\n *   vectors and arrays, this tests if the numeric key is within the\n *   range of indexes. \'contains?\' operates constant or logarithmic time;\n *   it will not perform a linear search for a value.  See also \'some\'.\n */\ncljs.core.contains_QMARK_ \x3d (function cljs$core$contains_QMARK_(coll,v){\nif((cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,v,cljs.core.lookup_sentinel) \x3d\x3d\x3d cljs.core.lookup_sentinel)){\nreturn false;\n} else {\nreturn true;\n}\n});\n/**\n * Returns the map entry for key, or nil if key not present.\n */\ncljs.core.find \x3d (function cljs$core$find(coll,k){\nif(cljs.core.ifind_QMARK_(coll)){\nreturn cljs.core._find(coll,k);\n} else {\nif((((!((coll \x3d\x3d null)))) \x26\x26 (cljs.core.associative_QMARK_(coll)) \x26\x26 (cljs.core.contains_QMARK_(coll,k)))){\nreturn (new cljs.core.MapEntry(k,cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,k),null));\n} else {\nreturn null;\n}\n}\n});\n/**\n * Returns true if no two of the arguments are \x3d\n */\ncljs.core.distinct_QMARK_ \x3d (function cljs$core$distinct_QMARK_(var_args){\nvar G__9700 \x3d arguments.length;\nswitch (G__9700) {\ncase 1:\nreturn cljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9702 \x3d arguments.length;\nvar i__4731__auto___9703 \x3d (0);\nwhile(true){\nif((i__4731__auto___9703 \x3c len__4730__auto___9702)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9703]));\n\nvar G__9704 \x3d (i__4731__auto___9703 + (1));\ni__4731__auto___9703 \x3d G__9704;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn true;\n});\n\ncljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)));\n});\n\ncljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nif((!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)))){\nvar s \x3d cljs.core.PersistentHashSet.createAsIfByAssoc([x,y]);\nvar xs \x3d more;\nwhile(true){\nvar x__$1 \x3d cljs.core.first(xs);\nvar etc \x3d cljs.core.next(xs);\nif(cljs.core.truth_(xs)){\nif(cljs.core.contains_QMARK_(s,x__$1)){\nreturn false;\n} else {\nvar G__9705 \x3d cljs.core.conj.cljs$core$IFn$_invoke$arity$2(s,x__$1);\nvar G__9706 \x3d etc;\ns \x3d G__9705;\nxs \x3d G__9706;\ncontinue;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n} else {\nreturn false;\n}\n});\n\n/** @this {Function} */\ncljs.core.distinct_QMARK_.cljs$lang$applyTo \x3d (function (seq9697){\nvar G__9698 \x3d cljs.core.first(seq9697);\nvar seq9697__$1 \x3d cljs.core.next(seq9697);\nvar G__9699 \x3d cljs.core.first(seq9697__$1);\nvar seq9697__$2 \x3d cljs.core.next(seq9697__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9698,G__9699,seq9697__$2);\n});\n\ncljs.core.distinct_QMARK_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Comparator. Returns a negative number, zero, or a positive number\n *   when x is logically \'less than\', \'equal to\', or \'greater than\'\n *   y. Uses IComparable if available and google.array.defaultCompare for objects\n *  of the same type and special-cases nil to be less than any other object.\n */\ncljs.core.compare \x3d (function cljs$core$compare(x,y){\nif((x \x3d\x3d\x3d y)){\nreturn (0);\n} else {\nif((x \x3d\x3d null)){\nreturn (-1);\n} else {\nif((y \x3d\x3d null)){\nreturn (1);\n} else {\nif(typeof x \x3d\x3d\x3d \'number\'){\nif(typeof y \x3d\x3d\x3d \'number\'){\nreturn goog.array.defaultCompare(x,y);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join(\'\')));\n}\n} else {\nif((((!((x \x3d\x3d null))))?(((((x.cljs$lang$protocol_mask$partition1$ \x26 (2048))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IComparable$))))?true:(((!x.cljs$lang$protocol_mask$partition1$))?cljs.core.native_satisfies_QMARK_(cljs.core.IComparable,x):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IComparable,x))){\nreturn cljs.core._compare(x,y);\n} else {\nif(((((typeof x \x3d\x3d\x3d \'string\') || (cljs.core.array_QMARK_(x)) || (x \x3d\x3d\x3d true) || (x \x3d\x3d\x3d false))) \x26\x26 ((cljs.core.type(x) \x3d\x3d\x3d cljs.core.type(y))))){\nreturn goog.array.defaultCompare(x,y);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join(\'\')));\n}\n\n}\n}\n}\n}\n}\n});\n/**\n * Compare indexed collection.\n */\ncljs.core.compare_indexed \x3d (function cljs$core$compare_indexed(var_args){\nvar G__9709 \x3d arguments.length;\nswitch (G__9709) {\ncase 2:\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 4:\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2 \x3d (function (xs,ys){\nvar xl \x3d cljs.core.count(xs);\nvar yl \x3d cljs.core.count(ys);\nif((xl \x3c yl)){\nreturn (-1);\n} else {\nif((xl \x3e yl)){\nreturn (1);\n} else {\nif((xl \x3d\x3d\x3d (0))){\nreturn (0);\n} else {\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$4(xs,ys,xl,(0));\n\n}\n}\n}\n});\n\ncljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$4 \x3d (function (xs,ys,len,n){\nwhile(true){\nvar d \x3d cljs.core.compare(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(xs,n),cljs.core.nth.cljs$core$IFn$_invoke$arity$2(ys,n));\nif((((d \x3d\x3d\x3d (0))) \x26\x26 (((n + (1)) \x3c len)))){\nvar G__9711 \x3d xs;\nvar G__9712 \x3d ys;\nvar G__9713 \x3d len;\nvar G__9714 \x3d (n + (1));\nxs \x3d G__9711;\nys \x3d G__9712;\nlen \x3d G__9713;\nn \x3d G__9714;\ncontinue;\n} else {\nreturn d;\n}\nbreak;\n}\n});\n\ncljs.core.compare_indexed.cljs$lang$maxFixedArity \x3d 4;\n\n/**\n * Given a fn that might be boolean valued or a comparator,\n * return a fn that is a comparator.\n */\ncljs.core.fn__GT_comparator \x3d (function cljs$core$fn__GT_comparator(f){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(f,cljs.core.compare)){\nreturn cljs.core.compare;\n} else {\nreturn (function (x,y){\nvar r \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y));\nif(typeof r \x3d\x3d\x3d \'number\'){\nreturn r;\n} else {\nif(cljs.core.truth_(r)){\nreturn (-1);\n} else {\nif(cljs.core.truth_((f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(y,x) : f.call(null,y,x)))){\nreturn (1);\n} else {\nreturn (0);\n}\n}\n}\n});\n}\n});\n/**\n * Returns a sorted sequence of the items in coll. Comp can be\n * boolean-valued comparison function, or a -/0/+ valued comparator.\n * Comp defaults to compare.\n */\ncljs.core.sort \x3d (function cljs$core$sort(var_args){\nvar G__9716 \x3d arguments.length;\nswitch (G__9716) {\ncase 1:\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.sort.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2(cljs.core.compare,coll);\n});\n\ncljs.core.sort.cljs$core$IFn$_invoke$arity$2 \x3d (function (comp,coll){\nif(cljs.core.seq(coll)){\nvar a \x3d cljs.core.to_array(coll);\nvar G__9717_9720 \x3d a;\nvar G__9718_9721 \x3d cljs.core.fn__GT_comparator(comp);\ngoog.array.stableSort(G__9717_9720,G__9718_9721);\n\nreturn cljs.core.seq(a);\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.sort.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a sorted sequence of the items in coll, where the sort\n * order is determined by comparing (keyfn item).  Comp can be\n * boolean-valued comparison function, or a -/0/+ valued comparator.\n * Comp defaults to compare.\n */\ncljs.core.sort_by \x3d (function cljs$core$sort_by(var_args){\nvar G__9723 \x3d arguments.length;\nswitch (G__9723) {\ncase 2:\nreturn cljs.core.sort_by.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.sort_by.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.sort_by.cljs$core$IFn$_invoke$arity$2 \x3d (function (keyfn,coll){\nreturn cljs.core.sort_by.cljs$core$IFn$_invoke$arity$3(keyfn,cljs.core.compare,coll);\n});\n\ncljs.core.sort_by.cljs$core$IFn$_invoke$arity$3 \x3d (function (keyfn,comp,coll){\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2((function (x,y){\nvar G__9725 \x3d (keyfn.cljs$core$IFn$_invoke$arity$1 ? keyfn.cljs$core$IFn$_invoke$arity$1(x) : keyfn.call(null,x));\nvar G__9726 \x3d (keyfn.cljs$core$IFn$_invoke$arity$1 ? keyfn.cljs$core$IFn$_invoke$arity$1(y) : keyfn.call(null,y));\nvar fexpr__9724 \x3d cljs.core.fn__GT_comparator(comp);\nreturn (fexpr__9724.cljs$core$IFn$_invoke$arity$2 ? fexpr__9724.cljs$core$IFn$_invoke$arity$2(G__9725,G__9726) : fexpr__9724.call(null,G__9725,G__9726));\n}),coll);\n});\n\ncljs.core.sort_by.cljs$lang$maxFixedArity \x3d 3;\n\ncljs.core.seq_reduce \x3d (function cljs$core$seq_reduce(var_args){\nvar G__9729 \x3d arguments.length;\nswitch (G__9729) {\ncase 2:\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,coll){\nvar temp__5718__auto__ \x3d cljs.core.seq(coll);\nif(temp__5718__auto__){\nvar s \x3d temp__5718__auto__;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(f,cljs.core.first(s),cljs.core.next(s));\n} else {\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n}\n});\n\ncljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,val,coll){\nvar val__$1 \x3d val;\nvar coll__$1 \x3d cljs.core.seq(coll);\nwhile(true){\nif(coll__$1){\nvar nval \x3d (function (){var G__9730 \x3d val__$1;\nvar G__9731 \x3d cljs.core.first(coll__$1);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__9730,G__9731) : f.call(null,G__9730,G__9731));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__9733 \x3d nval;\nvar G__9734 \x3d cljs.core.next(coll__$1);\nval__$1 \x3d G__9733;\ncoll__$1 \x3d G__9734;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.seq_reduce.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Return a random permutation of coll\n */\ncljs.core.shuffle \x3d (function cljs$core$shuffle(coll){\nvar a \x3d cljs.core.to_array(coll);\ngoog.array.shuffle(a);\n\nreturn cljs.core.vec(a);\n});\ncljs.core.iter_reduce \x3d (function cljs$core$iter_reduce(var_args){\nvar G__9736 \x3d arguments.length;\nswitch (G__9736) {\ncase 2:\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,f){\nvar iter \x3d cljs.core._iterator(coll);\nif(cljs.core.truth_(iter.hasNext())){\nvar init \x3d iter.next();\nvar acc \x3d init;\nwhile(true){\nif(iter.hasNext()){\nvar nacc \x3d (function (){var G__9737 \x3d acc;\nvar G__9738 \x3d iter.next();\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__9737,G__9738) : f.call(null,G__9737,G__9738));\n})();\nif(cljs.core.reduced_QMARK_(nacc)){\nreturn cljs.core.deref(nacc);\n} else {\nvar G__9742 \x3d nacc;\nacc \x3d G__9742;\ncontinue;\n}\n} else {\nreturn acc;\n}\nbreak;\n}\n} else {\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n}\n});\n\ncljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$3 \x3d (function (coll,f,init){\nvar iter \x3d cljs.core._iterator(coll);\nvar acc \x3d init;\nwhile(true){\nif(iter.hasNext()){\nvar nacc \x3d (function (){var G__9739 \x3d acc;\nvar G__9740 \x3d iter.next();\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__9739,G__9740) : f.call(null,G__9739,G__9740));\n})();\nif(cljs.core.reduced_QMARK_(nacc)){\nreturn cljs.core.deref(nacc);\n} else {\nvar G__9743 \x3d nacc;\nacc \x3d G__9743;\ncontinue;\n}\n} else {\nreturn acc;\n}\nbreak;\n}\n});\n\ncljs.core.iter_reduce.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * f should be a function of 2 arguments. If val is not supplied,\n *   returns the result of applying f to the first 2 items in coll, then\n *   applying f to that result and the 3rd item, etc. If coll contains no\n *   items, f must accept no arguments as well, and reduce returns the\n *   result of calling f with no arguments.  If coll has only 1 item, it\n *   is returned and f is not called.  If val is supplied, returns the\n *   result of applying f to val and the first item in coll, then\n *   applying f to that result and the 2nd item, etc. If coll contains no\n *   items, returns val and f is not called.\n */\ncljs.core.reduce \x3d (function cljs$core$reduce(var_args){\nvar G__9745 \x3d arguments.length;\nswitch (G__9745) {\ncase 2:\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.reduce.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,coll){\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (524288))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$IReduce$))))?true:false):false)){\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nif(typeof coll \x3d\x3d\x3d \'string\'){\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.IReduce,coll)){\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nif(cljs.core.iterable_QMARK_(coll)){\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll);\n\n}\n}\n}\n}\n}\n});\n\ncljs.core.reduce.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,val,coll){\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (524288))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$IReduce$))))?true:false):false)){\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nif(typeof coll \x3d\x3d\x3d \'string\'){\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.IReduce,coll)){\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nif(cljs.core.iterable_QMARK_(coll)){\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,val,coll);\n\n}\n}\n}\n}\n}\n});\n\ncljs.core.reduce.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Reduces an associative collection. f should be a function of 3\n *   arguments. Returns the result of applying f to init, the first key\n *   and the first value in coll, then applying f to that result and the\n *   2nd key and value, etc. If coll contains no entries, returns init\n *   and f is not called. Note that reduce-kv is supported on vectors,\n *   where the keys will be the ordinals.\n */\ncljs.core.reduce_kv \x3d (function cljs$core$reduce_kv(f,init,coll){\nif((!((coll \x3d\x3d null)))){\nreturn cljs.core._kv_reduce(coll,f,init);\n} else {\nreturn init;\n}\n});\n/**\n * Returns its argument.\n */\ncljs.core.identity \x3d (function cljs$core$identity(x){\nreturn x;\n});\n/**\n * Takes a reducing function f of 2 args and returns a fn suitable for\n *   transduce by adding an arity-1 signature that calls cf (default -\n *   identity) on the result argument.\n */\ncljs.core.completing \x3d (function cljs$core$completing(var_args){\nvar G__9750 \x3d arguments.length;\nswitch (G__9750) {\ncase 1:\nreturn cljs.core.completing.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.completing.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.completing.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn cljs.core.completing.cljs$core$IFn$_invoke$arity$2(f,cljs.core.identity);\n});\n\ncljs.core.completing.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,cf){\nreturn (function() {\nvar G__9752 \x3d null;\nvar G__9752__0 \x3d (function (){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n});\nvar G__9752__1 \x3d (function (x){\nreturn (cf.cljs$core$IFn$_invoke$arity$1 ? cf.cljs$core$IFn$_invoke$arity$1(x) : cf.call(null,x));\n});\nvar G__9752__2 \x3d (function (x,y){\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y));\n});\nG__9752 \x3d function(x,y){\nswitch(arguments.length){\ncase 0:\nreturn G__9752__0.call(this);\ncase 1:\nreturn G__9752__1.call(this,x);\ncase 2:\nreturn G__9752__2.call(this,x,y);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__9752.cljs$core$IFn$_invoke$arity$0 \x3d G__9752__0;\nG__9752.cljs$core$IFn$_invoke$arity$1 \x3d G__9752__1;\nG__9752.cljs$core$IFn$_invoke$arity$2 \x3d G__9752__2;\nreturn G__9752;\n})()\n});\n\ncljs.core.completing.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * reduce with a transformation of f (xf). If init is not\n *   supplied, (f) will be called to produce it. f should be a reducing\n *   step function that accepts both 1 and 2 arguments, if it accepts\n *   only 2 you can add the arity-1 with \'completing\'. Returns the result\n *   of applying (the transformed) xf to init and the first item in coll,\n *   then applying xf to that result and the 2nd item, etc. If coll\n *   contains no items, returns init and f is not called. Note that\n *   certain transforms may inject or skip items.\n */\ncljs.core.transduce \x3d (function cljs$core$transduce(var_args){\nvar G__9754 \x3d arguments.length;\nswitch (G__9754) {\ncase 3:\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.transduce.cljs$core$IFn$_invoke$arity$3 \x3d (function (xform,f,coll){\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$4(xform,f,(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),coll);\n});\n\ncljs.core.transduce.cljs$core$IFn$_invoke$arity$4 \x3d (function (xform,f,init,coll){\nvar f__$1 \x3d (xform.cljs$core$IFn$_invoke$arity$1 ? xform.cljs$core$IFn$_invoke$arity$1(f) : xform.call(null,f));\nvar ret \x3d cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(f__$1,init,coll);\nreturn (f__$1.cljs$core$IFn$_invoke$arity$1 ? f__$1.cljs$core$IFn$_invoke$arity$1(ret) : f__$1.call(null,ret));\n});\n\ncljs.core.transduce.cljs$lang$maxFixedArity \x3d 4;\n\n/**\n * Returns the sum of nums. (+) returns 0.\n */\ncljs.core._PLUS_ \x3d (function cljs$core$_PLUS_(var_args){\nvar G__9760 \x3d arguments.length;\nswitch (G__9760) {\ncase 0:\nreturn cljs.core._PLUS_.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core._PLUS_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._PLUS_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9762 \x3d arguments.length;\nvar i__4731__auto___9763 \x3d (0);\nwhile(true){\nif((i__4731__auto___9763 \x3c len__4730__auto___9762)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9763]));\n\nvar G__9764 \x3d (i__4731__auto___9763 + (1));\ni__4731__auto___9763 \x3d G__9764;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._PLUS_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._PLUS_.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn (0);\n});\n\ncljs.core._PLUS_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn x;\n});\n\ncljs.core._PLUS_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x + y);\n});\n\ncljs.core._PLUS_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._PLUS_,(x + y),more);\n});\n\n/** @this {Function} */\ncljs.core._PLUS_.cljs$lang$applyTo \x3d (function (seq9757){\nvar G__9758 \x3d cljs.core.first(seq9757);\nvar seq9757__$1 \x3d cljs.core.next(seq9757);\nvar G__9759 \x3d cljs.core.first(seq9757__$1);\nvar seq9757__$2 \x3d cljs.core.next(seq9757__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9758,G__9759,seq9757__$2);\n});\n\ncljs.core._PLUS_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * If no ys are supplied, returns the negation of x, else subtracts\n *   the ys from x and returns the result.\n */\ncljs.core._ \x3d (function cljs$core$_(var_args){\nvar G__9769 \x3d arguments.length;\nswitch (G__9769) {\ncase 1:\nreturn cljs.core._.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9771 \x3d arguments.length;\nvar i__4731__auto___9772 \x3d (0);\nwhile(true){\nif((i__4731__auto___9772 \x3c len__4730__auto___9771)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9772]));\n\nvar G__9773 \x3d (i__4731__auto___9772 + (1));\ni__4731__auto___9772 \x3d G__9773;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn (- x);\n});\n\ncljs.core._.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x - y);\n});\n\ncljs.core._.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._,(x - y),more);\n});\n\n/** @this {Function} */\ncljs.core._.cljs$lang$applyTo \x3d (function (seq9766){\nvar G__9767 \x3d cljs.core.first(seq9766);\nvar seq9766__$1 \x3d cljs.core.next(seq9766);\nvar G__9768 \x3d cljs.core.first(seq9766__$1);\nvar seq9766__$2 \x3d cljs.core.next(seq9766__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9767,G__9768,seq9766__$2);\n});\n\ncljs.core._.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns the product of nums. (*) returns 1.\n */\ncljs.core._STAR_ \x3d (function cljs$core$_STAR_(var_args){\nvar G__9778 \x3d arguments.length;\nswitch (G__9778) {\ncase 0:\nreturn cljs.core._STAR_.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core._STAR_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._STAR_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9780 \x3d arguments.length;\nvar i__4731__auto___9781 \x3d (0);\nwhile(true){\nif((i__4731__auto___9781 \x3c len__4730__auto___9780)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9781]));\n\nvar G__9782 \x3d (i__4731__auto___9781 + (1));\ni__4731__auto___9781 \x3d G__9782;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._STAR_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._STAR_.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn (1);\n});\n\ncljs.core._STAR_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn x;\n});\n\ncljs.core._STAR_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x * y);\n});\n\ncljs.core._STAR_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._STAR_,(x * y),more);\n});\n\n/** @this {Function} */\ncljs.core._STAR_.cljs$lang$applyTo \x3d (function (seq9775){\nvar G__9776 \x3d cljs.core.first(seq9775);\nvar seq9775__$1 \x3d cljs.core.next(seq9775);\nvar G__9777 \x3d cljs.core.first(seq9775__$1);\nvar seq9775__$2 \x3d cljs.core.next(seq9775__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9776,G__9777,seq9775__$2);\n});\n\ncljs.core._STAR_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * If no denominators are supplied, returns 1/numerator,\n *   else returns numerator divided by all of the denominators.\n */\ncljs.core._SLASH_ \x3d (function cljs$core$_SLASH_(var_args){\nvar G__9787 \x3d arguments.length;\nswitch (G__9787) {\ncase 1:\nreturn cljs.core._SLASH_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._SLASH_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9789 \x3d arguments.length;\nvar i__4731__auto___9790 \x3d (0);\nwhile(true){\nif((i__4731__auto___9790 \x3c len__4730__auto___9789)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9790]));\n\nvar G__9791 \x3d (i__4731__auto___9790 + (1));\ni__4731__auto___9790 \x3d G__9791;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._SLASH_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._SLASH_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn ((1) / x);\n});\n\ncljs.core._SLASH_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x / y);\n});\n\ncljs.core._SLASH_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._SLASH_,(x / y),more);\n});\n\n/** @this {Function} */\ncljs.core._SLASH_.cljs$lang$applyTo \x3d (function (seq9784){\nvar G__9785 \x3d cljs.core.first(seq9784);\nvar seq9784__$1 \x3d cljs.core.next(seq9784);\nvar G__9786 \x3d cljs.core.first(seq9784__$1);\nvar seq9784__$2 \x3d cljs.core.next(seq9784__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9785,G__9786,seq9784__$2);\n});\n\ncljs.core._SLASH_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns non-nil if nums are in monotonically increasing order,\n *   otherwise false.\n */\ncljs.core._LT_ \x3d (function cljs$core$_LT_(var_args){\nvar G__9796 \x3d arguments.length;\nswitch (G__9796) {\ncase 1:\nreturn cljs.core._LT_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._LT_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9798 \x3d arguments.length;\nvar i__4731__auto___9799 \x3d (0);\nwhile(true){\nif((i__4731__auto___9799 \x3c len__4730__auto___9798)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9799]));\n\nvar G__9800 \x3d (i__4731__auto___9799 + (1));\ni__4731__auto___9799 \x3d G__9800;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._LT_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._LT_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn true;\n});\n\ncljs.core._LT_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x \x3c y);\n});\n\ncljs.core._LT_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nwhile(true){\nif((x \x3c y)){\nif(cljs.core.next(more)){\nvar G__9801 \x3d y;\nvar G__9802 \x3d cljs.core.first(more);\nvar G__9803 \x3d cljs.core.next(more);\nx \x3d G__9801;\ny \x3d G__9802;\nmore \x3d G__9803;\ncontinue;\n} else {\nreturn (y \x3c cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._LT_.cljs$lang$applyTo \x3d (function (seq9793){\nvar G__9794 \x3d cljs.core.first(seq9793);\nvar seq9793__$1 \x3d cljs.core.next(seq9793);\nvar G__9795 \x3d cljs.core.first(seq9793__$1);\nvar seq9793__$2 \x3d cljs.core.next(seq9793__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9794,G__9795,seq9793__$2);\n});\n\ncljs.core._LT_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns non-nil if nums are in monotonically non-decreasing order,\n *   otherwise false.\n */\ncljs.core._LT__EQ_ \x3d (function cljs$core$_LT__EQ_(var_args){\nvar G__9808 \x3d arguments.length;\nswitch (G__9808) {\ncase 1:\nreturn cljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9810 \x3d arguments.length;\nvar i__4731__auto___9811 \x3d (0);\nwhile(true){\nif((i__4731__auto___9811 \x3c len__4730__auto___9810)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9811]));\n\nvar G__9812 \x3d (i__4731__auto___9811 + (1));\ni__4731__auto___9811 \x3d G__9812;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn true;\n});\n\ncljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x \x3c\x3d y);\n});\n\ncljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nwhile(true){\nif((x \x3c\x3d y)){\nif(cljs.core.next(more)){\nvar G__9813 \x3d y;\nvar G__9814 \x3d cljs.core.first(more);\nvar G__9815 \x3d cljs.core.next(more);\nx \x3d G__9813;\ny \x3d G__9814;\nmore \x3d G__9815;\ncontinue;\n} else {\nreturn (y \x3c\x3d cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._LT__EQ_.cljs$lang$applyTo \x3d (function (seq9805){\nvar G__9806 \x3d cljs.core.first(seq9805);\nvar seq9805__$1 \x3d cljs.core.next(seq9805);\nvar G__9807 \x3d cljs.core.first(seq9805__$1);\nvar seq9805__$2 \x3d cljs.core.next(seq9805__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9806,G__9807,seq9805__$2);\n});\n\ncljs.core._LT__EQ_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns non-nil if nums are in monotonically decreasing order,\n *   otherwise false.\n */\ncljs.core._GT_ \x3d (function cljs$core$_GT_(var_args){\nvar G__9820 \x3d arguments.length;\nswitch (G__9820) {\ncase 1:\nreturn cljs.core._GT_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._GT_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9822 \x3d arguments.length;\nvar i__4731__auto___9823 \x3d (0);\nwhile(true){\nif((i__4731__auto___9823 \x3c len__4730__auto___9822)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9823]));\n\nvar G__9824 \x3d (i__4731__auto___9823 + (1));\ni__4731__auto___9823 \x3d G__9824;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._GT_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._GT_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn true;\n});\n\ncljs.core._GT_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x \x3e y);\n});\n\ncljs.core._GT_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nwhile(true){\nif((x \x3e y)){\nif(cljs.core.next(more)){\nvar G__9825 \x3d y;\nvar G__9826 \x3d cljs.core.first(more);\nvar G__9827 \x3d cljs.core.next(more);\nx \x3d G__9825;\ny \x3d G__9826;\nmore \x3d G__9827;\ncontinue;\n} else {\nreturn (y \x3e cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._GT_.cljs$lang$applyTo \x3d (function (seq9817){\nvar G__9818 \x3d cljs.core.first(seq9817);\nvar seq9817__$1 \x3d cljs.core.next(seq9817);\nvar G__9819 \x3d cljs.core.first(seq9817__$1);\nvar seq9817__$2 \x3d cljs.core.next(seq9817__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9818,G__9819,seq9817__$2);\n});\n\ncljs.core._GT_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns non-nil if nums are in monotonically non-increasing order,\n *   otherwise false.\n */\ncljs.core._GT__EQ_ \x3d (function cljs$core$_GT__EQ_(var_args){\nvar G__9832 \x3d arguments.length;\nswitch (G__9832) {\ncase 1:\nreturn cljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9834 \x3d arguments.length;\nvar i__4731__auto___9835 \x3d (0);\nwhile(true){\nif((i__4731__auto___9835 \x3c len__4730__auto___9834)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9835]));\n\nvar G__9836 \x3d (i__4731__auto___9835 + (1));\ni__4731__auto___9835 \x3d G__9836;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn true;\n});\n\ncljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x \x3e\x3d y);\n});\n\ncljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nwhile(true){\nif((x \x3e\x3d y)){\nif(cljs.core.next(more)){\nvar G__9837 \x3d y;\nvar G__9838 \x3d cljs.core.first(more);\nvar G__9839 \x3d cljs.core.next(more);\nx \x3d G__9837;\ny \x3d G__9838;\nmore \x3d G__9839;\ncontinue;\n} else {\nreturn (y \x3e\x3d cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._GT__EQ_.cljs$lang$applyTo \x3d (function (seq9829){\nvar G__9830 \x3d cljs.core.first(seq9829);\nvar seq9829__$1 \x3d cljs.core.next(seq9829);\nvar G__9831 \x3d cljs.core.first(seq9829__$1);\nvar seq9829__$2 \x3d cljs.core.next(seq9829__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9830,G__9831,seq9829__$2);\n});\n\ncljs.core._GT__EQ_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns a number one less than num.\n */\ncljs.core.dec \x3d (function cljs$core$dec(x){\nreturn (x - (1));\n});\n/**\n * Returns the greatest of the nums.\n */\ncljs.core.max \x3d (function cljs$core$max(var_args){\nvar G__9844 \x3d arguments.length;\nswitch (G__9844) {\ncase 1:\nreturn cljs.core.max.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.max.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9846 \x3d arguments.length;\nvar i__4731__auto___9847 \x3d (0);\nwhile(true){\nif((i__4731__auto___9847 \x3c len__4730__auto___9846)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9847]));\n\nvar G__9848 \x3d (i__4731__auto___9847 + (1));\ni__4731__auto___9847 \x3d G__9848;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.max.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.max.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn x;\n});\n\ncljs.core.max.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nvar x__4219__auto__ \x3d x;\nvar y__4220__auto__ \x3d y;\nreturn ((x__4219__auto__ \x3e y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n});\n\ncljs.core.max.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.max,(function (){var x__4219__auto__ \x3d x;\nvar y__4220__auto__ \x3d y;\nreturn ((x__4219__auto__ \x3e y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})(),more);\n});\n\n/** @this {Function} */\ncljs.core.max.cljs$lang$applyTo \x3d (function (seq9841){\nvar G__9842 \x3d cljs.core.first(seq9841);\nvar seq9841__$1 \x3d cljs.core.next(seq9841);\nvar G__9843 \x3d cljs.core.first(seq9841__$1);\nvar seq9841__$2 \x3d cljs.core.next(seq9841__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9842,G__9843,seq9841__$2);\n});\n\ncljs.core.max.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns the least of the nums.\n */\ncljs.core.min \x3d (function cljs$core$min(var_args){\nvar G__9853 \x3d arguments.length;\nswitch (G__9853) {\ncase 1:\nreturn cljs.core.min.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.min.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9855 \x3d arguments.length;\nvar i__4731__auto___9856 \x3d (0);\nwhile(true){\nif((i__4731__auto___9856 \x3c len__4730__auto___9855)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9856]));\n\nvar G__9857 \x3d (i__4731__auto___9856 + (1));\ni__4731__auto___9856 \x3d G__9857;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.min.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.min.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn x;\n});\n\ncljs.core.min.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nvar x__4222__auto__ \x3d x;\nvar y__4223__auto__ \x3d y;\nreturn ((x__4222__auto__ \x3c y__4223__auto__) ? x__4222__auto__ : y__4223__auto__);\n});\n\ncljs.core.min.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.min,(function (){var x__4222__auto__ \x3d x;\nvar y__4223__auto__ \x3d y;\nreturn ((x__4222__auto__ \x3c y__4223__auto__) ? x__4222__auto__ : y__4223__auto__);\n})(),more);\n});\n\n/** @this {Function} */\ncljs.core.min.cljs$lang$applyTo \x3d (function (seq9850){\nvar G__9851 \x3d cljs.core.first(seq9850);\nvar seq9850__$1 \x3d cljs.core.next(seq9850);\nvar G__9852 \x3d cljs.core.first(seq9850__$1);\nvar seq9850__$2 \x3d cljs.core.next(seq9850__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9851,G__9852,seq9850__$2);\n});\n\ncljs.core.min.cljs$lang$maxFixedArity \x3d (2);\n\ncljs.core.byte$ \x3d (function cljs$core$byte(x){\nreturn x;\n});\n/**\n * Coerce to char\n */\ncljs.core.char$ \x3d (function cljs$core$char(x){\nif(typeof x \x3d\x3d\x3d \'number\'){\nreturn String.fromCharCode(x);\n} else {\nif(((typeof x \x3d\x3d\x3d \'string\') \x26\x26 ((x.length \x3d\x3d\x3d (1))))){\nreturn x;\n} else {\nthrow (new Error("Argument to char must be a character or number"));\n\n}\n}\n});\ncljs.core.short$ \x3d (function cljs$core$short(x){\nreturn x;\n});\ncljs.core.float$ \x3d (function cljs$core$float(x){\nreturn x;\n});\ncljs.core.double$ \x3d (function cljs$core$double(x){\nreturn x;\n});\ncljs.core.unchecked_byte \x3d (function cljs$core$unchecked_byte(x){\nreturn x;\n});\ncljs.core.unchecked_char \x3d (function cljs$core$unchecked_char(x){\nreturn x;\n});\ncljs.core.unchecked_short \x3d (function cljs$core$unchecked_short(x){\nreturn x;\n});\ncljs.core.unchecked_float \x3d (function cljs$core$unchecked_float(x){\nreturn x;\n});\ncljs.core.unchecked_double \x3d (function cljs$core$unchecked_double(x){\nreturn x;\n});\n/**\n * Returns the sum of nums. (+) returns 0.\n */\ncljs.core.unchecked_add \x3d (function cljs$core$unchecked_add(var_args){\nvar G__9862 \x3d arguments.length;\nswitch (G__9862) {\ncase 0:\nreturn cljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9864 \x3d arguments.length;\nvar i__4731__auto___9865 \x3d (0);\nwhile(true){\nif((i__4731__auto___9865 \x3c len__4730__auto___9864)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9865]));\n\nvar G__9866 \x3d (i__4731__auto___9865 + (1));\ni__4731__auto___9865 \x3d G__9866;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn (0);\n});\n\ncljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn x;\n});\n\ncljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x + y);\n});\n\ncljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_add,(x + y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_add.cljs$lang$applyTo \x3d (function (seq9859){\nvar G__9860 \x3d cljs.core.first(seq9859);\nvar seq9859__$1 \x3d cljs.core.next(seq9859);\nvar G__9861 \x3d cljs.core.first(seq9859__$1);\nvar seq9859__$2 \x3d cljs.core.next(seq9859__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9860,G__9861,seq9859__$2);\n});\n\ncljs.core.unchecked_add.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns the sum of nums. (+) returns 0.\n */\ncljs.core.unchecked_add_int \x3d (function cljs$core$unchecked_add_int(var_args){\nvar G__9871 \x3d arguments.length;\nswitch (G__9871) {\ncase 0:\nreturn cljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9873 \x3d arguments.length;\nvar i__4731__auto___9874 \x3d (0);\nwhile(true){\nif((i__4731__auto___9874 \x3c len__4730__auto___9873)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9874]));\n\nvar G__9875 \x3d (i__4731__auto___9874 + (1));\ni__4731__auto___9874 \x3d G__9875;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn (0);\n});\n\ncljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn x;\n});\n\ncljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x + y);\n});\n\ncljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_add_int,(x + y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_add_int.cljs$lang$applyTo \x3d (function (seq9868){\nvar G__9869 \x3d cljs.core.first(seq9868);\nvar seq9868__$1 \x3d cljs.core.next(seq9868);\nvar G__9870 \x3d cljs.core.first(seq9868__$1);\nvar seq9868__$2 \x3d cljs.core.next(seq9868__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9869,G__9870,seq9868__$2);\n});\n\ncljs.core.unchecked_add_int.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns a number one less than x, an int.\n */\ncljs.core.unchecked_dec \x3d (function cljs$core$unchecked_dec(x){\nreturn (x - (1));\n});\n/**\n * Returns a number one less than x, an int.\n */\ncljs.core.unchecked_dec_int \x3d (function cljs$core$unchecked_dec_int(x){\nreturn (x - (1));\n});\n/**\n * If no denominators are supplied, returns 1/numerator,\n *   else returns numerator divided by all of the denominators.\n */\ncljs.core.unchecked_divide_int \x3d (function cljs$core$unchecked_divide_int(var_args){\nvar G__9880 \x3d arguments.length;\nswitch (G__9880) {\ncase 1:\nreturn cljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9882 \x3d arguments.length;\nvar i__4731__auto___9883 \x3d (0);\nwhile(true){\nif((i__4731__auto___9883 \x3c len__4730__auto___9882)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9883]));\n\nvar G__9884 \x3d (i__4731__auto___9883 + (1));\ni__4731__auto___9883 \x3d G__9884;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn ((1) / x);\n});\n\ncljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x / y);\n});\n\ncljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_divide_int,(x / y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_divide_int.cljs$lang$applyTo \x3d (function (seq9877){\nvar G__9878 \x3d cljs.core.first(seq9877);\nvar seq9877__$1 \x3d cljs.core.next(seq9877);\nvar G__9879 \x3d cljs.core.first(seq9877__$1);\nvar seq9877__$2 \x3d cljs.core.next(seq9877__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9878,G__9879,seq9877__$2);\n});\n\ncljs.core.unchecked_divide_int.cljs$lang$maxFixedArity \x3d (2);\n\ncljs.core.unchecked_inc \x3d (function cljs$core$unchecked_inc(x){\nreturn (x + (1));\n});\ncljs.core.unchecked_inc_int \x3d (function cljs$core$unchecked_inc_int(x){\nreturn (x + (1));\n});\n/**\n * Returns the product of nums. (*) returns 1.\n */\ncljs.core.unchecked_multiply \x3d (function cljs$core$unchecked_multiply(var_args){\nvar G__9889 \x3d arguments.length;\nswitch (G__9889) {\ncase 0:\nreturn cljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9891 \x3d arguments.length;\nvar i__4731__auto___9892 \x3d (0);\nwhile(true){\nif((i__4731__auto___9892 \x3c len__4730__auto___9891)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9892]));\n\nvar G__9893 \x3d (i__4731__auto___9892 + (1));\ni__4731__auto___9892 \x3d G__9893;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn (1);\n});\n\ncljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn x;\n});\n\ncljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x * y);\n});\n\ncljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_multiply,(x * y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_multiply.cljs$lang$applyTo \x3d (function (seq9886){\nvar G__9887 \x3d cljs.core.first(seq9886);\nvar seq9886__$1 \x3d cljs.core.next(seq9886);\nvar G__9888 \x3d cljs.core.first(seq9886__$1);\nvar seq9886__$2 \x3d cljs.core.next(seq9886__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9887,G__9888,seq9886__$2);\n});\n\ncljs.core.unchecked_multiply.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns the product of nums. (*) returns 1.\n */\ncljs.core.unchecked_multiply_int \x3d (function cljs$core$unchecked_multiply_int(var_args){\nvar G__9898 \x3d arguments.length;\nswitch (G__9898) {\ncase 0:\nreturn cljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9900 \x3d arguments.length;\nvar i__4731__auto___9901 \x3d (0);\nwhile(true){\nif((i__4731__auto___9901 \x3c len__4730__auto___9900)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9901]));\n\nvar G__9902 \x3d (i__4731__auto___9901 + (1));\ni__4731__auto___9901 \x3d G__9902;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn (1);\n});\n\ncljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn x;\n});\n\ncljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x * y);\n});\n\ncljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_multiply_int,(x * y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_multiply_int.cljs$lang$applyTo \x3d (function (seq9895){\nvar G__9896 \x3d cljs.core.first(seq9895);\nvar seq9895__$1 \x3d cljs.core.next(seq9895);\nvar G__9897 \x3d cljs.core.first(seq9895__$1);\nvar seq9895__$2 \x3d cljs.core.next(seq9895__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9896,G__9897,seq9895__$2);\n});\n\ncljs.core.unchecked_multiply_int.cljs$lang$maxFixedArity \x3d (2);\n\ncljs.core.unchecked_negate \x3d (function cljs$core$unchecked_negate(x){\nreturn (- x);\n});\ncljs.core.unchecked_negate_int \x3d (function cljs$core$unchecked_negate_int(x){\nreturn (- x);\n});\ncljs.core.unchecked_remainder_int \x3d (function cljs$core$unchecked_remainder_int(x,n){\nreturn cljs.core.mod(x,n);\n});\n/**\n * If no ys are supplied, returns the negation of x, else subtracts\n *   the ys from x and returns the result.\n */\ncljs.core.unchecked_subtract \x3d (function cljs$core$unchecked_subtract(var_args){\nvar G__9907 \x3d arguments.length;\nswitch (G__9907) {\ncase 1:\nreturn cljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9909 \x3d arguments.length;\nvar i__4731__auto___9910 \x3d (0);\nwhile(true){\nif((i__4731__auto___9910 \x3c len__4730__auto___9909)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9910]));\n\nvar G__9911 \x3d (i__4731__auto___9910 + (1));\ni__4731__auto___9910 \x3d G__9911;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn (- x);\n});\n\ncljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x - y);\n});\n\ncljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_subtract,(x - y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_subtract.cljs$lang$applyTo \x3d (function (seq9904){\nvar G__9905 \x3d cljs.core.first(seq9904);\nvar seq9904__$1 \x3d cljs.core.next(seq9904);\nvar G__9906 \x3d cljs.core.first(seq9904__$1);\nvar seq9904__$2 \x3d cljs.core.next(seq9904__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9905,G__9906,seq9904__$2);\n});\n\ncljs.core.unchecked_subtract.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * If no ys are supplied, returns the negation of x, else subtracts\n *   the ys from x and returns the result.\n */\ncljs.core.unchecked_subtract_int \x3d (function cljs$core$unchecked_subtract_int(var_args){\nvar G__9916 \x3d arguments.length;\nswitch (G__9916) {\ncase 1:\nreturn cljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9918 \x3d arguments.length;\nvar i__4731__auto___9919 \x3d (0);\nwhile(true){\nif((i__4731__auto___9919 \x3c len__4730__auto___9918)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9919]));\n\nvar G__9920 \x3d (i__4731__auto___9919 + (1));\ni__4731__auto___9919 \x3d G__9920;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn (- x);\n});\n\ncljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x - y);\n});\n\ncljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_subtract_int,(x - y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_subtract_int.cljs$lang$applyTo \x3d (function (seq9913){\nvar G__9914 \x3d cljs.core.first(seq9913);\nvar seq9913__$1 \x3d cljs.core.next(seq9913);\nvar G__9915 \x3d cljs.core.first(seq9913__$1);\nvar seq9913__$2 \x3d cljs.core.next(seq9913__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9914,G__9915,seq9913__$2);\n});\n\ncljs.core.unchecked_subtract_int.cljs$lang$maxFixedArity \x3d (2);\n\ncljs.core.fix \x3d (function cljs$core$fix(q){\nif((q \x3e\x3d (0))){\nreturn Math.floor(q);\n} else {\nreturn Math.ceil(q);\n}\n});\n/**\n * Coerce to int by stripping decimal places.\n */\ncljs.core.int$ \x3d (function cljs$core$int(x){\nreturn (x | (0));\n});\n/**\n * Coerce to int by stripping decimal places.\n */\ncljs.core.unchecked_int \x3d (function cljs$core$unchecked_int(x){\nreturn cljs.core.fix(x);\n});\n/**\n * Coerce to long by stripping decimal places. Identical to `int\'.\n */\ncljs.core.long$ \x3d (function cljs$core$long(x){\nreturn cljs.core.fix(x);\n});\n/**\n * Coerce to long by stripping decimal places. Identical to `int\'.\n */\ncljs.core.unchecked_long \x3d (function cljs$core$unchecked_long(x){\nreturn cljs.core.fix(x);\n});\ncljs.core.booleans \x3d (function cljs$core$booleans(x){\nreturn x;\n});\ncljs.core.bytes \x3d (function cljs$core$bytes(x){\nreturn x;\n});\ncljs.core.chars \x3d (function cljs$core$chars(x){\nreturn x;\n});\ncljs.core.shorts \x3d (function cljs$core$shorts(x){\nreturn x;\n});\ncljs.core.ints \x3d (function cljs$core$ints(x){\nreturn x;\n});\ncljs.core.floats \x3d (function cljs$core$floats(x){\nreturn x;\n});\ncljs.core.doubles \x3d (function cljs$core$doubles(x){\nreturn x;\n});\ncljs.core.longs \x3d (function cljs$core$longs(x){\nreturn x;\n});\n/**\n * Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\n */\ncljs.core.js_mod \x3d (function cljs$core$js_mod(n,d){\nreturn (n % d);\n});\n/**\n * Modulus of num and div. Truncates toward negative infinity.\n */\ncljs.core.mod \x3d (function cljs$core$mod(n,d){\nreturn (((n % d) + d) % d);\n});\n/**\n * quot[ient] of dividing numerator by denominator.\n */\ncljs.core.quot \x3d (function cljs$core$quot(n,d){\nvar rem \x3d (n % d);\nreturn cljs.core.fix(((n - rem) / d));\n});\n/**\n * remainder of dividing numerator by denominator.\n */\ncljs.core.rem \x3d (function cljs$core$rem(n,d){\nvar q \x3d cljs.core.quot(n,d);\nreturn (n - (d * q));\n});\n/**\n * Bitwise exclusive or\n */\ncljs.core.bit_xor \x3d (function cljs$core$bit_xor(var_args){\nvar G__9925 \x3d arguments.length;\nswitch (G__9925) {\ncase 2:\nreturn cljs.core.bit_xor.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9927 \x3d arguments.length;\nvar i__4731__auto___9928 \x3d (0);\nwhile(true){\nif((i__4731__auto___9928 \x3c len__4730__auto___9927)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9928]));\n\nvar G__9929 \x3d (i__4731__auto___9928 + (1));\ni__4731__auto___9928 \x3d G__9929;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.bit_xor.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.bit_xor.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x ^ y);\n});\n\ncljs.core.bit_xor.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.bit_xor,(x ^ y),more);\n});\n\n/** @this {Function} */\ncljs.core.bit_xor.cljs$lang$applyTo \x3d (function (seq9922){\nvar G__9923 \x3d cljs.core.first(seq9922);\nvar seq9922__$1 \x3d cljs.core.next(seq9922);\nvar G__9924 \x3d cljs.core.first(seq9922__$1);\nvar seq9922__$2 \x3d cljs.core.next(seq9922__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9923,G__9924,seq9922__$2);\n});\n\ncljs.core.bit_xor.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Bitwise and\n */\ncljs.core.bit_and \x3d (function cljs$core$bit_and(var_args){\nvar G__9934 \x3d arguments.length;\nswitch (G__9934) {\ncase 2:\nreturn cljs.core.bit_and.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9936 \x3d arguments.length;\nvar i__4731__auto___9937 \x3d (0);\nwhile(true){\nif((i__4731__auto___9937 \x3c len__4730__auto___9936)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9937]));\n\nvar G__9938 \x3d (i__4731__auto___9937 + (1));\ni__4731__auto___9937 \x3d G__9938;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.bit_and.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.bit_and.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x \x26 y);\n});\n\ncljs.core.bit_and.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.bit_and,(x \x26 y),more);\n});\n\n/** @this {Function} */\ncljs.core.bit_and.cljs$lang$applyTo \x3d (function (seq9931){\nvar G__9932 \x3d cljs.core.first(seq9931);\nvar seq9931__$1 \x3d cljs.core.next(seq9931);\nvar G__9933 \x3d cljs.core.first(seq9931__$1);\nvar seq9931__$2 \x3d cljs.core.next(seq9931__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9932,G__9933,seq9931__$2);\n});\n\ncljs.core.bit_and.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Bitwise or\n */\ncljs.core.bit_or \x3d (function cljs$core$bit_or(var_args){\nvar G__9943 \x3d arguments.length;\nswitch (G__9943) {\ncase 2:\nreturn cljs.core.bit_or.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9945 \x3d arguments.length;\nvar i__4731__auto___9946 \x3d (0);\nwhile(true){\nif((i__4731__auto___9946 \x3c len__4730__auto___9945)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9946]));\n\nvar G__9947 \x3d (i__4731__auto___9946 + (1));\ni__4731__auto___9946 \x3d G__9947;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.bit_or.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.bit_or.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x | y);\n});\n\ncljs.core.bit_or.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.bit_or,(x | y),more);\n});\n\n/** @this {Function} */\ncljs.core.bit_or.cljs$lang$applyTo \x3d (function (seq9940){\nvar G__9941 \x3d cljs.core.first(seq9940);\nvar seq9940__$1 \x3d cljs.core.next(seq9940);\nvar G__9942 \x3d cljs.core.first(seq9940__$1);\nvar seq9940__$2 \x3d cljs.core.next(seq9940__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9941,G__9942,seq9940__$2);\n});\n\ncljs.core.bit_or.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Bitwise and with complement\n */\ncljs.core.bit_and_not \x3d (function cljs$core$bit_and_not(var_args){\nvar G__9952 \x3d arguments.length;\nswitch (G__9952) {\ncase 2:\nreturn cljs.core.bit_and_not.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9954 \x3d arguments.length;\nvar i__4731__auto___9955 \x3d (0);\nwhile(true){\nif((i__4731__auto___9955 \x3c len__4730__auto___9954)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9955]));\n\nvar G__9956 \x3d (i__4731__auto___9955 + (1));\ni__4731__auto___9955 \x3d G__9956;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.bit_and_not.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.bit_and_not.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (x \x26 ~y);\n});\n\ncljs.core.bit_and_not.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.bit_and_not,(x \x26 ~y),more);\n});\n\n/** @this {Function} */\ncljs.core.bit_and_not.cljs$lang$applyTo \x3d (function (seq9949){\nvar G__9950 \x3d cljs.core.first(seq9949);\nvar seq9949__$1 \x3d cljs.core.next(seq9949);\nvar G__9951 \x3d cljs.core.first(seq9949__$1);\nvar seq9949__$2 \x3d cljs.core.next(seq9949__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9950,G__9951,seq9949__$2);\n});\n\ncljs.core.bit_and_not.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Clear bit at index n\n */\ncljs.core.bit_clear \x3d (function cljs$core$bit_clear(x,n){\nreturn (x \x26 ~(1 \x3c\x3c n));\n});\n/**\n * Flip bit at index n\n */\ncljs.core.bit_flip \x3d (function cljs$core$bit_flip(x,n){\nreturn (x ^ (1 \x3c\x3c n));\n});\n/**\n * Bitwise complement\n */\ncljs.core.bit_not \x3d (function cljs$core$bit_not(x){\nreturn (~ x);\n});\n/**\n * Set bit at index n\n */\ncljs.core.bit_set \x3d (function cljs$core$bit_set(x,n){\nreturn (x | (1 \x3c\x3c n));\n});\n/**\n * Test bit at index n\n */\ncljs.core.bit_test \x3d (function cljs$core$bit_test(x,n){\nreturn ((x \x26 (1 \x3c\x3c n)) !\x3d 0);\n});\n/**\n * Bitwise shift left\n */\ncljs.core.bit_shift_left \x3d (function cljs$core$bit_shift_left(x,n){\nreturn (x \x3c\x3c n);\n});\n/**\n * Bitwise shift right\n */\ncljs.core.bit_shift_right \x3d (function cljs$core$bit_shift_right(x,n){\nreturn (x \x3e\x3e n);\n});\n/**\n * DEPRECATED: Bitwise shift right with zero fill\n */\ncljs.core.bit_shift_right_zero_fill \x3d (function cljs$core$bit_shift_right_zero_fill(x,n){\nreturn (x \x3e\x3e\x3e n);\n});\n/**\n * Bitwise shift right with zero fill\n */\ncljs.core.unsigned_bit_shift_right \x3d (function cljs$core$unsigned_bit_shift_right(x,n){\nreturn (x \x3e\x3e\x3e n);\n});\n/**\n * Counts the number of bits set in n\n */\ncljs.core.bit_count \x3d (function cljs$core$bit_count(v){\nvar v__$1 \x3d (v - ((v \x3e\x3e (1)) \x26 (1431655765)));\nvar v__$2 \x3d ((v__$1 \x26 (858993459)) + ((v__$1 \x3e\x3e (2)) \x26 (858993459)));\nreturn ((((v__$2 + (v__$2 \x3e\x3e (4))) \x26 (252645135)) * (16843009)) \x3e\x3e (24));\n});\n/**\n * Returns non-nil if nums all have the equivalent\n *   value, otherwise false. Behavior on non nums is\n *   undefined.\n */\ncljs.core._EQ__EQ_ \x3d (function cljs$core$_EQ__EQ_(var_args){\nvar G__9961 \x3d arguments.length;\nswitch (G__9961) {\ncase 1:\nreturn cljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9963 \x3d arguments.length;\nvar i__4731__auto___9964 \x3d (0);\nwhile(true){\nif((i__4731__auto___9964 \x3c len__4730__auto___9963)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9964]));\n\nvar G__9965 \x3d (i__4731__auto___9964 + (1));\ni__4731__auto___9964 \x3d G__9965;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn true;\n});\n\ncljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn cljs.core._equiv(x,y);\n});\n\ncljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nwhile(true){\nif((x \x3d\x3d\x3d y)){\nif(cljs.core.next(more)){\nvar G__9966 \x3d y;\nvar G__9967 \x3d cljs.core.first(more);\nvar G__9968 \x3d cljs.core.next(more);\nx \x3d G__9966;\ny \x3d G__9967;\nmore \x3d G__9968;\ncontinue;\n} else {\nreturn (y \x3d\x3d\x3d cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._EQ__EQ_.cljs$lang$applyTo \x3d (function (seq9958){\nvar G__9959 \x3d cljs.core.first(seq9958);\nvar seq9958__$1 \x3d cljs.core.next(seq9958);\nvar G__9960 \x3d cljs.core.first(seq9958__$1);\nvar seq9958__$2 \x3d cljs.core.next(seq9958__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9959,G__9960,seq9958__$2);\n});\n\ncljs.core._EQ__EQ_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns true if num is greater than zero, else false\n */\ncljs.core.pos_QMARK_ \x3d (function cljs$core$pos_QMARK_(x){\nreturn (x \x3e (0));\n});\n/**\n * Returns true if num is zero, else false\n */\ncljs.core.zero_QMARK_ \x3d (function cljs$core$zero_QMARK_(x){\nreturn (x \x3d\x3d\x3d (0));\n});\n/**\n * Returns true if num is less than zero, else false\n */\ncljs.core.neg_QMARK_ \x3d (function cljs$core$neg_QMARK_(x){\nreturn (x \x3c (0));\n});\n/**\n * Returns the nth next of coll, (seq coll) when n is 0.\n */\ncljs.core.nthnext \x3d (function cljs$core$nthnext(coll,n){\nvar n__$1 \x3d n;\nvar xs \x3d cljs.core.seq(coll);\nwhile(true){\nif(((xs) \x26\x26 ((n__$1 \x3e (0))))){\nvar G__9969 \x3d (n__$1 - (1));\nvar G__9970 \x3d cljs.core.next(xs);\nn__$1 \x3d G__9969;\nxs \x3d G__9970;\ncontinue;\n} else {\nreturn xs;\n}\nbreak;\n}\n});\n/**\n * With no args, returns the empty string. With one arg x, returns\n *   x.toString().  (str nil) returns the empty string. With more than\n *   one arg, returns the concatenation of the str values of the args.\n */\ncljs.core.str \x3d (function cljs$core$str(var_args){\nvar G__9974 \x3d arguments.length;\nswitch (G__9974) {\ncase 0:\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___9976 \x3d arguments.length;\nvar i__4731__auto___9977 \x3d (0);\nwhile(true){\nif((i__4731__auto___9977 \x3c len__4730__auto___9976)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___9977]));\n\nvar G__9978 \x3d (i__4731__auto___9977 + (1));\ni__4731__auto___9977 \x3d G__9978;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.str.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn "";\n});\n\ncljs.core.str.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nif((x \x3d\x3d null)){\nreturn "";\n} else {\nreturn [x].join("");\n}\n});\n\ncljs.core.str.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,ys){\nvar sb \x3d (new goog.string.StringBuffer(cljs.core.str.cljs$core$IFn$_invoke$arity$1(x)));\nvar more \x3d ys;\nwhile(true){\nif(cljs.core.truth_(more)){\nvar G__9979 \x3d sb.append(cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(more)));\nvar G__9980 \x3d cljs.core.next(more);\nsb \x3d G__9979;\nmore \x3d G__9980;\ncontinue;\n} else {\nreturn sb.toString();\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.str.cljs$lang$applyTo \x3d (function (seq9972){\nvar G__9973 \x3d cljs.core.first(seq9972);\nvar seq9972__$1 \x3d cljs.core.next(seq9972);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__9973,seq9972__$1);\n});\n\ncljs.core.str.cljs$lang$maxFixedArity \x3d (1);\n\n/**\n * Returns the substring of s beginning at start inclusive, and ending\n *   at end (defaults to length of string), exclusive.\n */\ncljs.core.subs \x3d (function cljs$core$subs(var_args){\nvar G__9982 \x3d arguments.length;\nswitch (G__9982) {\ncase 2:\nreturn cljs.core.subs.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.subs.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.subs.cljs$core$IFn$_invoke$arity$2 \x3d (function (s,start){\nreturn s.substring(start);\n});\n\ncljs.core.subs.cljs$core$IFn$_invoke$arity$3 \x3d (function (s,start,end){\nreturn s.substring(start,end);\n});\n\ncljs.core.subs.cljs$lang$maxFixedArity \x3d 3;\n\n\n/**\n * Assumes x is sequential. Returns true if x equals y, otherwise\n *   returns false.\n */\ncljs.core.equiv_sequential \x3d (function cljs$core$equiv_sequential(x,y){\nreturn cljs.core.boolean$(((cljs.core.sequential_QMARK_(y))?((((cljs.core.counted_QMARK_(x)) \x26\x26 (cljs.core.counted_QMARK_(y)) \x26\x26 ((!((cljs.core.count(x) \x3d\x3d\x3d cljs.core.count(y)))))))?false:(function (){var xs \x3d cljs.core.seq(x);\nvar ys \x3d cljs.core.seq(y);\nwhile(true){\nif((xs \x3d\x3d null)){\nreturn (ys \x3d\x3d null);\n} else {\nif((ys \x3d\x3d null)){\nreturn false;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(xs),cljs.core.first(ys))){\nvar G__9984 \x3d cljs.core.next(xs);\nvar G__9985 \x3d cljs.core.next(ys);\nxs \x3d G__9984;\nys \x3d G__9985;\ncontinue;\n} else {\nreturn false;\n\n}\n}\n}\nbreak;\n}\n})()):null));\n});\ncljs.core.hash_coll \x3d (function cljs$core$hash_coll(coll){\nif(cljs.core.seq(coll)){\nvar res \x3d cljs.core.hash(cljs.core.first(coll));\nvar s \x3d cljs.core.next(coll);\nwhile(true){\nif((s \x3d\x3d null)){\nreturn res;\n} else {\nvar G__9986 \x3d cljs.core.hash_combine(res,cljs.core.hash(cljs.core.first(s)));\nvar G__9987 \x3d cljs.core.next(s);\nres \x3d G__9986;\ns \x3d G__9987;\ncontinue;\n}\nbreak;\n}\n} else {\nreturn (0);\n}\n});\n\ncljs.core.hash_imap \x3d (function cljs$core$hash_imap(m){\nvar h \x3d (0);\nvar s \x3d cljs.core.seq(m);\nwhile(true){\nif(s){\nvar e \x3d cljs.core.first(s);\nvar G__9988 \x3d ((h + (cljs.core.hash(cljs.core.key(e)) ^ cljs.core.hash(cljs.core.val(e)))) % (4503599627370496));\nvar G__9989 \x3d cljs.core.next(s);\nh \x3d G__9988;\ns \x3d G__9989;\ncontinue;\n} else {\nreturn h;\n}\nbreak;\n}\n});\ncljs.core.hash_iset \x3d (function cljs$core$hash_iset(s){\nvar h \x3d (0);\nvar s__$1 \x3d cljs.core.seq(s);\nwhile(true){\nif(s__$1){\nvar e \x3d cljs.core.first(s__$1);\nvar G__9990 \x3d ((h + cljs.core.hash(e)) % (4503599627370496));\nvar G__9991 \x3d cljs.core.next(s__$1);\nh \x3d G__9990;\ns__$1 \x3d G__9991;\ncontinue;\n} else {\nreturn h;\n}\nbreak;\n}\n});\n\n\n/**\n * Takes a JavaScript object and a map of names to functions and\n *   attaches said functions as methods on the object.  Any references to\n *   JavaScript\'s implicit this (via the this-as macro) will resolve to the\n *   object that the function is attached.\n */\ncljs.core.extend_object_BANG_ \x3d (function cljs$core$extend_object_BANG_(obj,fn_map){\nvar seq__9992_10008 \x3d cljs.core.seq(fn_map);\nvar chunk__9993_10009 \x3d null;\nvar count__9994_10010 \x3d (0);\nvar i__9995_10011 \x3d (0);\nwhile(true){\nif((i__9995_10011 \x3c count__9994_10010)){\nvar vec__10002_10012 \x3d chunk__9993_10009.cljs$core$IIndexed$_nth$arity$2(null,i__9995_10011);\nvar key_name_10013 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10002_10012,(0),null);\nvar f_10014 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10002_10012,(1),null);\nvar str_name_10015 \x3d cljs.core.name(key_name_10013);\ngoog.object.set(obj,str_name_10015,f_10014);\n\n\nvar G__10016 \x3d seq__9992_10008;\nvar G__10017 \x3d chunk__9993_10009;\nvar G__10018 \x3d count__9994_10010;\nvar G__10019 \x3d (i__9995_10011 + (1));\nseq__9992_10008 \x3d G__10016;\nchunk__9993_10009 \x3d G__10017;\ncount__9994_10010 \x3d G__10018;\ni__9995_10011 \x3d G__10019;\ncontinue;\n} else {\nvar temp__5720__auto___10020 \x3d cljs.core.seq(seq__9992_10008);\nif(temp__5720__auto___10020){\nvar seq__9992_10021__$1 \x3d temp__5720__auto___10020;\nif(cljs.core.chunked_seq_QMARK_(seq__9992_10021__$1)){\nvar c__4550__auto___10022 \x3d cljs.core.chunk_first(seq__9992_10021__$1);\nvar G__10023 \x3d cljs.core.chunk_rest(seq__9992_10021__$1);\nvar G__10024 \x3d c__4550__auto___10022;\nvar G__10025 \x3d cljs.core.count(c__4550__auto___10022);\nvar G__10026 \x3d (0);\nseq__9992_10008 \x3d G__10023;\nchunk__9993_10009 \x3d G__10024;\ncount__9994_10010 \x3d G__10025;\ni__9995_10011 \x3d G__10026;\ncontinue;\n} else {\nvar vec__10005_10027 \x3d cljs.core.first(seq__9992_10021__$1);\nvar key_name_10028 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10005_10027,(0),null);\nvar f_10029 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10005_10027,(1),null);\nvar str_name_10030 \x3d cljs.core.name(key_name_10028);\ngoog.object.set(obj,str_name_10030,f_10029);\n\n\nvar G__10031 \x3d cljs.core.next(seq__9992_10021__$1);\nvar G__10032 \x3d null;\nvar G__10033 \x3d (0);\nvar G__10034 \x3d (0);\nseq__9992_10008 \x3d G__10031;\nchunk__9993_10009 \x3d G__10032;\ncount__9994_10010 \x3d G__10033;\ni__9995_10011 \x3d G__10034;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn obj;\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IList}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.List \x3d (function (meta,first,rest,count,__hash){\nthis.meta \x3d meta;\nthis.first \x3d first;\nthis.rest \x3d rest;\nthis.count \x3d count;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 65937646;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 8192;\n});\ncljs.core.List.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.List.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.List.prototype.indexOf \x3d (function() {\nvar G__10035 \x3d null;\nvar G__10035__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10035__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10035 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10035__1.call(this,x);\ncase 2:\nreturn G__10035__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10035.cljs$core$IFn$_invoke$arity$1 \x3d G__10035__1;\nG__10035.cljs$core$IFn$_invoke$arity$2 \x3d G__10035__2;\nreturn G__10035;\n})()\n;\n\ncljs.core.List.prototype.lastIndexOf \x3d (function() {\nvar G__10036 \x3d null;\nvar G__10036__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,self__.count);\n});\nvar G__10036__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10036 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10036__1.call(this,x);\ncase 2:\nreturn G__10036__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10036.cljs$core$IFn$_invoke$arity$1 \x3d G__10036__1;\nG__10036.cljs$core$IFn$_invoke$arity$2 \x3d G__10036__2;\nreturn G__10036;\n})()\n;\n\ncljs.core.List.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.List.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.List(self__.meta,self__.first,self__.rest,self__.count,self__.__hash));\n});\n\ncljs.core.List.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.count \x3d\x3d\x3d (1))){\nreturn null;\n} else {\nreturn self__.rest;\n}\n});\n\ncljs.core.List.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.count;\n});\n\ncljs.core.List.prototype.cljs$core$IStack$_peek$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.first;\n});\n\ncljs.core.List.prototype.cljs$core$IStack$_pop$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ISeq$_rest$arity$1(null);\n});\n\ncljs.core.List.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.List.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.List.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.List.EMPTY,self__.meta);\n});\n\ncljs.core.List.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.List.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.List.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.first;\n});\n\ncljs.core.List.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.count \x3d\x3d\x3d (1))){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.rest;\n}\n});\n\ncljs.core.List.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.List.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.List(new_meta,self__.first,self__.rest,self__.count,self__.__hash));\n}\n});\n\ncljs.core.List.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.List(self__.meta,o,coll__$1,(self__.count + (1)),null));\n});\n\ncljs.core.List.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$first,cljs.core.cst$sym$rest,cljs.core.cst$sym$count,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.List.cljs$lang$type \x3d true;\n\ncljs.core.List.cljs$lang$ctorStr \x3d "cljs.core/List";\n\ncljs.core.List.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/List");\n});\n\n/**\n * Positional factory function for cljs.core/List.\n */\ncljs.core.__GT_List \x3d (function cljs$core$__GT_List(meta,first,rest,count,__hash){\nreturn (new cljs.core.List(meta,first,rest,count,__hash));\n});\n\n/**\n * Returns true if x implements IList\n */\ncljs.core.list_QMARK_ \x3d (function cljs$core$list_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (33554432))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IList$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IList,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IList,x);\n}\n});\nvar G__10038_10041 \x3d cljs.core.List.prototype;\nvar G__10039_10042 \x3d cljs.core.ITER_SYMBOL;\nvar G__10040_10043 \x3d ((function (G__10038_10041,G__10039_10042){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10038_10041,G__10039_10042))\n;\ngoog.object.set(G__10038_10041,G__10039_10042,G__10040_10043);\n\n/**\n* @constructor\n * @implements {cljs.core.IList}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.EmptyList \x3d (function (meta){\nthis.meta \x3d meta;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 65937614;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 8192;\n});\ncljs.core.EmptyList.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.EmptyList.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.EmptyList.prototype.indexOf \x3d (function() {\nvar G__10044 \x3d null;\nvar G__10044__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10044__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10044 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10044__1.call(this,x);\ncase 2:\nreturn G__10044__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10044.cljs$core$IFn$_invoke$arity$1 \x3d G__10044__1;\nG__10044.cljs$core$IFn$_invoke$arity$2 \x3d G__10044__2;\nreturn G__10044;\n})()\n;\n\ncljs.core.EmptyList.prototype.lastIndexOf \x3d (function() {\nvar G__10045 \x3d null;\nvar G__10045__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10045__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10045 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10045__1.call(this,x);\ncase 2:\nreturn G__10045__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10045.cljs$core$IFn$_invoke$arity$1 \x3d G__10045__1;\nG__10045.cljs$core$IFn$_invoke$arity$2 \x3d G__10045__2;\nreturn G__10045;\n})()\n;\n\ncljs.core.EmptyList.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.EmptyList(self__.meta));\n});\n\ncljs.core.EmptyList.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (0);\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IStack$_peek$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IStack$_pop$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nthrow (new Error("Can\'t pop empty list"));\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.empty_ordered_hash;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((cljs.core.list_QMARK_(other)) || (cljs.core.sequential_QMARK_(other)))){\nreturn (cljs.core.seq(other) \x3d\x3d null);\n} else {\nreturn false;\n}\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.EmptyList(new_meta));\n}\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.List(self__.meta,o,null,(1),null));\n});\n\ncljs.core.EmptyList.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta], null);\n});\n\ncljs.core.EmptyList.cljs$lang$type \x3d true;\n\ncljs.core.EmptyList.cljs$lang$ctorStr \x3d "cljs.core/EmptyList";\n\ncljs.core.EmptyList.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/EmptyList");\n});\n\n/**\n * Positional factory function for cljs.core/EmptyList.\n */\ncljs.core.__GT_EmptyList \x3d (function cljs$core$__GT_EmptyList(meta){\nreturn (new cljs.core.EmptyList(meta));\n});\n\ncljs.core.List.EMPTY \x3d (new cljs.core.EmptyList(null));\nvar G__10046_10049 \x3d cljs.core.EmptyList.prototype;\nvar G__10047_10050 \x3d cljs.core.ITER_SYMBOL;\nvar G__10048_10051 \x3d ((function (G__10046_10049,G__10047_10050){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10046_10049,G__10047_10050))\n;\ngoog.object.set(G__10046_10049,G__10047_10050,G__10048_10051);\n/**\n * Returns true if coll satisfies? IReversible.\n */\ncljs.core.reversible_QMARK_ \x3d (function cljs$core$reversible_QMARK_(coll){\nif((!((coll \x3d\x3d null)))){\nif((((coll.cljs$lang$protocol_mask$partition0$ \x26 (134217728))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$IReversible$)))){\nreturn true;\n} else {\nif((!coll.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IReversible,coll);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IReversible,coll);\n}\n});\n/**\n * Returns, in constant time, a seq of the items in rev (which\n *   can be a vector or sorted-map), in reverse order. If rev is empty returns nil\n */\ncljs.core.rseq \x3d (function cljs$core$rseq(rev){\nreturn cljs.core._rseq(rev);\n});\n/**\n * Returns a seq of the items in coll in reverse order. Not lazy.\n */\ncljs.core.reverse \x3d (function cljs$core$reverse(coll){\nif(cljs.core.reversible_QMARK_(coll)){\nvar or__4131__auto__ \x3d cljs.core.rseq(coll);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,cljs.core.List.EMPTY,coll);\n}\n});\n/**\n * Creates a new list containing the items.\n */\ncljs.core.list \x3d (function cljs$core$list(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___10054 \x3d arguments.length;\nvar i__4731__auto___10055 \x3d (0);\nwhile(true){\nif((i__4731__auto___10055 \x3c len__4730__auto___10054)){\nargs__4736__auto__.push((arguments[i__4731__auto___10055]));\n\nvar G__10056 \x3d (i__4731__auto___10055 + (1));\ni__4731__auto___10055 \x3d G__10056;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.list.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.list.cljs$core$IFn$_invoke$arity$variadic \x3d (function (xs){\nvar arr \x3d (((((xs instanceof cljs.core.IndexedSeq)) \x26\x26 ((xs.i \x3d\x3d\x3d (0)))))?xs.arr:(function (){var arr \x3d [];\nvar xs__$1 \x3d xs;\nwhile(true){\nif((!((xs__$1 \x3d\x3d null)))){\narr.push(cljs.core._first(xs__$1));\n\nvar G__10057 \x3d cljs.core._next(xs__$1);\nxs__$1 \x3d G__10057;\ncontinue;\n} else {\nreturn arr;\n}\nbreak;\n}\n})());\nvar i \x3d arr.length;\nvar r \x3d cljs.core.List.EMPTY;\nwhile(true){\nif((i \x3e (0))){\nvar G__10058 \x3d (i - (1));\nvar G__10059 \x3d cljs.core._conj(r,(arr[(i - (1))]));\ni \x3d G__10058;\nr \x3d G__10059;\ncontinue;\n} else {\nreturn r;\n}\nbreak;\n}\n});\n\ncljs.core.list.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.list.cljs$lang$applyTo \x3d (function (seq10053){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq10053));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IList}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Cons \x3d (function (meta,first,rest,__hash){\nthis.meta \x3d meta;\nthis.first \x3d first;\nthis.rest \x3d rest;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 65929452;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 8192;\n});\ncljs.core.Cons.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Cons.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Cons.prototype.indexOf \x3d (function() {\nvar G__10060 \x3d null;\nvar G__10060__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10060__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10060 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10060__1.call(this,x);\ncase 2:\nreturn G__10060__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10060.cljs$core$IFn$_invoke$arity$1 \x3d G__10060__1;\nG__10060.cljs$core$IFn$_invoke$arity$2 \x3d G__10060__2;\nreturn G__10060;\n})()\n;\n\ncljs.core.Cons.prototype.lastIndexOf \x3d (function() {\nvar G__10061 \x3d null;\nvar G__10061__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10061__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10061 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10061__1.call(this,x);\ncase 2:\nreturn G__10061__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10061.cljs$core$IFn$_invoke$arity$1 \x3d G__10061__1;\nG__10061.cljs$core$IFn$_invoke$arity$2 \x3d G__10061__2;\nreturn G__10061;\n})()\n;\n\ncljs.core.Cons.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.Cons.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.Cons(self__.meta,self__.first,self__.rest,self__.__hash));\n});\n\ncljs.core.Cons.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.rest \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core.seq(self__.rest);\n}\n});\n\ncljs.core.Cons.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Cons.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.Cons.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Cons.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.Cons.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.Cons.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.first;\n});\n\ncljs.core.Cons.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.rest \x3d\x3d null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.rest;\n}\n});\n\ncljs.core.Cons.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.Cons.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.Cons(new_meta,self__.first,self__.rest,self__.__hash));\n}\n});\n\ncljs.core.Cons.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.Cons(null,o,coll__$1,null));\n});\n\ncljs.core.Cons.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$first,cljs.core.cst$sym$rest,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Cons.cljs$lang$type \x3d true;\n\ncljs.core.Cons.cljs$lang$ctorStr \x3d "cljs.core/Cons";\n\ncljs.core.Cons.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Cons");\n});\n\n/**\n * Positional factory function for cljs.core/Cons.\n */\ncljs.core.__GT_Cons \x3d (function cljs$core$__GT_Cons(meta,first,rest,__hash){\nreturn (new cljs.core.Cons(meta,first,rest,__hash));\n});\n\nvar G__10062_10065 \x3d cljs.core.Cons.prototype;\nvar G__10063_10066 \x3d cljs.core.ITER_SYMBOL;\nvar G__10064_10067 \x3d ((function (G__10062_10065,G__10063_10066){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10062_10065,G__10063_10066))\n;\ngoog.object.set(G__10062_10065,G__10063_10066,G__10064_10067);\n/**\n * Returns a new seq where x is the first element and coll is the rest.\n */\ncljs.core.cons \x3d (function cljs$core$cons(x,coll){\nif((coll \x3d\x3d null)){\nreturn (new cljs.core.List(null,x,null,(1),null));\n} else {\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (64))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$ISeq$))))?true:false):false)){\nreturn (new cljs.core.Cons(null,x,coll,null));\n} else {\nreturn (new cljs.core.Cons(null,x,cljs.core.seq(coll),null));\n\n}\n}\n});\ncljs.core.hash_keyword \x3d (function cljs$core$hash_keyword(k){\nreturn ((cljs.core.hash_symbol(k) + (2654435769)) | (0));\n});\ncljs.core.compare_keywords \x3d (function cljs$core$compare_keywords(a,b){\nif((a.fqn \x3d\x3d\x3d b.fqn)){\nreturn (0);\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ \x3d cljs.core.not(a.ns);\nif(and__4120__auto__){\nreturn b.ns;\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn (-1);\n} else {\nif(cljs.core.truth_(a.ns)){\nif(cljs.core.not(b.ns)){\nreturn (1);\n} else {\nvar nsc \x3d (function (){var G__10069 \x3d a.ns;\nvar G__10070 \x3d b.ns;\nreturn goog.array.defaultCompare(G__10069,G__10070);\n})();\nif(((0) \x3d\x3d\x3d nsc)){\nvar G__10071 \x3d a.name;\nvar G__10072 \x3d b.name;\nreturn goog.array.defaultCompare(G__10071,G__10072);\n} else {\nreturn nsc;\n}\n}\n} else {\nvar G__10073 \x3d a.name;\nvar G__10074 \x3d b.name;\nreturn goog.array.defaultCompare(G__10073,G__10074);\n\n}\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.INamed}\n * @implements {cljs.core.IPrintWithWriter}\n*/\ncljs.core.Keyword \x3d (function (ns,name,fqn,_hash){\nthis.ns \x3d ns;\nthis.name \x3d name;\nthis.fqn \x3d fqn;\nthis._hash \x3d _hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 2153775105;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 4096;\n});\ncljs.core.Keyword.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn [":",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.fqn)].join(\'\');\n});\n\ncljs.core.Keyword.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Keyword.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (_,other){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nif((other instanceof cljs.core.Keyword)){\nreturn (self__.fqn \x3d\x3d\x3d other.fqn);\n} else {\nreturn false;\n}\n});\n\ncljs.core.Keyword.prototype.call \x3d (function() {\nvar G__10076 \x3d null;\nvar G__10076__2 \x3d (function (self__,coll){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar kw \x3d self____$1;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,kw);\n});\nvar G__10076__3 \x3d (function (self__,coll,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar kw \x3d self____$1;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,kw,not_found);\n});\nG__10076 \x3d function(self__,coll,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__10076__2.call(this,self__,coll);\ncase 3:\nreturn G__10076__3.call(this,self__,coll,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__10076.cljs$core$IFn$_invoke$arity$2 \x3d G__10076__2;\nG__10076.cljs$core$IFn$_invoke$arity$3 \x3d G__10076__3;\nreturn G__10076;\n})()\n;\n\ncljs.core.Keyword.prototype.apply \x3d (function (self__,args10075){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args10075)));\n});\n\ncljs.core.Keyword.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar kw \x3d this;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,kw);\n});\n\ncljs.core.Keyword.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (coll,not_found){\nvar self__ \x3d this;\nvar kw \x3d this;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,kw,not_found);\n});\n\ncljs.core.Keyword.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nvar h__4243__auto__ \x3d self__._hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_keyword(this$__$1);\nself__._hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Keyword.prototype.cljs$core$INamed$_name$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.name;\n});\n\ncljs.core.Keyword.prototype.cljs$core$INamed$_namespace$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.ns;\n});\n\ncljs.core.Keyword.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (o,writer,_){\nvar self__ \x3d this;\nvar o__$1 \x3d this;\nreturn cljs.core._write(writer,[":",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.fqn)].join(\'\'));\n});\n\ncljs.core.Keyword.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$ns,cljs.core.cst$sym$name,cljs.core.cst$sym$fqn,cljs.core.with_meta(cljs.core.cst$sym$_hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Keyword.cljs$lang$type \x3d true;\n\ncljs.core.Keyword.cljs$lang$ctorStr \x3d "cljs.core/Keyword";\n\ncljs.core.Keyword.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Keyword");\n});\n\n/**\n * Positional factory function for cljs.core/Keyword.\n */\ncljs.core.__GT_Keyword \x3d (function cljs$core$__GT_Keyword(ns,name,fqn,_hash){\nreturn (new cljs.core.Keyword(ns,name,fqn,_hash));\n});\n\n/**\n * Return true if x is a Keyword\n */\ncljs.core.keyword_QMARK_ \x3d (function cljs$core$keyword_QMARK_(x){\nreturn (x instanceof cljs.core.Keyword);\n});\n/**\n * Efficient test to determine that two keywords are identical.\n */\ncljs.core.keyword_identical_QMARK_ \x3d (function cljs$core$keyword_identical_QMARK_(x,y){\nif((x \x3d\x3d\x3d y)){\nreturn true;\n} else {\nif((((x instanceof cljs.core.Keyword)) \x26\x26 ((y instanceof cljs.core.Keyword)))){\nreturn (x.fqn \x3d\x3d\x3d y.fqn);\n} else {\nreturn false;\n}\n}\n});\n/**\n * Efficient test to determine that two symbols are identical.\n */\ncljs.core.symbol_identical_QMARK_ \x3d (function cljs$core$symbol_identical_QMARK_(x,y){\nif((x \x3d\x3d\x3d y)){\nreturn true;\n} else {\nif((((x instanceof cljs.core.Symbol)) \x26\x26 ((y instanceof cljs.core.Symbol)))){\nreturn (x.str \x3d\x3d\x3d y.str);\n} else {\nreturn false;\n}\n}\n});\n/**\n * Returns the namespace String of a symbol or keyword, or nil if not present.\n */\ncljs.core.namespace \x3d (function cljs$core$namespace(x){\nif((((!((x \x3d\x3d null))))?(((((x.cljs$lang$protocol_mask$partition1$ \x26 (4096))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$INamed$))))?true:false):false)){\nreturn cljs.core._namespace(x);\n} else {\nthrow (new Error(["Doesn\'t support namespace: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x)].join(\'\')));\n}\n});\n/**\n * Return true if x is a symbol or keyword\n */\ncljs.core.ident_QMARK_ \x3d (function cljs$core$ident_QMARK_(x){\nreturn (((x instanceof cljs.core.Keyword)) || ((x instanceof cljs.core.Symbol)));\n});\n/**\n * Return true if x is a symbol or keyword without a namespace\n */\ncljs.core.simple_ident_QMARK_ \x3d (function cljs$core$simple_ident_QMARK_(x){\nreturn ((cljs.core.ident_QMARK_(x)) \x26\x26 ((cljs.core.namespace(x) \x3d\x3d null)));\n});\n/**\n * Return true if x is a symbol or keyword with a namespace\n */\ncljs.core.qualified_ident_QMARK_ \x3d (function cljs$core$qualified_ident_QMARK_(x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d cljs.core.ident_QMARK_(x);\nif(and__4120__auto__){\nvar and__4120__auto____$1 \x3d cljs.core.namespace(x);\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn true;\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\n/**\n * Return true if x is a symbol without a namespace\n */\ncljs.core.simple_symbol_QMARK_ \x3d (function cljs$core$simple_symbol_QMARK_(x){\nreturn (((x instanceof cljs.core.Symbol)) \x26\x26 ((cljs.core.namespace(x) \x3d\x3d null)));\n});\n/**\n * Return true if x is a symbol with a namespace\n */\ncljs.core.qualified_symbol_QMARK_ \x3d (function cljs$core$qualified_symbol_QMARK_(x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (x instanceof cljs.core.Symbol);\nif(and__4120__auto__){\nvar and__4120__auto____$1 \x3d cljs.core.namespace(x);\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn true;\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\n/**\n * Return true if x is a keyword without a namespace\n */\ncljs.core.simple_keyword_QMARK_ \x3d (function cljs$core$simple_keyword_QMARK_(x){\nreturn (((x instanceof cljs.core.Keyword)) \x26\x26 ((cljs.core.namespace(x) \x3d\x3d null)));\n});\n/**\n * Return true if x is a keyword with a namespace\n */\ncljs.core.qualified_keyword_QMARK_ \x3d (function cljs$core$qualified_keyword_QMARK_(x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (x instanceof cljs.core.Keyword);\nif(and__4120__auto__){\nvar and__4120__auto____$1 \x3d cljs.core.namespace(x);\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn true;\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\n/**\n * Returns a Keyword with the given namespace and name.  Do not use :\n *   in the keyword strings, it will be added automatically.\n */\ncljs.core.keyword \x3d (function cljs$core$keyword(var_args){\nvar G__10079 \x3d arguments.length;\nswitch (G__10079) {\ncase 1:\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.keyword.cljs$core$IFn$_invoke$arity$1 \x3d (function (name){\nif((name instanceof cljs.core.Keyword)){\nreturn name;\n} else {\nif((name instanceof cljs.core.Symbol)){\nreturn (new cljs.core.Keyword(cljs.core.namespace(name),cljs.core.name(name),name.str,null));\n} else {\nif(typeof name \x3d\x3d\x3d \'string\'){\nvar parts \x3d name.split("/");\nif((parts.length \x3d\x3d\x3d (2))){\nreturn (new cljs.core.Keyword((parts[(0)]),(parts[(1)]),name,null));\n} else {\nreturn (new cljs.core.Keyword(null,(parts[(0)]),name,null));\n}\n} else {\nreturn null;\n}\n}\n}\n});\n\ncljs.core.keyword.cljs$core$IFn$_invoke$arity$2 \x3d (function (ns,name){\nvar ns__$1 \x3d (((ns instanceof cljs.core.Keyword))?cljs.core.name(ns):(((ns instanceof cljs.core.Symbol))?cljs.core.name(ns):ns\n));\nvar name__$1 \x3d (((name instanceof cljs.core.Keyword))?cljs.core.name(name):(((name instanceof cljs.core.Symbol))?cljs.core.name(name):name\n));\nreturn (new cljs.core.Keyword(ns__$1,name__$1,[(cljs.core.truth_(ns__$1)?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns__$1),"/"].join(\'\'):null),cljs.core.str.cljs$core$IFn$_invoke$arity$1(name__$1)].join(\'\'),null));\n});\n\ncljs.core.keyword.cljs$lang$maxFixedArity \x3d 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.LazySeq \x3d (function (meta,fn,s,__hash){\nthis.meta \x3d meta;\nthis.fn \x3d fn;\nthis.s \x3d s;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32374988;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 1;\n});\ncljs.core.LazySeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.LazySeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.LazySeq.prototype.sval \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nif((self__.fn \x3d\x3d null)){\nreturn self__.s;\n} else {\nself__.s \x3d (self__.fn.cljs$core$IFn$_invoke$arity$0 ? self__.fn.cljs$core$IFn$_invoke$arity$0() : self__.fn.call(null));\n\nself__.fn \x3d null;\n\nreturn self__.s;\n}\n});\n\ncljs.core.LazySeq.prototype.indexOf \x3d (function() {\nvar G__10081 \x3d null;\nvar G__10081__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10081__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10081 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10081__1.call(this,x);\ncase 2:\nreturn G__10081__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10081.cljs$core$IFn$_invoke$arity$1 \x3d G__10081__1;\nG__10081.cljs$core$IFn$_invoke$arity$2 \x3d G__10081__2;\nreturn G__10081;\n})()\n;\n\ncljs.core.LazySeq.prototype.lastIndexOf \x3d (function() {\nvar G__10082 \x3d null;\nvar G__10082__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10082__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10082 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10082__1.call(this,x);\ncase 2:\nreturn G__10082__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10082.cljs$core$IFn$_invoke$arity$1 \x3d G__10082__1;\nG__10082.cljs$core$IFn$_invoke$arity$2 \x3d G__10082__2;\nreturn G__10082;\n})()\n;\n\ncljs.core.LazySeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.LazySeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\ncoll__$1.cljs$core$ISeqable$_seq$arity$1(null);\n\nif((self__.s \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core.next(self__.s);\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.List.EMPTY,self__.meta);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.not(self__.fn);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\ncoll__$1.cljs$core$ISeqable$_seq$arity$1(null);\n\nif((self__.s \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core.first(self__.s);\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\ncoll__$1.cljs$core$ISeqable$_seq$arity$1(null);\n\nif((!((self__.s \x3d\x3d null)))){\nreturn cljs.core.rest(self__.s);\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\ncoll__$1.sval();\n\nif((self__.s \x3d\x3d null)){\nreturn null;\n} else {\nvar ls \x3d self__.s;\nwhile(true){\nif((ls instanceof cljs.core.LazySeq)){\nvar G__10083 \x3d ls.sval();\nls \x3d G__10083;\ncontinue;\n} else {\nself__.s \x3d ls;\n\nreturn cljs.core.seq(self__.s);\n}\nbreak;\n}\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.LazySeq(new_meta,((function (coll__$1){\nreturn (function (){\nreturn coll__$1.cljs$core$ISeqable$_seq$arity$1(null);\n});})(coll__$1))\n,null,self__.__hash));\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.LazySeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.with_meta(cljs.core.cst$sym$fn,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$s,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.LazySeq.cljs$lang$type \x3d true;\n\ncljs.core.LazySeq.cljs$lang$ctorStr \x3d "cljs.core/LazySeq";\n\ncljs.core.LazySeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/LazySeq");\n});\n\n/**\n * Positional factory function for cljs.core/LazySeq.\n */\ncljs.core.__GT_LazySeq \x3d (function cljs$core$__GT_LazySeq(meta,fn,s,__hash){\nreturn (new cljs.core.LazySeq(meta,fn,s,__hash));\n});\n\nvar G__10084_10087 \x3d cljs.core.LazySeq.prototype;\nvar G__10085_10088 \x3d cljs.core.ITER_SYMBOL;\nvar G__10086_10089 \x3d ((function (G__10084_10087,G__10085_10088){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10084_10087,G__10085_10088))\n;\ngoog.object.set(G__10084_10087,G__10085_10088,G__10086_10089);\n\n/**\n* @constructor\n * @implements {cljs.core.ICounted}\n*/\ncljs.core.ChunkBuffer \x3d (function (buf,end){\nthis.buf \x3d buf;\nthis.end \x3d end;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 2;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.ChunkBuffer.prototype.add \x3d (function (o){\nvar self__ \x3d this;\nvar _ \x3d this;\n(self__.buf[self__.end] \x3d o);\n\nreturn self__.end \x3d (self__.end + (1));\n});\n\ncljs.core.ChunkBuffer.prototype.chunk \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar ret \x3d (new cljs.core.ArrayChunk(self__.buf,(0),self__.end));\nself__.buf \x3d null;\n\nreturn ret;\n});\n\ncljs.core.ChunkBuffer.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.end;\n});\n\ncljs.core.ChunkBuffer.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$buf,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$end,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ChunkBuffer.cljs$lang$type \x3d true;\n\ncljs.core.ChunkBuffer.cljs$lang$ctorStr \x3d "cljs.core/ChunkBuffer";\n\ncljs.core.ChunkBuffer.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ChunkBuffer");\n});\n\n/**\n * Positional factory function for cljs.core/ChunkBuffer.\n */\ncljs.core.__GT_ChunkBuffer \x3d (function cljs$core$__GT_ChunkBuffer(buf,end){\nreturn (new cljs.core.ChunkBuffer(buf,end));\n});\n\ncljs.core.chunk_buffer \x3d (function cljs$core$chunk_buffer(capacity){\nreturn (new cljs.core.ChunkBuffer((new Array(capacity)),(0)));\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.IChunk}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.ArrayChunk \x3d (function (arr,off,end){\nthis.arr \x3d arr;\nthis.off \x3d off;\nthis.end \x3d end;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 524306;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.ArrayChunk.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (self__.end - self__.off);\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (coll,i){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (self__.arr[(self__.off + i)]);\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (coll,i,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((((i \x3e\x3d (0))) \x26\x26 ((i \x3c (self__.end - self__.off))))){\nreturn (self__.arr[(self__.off + i)]);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IChunk$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ArrayChunk.prototype.cljs$core$IChunk$_drop_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.off \x3d\x3d\x3d self__.end)){\nthrow (new Error("-drop-first of empty chunk"));\n} else {\nreturn (new cljs.core.ArrayChunk(self__.arr,(self__.off + (1)),self__.end));\n}\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4(self__.arr,f,(self__.arr[self__.off]),(self__.off + (1)));\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4(self__.arr,f,start,self__.off);\n});\n\ncljs.core.ArrayChunk.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$arr,cljs.core.cst$sym$off,cljs.core.cst$sym$end], null);\n});\n\ncljs.core.ArrayChunk.cljs$lang$type \x3d true;\n\ncljs.core.ArrayChunk.cljs$lang$ctorStr \x3d "cljs.core/ArrayChunk";\n\ncljs.core.ArrayChunk.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ArrayChunk");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayChunk.\n */\ncljs.core.__GT_ArrayChunk \x3d (function cljs$core$__GT_ArrayChunk(arr,off,end){\nreturn (new cljs.core.ArrayChunk(arr,off,end));\n});\n\ncljs.core.array_chunk \x3d (function cljs$core$array_chunk(var_args){\nvar G__10091 \x3d arguments.length;\nswitch (G__10091) {\ncase 1:\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.array_chunk.cljs$core$IFn$_invoke$arity$1 \x3d (function (arr){\nreturn (new cljs.core.ArrayChunk(arr,(0),arr.length));\n});\n\ncljs.core.array_chunk.cljs$core$IFn$_invoke$arity$2 \x3d (function (arr,off){\nreturn (new cljs.core.ArrayChunk(arr,off,arr.length));\n});\n\ncljs.core.array_chunk.cljs$core$IFn$_invoke$arity$3 \x3d (function (arr,off,end){\nreturn (new cljs.core.ArrayChunk(arr,off,end));\n});\n\ncljs.core.array_chunk.cljs$lang$maxFixedArity \x3d 3;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IChunkedNext}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IChunkedSeq}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.ChunkedCons \x3d (function (chunk,more,meta,__hash){\nthis.chunk \x3d chunk;\nthis.more \x3d more;\nthis.meta \x3d meta;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 31850732;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 1536;\n});\ncljs.core.ChunkedCons.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ChunkedCons.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ChunkedCons.prototype.indexOf \x3d (function() {\nvar G__10093 \x3d null;\nvar G__10093__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10093__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10093 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10093__1.call(this,x);\ncase 2:\nreturn G__10093__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10093.cljs$core$IFn$_invoke$arity$1 \x3d G__10093__1;\nG__10093.cljs$core$IFn$_invoke$arity$2 \x3d G__10093__2;\nreturn G__10093;\n})()\n;\n\ncljs.core.ChunkedCons.prototype.lastIndexOf \x3d (function() {\nvar G__10094 \x3d null;\nvar G__10094__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10094__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10094 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10094__1.call(this,x);\ncase 2:\nreturn G__10094__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10094.cljs$core$IFn$_invoke$arity$1 \x3d G__10094__1;\nG__10094.cljs$core$IFn$_invoke$arity$2 \x3d G__10094__2;\nreturn G__10094;\n})()\n;\n\ncljs.core.ChunkedCons.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((cljs.core._count(self__.chunk) \x3e (1))){\nreturn (new cljs.core.ChunkedCons(cljs.core._drop_first(self__.chunk),self__.more,null,null));\n} else {\nif((self__.more \x3d\x3d null)){\nreturn null;\n} else {\nreturn cljs.core._seq(self__.more);\n}\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.chunk,(0));\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((cljs.core._count(self__.chunk) \x3e (1))){\nreturn (new cljs.core.ChunkedCons(cljs.core._drop_first(self__.chunk),self__.more,null,null));\n} else {\nif((self__.more \x3d\x3d null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.more;\n}\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IChunkedSeq$_chunked_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.chunk;\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IChunkedSeq$_chunked_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.more \x3d\x3d null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.more;\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.ChunkedCons(self__.chunk,self__.more,new_meta,self__.__hash));\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (this$,o){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn cljs.core.cons(o,this$__$1);\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IChunkedNext$_chunked_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.more \x3d\x3d null)){\nreturn null;\n} else {\nreturn self__.more;\n}\n});\n\ncljs.core.ChunkedCons.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$chunk,cljs.core.cst$sym$more,cljs.core.cst$sym$meta,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ChunkedCons.cljs$lang$type \x3d true;\n\ncljs.core.ChunkedCons.cljs$lang$ctorStr \x3d "cljs.core/ChunkedCons";\n\ncljs.core.ChunkedCons.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ChunkedCons");\n});\n\n/**\n * Positional factory function for cljs.core/ChunkedCons.\n */\ncljs.core.__GT_ChunkedCons \x3d (function cljs$core$__GT_ChunkedCons(chunk,more,meta,__hash){\nreturn (new cljs.core.ChunkedCons(chunk,more,meta,__hash));\n});\n\nvar G__10095_10098 \x3d cljs.core.ChunkedCons.prototype;\nvar G__10096_10099 \x3d cljs.core.ITER_SYMBOL;\nvar G__10097_10100 \x3d ((function (G__10095_10098,G__10096_10099){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10095_10098,G__10096_10099))\n;\ngoog.object.set(G__10095_10098,G__10096_10099,G__10097_10100);\ncljs.core.chunk_cons \x3d (function cljs$core$chunk_cons(chunk,rest){\nif((cljs.core._count(chunk) \x3d\x3d\x3d (0))){\nreturn rest;\n} else {\nreturn (new cljs.core.ChunkedCons(chunk,rest,null,null));\n}\n});\ncljs.core.chunk_append \x3d (function cljs$core$chunk_append(b,x){\nreturn b.add(x);\n});\ncljs.core.chunk \x3d (function cljs$core$chunk(b){\nreturn b.chunk();\n});\ncljs.core.chunk_first \x3d (function cljs$core$chunk_first(s){\nreturn cljs.core._chunked_first(s);\n});\ncljs.core.chunk_rest \x3d (function cljs$core$chunk_rest(s){\nreturn cljs.core._chunked_rest(s);\n});\ncljs.core.chunk_next \x3d (function cljs$core$chunk_next(s){\nif((((!((s \x3d\x3d null))))?(((((s.cljs$lang$protocol_mask$partition1$ \x26 (1024))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d s.cljs$core$IChunkedNext$))))?true:false):false)){\nreturn cljs.core._chunked_next(s);\n} else {\nreturn cljs.core.seq(cljs.core._chunked_rest(s));\n}\n});\n/**\n * Returns an array containing the contents of coll.\n */\ncljs.core.to_array \x3d (function cljs$core$to_array(coll){\nvar ary \x3d [];\nvar s \x3d cljs.core.seq(coll);\nwhile(true){\nif((!((s \x3d\x3d null)))){\nary.push(cljs.core.first(s));\n\nvar G__10102 \x3d cljs.core.next(s);\ns \x3d G__10102;\ncontinue;\n} else {\nreturn ary;\n}\nbreak;\n}\n});\n/**\n * Returns a (potentially-ragged) 2-dimensional array\n *   containing the contents of coll.\n */\ncljs.core.to_array_2d \x3d (function cljs$core$to_array_2d(coll){\nvar ret \x3d (new Array(cljs.core.count(coll)));\nvar i_10103 \x3d (0);\nvar xs_10104 \x3d cljs.core.seq(coll);\nwhile(true){\nif((xs_10104 \x3d\x3d null)){\n} else {\n(ret[i_10103] \x3d cljs.core.to_array(cljs.core.first(xs_10104)));\n\nvar G__10105 \x3d (i_10103 + (1));\nvar G__10106 \x3d cljs.core.next(xs_10104);\ni_10103 \x3d G__10105;\nxs_10104 \x3d G__10106;\ncontinue;\n}\nbreak;\n}\n\nreturn ret;\n});\n/**\n * Creates an array of ints. Does not coerce array, provided for compatibility\n *   with Clojure.\n */\ncljs.core.int_array \x3d (function cljs$core$int_array(var_args){\nvar G__10108 \x3d arguments.length;\nswitch (G__10108) {\ncase 1:\nreturn cljs.core.int_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.int_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.int_array.cljs$core$IFn$_invoke$arity$1 \x3d (function (size_or_seq){\nif(typeof size_or_seq \x3d\x3d\x3d \'number\'){\nreturn cljs.core.int_array.cljs$core$IFn$_invoke$arity$2(size_or_seq,null);\n} else {\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(size_or_seq);\n}\n});\n\ncljs.core.int_array.cljs$core$IFn$_invoke$arity$2 \x3d (function (size,init_val_or_seq){\nvar a \x3d (new Array(size));\nif(cljs.core.seq_QMARK_(init_val_or_seq)){\nvar s \x3d cljs.core.seq(init_val_or_seq);\nvar i \x3d (0);\nvar s__$1 \x3d s;\nwhile(true){\nif(((s__$1) \x26\x26 ((i \x3c size)))){\n(a[i] \x3d cljs.core.first(s__$1));\n\nvar G__10110 \x3d (i + (1));\nvar G__10111 \x3d cljs.core.next(s__$1);\ni \x3d G__10110;\ns__$1 \x3d G__10111;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n} else {\nvar n__4607__auto___10112 \x3d size;\nvar i_10113 \x3d (0);\nwhile(true){\nif((i_10113 \x3c n__4607__auto___10112)){\n(a[i_10113] \x3d init_val_or_seq);\n\nvar G__10114 \x3d (i_10113 + (1));\ni_10113 \x3d G__10114;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn a;\n}\n});\n\ncljs.core.int_array.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Creates an array of longs. Does not coerce array, provided for compatibility\n *   with Clojure.\n */\ncljs.core.long_array \x3d (function cljs$core$long_array(var_args){\nvar G__10116 \x3d arguments.length;\nswitch (G__10116) {\ncase 1:\nreturn cljs.core.long_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.long_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.long_array.cljs$core$IFn$_invoke$arity$1 \x3d (function (size_or_seq){\nif(typeof size_or_seq \x3d\x3d\x3d \'number\'){\nreturn cljs.core.long_array.cljs$core$IFn$_invoke$arity$2(size_or_seq,null);\n} else {\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(size_or_seq);\n}\n});\n\ncljs.core.long_array.cljs$core$IFn$_invoke$arity$2 \x3d (function (size,init_val_or_seq){\nvar a \x3d (new Array(size));\nif(cljs.core.seq_QMARK_(init_val_or_seq)){\nvar s \x3d cljs.core.seq(init_val_or_seq);\nvar i \x3d (0);\nvar s__$1 \x3d s;\nwhile(true){\nif(((s__$1) \x26\x26 ((i \x3c size)))){\n(a[i] \x3d cljs.core.first(s__$1));\n\nvar G__10118 \x3d (i + (1));\nvar G__10119 \x3d cljs.core.next(s__$1);\ni \x3d G__10118;\ns__$1 \x3d G__10119;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n} else {\nvar n__4607__auto___10120 \x3d size;\nvar i_10121 \x3d (0);\nwhile(true){\nif((i_10121 \x3c n__4607__auto___10120)){\n(a[i_10121] \x3d init_val_or_seq);\n\nvar G__10122 \x3d (i_10121 + (1));\ni_10121 \x3d G__10122;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn a;\n}\n});\n\ncljs.core.long_array.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Creates an array of doubles. Does not coerce array, provided for compatibility\n *   with Clojure.\n */\ncljs.core.double_array \x3d (function cljs$core$double_array(var_args){\nvar G__10124 \x3d arguments.length;\nswitch (G__10124) {\ncase 1:\nreturn cljs.core.double_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.double_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.double_array.cljs$core$IFn$_invoke$arity$1 \x3d (function (size_or_seq){\nif(typeof size_or_seq \x3d\x3d\x3d \'number\'){\nreturn cljs.core.double_array.cljs$core$IFn$_invoke$arity$2(size_or_seq,null);\n} else {\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(size_or_seq);\n}\n});\n\ncljs.core.double_array.cljs$core$IFn$_invoke$arity$2 \x3d (function (size,init_val_or_seq){\nvar a \x3d (new Array(size));\nif(cljs.core.seq_QMARK_(init_val_or_seq)){\nvar s \x3d cljs.core.seq(init_val_or_seq);\nvar i \x3d (0);\nvar s__$1 \x3d s;\nwhile(true){\nif(((s__$1) \x26\x26 ((i \x3c size)))){\n(a[i] \x3d cljs.core.first(s__$1));\n\nvar G__10126 \x3d (i + (1));\nvar G__10127 \x3d cljs.core.next(s__$1);\ni \x3d G__10126;\ns__$1 \x3d G__10127;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n} else {\nvar n__4607__auto___10128 \x3d size;\nvar i_10129 \x3d (0);\nwhile(true){\nif((i_10129 \x3c n__4607__auto___10128)){\n(a[i_10129] \x3d init_val_or_seq);\n\nvar G__10130 \x3d (i_10129 + (1));\ni_10129 \x3d G__10130;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn a;\n}\n});\n\ncljs.core.double_array.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Creates an array of objects. Does not coerce array, provided for compatibility\n *   with Clojure.\n */\ncljs.core.object_array \x3d (function cljs$core$object_array(var_args){\nvar G__10132 \x3d arguments.length;\nswitch (G__10132) {\ncase 1:\nreturn cljs.core.object_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.object_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.object_array.cljs$core$IFn$_invoke$arity$1 \x3d (function (size_or_seq){\nif(typeof size_or_seq \x3d\x3d\x3d \'number\'){\nreturn cljs.core.object_array.cljs$core$IFn$_invoke$arity$2(size_or_seq,null);\n} else {\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(size_or_seq);\n}\n});\n\ncljs.core.object_array.cljs$core$IFn$_invoke$arity$2 \x3d (function (size,init_val_or_seq){\nvar a \x3d (new Array(size));\nif(cljs.core.seq_QMARK_(init_val_or_seq)){\nvar s \x3d cljs.core.seq(init_val_or_seq);\nvar i \x3d (0);\nvar s__$1 \x3d s;\nwhile(true){\nif(((s__$1) \x26\x26 ((i \x3c size)))){\n(a[i] \x3d cljs.core.first(s__$1));\n\nvar G__10134 \x3d (i + (1));\nvar G__10135 \x3d cljs.core.next(s__$1);\ni \x3d G__10134;\ns__$1 \x3d G__10135;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n} else {\nvar n__4607__auto___10136 \x3d size;\nvar i_10137 \x3d (0);\nwhile(true){\nif((i_10137 \x3c n__4607__auto___10136)){\n(a[i_10137] \x3d init_val_or_seq);\n\nvar G__10138 \x3d (i_10137 + (1));\ni_10137 \x3d G__10138;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn a;\n}\n});\n\ncljs.core.object_array.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * If coll is counted? returns its count, else will count at most the first n\n * elements of coll using its seq\n */\ncljs.core.bounded_count \x3d (function cljs$core$bounded_count(n,coll){\nif(cljs.core.counted_QMARK_(coll)){\nreturn cljs.core.count(coll);\n} else {\nvar i \x3d (0);\nvar s \x3d cljs.core.seq(coll);\nwhile(true){\nif((((!((s \x3d\x3d null)))) \x26\x26 ((i \x3c n)))){\nvar G__10139 \x3d (i + (1));\nvar G__10140 \x3d cljs.core.next(s);\ni \x3d G__10139;\ns \x3d G__10140;\ncontinue;\n} else {\nreturn i;\n}\nbreak;\n}\n}\n});\ncljs.core.spread \x3d (function cljs$core$spread(arglist){\nif((arglist \x3d\x3d null)){\nreturn null;\n} else {\nvar n \x3d cljs.core.next(arglist);\nif((n \x3d\x3d null)){\nreturn cljs.core.seq(cljs.core.first(arglist));\n} else {\nreturn cljs.core.cons(cljs.core.first(arglist),(cljs.core.spread.cljs$core$IFn$_invoke$arity$1 ? cljs.core.spread.cljs$core$IFn$_invoke$arity$1(n) : cljs.core.spread.call(null,n)));\n}\n}\n});\n/**\n * Returns a lazy seq representing the concatenation of the elements in the supplied colls.\n */\ncljs.core.concat \x3d (function cljs$core$concat(var_args){\nvar G__10145 \x3d arguments.length;\nswitch (G__10145) {\ncase 0:\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10147 \x3d arguments.length;\nvar i__4731__auto___10148 \x3d (0);\nwhile(true){\nif((i__4731__auto___10148 \x3c len__4730__auto___10147)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10148]));\n\nvar G__10149 \x3d (i__4731__auto___10148 + (1));\ni__4731__auto___10148 \x3d G__10149;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.concat.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn null;\n}),null,null));\n});\n\ncljs.core.concat.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn x;\n}),null,null));\n});\n\ncljs.core.concat.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s \x3d cljs.core.seq(x);\nif(s){\nif(cljs.core.chunked_seq_QMARK_(s)){\nreturn cljs.core.chunk_cons(cljs.core.chunk_first(s),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.chunk_rest(s),y));\n} else {\nreturn cljs.core.cons(cljs.core.first(s),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.rest(s),y));\n}\n} else {\nreturn y;\n}\n}),null,null));\n});\n\ncljs.core.concat.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,zs){\nvar cat \x3d (function cljs$core$cat(xys,zs__$1){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar xys__$1 \x3d cljs.core.seq(xys);\nif(xys__$1){\nif(cljs.core.chunked_seq_QMARK_(xys__$1)){\nreturn cljs.core.chunk_cons(cljs.core.chunk_first(xys__$1),cljs$core$cat(cljs.core.chunk_rest(xys__$1),zs__$1));\n} else {\nreturn cljs.core.cons(cljs.core.first(xys__$1),cljs$core$cat(cljs.core.rest(xys__$1),zs__$1));\n}\n} else {\nif(cljs.core.truth_(zs__$1)){\nreturn cljs$core$cat(cljs.core.first(zs__$1),cljs.core.next(zs__$1));\n} else {\nreturn null;\n}\n}\n}),null,null));\n});\nreturn cat(cljs.core.concat.cljs$core$IFn$_invoke$arity$2(x,y),zs);\n});\n\n/** @this {Function} */\ncljs.core.concat.cljs$lang$applyTo \x3d (function (seq10142){\nvar G__10143 \x3d cljs.core.first(seq10142);\nvar seq10142__$1 \x3d cljs.core.next(seq10142);\nvar G__10144 \x3d cljs.core.first(seq10142__$1);\nvar seq10142__$2 \x3d cljs.core.next(seq10142__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10143,G__10144,seq10142__$2);\n});\n\ncljs.core.concat.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Creates a new list containing the items prepended to the rest, the\n *   last of which will be treated as a sequence.\n */\ncljs.core.list_STAR_ \x3d (function cljs$core$list_STAR_(var_args){\nvar G__10156 \x3d arguments.length;\nswitch (G__10156) {\ncase 1:\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10158 \x3d arguments.length;\nvar i__4731__auto___10159 \x3d (0);\nwhile(true){\nif((i__4731__auto___10159 \x3c len__4730__auto___10158)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10159]));\n\nvar G__10160 \x3d (i__4731__auto___10159 + (1));\ni__4731__auto___10159 \x3d G__10160;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$1 \x3d (function (args){\nreturn cljs.core.seq(args);\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$2 \x3d (function (a,args){\nreturn cljs.core.cons(a,args);\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$3 \x3d (function (a,b,args){\nreturn cljs.core.cons(a,cljs.core.cons(b,args));\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4 \x3d (function (a,b,c,args){\nreturn cljs.core.cons(a,cljs.core.cons(b,cljs.core.cons(c,args)));\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (a,b,c,d,more){\nreturn cljs.core.cons(a,cljs.core.cons(b,cljs.core.cons(c,cljs.core.cons(d,cljs.core.spread(more)))));\n});\n\n/** @this {Function} */\ncljs.core.list_STAR_.cljs$lang$applyTo \x3d (function (seq10151){\nvar G__10152 \x3d cljs.core.first(seq10151);\nvar seq10151__$1 \x3d cljs.core.next(seq10151);\nvar G__10153 \x3d cljs.core.first(seq10151__$1);\nvar seq10151__$2 \x3d cljs.core.next(seq10151__$1);\nvar G__10154 \x3d cljs.core.first(seq10151__$2);\nvar seq10151__$3 \x3d cljs.core.next(seq10151__$2);\nvar G__10155 \x3d cljs.core.first(seq10151__$3);\nvar seq10151__$4 \x3d cljs.core.next(seq10151__$3);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10152,G__10153,G__10154,G__10155,seq10151__$4);\n});\n\ncljs.core.list_STAR_.cljs$lang$maxFixedArity \x3d (4);\n\n/**\n * Returns a new, transient version of the collection, in constant time.\n */\ncljs.core.transient$ \x3d (function cljs$core$transient(coll){\nreturn cljs.core._as_transient(coll);\n});\n/**\n * Returns a new, persistent version of the transient collection, in\n *   constant time. The transient collection cannot be used after this\n *   call, any such use will throw an exception.\n */\ncljs.core.persistent_BANG_ \x3d (function cljs$core$persistent_BANG_(tcoll){\nreturn cljs.core._persistent_BANG_(tcoll);\n});\n/**\n * Adds val to the transient collection, and return tcoll. The \'addition\'\n *   may happen at different \'places\' depending on the concrete type.\n */\ncljs.core.conj_BANG_ \x3d (function cljs$core$conj_BANG_(var_args){\nvar G__10165 \x3d arguments.length;\nswitch (G__10165) {\ncase 0:\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10167 \x3d arguments.length;\nvar i__4731__auto___10168 \x3d (0);\nwhile(true){\nif((i__4731__auto___10168 \x3c len__4730__auto___10167)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10168]));\n\nvar G__10169 \x3d (i__4731__auto___10168 + (1));\ni__4731__auto___10168 \x3d G__10169;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\n});\n\ncljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$1 \x3d (function (tcoll){\nreturn tcoll;\n});\n\ncljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2 \x3d (function (tcoll,val){\nreturn cljs.core._conj_BANG_(tcoll,val);\n});\n\ncljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (tcoll,val,vals){\nwhile(true){\nvar ntcoll \x3d cljs.core._conj_BANG_(tcoll,val);\nif(cljs.core.truth_(vals)){\nvar G__10170 \x3d ntcoll;\nvar G__10171 \x3d cljs.core.first(vals);\nvar G__10172 \x3d cljs.core.next(vals);\ntcoll \x3d G__10170;\nval \x3d G__10171;\nvals \x3d G__10172;\ncontinue;\n} else {\nreturn ntcoll;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.conj_BANG_.cljs$lang$applyTo \x3d (function (seq10162){\nvar G__10163 \x3d cljs.core.first(seq10162);\nvar seq10162__$1 \x3d cljs.core.next(seq10162);\nvar G__10164 \x3d cljs.core.first(seq10162__$1);\nvar seq10162__$2 \x3d cljs.core.next(seq10162__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10163,G__10164,seq10162__$2);\n});\n\ncljs.core.conj_BANG_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * When applied to a transient map, adds mapping of key(s) to\n *   val(s). When applied to a transient vector, sets the val at index.\n *   Note - index must be \x3c\x3d (count vector). Returns coll.\n */\ncljs.core.assoc_BANG_ \x3d (function cljs$core$assoc_BANG_(var_args){\nvar G__10178 \x3d arguments.length;\nswitch (G__10178) {\ncase 3:\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10180 \x3d arguments.length;\nvar i__4731__auto___10181 \x3d (0);\nwhile(true){\nif((i__4731__auto___10181 \x3c len__4730__auto___10180)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10181]));\n\nvar G__10182 \x3d (i__4731__auto___10181 + (1));\ni__4731__auto___10181 \x3d G__10182;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3 \x3d (function (tcoll,key,val){\nreturn cljs.core._assoc_BANG_(tcoll,key,val);\n});\n\ncljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (tcoll,key,val,kvs){\nwhile(true){\nvar ntcoll \x3d cljs.core._assoc_BANG_(tcoll,key,val);\nif(cljs.core.truth_(kvs)){\nvar G__10183 \x3d ntcoll;\nvar G__10184 \x3d cljs.core.first(kvs);\nvar G__10185 \x3d cljs.core.second(kvs);\nvar G__10186 \x3d cljs.core.nnext(kvs);\ntcoll \x3d G__10183;\nkey \x3d G__10184;\nval \x3d G__10185;\nkvs \x3d G__10186;\ncontinue;\n} else {\nreturn ntcoll;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.assoc_BANG_.cljs$lang$applyTo \x3d (function (seq10174){\nvar G__10175 \x3d cljs.core.first(seq10174);\nvar seq10174__$1 \x3d cljs.core.next(seq10174);\nvar G__10176 \x3d cljs.core.first(seq10174__$1);\nvar seq10174__$2 \x3d cljs.core.next(seq10174__$1);\nvar G__10177 \x3d cljs.core.first(seq10174__$2);\nvar seq10174__$3 \x3d cljs.core.next(seq10174__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10175,G__10176,G__10177,seq10174__$3);\n});\n\ncljs.core.assoc_BANG_.cljs$lang$maxFixedArity \x3d (3);\n\n/**\n * Returns a transient map that doesn\'t contain a mapping for key(s).\n */\ncljs.core.dissoc_BANG_ \x3d (function cljs$core$dissoc_BANG_(var_args){\nvar G__10191 \x3d arguments.length;\nswitch (G__10191) {\ncase 2:\nreturn cljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10193 \x3d arguments.length;\nvar i__4731__auto___10194 \x3d (0);\nwhile(true){\nif((i__4731__auto___10194 \x3c len__4730__auto___10193)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10194]));\n\nvar G__10195 \x3d (i__4731__auto___10194 + (1));\ni__4731__auto___10194 \x3d G__10195;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$2 \x3d (function (tcoll,key){\nreturn cljs.core._dissoc_BANG_(tcoll,key);\n});\n\ncljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (tcoll,key,ks){\nwhile(true){\nvar ntcoll \x3d cljs.core._dissoc_BANG_(tcoll,key);\nif(cljs.core.truth_(ks)){\nvar G__10196 \x3d ntcoll;\nvar G__10197 \x3d cljs.core.first(ks);\nvar G__10198 \x3d cljs.core.next(ks);\ntcoll \x3d G__10196;\nkey \x3d G__10197;\nks \x3d G__10198;\ncontinue;\n} else {\nreturn ntcoll;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.dissoc_BANG_.cljs$lang$applyTo \x3d (function (seq10188){\nvar G__10189 \x3d cljs.core.first(seq10188);\nvar seq10188__$1 \x3d cljs.core.next(seq10188);\nvar G__10190 \x3d cljs.core.first(seq10188__$1);\nvar seq10188__$2 \x3d cljs.core.next(seq10188__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10189,G__10190,seq10188__$2);\n});\n\ncljs.core.dissoc_BANG_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Removes the last item from a transient vector. If\n *   the collection is empty, throws an exception. Returns tcoll\n */\ncljs.core.pop_BANG_ \x3d (function cljs$core$pop_BANG_(tcoll){\nreturn cljs.core._pop_BANG_(tcoll);\n});\n/**\n * disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n *   does not contain key(s).\n */\ncljs.core.disj_BANG_ \x3d (function cljs$core$disj_BANG_(var_args){\nvar G__10203 \x3d arguments.length;\nswitch (G__10203) {\ncase 2:\nreturn cljs.core.disj_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10205 \x3d arguments.length;\nvar i__4731__auto___10206 \x3d (0);\nwhile(true){\nif((i__4731__auto___10206 \x3c len__4730__auto___10205)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10206]));\n\nvar G__10207 \x3d (i__4731__auto___10206 + (1));\ni__4731__auto___10206 \x3d G__10207;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.disj_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.disj_BANG_.cljs$core$IFn$_invoke$arity$2 \x3d (function (tcoll,val){\nreturn cljs.core._disjoin_BANG_(tcoll,val);\n});\n\ncljs.core.disj_BANG_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (tcoll,val,vals){\nwhile(true){\nvar ntcoll \x3d cljs.core._disjoin_BANG_(tcoll,val);\nif(cljs.core.truth_(vals)){\nvar G__10208 \x3d ntcoll;\nvar G__10209 \x3d cljs.core.first(vals);\nvar G__10210 \x3d cljs.core.next(vals);\ntcoll \x3d G__10208;\nval \x3d G__10209;\nvals \x3d G__10210;\ncontinue;\n} else {\nreturn ntcoll;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.disj_BANG_.cljs$lang$applyTo \x3d (function (seq10200){\nvar G__10201 \x3d cljs.core.first(seq10200);\nvar seq10200__$1 \x3d cljs.core.next(seq10200);\nvar G__10202 \x3d cljs.core.first(seq10200__$1);\nvar seq10200__$2 \x3d cljs.core.next(seq10200__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10201,G__10202,seq10200__$2);\n});\n\ncljs.core.disj_BANG_.cljs$lang$maxFixedArity \x3d (2);\n\n\ncljs.core.apply_to \x3d (function cljs$core$apply_to(f,argc,args){\nvar args__$1 \x3d cljs.core.seq(args);\nif((argc \x3d\x3d\x3d (0))){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n} else {\nvar a142 \x3d cljs.core._first(args__$1);\nvar args__$2 \x3d cljs.core._rest(args__$1);\nif((argc \x3d\x3d\x3d (1))){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(a142) : f.call(null,a142));\n} else {\nvar b143 \x3d cljs.core._first(args__$2);\nvar args__$3 \x3d cljs.core._rest(args__$2);\nif((argc \x3d\x3d\x3d (2))){\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(a142,b143) : f.call(null,a142,b143));\n} else {\nvar c144 \x3d cljs.core._first(args__$3);\nvar args__$4 \x3d cljs.core._rest(args__$3);\nif((argc \x3d\x3d\x3d (3))){\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(a142,b143,c144) : f.call(null,a142,b143,c144));\n} else {\nvar d145 \x3d cljs.core._first(args__$4);\nvar args__$5 \x3d cljs.core._rest(args__$4);\nif((argc \x3d\x3d\x3d (4))){\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(a142,b143,c144,d145) : f.call(null,a142,b143,c144,d145));\n} else {\nvar e146 \x3d cljs.core._first(args__$5);\nvar args__$6 \x3d cljs.core._rest(args__$5);\nif((argc \x3d\x3d\x3d (5))){\nreturn (f.cljs$core$IFn$_invoke$arity$5 ? f.cljs$core$IFn$_invoke$arity$5(a142,b143,c144,d145,e146) : f.call(null,a142,b143,c144,d145,e146));\n} else {\nvar f147 \x3d cljs.core._first(args__$6);\nvar args__$7 \x3d cljs.core._rest(args__$6);\nif((argc \x3d\x3d\x3d (6))){\nreturn (f.cljs$core$IFn$_invoke$arity$6 ? f.cljs$core$IFn$_invoke$arity$6(a142,b143,c144,d145,e146,f147) : f.call(null,a142,b143,c144,d145,e146,f147));\n} else {\nvar g148 \x3d cljs.core._first(args__$7);\nvar args__$8 \x3d cljs.core._rest(args__$7);\nif((argc \x3d\x3d\x3d (7))){\nreturn (f.cljs$core$IFn$_invoke$arity$7 ? f.cljs$core$IFn$_invoke$arity$7(a142,b143,c144,d145,e146,f147,g148) : f.call(null,a142,b143,c144,d145,e146,f147,g148));\n} else {\nvar h149 \x3d cljs.core._first(args__$8);\nvar args__$9 \x3d cljs.core._rest(args__$8);\nif((argc \x3d\x3d\x3d (8))){\nreturn (f.cljs$core$IFn$_invoke$arity$8 ? f.cljs$core$IFn$_invoke$arity$8(a142,b143,c144,d145,e146,f147,g148,h149) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149));\n} else {\nvar i150 \x3d cljs.core._first(args__$9);\nvar args__$10 \x3d cljs.core._rest(args__$9);\nif((argc \x3d\x3d\x3d (9))){\nreturn (f.cljs$core$IFn$_invoke$arity$9 ? f.cljs$core$IFn$_invoke$arity$9(a142,b143,c144,d145,e146,f147,g148,h149,i150) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150));\n} else {\nvar j151 \x3d cljs.core._first(args__$10);\nvar args__$11 \x3d cljs.core._rest(args__$10);\nif((argc \x3d\x3d\x3d (10))){\nreturn (f.cljs$core$IFn$_invoke$arity$10 ? f.cljs$core$IFn$_invoke$arity$10(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151));\n} else {\nvar k152 \x3d cljs.core._first(args__$11);\nvar args__$12 \x3d cljs.core._rest(args__$11);\nif((argc \x3d\x3d\x3d (11))){\nreturn (f.cljs$core$IFn$_invoke$arity$11 ? f.cljs$core$IFn$_invoke$arity$11(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152));\n} else {\nvar l153 \x3d cljs.core._first(args__$12);\nvar args__$13 \x3d cljs.core._rest(args__$12);\nif((argc \x3d\x3d\x3d (12))){\nreturn (f.cljs$core$IFn$_invoke$arity$12 ? f.cljs$core$IFn$_invoke$arity$12(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153));\n} else {\nvar m154 \x3d cljs.core._first(args__$13);\nvar args__$14 \x3d cljs.core._rest(args__$13);\nif((argc \x3d\x3d\x3d (13))){\nreturn (f.cljs$core$IFn$_invoke$arity$13 ? f.cljs$core$IFn$_invoke$arity$13(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154));\n} else {\nvar n155 \x3d cljs.core._first(args__$14);\nvar args__$15 \x3d cljs.core._rest(args__$14);\nif((argc \x3d\x3d\x3d (14))){\nreturn (f.cljs$core$IFn$_invoke$arity$14 ? f.cljs$core$IFn$_invoke$arity$14(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155));\n} else {\nvar o156 \x3d cljs.core._first(args__$15);\nvar args__$16 \x3d cljs.core._rest(args__$15);\nif((argc \x3d\x3d\x3d (15))){\nreturn (f.cljs$core$IFn$_invoke$arity$15 ? f.cljs$core$IFn$_invoke$arity$15(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156));\n} else {\nvar p157 \x3d cljs.core._first(args__$16);\nvar args__$17 \x3d cljs.core._rest(args__$16);\nif((argc \x3d\x3d\x3d (16))){\nreturn (f.cljs$core$IFn$_invoke$arity$16 ? f.cljs$core$IFn$_invoke$arity$16(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157));\n} else {\nvar q158 \x3d cljs.core._first(args__$17);\nvar args__$18 \x3d cljs.core._rest(args__$17);\nif((argc \x3d\x3d\x3d (17))){\nreturn (f.cljs$core$IFn$_invoke$arity$17 ? f.cljs$core$IFn$_invoke$arity$17(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158));\n} else {\nvar r159 \x3d cljs.core._first(args__$18);\nvar args__$19 \x3d cljs.core._rest(args__$18);\nif((argc \x3d\x3d\x3d (18))){\nreturn (f.cljs$core$IFn$_invoke$arity$18 ? f.cljs$core$IFn$_invoke$arity$18(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159));\n} else {\nvar s160 \x3d cljs.core._first(args__$19);\nvar args__$20 \x3d cljs.core._rest(args__$19);\nif((argc \x3d\x3d\x3d (19))){\nreturn (f.cljs$core$IFn$_invoke$arity$19 ? f.cljs$core$IFn$_invoke$arity$19(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159,s160) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159,s160));\n} else {\nvar t161 \x3d cljs.core._first(args__$20);\nvar args__$21 \x3d cljs.core._rest(args__$20);\nif((argc \x3d\x3d\x3d (20))){\nreturn (f.cljs$core$IFn$_invoke$arity$20 ? f.cljs$core$IFn$_invoke$arity$20(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159,s160,t161) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159,s160,t161));\n} else {\nthrow (new Error("Only up to 20 arguments supported on functions"));\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n});\n\n/**\n * Internal. DO NOT USE! Next without the nil? check.\n */\ncljs.core.next_STAR_ \x3d (function cljs$core$next_STAR_(coll){\nif((((!((coll \x3d\x3d null))))?(((((coll.cljs$lang$protocol_mask$partition0$ \x26 (128))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d coll.cljs$core$INext$))))?true:false):false)){\nreturn coll.cljs$core$INext$_next$arity$1(null);\n} else {\nreturn cljs.core.seq(cljs.core.rest(coll));\n}\n});\n/**\n * Internal. DO NOT USE!\n *   Assumes args was already called with seq beforehand!\n */\ncljs.core.apply_to_simple \x3d (function cljs$core$apply_to_simple(var_args){\nvar G__10213 \x3d arguments.length;\nswitch (G__10213) {\ncase 2:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,args){\nif((args \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$0){\nreturn f.cljs$core$IFn$_invoke$arity$0();\n} else {\nreturn f.call(f);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3(f,cljs.core._first(args),cljs.core.next_STAR_(args));\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,a0,args){\nif((args \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$1){\nreturn f.cljs$core$IFn$_invoke$arity$1(a0);\n} else {\nreturn f.call(f,a0);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$4(f,a0,cljs.core._first(args),cljs.core.next_STAR_(args));\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$4 \x3d (function (f,a0,a1,args){\nif((args \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$2){\nreturn f.cljs$core$IFn$_invoke$arity$2(a0,a1);\n} else {\nreturn f.call(f,a0,a1);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$5(f,a0,a1,cljs.core._first(args),cljs.core.next_STAR_(args));\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$5 \x3d (function (f,a0,a1,a2,args){\nif((args \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$3){\nreturn f.cljs$core$IFn$_invoke$arity$3(a0,a1,a2);\n} else {\nreturn f.call(f,a0,a1,a2);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$6(f,a0,a1,a2,cljs.core._first(args),cljs.core.next_STAR_(args));\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$6 \x3d (function (f,a0,a1,a2,a3,args){\nif((args \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$4){\nreturn f.cljs$core$IFn$_invoke$arity$4(a0,a1,a2,a3);\n} else {\nreturn f.call(f,a0,a1,a2,a3);\n}\n} else {\nvar a4 \x3d cljs.core._first(args);\nvar next_4 \x3d cljs.core.next(args);\nif((next_4 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$5){\nreturn f.cljs$core$IFn$_invoke$arity$5(a0,a1,a2,a3,a4);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4);\n}\n} else {\nvar a5 \x3d cljs.core._first(next_4);\nvar next_5 \x3d cljs.core.next(next_4);\nif((next_5 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$6){\nreturn f.cljs$core$IFn$_invoke$arity$6(a0,a1,a2,a3,a4,a5);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5);\n}\n} else {\nvar a6 \x3d cljs.core._first(next_5);\nvar next_6 \x3d cljs.core.next(next_5);\nif((next_6 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$7){\nreturn f.cljs$core$IFn$_invoke$arity$7(a0,a1,a2,a3,a4,a5,a6);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6);\n}\n} else {\nvar a7 \x3d cljs.core._first(next_6);\nvar next_7 \x3d cljs.core.next(next_6);\nif((next_7 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$8){\nreturn f.cljs$core$IFn$_invoke$arity$8(a0,a1,a2,a3,a4,a5,a6,a7);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7);\n}\n} else {\nvar a8 \x3d cljs.core._first(next_7);\nvar next_8 \x3d cljs.core.next(next_7);\nif((next_8 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$9){\nreturn f.cljs$core$IFn$_invoke$arity$9(a0,a1,a2,a3,a4,a5,a6,a7,a8);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8);\n}\n} else {\nvar a9 \x3d cljs.core._first(next_8);\nvar next_9 \x3d cljs.core.next(next_8);\nif((next_9 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$10){\nreturn f.cljs$core$IFn$_invoke$arity$10(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9);\n}\n} else {\nvar a10 \x3d cljs.core._first(next_9);\nvar next_10 \x3d cljs.core.next(next_9);\nif((next_10 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$11){\nreturn f.cljs$core$IFn$_invoke$arity$11(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);\n}\n} else {\nvar a11 \x3d cljs.core._first(next_10);\nvar next_11 \x3d cljs.core.next(next_10);\nif((next_11 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$12){\nreturn f.cljs$core$IFn$_invoke$arity$12(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);\n}\n} else {\nvar a12 \x3d cljs.core._first(next_11);\nvar next_12 \x3d cljs.core.next(next_11);\nif((next_12 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$13){\nreturn f.cljs$core$IFn$_invoke$arity$13(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12);\n}\n} else {\nvar a13 \x3d cljs.core._first(next_12);\nvar next_13 \x3d cljs.core.next(next_12);\nif((next_13 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$14){\nreturn f.cljs$core$IFn$_invoke$arity$14(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13);\n}\n} else {\nvar a14 \x3d cljs.core._first(next_13);\nvar next_14 \x3d cljs.core.next(next_13);\nif((next_14 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$15){\nreturn f.cljs$core$IFn$_invoke$arity$15(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14);\n}\n} else {\nvar a15 \x3d cljs.core._first(next_14);\nvar next_15 \x3d cljs.core.next(next_14);\nif((next_15 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$16){\nreturn f.cljs$core$IFn$_invoke$arity$16(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);\n}\n} else {\nvar a16 \x3d cljs.core._first(next_15);\nvar next_16 \x3d cljs.core.next(next_15);\nif((next_16 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$17){\nreturn f.cljs$core$IFn$_invoke$arity$17(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);\n}\n} else {\nvar a17 \x3d cljs.core._first(next_16);\nvar next_17 \x3d cljs.core.next(next_16);\nif((next_17 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$18){\nreturn f.cljs$core$IFn$_invoke$arity$18(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17);\n}\n} else {\nvar a18 \x3d cljs.core._first(next_17);\nvar next_18 \x3d cljs.core.next(next_17);\nif((next_18 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$19){\nreturn f.cljs$core$IFn$_invoke$arity$19(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18);\n}\n} else {\nvar a19 \x3d cljs.core._first(next_18);\nvar next_19 \x3d cljs.core.next(next_18);\nif((next_19 \x3d\x3d null)){\nif(f.cljs$core$IFn$_invoke$arity$20){\nreturn f.cljs$core$IFn$_invoke$arity$20(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19);\n}\n} else {\nvar arr__4655__auto__ \x3d [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19];\nvar s__4656__auto___10215 \x3d next_19;\nwhile(true){\nif(s__4656__auto___10215){\narr__4655__auto__.push(cljs.core._first(s__4656__auto___10215));\n\nvar G__10216 \x3d cljs.core.next(s__4656__auto___10215);\ns__4656__auto___10215 \x3d G__10216;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn f.apply(f,arr__4655__auto__);\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n});\n\ncljs.core.apply_to_simple.cljs$lang$maxFixedArity \x3d 6;\n\n/**\n * Applies fn f to the argument list formed by prepending intervening arguments to args.\n */\ncljs.core.apply \x3d (function cljs$core$apply(var_args){\nvar G__10224 \x3d arguments.length;\nswitch (G__10224) {\ncase 2:\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10226 \x3d arguments.length;\nvar i__4731__auto___10227 \x3d (0);\nwhile(true){\nif((i__4731__auto___10227 \x3c len__4730__auto___10226)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10227]));\n\nvar G__10228 \x3d (i__4731__auto___10227 + (1));\ni__4731__auto___10227 \x3d G__10228;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((5)),(0),null));\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,args){\nif(f.cljs$lang$applyTo){\nvar fixed_arity \x3d f.cljs$lang$maxFixedArity;\nvar bc \x3d cljs.core.bounded_count((fixed_arity + (1)),args);\nif((bc \x3c\x3d fixed_arity)){\nreturn cljs.core.apply_to(f,bc,args);\n} else {\nreturn f.cljs$lang$applyTo(args);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2(f,cljs.core.seq(args));\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,x,args){\nif(f.cljs$lang$applyTo){\nvar arglist \x3d cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$2(x,args);\nvar fixed_arity \x3d f.cljs$lang$maxFixedArity;\nvar bc \x3d (cljs.core.bounded_count(fixed_arity,args) + (1));\nif((bc \x3c\x3d fixed_arity)){\nreturn cljs.core.apply_to(f,bc,arglist);\n} else {\nreturn f.cljs$lang$applyTo(arglist);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3(f,x,cljs.core.seq(args));\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$4 \x3d (function (f,x,y,args){\nif(f.cljs$lang$applyTo){\nvar arglist \x3d cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$3(x,y,args);\nvar fixed_arity \x3d f.cljs$lang$maxFixedArity;\nvar bc \x3d ((2) + cljs.core.bounded_count((fixed_arity - (1)),args));\nif((bc \x3c\x3d fixed_arity)){\nreturn cljs.core.apply_to(f,bc,arglist);\n} else {\nreturn f.cljs$lang$applyTo(arglist);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$4(f,x,y,cljs.core.seq(args));\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$5 \x3d (function (f,x,y,z,args){\nif(f.cljs$lang$applyTo){\nvar arglist \x3d cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(x,y,z,args);\nvar fixed_arity \x3d f.cljs$lang$maxFixedArity;\nvar bc \x3d ((3) + cljs.core.bounded_count((fixed_arity - (2)),args));\nif((bc \x3c\x3d fixed_arity)){\nreturn cljs.core.apply_to(f,bc,arglist);\n} else {\nreturn f.cljs$lang$applyTo(arglist);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$5(f,x,y,z,cljs.core.seq(args));\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,a,b,c,d,args){\nif(f.cljs$lang$applyTo){\nvar spread_args \x3d cljs.core.spread(args);\nvar arglist \x3d cljs.core.cons(a,cljs.core.cons(b,cljs.core.cons(c,cljs.core.cons(d,spread_args))));\nvar fixed_arity \x3d f.cljs$lang$maxFixedArity;\nvar bc \x3d ((4) + cljs.core.bounded_count((fixed_arity - (3)),spread_args));\nif((bc \x3c\x3d fixed_arity)){\nreturn cljs.core.apply_to(f,bc,arglist);\n} else {\nreturn f.cljs$lang$applyTo(arglist);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$6(f,a,b,c,d,cljs.core.spread(args));\n}\n});\n\n/** @this {Function} */\ncljs.core.apply.cljs$lang$applyTo \x3d (function (seq10218){\nvar G__10219 \x3d cljs.core.first(seq10218);\nvar seq10218__$1 \x3d cljs.core.next(seq10218);\nvar G__10220 \x3d cljs.core.first(seq10218__$1);\nvar seq10218__$2 \x3d cljs.core.next(seq10218__$1);\nvar G__10221 \x3d cljs.core.first(seq10218__$2);\nvar seq10218__$3 \x3d cljs.core.next(seq10218__$2);\nvar G__10222 \x3d cljs.core.first(seq10218__$3);\nvar seq10218__$4 \x3d cljs.core.next(seq10218__$3);\nvar G__10223 \x3d cljs.core.first(seq10218__$4);\nvar seq10218__$5 \x3d cljs.core.next(seq10218__$4);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10219,G__10220,G__10221,G__10222,G__10223,seq10218__$5);\n});\n\ncljs.core.apply.cljs$lang$maxFixedArity \x3d (5);\n\n/**\n * Returns an object of the same type and value as obj, with\n *   (apply f (meta obj) args) as its metadata.\n */\ncljs.core.vary_meta \x3d (function cljs$core$vary_meta(var_args){\nvar G__10237 \x3d arguments.length;\nswitch (G__10237) {\ncase 2:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10254 \x3d arguments.length;\nvar i__4731__auto___10255 \x3d (0);\nwhile(true){\nif((i__4731__auto___10255 \x3c len__4730__auto___10254)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10255]));\n\nvar G__10256 \x3d (i__4731__auto___10255 + (1));\ni__4731__auto___10255 \x3d G__10256;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((6)),(0),null));\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$2 \x3d (function (obj,f){\nreturn cljs.core.with_meta(obj,(function (){var G__10238 \x3d cljs.core.meta(obj);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10238) : f.call(null,G__10238));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$3 \x3d (function (obj,f,a){\nreturn cljs.core.with_meta(obj,(function (){var G__10239 \x3d cljs.core.meta(obj);\nvar G__10240 \x3d a;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10239,G__10240) : f.call(null,G__10239,G__10240));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4 \x3d (function (obj,f,a,b){\nreturn cljs.core.with_meta(obj,(function (){var G__10241 \x3d cljs.core.meta(obj);\nvar G__10242 \x3d a;\nvar G__10243 \x3d b;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10241,G__10242,G__10243) : f.call(null,G__10241,G__10242,G__10243));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$5 \x3d (function (obj,f,a,b,c){\nreturn cljs.core.with_meta(obj,(function (){var G__10244 \x3d cljs.core.meta(obj);\nvar G__10245 \x3d a;\nvar G__10246 \x3d b;\nvar G__10247 \x3d c;\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(G__10244,G__10245,G__10246,G__10247) : f.call(null,G__10244,G__10245,G__10246,G__10247));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$6 \x3d (function (obj,f,a,b,c,d){\nreturn cljs.core.with_meta(obj,(function (){var G__10248 \x3d cljs.core.meta(obj);\nvar G__10249 \x3d a;\nvar G__10250 \x3d b;\nvar G__10251 \x3d c;\nvar G__10252 \x3d d;\nreturn (f.cljs$core$IFn$_invoke$arity$5 ? f.cljs$core$IFn$_invoke$arity$5(G__10248,G__10249,G__10250,G__10251,G__10252) : f.call(null,G__10248,G__10249,G__10250,G__10251,G__10252));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$variadic \x3d (function (obj,f,a,b,c,d,args){\nreturn cljs.core.with_meta(obj,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,cljs.core.meta(obj),a,b,c,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([d,args], 0)));\n});\n\n/** @this {Function} */\ncljs.core.vary_meta.cljs$lang$applyTo \x3d (function (seq10230){\nvar G__10231 \x3d cljs.core.first(seq10230);\nvar seq10230__$1 \x3d cljs.core.next(seq10230);\nvar G__10232 \x3d cljs.core.first(seq10230__$1);\nvar seq10230__$2 \x3d cljs.core.next(seq10230__$1);\nvar G__10233 \x3d cljs.core.first(seq10230__$2);\nvar seq10230__$3 \x3d cljs.core.next(seq10230__$2);\nvar G__10234 \x3d cljs.core.first(seq10230__$3);\nvar seq10230__$4 \x3d cljs.core.next(seq10230__$3);\nvar G__10235 \x3d cljs.core.first(seq10230__$4);\nvar seq10230__$5 \x3d cljs.core.next(seq10230__$4);\nvar G__10236 \x3d cljs.core.first(seq10230__$5);\nvar seq10230__$6 \x3d cljs.core.next(seq10230__$5);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10231,G__10232,G__10233,G__10234,G__10235,G__10236,seq10230__$6);\n});\n\ncljs.core.vary_meta.cljs$lang$maxFixedArity \x3d (6);\n\n/**\n * Same as (not (\x3d obj1 obj2))\n */\ncljs.core.not_EQ_ \x3d (function cljs$core$not_EQ_(var_args){\nvar G__10261 \x3d arguments.length;\nswitch (G__10261) {\ncase 1:\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10263 \x3d arguments.length;\nvar i__4731__auto___10264 \x3d (0);\nwhile(true){\nif((i__4731__auto___10264 \x3c len__4730__auto___10263)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10264]));\n\nvar G__10265 \x3d (i__4731__auto___10264 + (1));\ni__4731__auto___10264 \x3d G__10265;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn false;\n});\n\ncljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2 \x3d (function (x,y){\nreturn (!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)));\n});\n\ncljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,y,more){\nreturn cljs.core.not(cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core._EQ_,x,y,more));\n});\n\n/** @this {Function} */\ncljs.core.not_EQ_.cljs$lang$applyTo \x3d (function (seq10258){\nvar G__10259 \x3d cljs.core.first(seq10258);\nvar seq10258__$1 \x3d cljs.core.next(seq10258);\nvar G__10260 \x3d cljs.core.first(seq10258__$1);\nvar seq10258__$2 \x3d cljs.core.next(seq10258__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10259,G__10260,seq10258__$2);\n});\n\ncljs.core.not_EQ_.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * If coll is empty, returns nil, else coll\n */\ncljs.core.not_empty \x3d (function cljs$core$not_empty(coll){\nif(cljs.core.seq(coll)){\nreturn coll;\n} else {\nreturn null;\n}\n});\ncljs.core.nil_iter \x3d (function cljs$core$nil_iter(){\nif((typeof cljs !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core.t_cljs$core10266 !\x3d\x3d \'undefined\')){\n} else {\n\n/**\n* @constructor\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.t_cljs$core10266 \x3d (function (meta10267){\nthis.meta10267 \x3d meta10267;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 393216;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.t_cljs$core10266.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (_10268,meta10267__$1){\nvar self__ \x3d this;\nvar _10268__$1 \x3d this;\nreturn (new cljs.core.t_cljs$core10266(meta10267__$1));\n});\n\ncljs.core.t_cljs$core10266.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (_10268){\nvar self__ \x3d this;\nvar _10268__$1 \x3d this;\nreturn self__.meta10267;\n});\n\ncljs.core.t_cljs$core10266.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn false;\n});\n\ncljs.core.t_cljs$core10266.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("No such element"));\n});\n\ncljs.core.t_cljs$core10266.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.t_cljs$core10266.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta10267], null);\n});\n\ncljs.core.t_cljs$core10266.cljs$lang$type \x3d true;\n\ncljs.core.t_cljs$core10266.cljs$lang$ctorStr \x3d "cljs.core/t_cljs$core10266";\n\ncljs.core.t_cljs$core10266.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/t_cljs$core10266");\n});\n\n/**\n * Positional factory function for cljs.core/t_cljs$core10266.\n */\ncljs.core.__GT_t_cljs$core10266 \x3d (function cljs$core$nil_iter_$___GT_t_cljs$core10266(meta10267){\nreturn (new cljs.core.t_cljs$core10266(meta10267));\n});\n\n}\n\nreturn (new cljs.core.t_cljs$core10266(cljs.core.PersistentArrayMap.EMPTY));\n});\n\n/**\n* @constructor\n*/\ncljs.core.StringIter \x3d (function (s,i){\nthis.s \x3d s;\nthis.i \x3d i;\n});\ncljs.core.StringIter.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.i \x3c self__.s.length);\n});\n\ncljs.core.StringIter.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar ret \x3d self__.s.charAt(self__.i);\nself__.i \x3d (self__.i + (1));\n\nreturn ret;\n});\n\ncljs.core.StringIter.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.StringIter.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$s,cljs.core.with_meta(cljs.core.cst$sym$i,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.StringIter.cljs$lang$type \x3d true;\n\ncljs.core.StringIter.cljs$lang$ctorStr \x3d "cljs.core/StringIter";\n\ncljs.core.StringIter.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/StringIter");\n});\n\n/**\n * Positional factory function for cljs.core/StringIter.\n */\ncljs.core.__GT_StringIter \x3d (function cljs$core$__GT_StringIter(s,i){\nreturn (new cljs.core.StringIter(s,i));\n});\n\ncljs.core.string_iter \x3d (function cljs$core$string_iter(x){\nreturn (new cljs.core.StringIter(x,(0)));\n});\n\n/**\n* @constructor\n*/\ncljs.core.ArrayIter \x3d (function (arr,i){\nthis.arr \x3d arr;\nthis.i \x3d i;\n});\ncljs.core.ArrayIter.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.i \x3c self__.arr.length);\n});\n\ncljs.core.ArrayIter.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar ret \x3d (self__.arr[self__.i]);\nself__.i \x3d (self__.i + (1));\n\nreturn ret;\n});\n\ncljs.core.ArrayIter.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.ArrayIter.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$arr,cljs.core.with_meta(cljs.core.cst$sym$i,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ArrayIter.cljs$lang$type \x3d true;\n\ncljs.core.ArrayIter.cljs$lang$ctorStr \x3d "cljs.core/ArrayIter";\n\ncljs.core.ArrayIter.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ArrayIter");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayIter.\n */\ncljs.core.__GT_ArrayIter \x3d (function cljs$core$__GT_ArrayIter(arr,i){\nreturn (new cljs.core.ArrayIter(arr,i));\n});\n\ncljs.core.array_iter \x3d (function cljs$core$array_iter(x){\nreturn (new cljs.core.ArrayIter(x,(0)));\n});\ncljs.core.INIT \x3d ({});\ncljs.core.START \x3d ({});\n\n/**\n* @constructor\n*/\ncljs.core.SeqIter \x3d (function (_seq,_next){\nthis._seq \x3d _seq;\nthis._next \x3d _next;\n});\ncljs.core.SeqIter.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nif((self__._seq \x3d\x3d\x3d cljs.core.INIT)){\nself__._seq \x3d cljs.core.START;\n\nself__._next \x3d cljs.core.seq(self__._next);\n} else {\nif((self__._seq \x3d\x3d\x3d self__._next)){\nself__._next \x3d cljs.core.next(self__._seq);\n} else {\n}\n}\n\nreturn (!((self__._next \x3d\x3d null)));\n});\n\ncljs.core.SeqIter.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nif((!(this$.hasNext()))){\nthrow (new Error("No such element"));\n} else {\nself__._seq \x3d self__._next;\n\nreturn cljs.core.first(self__._next);\n}\n});\n\ncljs.core.SeqIter.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.SeqIter.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$_seq,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$_next,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.SeqIter.cljs$lang$type \x3d true;\n\ncljs.core.SeqIter.cljs$lang$ctorStr \x3d "cljs.core/SeqIter";\n\ncljs.core.SeqIter.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/SeqIter");\n});\n\n/**\n * Positional factory function for cljs.core/SeqIter.\n */\ncljs.core.__GT_SeqIter \x3d (function cljs$core$__GT_SeqIter(_seq,_next){\nreturn (new cljs.core.SeqIter(_seq,_next));\n});\n\ncljs.core.seq_iter \x3d (function cljs$core$seq_iter(coll){\nreturn (new cljs.core.SeqIter(cljs.core.INIT,coll));\n});\ncljs.core.iter \x3d (function cljs$core$iter(coll){\nif(cljs.core.iterable_QMARK_(coll)){\nreturn cljs.core._iterator(coll);\n} else {\nif((coll \x3d\x3d null)){\nreturn cljs.core.nil_iter();\n} else {\nif(typeof coll \x3d\x3d\x3d \'string\'){\nreturn cljs.core.string_iter(coll);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn cljs.core.array_iter(coll);\n} else {\nif(cljs.core.seqable_QMARK_(coll)){\nreturn cljs.core.seq_iter(coll);\n} else {\nthrow (new Error(["Cannot create iterator from ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(coll)].join(\'\')));\n\n}\n}\n}\n}\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.Many \x3d (function (vals){\nthis.vals \x3d vals;\n});\ncljs.core.Many.prototype.add \x3d (function (o){\nvar self__ \x3d this;\nvar this$ \x3d this;\nself__.vals.push(o);\n\nreturn this$;\n});\n\ncljs.core.Many.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn self__.vals.shift();\n});\n\ncljs.core.Many.prototype.isEmpty \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn (self__.vals.length \x3d\x3d\x3d (0));\n});\n\ncljs.core.Many.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn ["Many: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.vals)].join(\'\');\n});\n\ncljs.core.Many.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$vals], null);\n});\n\ncljs.core.Many.cljs$lang$type \x3d true;\n\ncljs.core.Many.cljs$lang$ctorStr \x3d "cljs.core/Many";\n\ncljs.core.Many.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Many");\n});\n\n/**\n * Positional factory function for cljs.core/Many.\n */\ncljs.core.__GT_Many \x3d (function cljs$core$__GT_Many(vals){\nreturn (new cljs.core.Many(vals));\n});\n\ncljs.core.NONE \x3d ({});\n\n/**\n* @constructor\n*/\ncljs.core.Single \x3d (function (val){\nthis.val \x3d val;\n});\ncljs.core.Single.prototype.add \x3d (function (o){\nvar self__ \x3d this;\nvar this$ \x3d this;\nif((self__.val \x3d\x3d\x3d cljs.core.NONE)){\nself__.val \x3d o;\n\nreturn this$;\n} else {\nreturn (new cljs.core.Many([self__.val,o]));\n}\n});\n\ncljs.core.Single.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nif((self__.val \x3d\x3d\x3d cljs.core.NONE)){\nthrow (new Error("Removing object from empty buffer"));\n} else {\nvar ret \x3d self__.val;\nself__.val \x3d cljs.core.NONE;\n\nreturn ret;\n}\n});\n\ncljs.core.Single.prototype.isEmpty \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn (self__.val \x3d\x3d\x3d cljs.core.NONE);\n});\n\ncljs.core.Single.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn ["Single: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.val)].join(\'\');\n});\n\ncljs.core.Single.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$val,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Single.cljs$lang$type \x3d true;\n\ncljs.core.Single.cljs$lang$ctorStr \x3d "cljs.core/Single";\n\ncljs.core.Single.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Single");\n});\n\n/**\n * Positional factory function for cljs.core/Single.\n */\ncljs.core.__GT_Single \x3d (function cljs$core$__GT_Single(val){\nreturn (new cljs.core.Single(val));\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.Empty \x3d (function (){\n});\ncljs.core.Empty.prototype.add \x3d (function (o){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn (new cljs.core.Single(o));\n});\n\ncljs.core.Empty.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nthrow (new Error("Removing object from empty buffer"));\n});\n\ncljs.core.Empty.prototype.isEmpty \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn true;\n});\n\ncljs.core.Empty.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn "Empty";\n});\n\ncljs.core.Empty.getBasis \x3d (function (){\nreturn cljs.core.PersistentVector.EMPTY;\n});\n\ncljs.core.Empty.cljs$lang$type \x3d true;\n\ncljs.core.Empty.cljs$lang$ctorStr \x3d "cljs.core/Empty";\n\ncljs.core.Empty.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Empty");\n});\n\n/**\n * Positional factory function for cljs.core/Empty.\n */\ncljs.core.__GT_Empty \x3d (function cljs$core$__GT_Empty(){\nreturn (new cljs.core.Empty());\n});\n\ncljs.core.EMPTY \x3d (new cljs.core.Empty());\n\n/**\n* @constructor\n*/\ncljs.core.MultiIterator \x3d (function (iters){\nthis.iters \x3d iters;\n});\ncljs.core.MultiIterator.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar iters__$1 \x3d cljs.core.seq(self__.iters);\nwhile(true){\nif((!((iters__$1 \x3d\x3d null)))){\nvar iter \x3d cljs.core.first(iters__$1);\nif((!(iter.hasNext()))){\nreturn false;\n} else {\nvar G__10269 \x3d cljs.core.next(iters__$1);\niters__$1 \x3d G__10269;\ncontinue;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n});\n\ncljs.core.MultiIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar nexts \x3d [];\nvar n__4607__auto___10270 \x3d self__.iters.length;\nvar i_10271 \x3d (0);\nwhile(true){\nif((i_10271 \x3c n__4607__auto___10270)){\n(nexts[i_10271] \x3d (self__.iters[i_10271]).next());\n\nvar G__10272 \x3d (i_10271 + (1));\ni_10271 \x3d G__10272;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(nexts,(0));\n});\n\ncljs.core.MultiIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$iters], null);\n});\n\ncljs.core.MultiIterator.cljs$lang$type \x3d true;\n\ncljs.core.MultiIterator.cljs$lang$ctorStr \x3d "cljs.core/MultiIterator";\n\ncljs.core.MultiIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/MultiIterator");\n});\n\n/**\n * Positional factory function for cljs.core/MultiIterator.\n */\ncljs.core.__GT_MultiIterator \x3d (function cljs$core$__GT_MultiIterator(iters){\nreturn (new cljs.core.MultiIterator(iters));\n});\n\ncljs.core.chunkIteratorSeq \x3d (function cljs$core$chunkIteratorSeq(iter){\nreturn (new cljs.core.LazySeq(null,(function (){\nif(iter.hasNext()){\nvar arr \x3d [];\nvar n \x3d (0);\nwhile(true){\nif(cljs.core.truth_((function (){var and__4120__auto__ \x3d iter.hasNext();\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (n \x3c (32));\n} else {\nreturn and__4120__auto__;\n}\n})())){\n(arr[n] \x3d iter.next());\n\nvar G__10273 \x3d (n + (1));\nn \x3d G__10273;\ncontinue;\n} else {\nreturn cljs.core.chunk_cons(cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$3(arr,(0),n),(cljs.core.chunkIteratorSeq.cljs$core$IFn$_invoke$arity$1 ? cljs.core.chunkIteratorSeq.cljs$core$IFn$_invoke$arity$1(iter) : cljs.core.chunkIteratorSeq.call(null,iter)));\n}\nbreak;\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\n/**\n* @constructor\n*/\ncljs.core.TransformerIterator \x3d (function (buffer,_next,completed,xf,sourceIter,multi){\nthis.buffer \x3d buffer;\nthis._next \x3d _next;\nthis.completed \x3d completed;\nthis.xf \x3d xf;\nthis.sourceIter \x3d sourceIter;\nthis.multi \x3d multi;\n});\ncljs.core.TransformerIterator.prototype.step \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nif((!((self__._next \x3d\x3d\x3d cljs.core.NONE)))){\nreturn true;\n} else {\nwhile(true){\nif((self__._next \x3d\x3d\x3d cljs.core.NONE)){\nif(self__.buffer.isEmpty()){\nif(self__.completed){\nreturn false;\n} else {\nif(self__.sourceIter.hasNext()){\nvar iter \x3d ((self__.multi)?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(self__.xf,cljs.core.cons(null,self__.sourceIter.next())):(function (){var G__10274 \x3d null;\nvar G__10275 \x3d self__.sourceIter.next();\nreturn (self__.xf.cljs$core$IFn$_invoke$arity$2 ? self__.xf.cljs$core$IFn$_invoke$arity$2(G__10274,G__10275) : self__.xf.call(null,G__10274,G__10275));\n})());\nif(cljs.core.reduced_QMARK_(iter)){\n(self__.xf.cljs$core$IFn$_invoke$arity$1 ? self__.xf.cljs$core$IFn$_invoke$arity$1(null) : self__.xf.call(null,null));\n\nself__.completed \x3d true;\n} else {\n}\n\ncontinue;\n} else {\n(self__.xf.cljs$core$IFn$_invoke$arity$1 ? self__.xf.cljs$core$IFn$_invoke$arity$1(null) : self__.xf.call(null,null));\n\nself__.completed \x3d true;\n\ncontinue;\n}\n}\n} else {\nself__._next \x3d self__.buffer.remove();\n\ncontinue;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n}\n});\n\ncljs.core.TransformerIterator.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.step();\n});\n\ncljs.core.TransformerIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nif(this$.hasNext()){\nvar ret \x3d self__._next;\nself__._next \x3d cljs.core.NONE;\n\nreturn ret;\n} else {\nthrow (new Error("No such element"));\n}\n});\n\ncljs.core.TransformerIterator.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.TransformerIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$buffer,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$_next,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$completed,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$xf,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.cst$sym$sourceIter,cljs.core.cst$sym$multi], null);\n});\n\ncljs.core.TransformerIterator.cljs$lang$type \x3d true;\n\ncljs.core.TransformerIterator.cljs$lang$ctorStr \x3d "cljs.core/TransformerIterator";\n\ncljs.core.TransformerIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/TransformerIterator");\n});\n\n/**\n * Positional factory function for cljs.core/TransformerIterator.\n */\ncljs.core.__GT_TransformerIterator \x3d (function cljs$core$__GT_TransformerIterator(buffer,_next,completed,xf,sourceIter,multi){\nreturn (new cljs.core.TransformerIterator(buffer,_next,completed,xf,sourceIter,multi));\n});\n\nvar G__10276_10279 \x3d cljs.core.TransformerIterator.prototype;\nvar G__10277_10280 \x3d cljs.core.ITER_SYMBOL;\nvar G__10278_10281 \x3d ((function (G__10276_10279,G__10277_10280){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10276_10279,G__10277_10280))\n;\ngoog.object.set(G__10276_10279,G__10277_10280,G__10278_10281);\ncljs.core.transformer_iterator \x3d (function cljs$core$transformer_iterator(xform,sourceIter,multi){\nvar iterator \x3d (new cljs.core.TransformerIterator(cljs.core.EMPTY,cljs.core.NONE,false,null,sourceIter,multi));\niterator.xf \x3d (function (){var G__10282 \x3d ((function (iterator){\nreturn (function() {\nvar G__10283 \x3d null;\nvar G__10283__0 \x3d (function (){\nreturn null;\n});\nvar G__10283__1 \x3d (function (acc){\nreturn acc;\n});\nvar G__10283__2 \x3d (function (acc,o){\niterator.buffer \x3d iterator.buffer.add(o);\n\nreturn acc;\n});\nG__10283 \x3d function(acc,o){\nswitch(arguments.length){\ncase 0:\nreturn G__10283__0.call(this);\ncase 1:\nreturn G__10283__1.call(this,acc);\ncase 2:\nreturn G__10283__2.call(this,acc,o);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10283.cljs$core$IFn$_invoke$arity$0 \x3d G__10283__0;\nG__10283.cljs$core$IFn$_invoke$arity$1 \x3d G__10283__1;\nG__10283.cljs$core$IFn$_invoke$arity$2 \x3d G__10283__2;\nreturn G__10283;\n})()\n;})(iterator))\n;\nreturn (xform.cljs$core$IFn$_invoke$arity$1 ? xform.cljs$core$IFn$_invoke$arity$1(G__10282) : xform.call(null,G__10282));\n})();\n\nreturn iterator;\n});\ncljs.core.TransformerIterator.create \x3d (function (xform,source){\nreturn cljs.core.transformer_iterator(xform,source,false);\n});\ncljs.core.TransformerIterator.createMulti \x3d (function (xform,sources){\nreturn cljs.core.transformer_iterator(xform,(new cljs.core.MultiIterator(cljs.core.to_array(sources))),true);\n});\n/**\n * Coerces coll to a (possibly empty) sequence, if it is not already\n *   one. Will not force a lazy seq. (sequence nil) yields (), When a\n *   transducer is supplied, returns a lazy sequence of applications of\n *   the transform to the items in coll(s), i.e. to the set of first\n *   items of each coll, followed by the set of second\n *   items in each coll, until any one of the colls is exhausted.  Any\n *   remaining items in other colls are ignored. The transform should accept\n *   number-of-colls arguments\n */\ncljs.core.sequence \x3d (function cljs$core$sequence(var_args){\nvar G__10288 \x3d arguments.length;\nswitch (G__10288) {\ncase 1:\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10290 \x3d arguments.length;\nvar i__4731__auto___10291 \x3d (0);\nwhile(true){\nif((i__4731__auto___10291 \x3c len__4730__auto___10290)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10291]));\n\nvar G__10292 \x3d (i__4731__auto___10291 + (1));\ni__4731__auto___10291 \x3d G__10292;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.sequence.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nif(cljs.core.seq_QMARK_(coll)){\nreturn coll;\n} else {\nvar or__4131__auto__ \x3d cljs.core.seq(coll);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n}\n});\n\ncljs.core.sequence.cljs$core$IFn$_invoke$arity$2 \x3d (function (xform,coll){\nvar or__4131__auto__ \x3d cljs.core.chunkIteratorSeq(cljs.core.TransformerIterator.create(xform,cljs.core.iter(coll)));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.sequence.cljs$core$IFn$_invoke$arity$variadic \x3d (function (xform,coll,colls){\nvar or__4131__auto__ \x3d cljs.core.chunkIteratorSeq(cljs.core.TransformerIterator.createMulti(xform,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.iter,cljs.core.cons(coll,colls))));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\n/** @this {Function} */\ncljs.core.sequence.cljs$lang$applyTo \x3d (function (seq10285){\nvar G__10286 \x3d cljs.core.first(seq10285);\nvar seq10285__$1 \x3d cljs.core.next(seq10285);\nvar G__10287 \x3d cljs.core.first(seq10285__$1);\nvar seq10285__$2 \x3d cljs.core.next(seq10285__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10286,G__10287,seq10285__$2);\n});\n\ncljs.core.sequence.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns true if (pred x) is logical true for every x in coll, else\n *   false.\n */\ncljs.core.every_QMARK_ \x3d (function cljs$core$every_QMARK_(pred,coll){\nwhile(true){\nif((cljs.core.seq(coll) \x3d\x3d null)){\nreturn true;\n} else {\nif(cljs.core.truth_((function (){var G__10293 \x3d cljs.core.first(coll);\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(G__10293) : pred.call(null,G__10293));\n})())){\nvar G__10294 \x3d pred;\nvar G__10295 \x3d cljs.core.next(coll);\npred \x3d G__10294;\ncoll \x3d G__10295;\ncontinue;\n} else {\nreturn false;\n\n}\n}\nbreak;\n}\n});\n/**\n * Returns false if (pred x) is logical true for every x in\n *   coll, else true.\n */\ncljs.core.not_every_QMARK_ \x3d (function cljs$core$not_every_QMARK_(pred,coll){\nreturn (!(cljs.core.every_QMARK_(pred,coll)));\n});\n/**\n * Returns the first logical true value of (pred x) for any x in coll,\n *   else nil.  One common idiom is to use a set as pred, for example\n *   this will return :fred if :fred is in the sequence, otherwise nil:\n *   (some #{:fred} coll)\n */\ncljs.core.some \x3d (function cljs$core$some(pred,coll){\nwhile(true){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nvar or__4131__auto__ \x3d (function (){var G__10297 \x3d cljs.core.first(s);\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(G__10297) : pred.call(null,G__10297));\n})();\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar G__10298 \x3d pred;\nvar G__10299 \x3d cljs.core.next(s);\npred \x3d G__10298;\ncoll \x3d G__10299;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\n/**\n * Returns false if (pred x) is logical true for any x in coll,\n *   else true.\n */\ncljs.core.not_any_QMARK_ \x3d (function cljs$core$not_any_QMARK_(pred,coll){\nreturn cljs.core.not(cljs.core.some(pred,coll));\n});\n/**\n * Returns true if n is even, throws an exception if n is not an integer\n */\ncljs.core.even_QMARK_ \x3d (function cljs$core$even_QMARK_(n){\nif(cljs.core.integer_QMARK_(n)){\nreturn ((n \x26 (1)) \x3d\x3d\x3d (0));\n} else {\nthrow (new Error(["Argument must be an integer: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(n)].join(\'\')));\n}\n});\n/**\n * Returns true if n is odd, throws an exception if n is not an integer\n */\ncljs.core.odd_QMARK_ \x3d (function cljs$core$odd_QMARK_(n){\nreturn (!(cljs.core.even_QMARK_(n)));\n});\n/**\n * Takes a fn f and returns a fn that takes the same arguments as f,\n *   has the same effects, if any, and returns the opposite truth value.\n */\ncljs.core.complement \x3d (function cljs$core$complement(f){\nreturn (function() {\nvar G__10300 \x3d null;\nvar G__10300__0 \x3d (function (){\nreturn cljs.core.not((f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)));\n});\nvar G__10300__1 \x3d (function (x){\nreturn cljs.core.not((f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x)));\n});\nvar G__10300__2 \x3d (function (x,y){\nreturn cljs.core.not((f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y)));\n});\nvar G__10300__3 \x3d (function() { \nvar G__10301__delegate \x3d function (x,y,zs){\nreturn cljs.core.not(cljs.core.apply.cljs$core$IFn$_invoke$arity$4(f,x,y,zs));\n};\nvar G__10301 \x3d function (x,y,var_args){\nvar zs \x3d null;\nif (arguments.length \x3e 2) {\nvar G__10302__i \x3d 0, G__10302__a \x3d new Array(arguments.length -  2);\nwhile (G__10302__i \x3c G__10302__a.length) {G__10302__a[G__10302__i] \x3d arguments[G__10302__i + 2]; ++G__10302__i;}\n  zs \x3d new cljs.core.IndexedSeq(G__10302__a,0,null);\n} \nreturn G__10301__delegate.call(this,x,y,zs);};\nG__10301.cljs$lang$maxFixedArity \x3d 2;\nG__10301.cljs$lang$applyTo \x3d (function (arglist__10303){\nvar x \x3d cljs.core.first(arglist__10303);\narglist__10303 \x3d cljs.core.next(arglist__10303);\nvar y \x3d cljs.core.first(arglist__10303);\nvar zs \x3d cljs.core.rest(arglist__10303);\nreturn G__10301__delegate(x,y,zs);\n});\nG__10301.cljs$core$IFn$_invoke$arity$variadic \x3d G__10301__delegate;\nreturn G__10301;\n})()\n;\nG__10300 \x3d function(x,y,var_args){\nvar zs \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__10300__0.call(this);\ncase 1:\nreturn G__10300__1.call(this,x);\ncase 2:\nreturn G__10300__2.call(this,x,y);\ndefault:\nvar G__10304 \x3d null;\nif (arguments.length \x3e 2) {\nvar G__10305__i \x3d 0, G__10305__a \x3d new Array(arguments.length -  2);\nwhile (G__10305__i \x3c G__10305__a.length) {G__10305__a[G__10305__i] \x3d arguments[G__10305__i + 2]; ++G__10305__i;}\nG__10304 \x3d new cljs.core.IndexedSeq(G__10305__a,0,null);\n}\nreturn G__10300__3.cljs$core$IFn$_invoke$arity$variadic(x,y, G__10304);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10300.cljs$lang$maxFixedArity \x3d 2;\nG__10300.cljs$lang$applyTo \x3d G__10300__3.cljs$lang$applyTo;\nG__10300.cljs$core$IFn$_invoke$arity$0 \x3d G__10300__0;\nG__10300.cljs$core$IFn$_invoke$arity$1 \x3d G__10300__1;\nG__10300.cljs$core$IFn$_invoke$arity$2 \x3d G__10300__2;\nG__10300.cljs$core$IFn$_invoke$arity$variadic \x3d G__10300__3.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10300;\n})()\n});\n/**\n * Returns a function that takes any number of arguments and returns x.\n */\ncljs.core.constantly \x3d (function cljs$core$constantly(x){\nreturn (function() { \nvar G__10306__delegate \x3d function (args){\nreturn x;\n};\nvar G__10306 \x3d function (var_args){\nvar args \x3d null;\nif (arguments.length \x3e 0) {\nvar G__10307__i \x3d 0, G__10307__a \x3d new Array(arguments.length -  0);\nwhile (G__10307__i \x3c G__10307__a.length) {G__10307__a[G__10307__i] \x3d arguments[G__10307__i + 0]; ++G__10307__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10307__a,0,null);\n} \nreturn G__10306__delegate.call(this,args);};\nG__10306.cljs$lang$maxFixedArity \x3d 0;\nG__10306.cljs$lang$applyTo \x3d (function (arglist__10308){\nvar args \x3d cljs.core.seq(arglist__10308);\nreturn G__10306__delegate(args);\n});\nG__10306.cljs$core$IFn$_invoke$arity$variadic \x3d G__10306__delegate;\nreturn G__10306;\n})()\n;\n});\n/**\n * Takes a set of functions and returns a fn that is the composition\n *   of those fns.  The returned fn takes a variable number of args,\n *   applies the rightmost of fns to the args, the next\n *   fn (right-to-left) to the result, etc.\n */\ncljs.core.comp \x3d (function cljs$core$comp(var_args){\nvar G__10314 \x3d arguments.length;\nswitch (G__10314) {\ncase 0:\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10332 \x3d arguments.length;\nvar i__4731__auto___10333 \x3d (0);\nwhile(true){\nif((i__4731__auto___10333 \x3c len__4730__auto___10332)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10333]));\n\nvar G__10334 \x3d (i__4731__auto___10333 + (1));\ni__4731__auto___10333 \x3d G__10334;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.identity;\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn f;\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,g){\nreturn (function() {\nvar G__10335 \x3d null;\nvar G__10335__0 \x3d (function (){\nvar G__10315 \x3d (g.cljs$core$IFn$_invoke$arity$0 ? g.cljs$core$IFn$_invoke$arity$0() : g.call(null));\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10315) : f.call(null,G__10315));\n});\nvar G__10335__1 \x3d (function (x){\nvar G__10316 \x3d (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(x) : g.call(null,x));\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10316) : f.call(null,G__10316));\n});\nvar G__10335__2 \x3d (function (x,y){\nvar G__10317 \x3d (g.cljs$core$IFn$_invoke$arity$2 ? g.cljs$core$IFn$_invoke$arity$2(x,y) : g.call(null,x,y));\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10317) : f.call(null,G__10317));\n});\nvar G__10335__3 \x3d (function (x,y,z){\nvar G__10318 \x3d (g.cljs$core$IFn$_invoke$arity$3 ? g.cljs$core$IFn$_invoke$arity$3(x,y,z) : g.call(null,x,y,z));\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10318) : f.call(null,G__10318));\n});\nvar G__10335__4 \x3d (function() { \nvar G__10336__delegate \x3d function (x,y,z,args){\nvar G__10319 \x3d cljs.core.apply.cljs$core$IFn$_invoke$arity$5(g,x,y,z,args);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10319) : f.call(null,G__10319));\n};\nvar G__10336 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10337__i \x3d 0, G__10337__a \x3d new Array(arguments.length -  3);\nwhile (G__10337__i \x3c G__10337__a.length) {G__10337__a[G__10337__i] \x3d arguments[G__10337__i + 3]; ++G__10337__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10337__a,0,null);\n} \nreturn G__10336__delegate.call(this,x,y,z,args);};\nG__10336.cljs$lang$maxFixedArity \x3d 3;\nG__10336.cljs$lang$applyTo \x3d (function (arglist__10338){\nvar x \x3d cljs.core.first(arglist__10338);\narglist__10338 \x3d cljs.core.next(arglist__10338);\nvar y \x3d cljs.core.first(arglist__10338);\narglist__10338 \x3d cljs.core.next(arglist__10338);\nvar z \x3d cljs.core.first(arglist__10338);\nvar args \x3d cljs.core.rest(arglist__10338);\nreturn G__10336__delegate(x,y,z,args);\n});\nG__10336.cljs$core$IFn$_invoke$arity$variadic \x3d G__10336__delegate;\nreturn G__10336;\n})()\n;\nG__10335 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__10335__0.call(this);\ncase 1:\nreturn G__10335__1.call(this,x);\ncase 2:\nreturn G__10335__2.call(this,x,y);\ncase 3:\nreturn G__10335__3.call(this,x,y,z);\ndefault:\nvar G__10339 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10340__i \x3d 0, G__10340__a \x3d new Array(arguments.length -  3);\nwhile (G__10340__i \x3c G__10340__a.length) {G__10340__a[G__10340__i] \x3d arguments[G__10340__i + 3]; ++G__10340__i;}\nG__10339 \x3d new cljs.core.IndexedSeq(G__10340__a,0,null);\n}\nreturn G__10335__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10339);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10335.cljs$lang$maxFixedArity \x3d 3;\nG__10335.cljs$lang$applyTo \x3d G__10335__4.cljs$lang$applyTo;\nG__10335.cljs$core$IFn$_invoke$arity$0 \x3d G__10335__0;\nG__10335.cljs$core$IFn$_invoke$arity$1 \x3d G__10335__1;\nG__10335.cljs$core$IFn$_invoke$arity$2 \x3d G__10335__2;\nG__10335.cljs$core$IFn$_invoke$arity$3 \x3d G__10335__3;\nG__10335.cljs$core$IFn$_invoke$arity$variadic \x3d G__10335__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10335;\n})()\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,g,h){\nreturn (function() {\nvar G__10341 \x3d null;\nvar G__10341__0 \x3d (function (){\nvar G__10320 \x3d (function (){var G__10321 \x3d (h.cljs$core$IFn$_invoke$arity$0 ? h.cljs$core$IFn$_invoke$arity$0() : h.call(null));\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__10321) : g.call(null,G__10321));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10320) : f.call(null,G__10320));\n});\nvar G__10341__1 \x3d (function (x){\nvar G__10322 \x3d (function (){var G__10323 \x3d (h.cljs$core$IFn$_invoke$arity$1 ? h.cljs$core$IFn$_invoke$arity$1(x) : h.call(null,x));\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__10323) : g.call(null,G__10323));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10322) : f.call(null,G__10322));\n});\nvar G__10341__2 \x3d (function (x,y){\nvar G__10324 \x3d (function (){var G__10325 \x3d (h.cljs$core$IFn$_invoke$arity$2 ? h.cljs$core$IFn$_invoke$arity$2(x,y) : h.call(null,x,y));\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__10325) : g.call(null,G__10325));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10324) : f.call(null,G__10324));\n});\nvar G__10341__3 \x3d (function (x,y,z){\nvar G__10326 \x3d (function (){var G__10327 \x3d (h.cljs$core$IFn$_invoke$arity$3 ? h.cljs$core$IFn$_invoke$arity$3(x,y,z) : h.call(null,x,y,z));\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__10327) : g.call(null,G__10327));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10326) : f.call(null,G__10326));\n});\nvar G__10341__4 \x3d (function() { \nvar G__10342__delegate \x3d function (x,y,z,args){\nvar G__10328 \x3d (function (){var G__10329 \x3d cljs.core.apply.cljs$core$IFn$_invoke$arity$5(h,x,y,z,args);\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__10329) : g.call(null,G__10329));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10328) : f.call(null,G__10328));\n};\nvar G__10342 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10343__i \x3d 0, G__10343__a \x3d new Array(arguments.length -  3);\nwhile (G__10343__i \x3c G__10343__a.length) {G__10343__a[G__10343__i] \x3d arguments[G__10343__i + 3]; ++G__10343__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10343__a,0,null);\n} \nreturn G__10342__delegate.call(this,x,y,z,args);};\nG__10342.cljs$lang$maxFixedArity \x3d 3;\nG__10342.cljs$lang$applyTo \x3d (function (arglist__10344){\nvar x \x3d cljs.core.first(arglist__10344);\narglist__10344 \x3d cljs.core.next(arglist__10344);\nvar y \x3d cljs.core.first(arglist__10344);\narglist__10344 \x3d cljs.core.next(arglist__10344);\nvar z \x3d cljs.core.first(arglist__10344);\nvar args \x3d cljs.core.rest(arglist__10344);\nreturn G__10342__delegate(x,y,z,args);\n});\nG__10342.cljs$core$IFn$_invoke$arity$variadic \x3d G__10342__delegate;\nreturn G__10342;\n})()\n;\nG__10341 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__10341__0.call(this);\ncase 1:\nreturn G__10341__1.call(this,x);\ncase 2:\nreturn G__10341__2.call(this,x,y);\ncase 3:\nreturn G__10341__3.call(this,x,y,z);\ndefault:\nvar G__10345 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10346__i \x3d 0, G__10346__a \x3d new Array(arguments.length -  3);\nwhile (G__10346__i \x3c G__10346__a.length) {G__10346__a[G__10346__i] \x3d arguments[G__10346__i + 3]; ++G__10346__i;}\nG__10345 \x3d new cljs.core.IndexedSeq(G__10346__a,0,null);\n}\nreturn G__10341__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10345);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10341.cljs$lang$maxFixedArity \x3d 3;\nG__10341.cljs$lang$applyTo \x3d G__10341__4.cljs$lang$applyTo;\nG__10341.cljs$core$IFn$_invoke$arity$0 \x3d G__10341__0;\nG__10341.cljs$core$IFn$_invoke$arity$1 \x3d G__10341__1;\nG__10341.cljs$core$IFn$_invoke$arity$2 \x3d G__10341__2;\nG__10341.cljs$core$IFn$_invoke$arity$3 \x3d G__10341__3;\nG__10341.cljs$core$IFn$_invoke$arity$variadic \x3d G__10341__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10341;\n})()\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f1,f2,f3,fs){\nvar fs__$1 \x3d cljs.core.reverse(cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(f1,f2,f3,fs));\nreturn ((function (fs__$1){\nreturn (function() { \nvar G__10347__delegate \x3d function (args){\nvar ret \x3d cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.first(fs__$1),args);\nvar fs__$2 \x3d cljs.core.next(fs__$1);\nwhile(true){\nif(fs__$2){\nvar G__10348 \x3d (function (){var fexpr__10330 \x3d cljs.core.first(fs__$2);\nreturn (fexpr__10330.cljs$core$IFn$_invoke$arity$1 ? fexpr__10330.cljs$core$IFn$_invoke$arity$1(ret) : fexpr__10330.call(null,ret));\n})();\nvar G__10349 \x3d cljs.core.next(fs__$2);\nret \x3d G__10348;\nfs__$2 \x3d G__10349;\ncontinue;\n} else {\nreturn ret;\n}\nbreak;\n}\n};\nvar G__10347 \x3d function (var_args){\nvar args \x3d null;\nif (arguments.length \x3e 0) {\nvar G__10350__i \x3d 0, G__10350__a \x3d new Array(arguments.length -  0);\nwhile (G__10350__i \x3c G__10350__a.length) {G__10350__a[G__10350__i] \x3d arguments[G__10350__i + 0]; ++G__10350__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10350__a,0,null);\n} \nreturn G__10347__delegate.call(this,args);};\nG__10347.cljs$lang$maxFixedArity \x3d 0;\nG__10347.cljs$lang$applyTo \x3d (function (arglist__10351){\nvar args \x3d cljs.core.seq(arglist__10351);\nreturn G__10347__delegate(args);\n});\nG__10347.cljs$core$IFn$_invoke$arity$variadic \x3d G__10347__delegate;\nreturn G__10347;\n})()\n;\n;})(fs__$1))\n});\n\n/** @this {Function} */\ncljs.core.comp.cljs$lang$applyTo \x3d (function (seq10310){\nvar G__10311 \x3d cljs.core.first(seq10310);\nvar seq10310__$1 \x3d cljs.core.next(seq10310);\nvar G__10312 \x3d cljs.core.first(seq10310__$1);\nvar seq10310__$2 \x3d cljs.core.next(seq10310__$1);\nvar G__10313 \x3d cljs.core.first(seq10310__$2);\nvar seq10310__$3 \x3d cljs.core.next(seq10310__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10311,G__10312,G__10313,seq10310__$3);\n});\n\ncljs.core.comp.cljs$lang$maxFixedArity \x3d (3);\n\n/**\n * Takes a function f and fewer than the normal arguments to f, and\n *   returns a fn that takes a variable number of additional args. When\n *   called, the returned function calls f with args + additional args.\n */\ncljs.core.partial \x3d (function cljs$core$partial(var_args){\nvar G__10358 \x3d arguments.length;\nswitch (G__10358) {\ncase 1:\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10360 \x3d arguments.length;\nvar i__4731__auto___10361 \x3d (0);\nwhile(true){\nif((i__4731__auto___10361 \x3c len__4730__auto___10360)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10361]));\n\nvar G__10362 \x3d (i__4731__auto___10361 + (1));\ni__4731__auto___10361 \x3d G__10362;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn f;\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,arg1){\nreturn (function() {\nvar G__10363 \x3d null;\nvar G__10363__0 \x3d (function (){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(arg1) : f.call(null,arg1));\n});\nvar G__10363__1 \x3d (function (x){\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(arg1,x) : f.call(null,arg1,x));\n});\nvar G__10363__2 \x3d (function (x,y){\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(arg1,x,y) : f.call(null,arg1,x,y));\n});\nvar G__10363__3 \x3d (function (x,y,z){\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(arg1,x,y,z) : f.call(null,arg1,x,y,z));\n});\nvar G__10363__4 \x3d (function() { \nvar G__10364__delegate \x3d function (x,y,z,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,arg1,x,y,z,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([args], 0));\n};\nvar G__10364 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10365__i \x3d 0, G__10365__a \x3d new Array(arguments.length -  3);\nwhile (G__10365__i \x3c G__10365__a.length) {G__10365__a[G__10365__i] \x3d arguments[G__10365__i + 3]; ++G__10365__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10365__a,0,null);\n} \nreturn G__10364__delegate.call(this,x,y,z,args);};\nG__10364.cljs$lang$maxFixedArity \x3d 3;\nG__10364.cljs$lang$applyTo \x3d (function (arglist__10366){\nvar x \x3d cljs.core.first(arglist__10366);\narglist__10366 \x3d cljs.core.next(arglist__10366);\nvar y \x3d cljs.core.first(arglist__10366);\narglist__10366 \x3d cljs.core.next(arglist__10366);\nvar z \x3d cljs.core.first(arglist__10366);\nvar args \x3d cljs.core.rest(arglist__10366);\nreturn G__10364__delegate(x,y,z,args);\n});\nG__10364.cljs$core$IFn$_invoke$arity$variadic \x3d G__10364__delegate;\nreturn G__10364;\n})()\n;\nG__10363 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__10363__0.call(this);\ncase 1:\nreturn G__10363__1.call(this,x);\ncase 2:\nreturn G__10363__2.call(this,x,y);\ncase 3:\nreturn G__10363__3.call(this,x,y,z);\ndefault:\nvar G__10367 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10368__i \x3d 0, G__10368__a \x3d new Array(arguments.length -  3);\nwhile (G__10368__i \x3c G__10368__a.length) {G__10368__a[G__10368__i] \x3d arguments[G__10368__i + 3]; ++G__10368__i;}\nG__10367 \x3d new cljs.core.IndexedSeq(G__10368__a,0,null);\n}\nreturn G__10363__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10367);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10363.cljs$lang$maxFixedArity \x3d 3;\nG__10363.cljs$lang$applyTo \x3d G__10363__4.cljs$lang$applyTo;\nG__10363.cljs$core$IFn$_invoke$arity$0 \x3d G__10363__0;\nG__10363.cljs$core$IFn$_invoke$arity$1 \x3d G__10363__1;\nG__10363.cljs$core$IFn$_invoke$arity$2 \x3d G__10363__2;\nG__10363.cljs$core$IFn$_invoke$arity$3 \x3d G__10363__3;\nG__10363.cljs$core$IFn$_invoke$arity$variadic \x3d G__10363__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10363;\n})()\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,arg1,arg2){\nreturn (function() {\nvar G__10369 \x3d null;\nvar G__10369__0 \x3d (function (){\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(arg1,arg2) : f.call(null,arg1,arg2));\n});\nvar G__10369__1 \x3d (function (x){\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(arg1,arg2,x) : f.call(null,arg1,arg2,x));\n});\nvar G__10369__2 \x3d (function (x,y){\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(arg1,arg2,x,y) : f.call(null,arg1,arg2,x,y));\n});\nvar G__10369__3 \x3d (function (x,y,z){\nreturn (f.cljs$core$IFn$_invoke$arity$5 ? f.cljs$core$IFn$_invoke$arity$5(arg1,arg2,x,y,z) : f.call(null,arg1,arg2,x,y,z));\n});\nvar G__10369__4 \x3d (function() { \nvar G__10370__delegate \x3d function (x,y,z,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,arg1,arg2,x,y,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([z,args], 0));\n};\nvar G__10370 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10371__i \x3d 0, G__10371__a \x3d new Array(arguments.length -  3);\nwhile (G__10371__i \x3c G__10371__a.length) {G__10371__a[G__10371__i] \x3d arguments[G__10371__i + 3]; ++G__10371__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10371__a,0,null);\n} \nreturn G__10370__delegate.call(this,x,y,z,args);};\nG__10370.cljs$lang$maxFixedArity \x3d 3;\nG__10370.cljs$lang$applyTo \x3d (function (arglist__10372){\nvar x \x3d cljs.core.first(arglist__10372);\narglist__10372 \x3d cljs.core.next(arglist__10372);\nvar y \x3d cljs.core.first(arglist__10372);\narglist__10372 \x3d cljs.core.next(arglist__10372);\nvar z \x3d cljs.core.first(arglist__10372);\nvar args \x3d cljs.core.rest(arglist__10372);\nreturn G__10370__delegate(x,y,z,args);\n});\nG__10370.cljs$core$IFn$_invoke$arity$variadic \x3d G__10370__delegate;\nreturn G__10370;\n})()\n;\nG__10369 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__10369__0.call(this);\ncase 1:\nreturn G__10369__1.call(this,x);\ncase 2:\nreturn G__10369__2.call(this,x,y);\ncase 3:\nreturn G__10369__3.call(this,x,y,z);\ndefault:\nvar G__10373 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10374__i \x3d 0, G__10374__a \x3d new Array(arguments.length -  3);\nwhile (G__10374__i \x3c G__10374__a.length) {G__10374__a[G__10374__i] \x3d arguments[G__10374__i + 3]; ++G__10374__i;}\nG__10373 \x3d new cljs.core.IndexedSeq(G__10374__a,0,null);\n}\nreturn G__10369__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10373);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10369.cljs$lang$maxFixedArity \x3d 3;\nG__10369.cljs$lang$applyTo \x3d G__10369__4.cljs$lang$applyTo;\nG__10369.cljs$core$IFn$_invoke$arity$0 \x3d G__10369__0;\nG__10369.cljs$core$IFn$_invoke$arity$1 \x3d G__10369__1;\nG__10369.cljs$core$IFn$_invoke$arity$2 \x3d G__10369__2;\nG__10369.cljs$core$IFn$_invoke$arity$3 \x3d G__10369__3;\nG__10369.cljs$core$IFn$_invoke$arity$variadic \x3d G__10369__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10369;\n})()\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$4 \x3d (function (f,arg1,arg2,arg3){\nreturn (function() {\nvar G__10375 \x3d null;\nvar G__10375__0 \x3d (function (){\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(arg1,arg2,arg3) : f.call(null,arg1,arg2,arg3));\n});\nvar G__10375__1 \x3d (function (x){\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(arg1,arg2,arg3,x) : f.call(null,arg1,arg2,arg3,x));\n});\nvar G__10375__2 \x3d (function (x,y){\nreturn (f.cljs$core$IFn$_invoke$arity$5 ? f.cljs$core$IFn$_invoke$arity$5(arg1,arg2,arg3,x,y) : f.call(null,arg1,arg2,arg3,x,y));\n});\nvar G__10375__3 \x3d (function (x,y,z){\nreturn (f.cljs$core$IFn$_invoke$arity$6 ? f.cljs$core$IFn$_invoke$arity$6(arg1,arg2,arg3,x,y,z) : f.call(null,arg1,arg2,arg3,x,y,z));\n});\nvar G__10375__4 \x3d (function() { \nvar G__10376__delegate \x3d function (x,y,z,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,arg1,arg2,arg3,x,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([y,z,args], 0));\n};\nvar G__10376 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10377__i \x3d 0, G__10377__a \x3d new Array(arguments.length -  3);\nwhile (G__10377__i \x3c G__10377__a.length) {G__10377__a[G__10377__i] \x3d arguments[G__10377__i + 3]; ++G__10377__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10377__a,0,null);\n} \nreturn G__10376__delegate.call(this,x,y,z,args);};\nG__10376.cljs$lang$maxFixedArity \x3d 3;\nG__10376.cljs$lang$applyTo \x3d (function (arglist__10378){\nvar x \x3d cljs.core.first(arglist__10378);\narglist__10378 \x3d cljs.core.next(arglist__10378);\nvar y \x3d cljs.core.first(arglist__10378);\narglist__10378 \x3d cljs.core.next(arglist__10378);\nvar z \x3d cljs.core.first(arglist__10378);\nvar args \x3d cljs.core.rest(arglist__10378);\nreturn G__10376__delegate(x,y,z,args);\n});\nG__10376.cljs$core$IFn$_invoke$arity$variadic \x3d G__10376__delegate;\nreturn G__10376;\n})()\n;\nG__10375 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__10375__0.call(this);\ncase 1:\nreturn G__10375__1.call(this,x);\ncase 2:\nreturn G__10375__2.call(this,x,y);\ncase 3:\nreturn G__10375__3.call(this,x,y,z);\ndefault:\nvar G__10379 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10380__i \x3d 0, G__10380__a \x3d new Array(arguments.length -  3);\nwhile (G__10380__i \x3c G__10380__a.length) {G__10380__a[G__10380__i] \x3d arguments[G__10380__i + 3]; ++G__10380__i;}\nG__10379 \x3d new cljs.core.IndexedSeq(G__10380__a,0,null);\n}\nreturn G__10375__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10379);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10375.cljs$lang$maxFixedArity \x3d 3;\nG__10375.cljs$lang$applyTo \x3d G__10375__4.cljs$lang$applyTo;\nG__10375.cljs$core$IFn$_invoke$arity$0 \x3d G__10375__0;\nG__10375.cljs$core$IFn$_invoke$arity$1 \x3d G__10375__1;\nG__10375.cljs$core$IFn$_invoke$arity$2 \x3d G__10375__2;\nG__10375.cljs$core$IFn$_invoke$arity$3 \x3d G__10375__3;\nG__10375.cljs$core$IFn$_invoke$arity$variadic \x3d G__10375__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10375;\n})()\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,arg1,arg2,arg3,more){\nreturn (function() { \nvar G__10381__delegate \x3d function (args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,arg1,arg2,arg3,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(more,args));\n};\nvar G__10381 \x3d function (var_args){\nvar args \x3d null;\nif (arguments.length \x3e 0) {\nvar G__10382__i \x3d 0, G__10382__a \x3d new Array(arguments.length -  0);\nwhile (G__10382__i \x3c G__10382__a.length) {G__10382__a[G__10382__i] \x3d arguments[G__10382__i + 0]; ++G__10382__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10382__a,0,null);\n} \nreturn G__10381__delegate.call(this,args);};\nG__10381.cljs$lang$maxFixedArity \x3d 0;\nG__10381.cljs$lang$applyTo \x3d (function (arglist__10383){\nvar args \x3d cljs.core.seq(arglist__10383);\nreturn G__10381__delegate(args);\n});\nG__10381.cljs$core$IFn$_invoke$arity$variadic \x3d G__10381__delegate;\nreturn G__10381;\n})()\n;\n});\n\n/** @this {Function} */\ncljs.core.partial.cljs$lang$applyTo \x3d (function (seq10353){\nvar G__10354 \x3d cljs.core.first(seq10353);\nvar seq10353__$1 \x3d cljs.core.next(seq10353);\nvar G__10355 \x3d cljs.core.first(seq10353__$1);\nvar seq10353__$2 \x3d cljs.core.next(seq10353__$1);\nvar G__10356 \x3d cljs.core.first(seq10353__$2);\nvar seq10353__$3 \x3d cljs.core.next(seq10353__$2);\nvar G__10357 \x3d cljs.core.first(seq10353__$3);\nvar seq10353__$4 \x3d cljs.core.next(seq10353__$3);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10354,G__10355,G__10356,G__10357,seq10353__$4);\n});\n\ncljs.core.partial.cljs$lang$maxFixedArity \x3d (4);\n\n/**\n * Takes a function f, and returns a function that calls f, replacing\n *   a nil first argument to f with the supplied value x. Higher arity\n *   versions can replace arguments in the second and third\n *   positions (y, z). Note that the function f can take any number of\n *   arguments, not just the one(s) being nil-patched.\n */\ncljs.core.fnil \x3d (function cljs$core$fnil(var_args){\nvar G__10385 \x3d arguments.length;\nswitch (G__10385) {\ncase 2:\nreturn cljs.core.fnil.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.fnil.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.fnil.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.fnil.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,x){\nreturn (function() {\nvar G__10403 \x3d null;\nvar G__10403__1 \x3d (function (a){\nvar G__10386 \x3d (((a \x3d\x3d null))?x:a);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10386) : f.call(null,G__10386));\n});\nvar G__10403__2 \x3d (function (a,b){\nvar G__10387 \x3d (((a \x3d\x3d null))?x:a);\nvar G__10388 \x3d b;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10387,G__10388) : f.call(null,G__10387,G__10388));\n});\nvar G__10403__3 \x3d (function (a,b,c){\nvar G__10389 \x3d (((a \x3d\x3d null))?x:a);\nvar G__10390 \x3d b;\nvar G__10391 \x3d c;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10389,G__10390,G__10391) : f.call(null,G__10389,G__10390,G__10391));\n});\nvar G__10403__4 \x3d (function() { \nvar G__10404__delegate \x3d function (a,b,c,ds){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,(((a \x3d\x3d null))?x:a),b,c,ds);\n};\nvar G__10404 \x3d function (a,b,c,var_args){\nvar ds \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10405__i \x3d 0, G__10405__a \x3d new Array(arguments.length -  3);\nwhile (G__10405__i \x3c G__10405__a.length) {G__10405__a[G__10405__i] \x3d arguments[G__10405__i + 3]; ++G__10405__i;}\n  ds \x3d new cljs.core.IndexedSeq(G__10405__a,0,null);\n} \nreturn G__10404__delegate.call(this,a,b,c,ds);};\nG__10404.cljs$lang$maxFixedArity \x3d 3;\nG__10404.cljs$lang$applyTo \x3d (function (arglist__10406){\nvar a \x3d cljs.core.first(arglist__10406);\narglist__10406 \x3d cljs.core.next(arglist__10406);\nvar b \x3d cljs.core.first(arglist__10406);\narglist__10406 \x3d cljs.core.next(arglist__10406);\nvar c \x3d cljs.core.first(arglist__10406);\nvar ds \x3d cljs.core.rest(arglist__10406);\nreturn G__10404__delegate(a,b,c,ds);\n});\nG__10404.cljs$core$IFn$_invoke$arity$variadic \x3d G__10404__delegate;\nreturn G__10404;\n})()\n;\nG__10403 \x3d function(a,b,c,var_args){\nvar ds \x3d var_args;\nswitch(arguments.length){\ncase 1:\nreturn G__10403__1.call(this,a);\ncase 2:\nreturn G__10403__2.call(this,a,b);\ncase 3:\nreturn G__10403__3.call(this,a,b,c);\ndefault:\nvar G__10407 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10408__i \x3d 0, G__10408__a \x3d new Array(arguments.length -  3);\nwhile (G__10408__i \x3c G__10408__a.length) {G__10408__a[G__10408__i] \x3d arguments[G__10408__i + 3]; ++G__10408__i;}\nG__10407 \x3d new cljs.core.IndexedSeq(G__10408__a,0,null);\n}\nreturn G__10403__4.cljs$core$IFn$_invoke$arity$variadic(a,b,c, G__10407);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10403.cljs$lang$maxFixedArity \x3d 3;\nG__10403.cljs$lang$applyTo \x3d G__10403__4.cljs$lang$applyTo;\nG__10403.cljs$core$IFn$_invoke$arity$1 \x3d G__10403__1;\nG__10403.cljs$core$IFn$_invoke$arity$2 \x3d G__10403__2;\nG__10403.cljs$core$IFn$_invoke$arity$3 \x3d G__10403__3;\nG__10403.cljs$core$IFn$_invoke$arity$variadic \x3d G__10403__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10403;\n})()\n});\n\ncljs.core.fnil.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,x,y){\nreturn (function() {\nvar G__10409 \x3d null;\nvar G__10409__2 \x3d (function (a,b){\nvar G__10392 \x3d (((a \x3d\x3d null))?x:a);\nvar G__10393 \x3d (((b \x3d\x3d null))?y:b);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10392,G__10393) : f.call(null,G__10392,G__10393));\n});\nvar G__10409__3 \x3d (function (a,b,c){\nvar G__10394 \x3d (((a \x3d\x3d null))?x:a);\nvar G__10395 \x3d (((b \x3d\x3d null))?y:b);\nvar G__10396 \x3d c;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10394,G__10395,G__10396) : f.call(null,G__10394,G__10395,G__10396));\n});\nvar G__10409__4 \x3d (function() { \nvar G__10410__delegate \x3d function (a,b,c,ds){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,(((a \x3d\x3d null))?x:a),(((b \x3d\x3d null))?y:b),c,ds);\n};\nvar G__10410 \x3d function (a,b,c,var_args){\nvar ds \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10411__i \x3d 0, G__10411__a \x3d new Array(arguments.length -  3);\nwhile (G__10411__i \x3c G__10411__a.length) {G__10411__a[G__10411__i] \x3d arguments[G__10411__i + 3]; ++G__10411__i;}\n  ds \x3d new cljs.core.IndexedSeq(G__10411__a,0,null);\n} \nreturn G__10410__delegate.call(this,a,b,c,ds);};\nG__10410.cljs$lang$maxFixedArity \x3d 3;\nG__10410.cljs$lang$applyTo \x3d (function (arglist__10412){\nvar a \x3d cljs.core.first(arglist__10412);\narglist__10412 \x3d cljs.core.next(arglist__10412);\nvar b \x3d cljs.core.first(arglist__10412);\narglist__10412 \x3d cljs.core.next(arglist__10412);\nvar c \x3d cljs.core.first(arglist__10412);\nvar ds \x3d cljs.core.rest(arglist__10412);\nreturn G__10410__delegate(a,b,c,ds);\n});\nG__10410.cljs$core$IFn$_invoke$arity$variadic \x3d G__10410__delegate;\nreturn G__10410;\n})()\n;\nG__10409 \x3d function(a,b,c,var_args){\nvar ds \x3d var_args;\nswitch(arguments.length){\ncase 2:\nreturn G__10409__2.call(this,a,b);\ncase 3:\nreturn G__10409__3.call(this,a,b,c);\ndefault:\nvar G__10413 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10414__i \x3d 0, G__10414__a \x3d new Array(arguments.length -  3);\nwhile (G__10414__i \x3c G__10414__a.length) {G__10414__a[G__10414__i] \x3d arguments[G__10414__i + 3]; ++G__10414__i;}\nG__10413 \x3d new cljs.core.IndexedSeq(G__10414__a,0,null);\n}\nreturn G__10409__4.cljs$core$IFn$_invoke$arity$variadic(a,b,c, G__10413);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10409.cljs$lang$maxFixedArity \x3d 3;\nG__10409.cljs$lang$applyTo \x3d G__10409__4.cljs$lang$applyTo;\nG__10409.cljs$core$IFn$_invoke$arity$2 \x3d G__10409__2;\nG__10409.cljs$core$IFn$_invoke$arity$3 \x3d G__10409__3;\nG__10409.cljs$core$IFn$_invoke$arity$variadic \x3d G__10409__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10409;\n})()\n});\n\ncljs.core.fnil.cljs$core$IFn$_invoke$arity$4 \x3d (function (f,x,y,z){\nreturn (function() {\nvar G__10415 \x3d null;\nvar G__10415__2 \x3d (function (a,b){\nvar G__10397 \x3d (((a \x3d\x3d null))?x:a);\nvar G__10398 \x3d (((b \x3d\x3d null))?y:b);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10397,G__10398) : f.call(null,G__10397,G__10398));\n});\nvar G__10415__3 \x3d (function (a,b,c){\nvar G__10399 \x3d (((a \x3d\x3d null))?x:a);\nvar G__10400 \x3d (((b \x3d\x3d null))?y:b);\nvar G__10401 \x3d (((c \x3d\x3d null))?z:c);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10399,G__10400,G__10401) : f.call(null,G__10399,G__10400,G__10401));\n});\nvar G__10415__4 \x3d (function() { \nvar G__10416__delegate \x3d function (a,b,c,ds){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,(((a \x3d\x3d null))?x:a),(((b \x3d\x3d null))?y:b),(((c \x3d\x3d null))?z:c),ds);\n};\nvar G__10416 \x3d function (a,b,c,var_args){\nvar ds \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10417__i \x3d 0, G__10417__a \x3d new Array(arguments.length -  3);\nwhile (G__10417__i \x3c G__10417__a.length) {G__10417__a[G__10417__i] \x3d arguments[G__10417__i + 3]; ++G__10417__i;}\n  ds \x3d new cljs.core.IndexedSeq(G__10417__a,0,null);\n} \nreturn G__10416__delegate.call(this,a,b,c,ds);};\nG__10416.cljs$lang$maxFixedArity \x3d 3;\nG__10416.cljs$lang$applyTo \x3d (function (arglist__10418){\nvar a \x3d cljs.core.first(arglist__10418);\narglist__10418 \x3d cljs.core.next(arglist__10418);\nvar b \x3d cljs.core.first(arglist__10418);\narglist__10418 \x3d cljs.core.next(arglist__10418);\nvar c \x3d cljs.core.first(arglist__10418);\nvar ds \x3d cljs.core.rest(arglist__10418);\nreturn G__10416__delegate(a,b,c,ds);\n});\nG__10416.cljs$core$IFn$_invoke$arity$variadic \x3d G__10416__delegate;\nreturn G__10416;\n})()\n;\nG__10415 \x3d function(a,b,c,var_args){\nvar ds \x3d var_args;\nswitch(arguments.length){\ncase 2:\nreturn G__10415__2.call(this,a,b);\ncase 3:\nreturn G__10415__3.call(this,a,b,c);\ndefault:\nvar G__10419 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10420__i \x3d 0, G__10420__a \x3d new Array(arguments.length -  3);\nwhile (G__10420__i \x3c G__10420__a.length) {G__10420__a[G__10420__i] \x3d arguments[G__10420__i + 3]; ++G__10420__i;}\nG__10419 \x3d new cljs.core.IndexedSeq(G__10420__a,0,null);\n}\nreturn G__10415__4.cljs$core$IFn$_invoke$arity$variadic(a,b,c, G__10419);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10415.cljs$lang$maxFixedArity \x3d 3;\nG__10415.cljs$lang$applyTo \x3d G__10415__4.cljs$lang$applyTo;\nG__10415.cljs$core$IFn$_invoke$arity$2 \x3d G__10415__2;\nG__10415.cljs$core$IFn$_invoke$arity$3 \x3d G__10415__3;\nG__10415.cljs$core$IFn$_invoke$arity$variadic \x3d G__10415__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10415;\n})()\n});\n\ncljs.core.fnil.cljs$lang$maxFixedArity \x3d 4;\n\n/**\n * Returns a lazy sequence consisting of the result of applying f to 0\n *   and the first item of coll, followed by applying f to 1 and the second\n *   item in coll, etc, until coll is exhausted. Thus function f should\n *   accept 2 arguments, index and item. Returns a stateful transducer when\n *   no collection is provided.\n */\ncljs.core.map_indexed \x3d (function cljs$core$map_indexed(var_args){\nvar G__10422 \x3d arguments.length;\nswitch (G__10422) {\ncase 1:\nreturn cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.map_indexed.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn (function (rf){\nvar i \x3d cljs.core.volatile_BANG_((-1));\nreturn ((function (i){\nreturn (function() {\nvar G__10436 \x3d null;\nvar G__10436__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__10436__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__10436__2 \x3d (function (result,input){\nvar G__10423 \x3d result;\nvar G__10424 \x3d (function (){var G__10425 \x3d i.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(i.cljs$core$IDeref$_deref$arity$1(null) + (1)));\nvar G__10426 \x3d input;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10425,G__10426) : f.call(null,G__10425,G__10426));\n})();\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(G__10423,G__10424) : rf.call(null,G__10423,G__10424));\n});\nG__10436 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__10436__0.call(this);\ncase 1:\nreturn G__10436__1.call(this,result);\ncase 2:\nreturn G__10436__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10436.cljs$core$IFn$_invoke$arity$0 \x3d G__10436__0;\nG__10436.cljs$core$IFn$_invoke$arity$1 \x3d G__10436__1;\nG__10436.cljs$core$IFn$_invoke$arity$2 \x3d G__10436__2;\nreturn G__10436;\n})()\n;})(i))\n});\n});\n\ncljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,coll){\nvar mapi \x3d (function cljs$core$mapi(idx,coll__$1){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll__$1);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c \x3d cljs.core.chunk_first(s);\nvar size \x3d cljs.core.count(c);\nvar b \x3d cljs.core.chunk_buffer(size);\nvar n__4607__auto___10437 \x3d size;\nvar i_10438 \x3d (0);\nwhile(true){\nif((i_10438 \x3c n__4607__auto___10437)){\ncljs.core.chunk_append(b,(function (){var G__10431 \x3d (idx + i_10438);\nvar G__10432 \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_10438);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10431,G__10432) : f.call(null,G__10431,G__10432));\n})());\n\nvar G__10439 \x3d (i_10438 + (1));\ni_10438 \x3d G__10439;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs$core$mapi((idx + size),cljs.core.chunk_rest(s)));\n} else {\nreturn cljs.core.cons((function (){var G__10433 \x3d idx;\nvar G__10434 \x3d cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10433,G__10434) : f.call(null,G__10433,G__10434));\n})(),cljs$core$mapi((idx + (1)),cljs.core.rest(s)));\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\nreturn mapi((0),coll);\n});\n\ncljs.core.map_indexed.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a lazy sequence of the non-nil results of (f item). Note,\n *   this means false return values will be included.  f must be free of\n *   side-effects.  Returns a transducer when no collection is provided.\n */\ncljs.core.keep \x3d (function cljs$core$keep(var_args){\nvar G__10441 \x3d arguments.length;\nswitch (G__10441) {\ncase 1:\nreturn cljs.core.keep.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.keep.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.keep.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn (function (rf){\nreturn (function() {\nvar G__10445 \x3d null;\nvar G__10445__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__10445__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__10445__2 \x3d (function (result,input){\nvar v \x3d (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(input) : f.call(null,input));\nif((v \x3d\x3d null)){\nreturn result;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v));\n}\n});\nG__10445 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__10445__0.call(this);\ncase 1:\nreturn G__10445__1.call(this,result);\ncase 2:\nreturn G__10445__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10445.cljs$core$IFn$_invoke$arity$0 \x3d G__10445__0;\nG__10445.cljs$core$IFn$_invoke$arity$1 \x3d G__10445__1;\nG__10445.cljs$core$IFn$_invoke$arity$2 \x3d G__10445__2;\nreturn G__10445;\n})()\n});\n});\n\ncljs.core.keep.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c \x3d cljs.core.chunk_first(s);\nvar size \x3d cljs.core.count(c);\nvar b \x3d cljs.core.chunk_buffer(size);\nvar n__4607__auto___10446 \x3d size;\nvar i_10447 \x3d (0);\nwhile(true){\nif((i_10447 \x3c n__4607__auto___10446)){\nvar x_10448 \x3d (function (){var G__10442 \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_10447);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10442) : f.call(null,G__10442));\n})();\nif((x_10448 \x3d\x3d null)){\n} else {\ncljs.core.chunk_append(b,x_10448);\n}\n\nvar G__10449 \x3d (i_10447 + (1));\ni_10447 \x3d G__10449;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs.core.keep.cljs$core$IFn$_invoke$arity$2(f,cljs.core.chunk_rest(s)));\n} else {\nvar x \x3d (function (){var G__10443 \x3d cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10443) : f.call(null,G__10443));\n})();\nif((x \x3d\x3d null)){\nreturn cljs.core.keep.cljs$core$IFn$_invoke$arity$2(f,cljs.core.rest(s));\n} else {\nreturn cljs.core.cons(x,cljs.core.keep.cljs$core$IFn$_invoke$arity$2(f,cljs.core.rest(s)));\n}\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.keep.cljs$lang$maxFixedArity \x3d 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IWatchable}\n * @implements {cljs.core.IAtom}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IDeref}\n*/\ncljs.core.Atom \x3d (function (state,meta,validator,watches){\nthis.state \x3d state;\nthis.meta \x3d meta;\nthis.validator \x3d validator;\nthis.watches \x3d watches;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 16386;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 6455296;\n});\ncljs.core.Atom.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Atom.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (o,other){\nvar self__ \x3d this;\nvar o__$1 \x3d this;\nreturn (o__$1 \x3d\x3d\x3d other);\n});\n\ncljs.core.Atom.prototype.cljs$core$IDeref$_deref$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.state;\n});\n\ncljs.core.Atom.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.Atom.prototype.cljs$core$IWatchable$_notify_watches$arity$3 \x3d (function (this$,oldval,newval){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nvar seq__10450 \x3d cljs.core.seq(self__.watches);\nvar chunk__10451 \x3d null;\nvar count__10452 \x3d (0);\nvar i__10453 \x3d (0);\nwhile(true){\nif((i__10453 \x3c count__10452)){\nvar vec__10460 \x3d chunk__10451.cljs$core$IIndexed$_nth$arity$2(null,i__10453);\nvar key \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10460,(0),null);\nvar f \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10460,(1),null);\n(f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(key,this$__$1,oldval,newval) : f.call(null,key,this$__$1,oldval,newval));\n\n\nvar G__10466 \x3d seq__10450;\nvar G__10467 \x3d chunk__10451;\nvar G__10468 \x3d count__10452;\nvar G__10469 \x3d (i__10453 + (1));\nseq__10450 \x3d G__10466;\nchunk__10451 \x3d G__10467;\ncount__10452 \x3d G__10468;\ni__10453 \x3d G__10469;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__10450);\nif(temp__5720__auto__){\nvar seq__10450__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__10450__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__10450__$1);\nvar G__10470 \x3d cljs.core.chunk_rest(seq__10450__$1);\nvar G__10471 \x3d c__4550__auto__;\nvar G__10472 \x3d cljs.core.count(c__4550__auto__);\nvar G__10473 \x3d (0);\nseq__10450 \x3d G__10470;\nchunk__10451 \x3d G__10471;\ncount__10452 \x3d G__10472;\ni__10453 \x3d G__10473;\ncontinue;\n} else {\nvar vec__10463 \x3d cljs.core.first(seq__10450__$1);\nvar key \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10463,(0),null);\nvar f \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10463,(1),null);\n(f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(key,this$__$1,oldval,newval) : f.call(null,key,this$__$1,oldval,newval));\n\n\nvar G__10474 \x3d cljs.core.next(seq__10450__$1);\nvar G__10475 \x3d null;\nvar G__10476 \x3d (0);\nvar G__10477 \x3d (0);\nseq__10450 \x3d G__10474;\nchunk__10451 \x3d G__10475;\ncount__10452 \x3d G__10476;\ni__10453 \x3d G__10477;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.Atom.prototype.cljs$core$IWatchable$_add_watch$arity$3 \x3d (function (this$,key,f){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nthis$__$1.watches \x3d cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.watches,key,f);\n\nreturn this$__$1;\n});\n\ncljs.core.Atom.prototype.cljs$core$IWatchable$_remove_watch$arity$2 \x3d (function (this$,key){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn this$__$1.watches \x3d cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(self__.watches,key);\n});\n\ncljs.core.Atom.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn goog.getUid(this$__$1);\n});\n\ncljs.core.Atom.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$state,cljs.core.cst$sym$meta,cljs.core.cst$sym$validator,cljs.core.cst$sym$watches], null);\n});\n\ncljs.core.Atom.cljs$lang$type \x3d true;\n\ncljs.core.Atom.cljs$lang$ctorStr \x3d "cljs.core/Atom";\n\ncljs.core.Atom.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Atom");\n});\n\n/**\n * Positional factory function for cljs.core/Atom.\n */\ncljs.core.__GT_Atom \x3d (function cljs$core$__GT_Atom(state,meta,validator,watches){\nreturn (new cljs.core.Atom(state,meta,validator,watches));\n});\n\n/**\n * Creates and returns an Atom with an initial value of x and zero or\n *   more options (in any order):\n * \n *   :meta metadata-map\n * \n *   :validator validate-fn\n * \n *   If metadata-map is supplied, it will become the metadata on the\n *   atom. validate-fn must be nil or a side-effect-free fn of one\n *   argument, which will be passed the intended new state on any state\n *   change. If the new state is unacceptable, the validate-fn should\n *   return false or throw an Error.  If either of these error conditions\n *   occur, then the value of the atom will not change.\n */\ncljs.core.atom \x3d (function cljs$core$atom(var_args){\nvar G__10481 \x3d arguments.length;\nswitch (G__10481) {\ncase 1:\nreturn cljs.core.atom.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10486 \x3d arguments.length;\nvar i__4731__auto___10487 \x3d (0);\nwhile(true){\nif((i__4731__auto___10487 \x3c len__4730__auto___10486)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10487]));\n\nvar G__10488 \x3d (i__4731__auto___10487 + (1));\ni__4731__auto___10487 \x3d G__10488;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.atom.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.atom.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn (new cljs.core.Atom(x,null,null,null));\n});\n\ncljs.core.atom.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,p__10482){\nvar map__10483 \x3d p__10482;\nvar map__10483__$1 \x3d (((((!((map__10483 \x3d\x3d null))))?(((((map__10483.cljs$lang$protocol_mask$partition0$ \x26 (64))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d map__10483.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__10483):map__10483);\nvar meta \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__10483__$1,cljs.core.cst$kw$meta);\nvar validator \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__10483__$1,cljs.core.cst$kw$validator);\nreturn (new cljs.core.Atom(x,meta,validator,null));\n});\n\n/** @this {Function} */\ncljs.core.atom.cljs$lang$applyTo \x3d (function (seq10479){\nvar G__10480 \x3d cljs.core.first(seq10479);\nvar seq10479__$1 \x3d cljs.core.next(seq10479);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10480,seq10479__$1);\n});\n\ncljs.core.atom.cljs$lang$maxFixedArity \x3d (1);\n\n/**\n * Sets the value of atom to newval without regard for the\n *   current value. Returns new-value.\n */\ncljs.core.reset_BANG_ \x3d (function cljs$core$reset_BANG_(a,new_value){\nif((a instanceof cljs.core.Atom)){\nvar validate \x3d a.validator;\nif((validate \x3d\x3d null)){\n} else {\nif(cljs.core.truth_((validate.cljs$core$IFn$_invoke$arity$1 ? validate.cljs$core$IFn$_invoke$arity$1(new_value) : validate.call(null,new_value)))){\n} else {\nthrow (new Error("Validator rejected reference state"));\n}\n}\n\nvar old_value \x3d a.state;\na.state \x3d new_value;\n\nif((a.watches \x3d\x3d null)){\n} else {\na.cljs$core$IWatchable$_notify_watches$arity$3(null,old_value,new_value);\n}\n\nreturn new_value;\n} else {\nreturn cljs.core._reset_BANG_(a,new_value);\n}\n});\n/**\n * Sets the value of atom to newval. Returns [old new], the value of the\n * atom before and after the reset.\n */\ncljs.core.reset_vals_BANG_ \x3d (function cljs$core$reset_vals_BANG_(a,new_value){\nvar validate \x3d a.validator;\nif((validate \x3d\x3d null)){\n} else {\nif(cljs.core.truth_((validate.cljs$core$IFn$_invoke$arity$1 ? validate.cljs$core$IFn$_invoke$arity$1(new_value) : validate.call(null,new_value)))){\n} else {\nthrow (new Error("Validator rejected reference state"));\n}\n}\n\nvar old_value \x3d a.state;\na.state \x3d new_value;\n\nif((a.watches \x3d\x3d null)){\n} else {\ncljs.core._notify_watches(a,old_value,new_value);\n}\n\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [old_value,new_value], null);\n});\n/**\n * Atomically swaps the value of atom to be:\n *   (apply f current-value-of-atom args). Note that f may be called\n *   multiple times, and thus should be free of side effects.  Returns\n *   the value that was swapped in.\n */\ncljs.core.swap_BANG_ \x3d (function cljs$core$swap_BANG_(var_args){\nvar G__10495 \x3d arguments.length;\nswitch (G__10495) {\ncase 2:\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10503 \x3d arguments.length;\nvar i__4731__auto___10504 \x3d (0);\nwhile(true){\nif((i__4731__auto___10504 \x3c len__4730__auto___10503)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10504]));\n\nvar G__10505 \x3d (i__4731__auto___10504 + (1));\ni__4731__auto___10504 \x3d G__10505;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2 \x3d (function (a,f){\nif((a instanceof cljs.core.Atom)){\nreturn cljs.core.reset_BANG_(a,(function (){var G__10496 \x3d a.state;\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10496) : f.call(null,G__10496));\n})());\n} else {\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$2(a,f);\n}\n});\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3 \x3d (function (a,f,x){\nif((a instanceof cljs.core.Atom)){\nreturn cljs.core.reset_BANG_(a,(function (){var G__10497 \x3d a.state;\nvar G__10498 \x3d x;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10497,G__10498) : f.call(null,G__10497,G__10498));\n})());\n} else {\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$3(a,f,x);\n}\n});\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4 \x3d (function (a,f,x,y){\nif((a instanceof cljs.core.Atom)){\nreturn cljs.core.reset_BANG_(a,(function (){var G__10499 \x3d a.state;\nvar G__10500 \x3d x;\nvar G__10501 \x3d y;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10499,G__10500,G__10501) : f.call(null,G__10499,G__10500,G__10501));\n})());\n} else {\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$4(a,f,x,y);\n}\n});\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (a,f,x,y,more){\nif((a instanceof cljs.core.Atom)){\nreturn cljs.core.reset_BANG_(a,cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,a.state,x,y,more));\n} else {\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$5(a,f,x,y,more);\n}\n});\n\n/** @this {Function} */\ncljs.core.swap_BANG_.cljs$lang$applyTo \x3d (function (seq10490){\nvar G__10491 \x3d cljs.core.first(seq10490);\nvar seq10490__$1 \x3d cljs.core.next(seq10490);\nvar G__10492 \x3d cljs.core.first(seq10490__$1);\nvar seq10490__$2 \x3d cljs.core.next(seq10490__$1);\nvar G__10493 \x3d cljs.core.first(seq10490__$2);\nvar seq10490__$3 \x3d cljs.core.next(seq10490__$2);\nvar G__10494 \x3d cljs.core.first(seq10490__$3);\nvar seq10490__$4 \x3d cljs.core.next(seq10490__$3);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10491,G__10492,G__10493,G__10494,seq10490__$4);\n});\n\ncljs.core.swap_BANG_.cljs$lang$maxFixedArity \x3d (4);\n\n/**\n * Atomically swaps the value of atom to be:\n *   (apply f current-value-of-atom args). Note that f may be called\n *   multiple times, and thus should be free of side effects.\n *   Returns [old new], the value of the atom before and after the swap.\n */\ncljs.core.swap_vals_BANG_ \x3d (function cljs$core$swap_vals_BANG_(var_args){\nvar G__10512 \x3d arguments.length;\nswitch (G__10512) {\ncase 2:\nreturn cljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10520 \x3d arguments.length;\nvar i__4731__auto___10521 \x3d (0);\nwhile(true){\nif((i__4731__auto___10521 \x3c len__4730__auto___10520)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10521]));\n\nvar G__10522 \x3d (i__4731__auto___10521 + (1));\ni__4731__auto___10521 \x3d G__10522;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$2 \x3d (function (a,f){\nreturn cljs.core.reset_vals_BANG_(a,(function (){var G__10513 \x3d a.state;\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10513) : f.call(null,G__10513));\n})());\n});\n\ncljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$3 \x3d (function (a,f,x){\nreturn cljs.core.reset_vals_BANG_(a,(function (){var G__10514 \x3d a.state;\nvar G__10515 \x3d x;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10514,G__10515) : f.call(null,G__10514,G__10515));\n})());\n});\n\ncljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$4 \x3d (function (a,f,x,y){\nreturn cljs.core.reset_vals_BANG_(a,(function (){var G__10516 \x3d a.state;\nvar G__10517 \x3d x;\nvar G__10518 \x3d y;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10516,G__10517,G__10518) : f.call(null,G__10516,G__10517,G__10518));\n})());\n});\n\ncljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (a,f,x,y,more){\nreturn cljs.core.reset_vals_BANG_(a,cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,a.state,x,y,more));\n});\n\n/** @this {Function} */\ncljs.core.swap_vals_BANG_.cljs$lang$applyTo \x3d (function (seq10507){\nvar G__10508 \x3d cljs.core.first(seq10507);\nvar seq10507__$1 \x3d cljs.core.next(seq10507);\nvar G__10509 \x3d cljs.core.first(seq10507__$1);\nvar seq10507__$2 \x3d cljs.core.next(seq10507__$1);\nvar G__10510 \x3d cljs.core.first(seq10507__$2);\nvar seq10507__$3 \x3d cljs.core.next(seq10507__$2);\nvar G__10511 \x3d cljs.core.first(seq10507__$3);\nvar seq10507__$4 \x3d cljs.core.next(seq10507__$3);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10508,G__10509,G__10510,G__10511,seq10507__$4);\n});\n\ncljs.core.swap_vals_BANG_.cljs$lang$maxFixedArity \x3d (4);\n\n/**\n * Atomically sets the value of atom to newval if and only if the\n *   current value of the atom is equal to oldval. Returns true if\n *   set happened, else false.\n */\ncljs.core.compare_and_set_BANG_ \x3d (function cljs$core$compare_and_set_BANG_(a,oldval,newval){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(a.cljs$core$IDeref$_deref$arity$1(null),oldval)){\ncljs.core.reset_BANG_(a,newval);\n\nreturn true;\n} else {\nreturn false;\n}\n});\n/**\n * Sets the validator-fn for an atom. validator-fn must be nil or a\n *   side-effect-free fn of one argument, which will be passed the intended\n *   new state on any state change. If the new state is unacceptable, the\n *   validator-fn should return false or throw an Error. If the current state\n *   is not acceptable to the new validator, an Error will be thrown and the\n *   validator will not be changed.\n */\ncljs.core.set_validator_BANG_ \x3d (function cljs$core$set_validator_BANG_(iref,val){\nif((((!((val \x3d\x3d null)))) \x26\x26 (cljs.core.not((function (){var G__10524 \x3d cljs.core._deref(iref);\nreturn (val.cljs$core$IFn$_invoke$arity$1 ? val.cljs$core$IFn$_invoke$arity$1(G__10524) : val.call(null,G__10524));\n})())))){\nthrow (new Error("Validator rejected reference state"));\n} else {\n}\n\nreturn iref.validator \x3d val;\n});\n/**\n * Gets the validator-fn for a var/ref/agent/atom.\n */\ncljs.core.get_validator \x3d (function cljs$core$get_validator(iref){\nreturn iref.validator;\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IVolatile}\n * @implements {cljs.core.IDeref}\n*/\ncljs.core.Volatile \x3d (function (state){\nthis.state \x3d state;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32768;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.Volatile.prototype.cljs$core$IVolatile$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Volatile.prototype.cljs$core$IVolatile$_vreset_BANG_$arity$2 \x3d (function (_,new_state){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.state \x3d new_state;\n});\n\ncljs.core.Volatile.prototype.cljs$core$IDeref$_deref$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn self__.state;\n});\n\ncljs.core.Volatile.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$state,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Volatile.cljs$lang$type \x3d true;\n\ncljs.core.Volatile.cljs$lang$ctorStr \x3d "cljs.core/Volatile";\n\ncljs.core.Volatile.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Volatile");\n});\n\n/**\n * Positional factory function for cljs.core/Volatile.\n */\ncljs.core.__GT_Volatile \x3d (function cljs$core$__GT_Volatile(state){\nreturn (new cljs.core.Volatile(state));\n});\n\n/**\n * Creates and returns a Volatile with an initial value of val.\n */\ncljs.core.volatile_BANG_ \x3d (function cljs$core$volatile_BANG_(val){\nreturn (new cljs.core.Volatile(val));\n});\n/**\n * Returns true if x is a volatile.\n */\ncljs.core.volatile_QMARK_ \x3d (function cljs$core$volatile_QMARK_(x){\nreturn (x instanceof cljs.core.Volatile);\n});\n/**\n * Sets the value of volatile to newval without regard for the\n * current value. Returns newval.\n */\ncljs.core.vreset_BANG_ \x3d (function cljs$core$vreset_BANG_(vol,newval){\nreturn cljs.core._vreset_BANG_(vol,newval);\n});\n/**\n * Returns a lazy sequence of the non-nil results of (f index item). Note,\n *   this means false return values will be included.  f must be free of\n *   side-effects.  Returns a stateful transducer when no collection is\n *   provided.\n */\ncljs.core.keep_indexed \x3d (function cljs$core$keep_indexed(var_args){\nvar G__10526 \x3d arguments.length;\nswitch (G__10526) {\ncase 1:\nreturn cljs.core.keep_indexed.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.keep_indexed.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.keep_indexed.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn (function (rf){\nvar ia \x3d cljs.core.volatile_BANG_((-1));\nreturn ((function (ia){\nreturn (function() {\nvar G__10536 \x3d null;\nvar G__10536__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__10536__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__10536__2 \x3d (function (result,input){\nvar i \x3d ia.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(ia.cljs$core$IDeref$_deref$arity$1(null) + (1)));\nvar v \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(i,input) : f.call(null,i,input));\nif((v \x3d\x3d null)){\nreturn result;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v));\n}\n});\nG__10536 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__10536__0.call(this);\ncase 1:\nreturn G__10536__1.call(this,result);\ncase 2:\nreturn G__10536__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10536.cljs$core$IFn$_invoke$arity$0 \x3d G__10536__0;\nG__10536.cljs$core$IFn$_invoke$arity$1 \x3d G__10536__1;\nG__10536.cljs$core$IFn$_invoke$arity$2 \x3d G__10536__2;\nreturn G__10536;\n})()\n;})(ia))\n});\n});\n\ncljs.core.keep_indexed.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,coll){\nvar keepi \x3d (function cljs$core$keepi(idx,coll__$1){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll__$1);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c \x3d cljs.core.chunk_first(s);\nvar size \x3d cljs.core.count(c);\nvar b \x3d cljs.core.chunk_buffer(size);\nvar n__4607__auto___10537 \x3d size;\nvar i_10538 \x3d (0);\nwhile(true){\nif((i_10538 \x3c n__4607__auto___10537)){\nvar x_10539 \x3d (function (){var G__10531 \x3d (idx + i_10538);\nvar G__10532 \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_10538);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10531,G__10532) : f.call(null,G__10531,G__10532));\n})();\nif((x_10539 \x3d\x3d null)){\n} else {\ncljs.core.chunk_append(b,x_10539);\n}\n\nvar G__10540 \x3d (i_10538 + (1));\ni_10538 \x3d G__10540;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs$core$keepi((idx + size),cljs.core.chunk_rest(s)));\n} else {\nvar x \x3d (function (){var G__10533 \x3d idx;\nvar G__10534 \x3d cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10533,G__10534) : f.call(null,G__10533,G__10534));\n})();\nif((x \x3d\x3d null)){\nreturn cljs$core$keepi((idx + (1)),cljs.core.rest(s));\n} else {\nreturn cljs.core.cons(x,cljs$core$keepi((idx + (1)),cljs.core.rest(s)));\n}\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\nreturn keepi((0),coll);\n});\n\ncljs.core.keep_indexed.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Takes a set of predicates and returns a function f that returns true if all of its\n *   composing predicates return a logical true value against all of its arguments, else it returns\n *   false. Note that f is short-circuiting in that it will stop execution on the first\n *   argument that triggers a logical false result against the original predicates.\n */\ncljs.core.every_pred \x3d (function cljs$core$every_pred(var_args){\nvar G__10552 \x3d arguments.length;\nswitch (G__10552) {\ncase 1:\nreturn cljs.core.every_pred.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.every_pred.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.every_pred.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10554 \x3d arguments.length;\nvar i__4731__auto___10555 \x3d (0);\nwhile(true){\nif((i__4731__auto___10555 \x3c len__4730__auto___10554)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10555]));\n\nvar G__10556 \x3d (i__4731__auto___10555 + (1));\ni__4731__auto___10555 \x3d G__10556;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.every_pred.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.every_pred.cljs$core$IFn$_invoke$arity$1 \x3d (function (p){\nreturn (function() {\nvar cljs$core$ep1 \x3d null;\nvar cljs$core$ep1__0 \x3d (function (){\nreturn true;\n});\nvar cljs$core$ep1__1 \x3d (function (x){\nreturn cljs.core.boolean$((p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x)));\n});\nvar cljs$core$ep1__2 \x3d (function (x,y){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(y) : p.call(null,y));\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep1__3 \x3d (function (x,y,z){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 \x3d (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(y) : p.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(z) : p.call(null,z));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep1__4 \x3d (function() { \nvar G__10557__delegate \x3d function (x,y,z,args){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d cljs$core$ep1.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.every_QMARK_(p,args);\n} else {\nreturn and__4120__auto__;\n}\n})());\n};\nvar G__10557 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10558__i \x3d 0, G__10558__a \x3d new Array(arguments.length -  3);\nwhile (G__10558__i \x3c G__10558__a.length) {G__10558__a[G__10558__i] \x3d arguments[G__10558__i + 3]; ++G__10558__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10558__a,0,null);\n} \nreturn G__10557__delegate.call(this,x,y,z,args);};\nG__10557.cljs$lang$maxFixedArity \x3d 3;\nG__10557.cljs$lang$applyTo \x3d (function (arglist__10559){\nvar x \x3d cljs.core.first(arglist__10559);\narglist__10559 \x3d cljs.core.next(arglist__10559);\nvar y \x3d cljs.core.first(arglist__10559);\narglist__10559 \x3d cljs.core.next(arglist__10559);\nvar z \x3d cljs.core.first(arglist__10559);\nvar args \x3d cljs.core.rest(arglist__10559);\nreturn G__10557__delegate(x,y,z,args);\n});\nG__10557.cljs$core$IFn$_invoke$arity$variadic \x3d G__10557__delegate;\nreturn G__10557;\n})()\n;\ncljs$core$ep1 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$ep1__0.call(this);\ncase 1:\nreturn cljs$core$ep1__1.call(this,x);\ncase 2:\nreturn cljs$core$ep1__2.call(this,x,y);\ncase 3:\nreturn cljs$core$ep1__3.call(this,x,y,z);\ndefault:\nvar G__10560 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10561__i \x3d 0, G__10561__a \x3d new Array(arguments.length -  3);\nwhile (G__10561__i \x3c G__10561__a.length) {G__10561__a[G__10561__i] \x3d arguments[G__10561__i + 3]; ++G__10561__i;}\nG__10560 \x3d new cljs.core.IndexedSeq(G__10561__a,0,null);\n}\nreturn cljs$core$ep1__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10560);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\ncljs$core$ep1.cljs$lang$maxFixedArity \x3d 3;\ncljs$core$ep1.cljs$lang$applyTo \x3d cljs$core$ep1__4.cljs$lang$applyTo;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$0 \x3d cljs$core$ep1__0;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$1 \x3d cljs$core$ep1__1;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$2 \x3d cljs$core$ep1__2;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$3 \x3d cljs$core$ep1__3;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$variadic \x3d cljs$core$ep1__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$ep1;\n})()\n});\n\ncljs.core.every_pred.cljs$core$IFn$_invoke$arity$2 \x3d (function (p1,p2){\nreturn (function() {\nvar cljs$core$ep2 \x3d null;\nvar cljs$core$ep2__0 \x3d (function (){\nreturn true;\n});\nvar cljs$core$ep2__1 \x3d (function (x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep2__2 \x3d (function (x,y){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$2)){\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep2__3 \x3d (function (x,y,z){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(z) : p1.call(null,z));\nif(cljs.core.truth_(and__4120__auto____$2)){\nvar and__4120__auto____$3 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$3)){\nvar and__4120__auto____$4 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$4)){\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(z) : p2.call(null,z));\n} else {\nreturn and__4120__auto____$4;\n}\n} else {\nreturn and__4120__auto____$3;\n}\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep2__4 \x3d (function() { \nvar G__10562__delegate \x3d function (x,y,z,args){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d cljs$core$ep2.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.every_QMARK_(((function (and__4120__auto__){\nreturn (function (p1__10541_SHARP_){\nvar and__4120__auto____$1 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(p1__10541_SHARP_) : p1.call(null,p1__10541_SHARP_));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(p1__10541_SHARP_) : p2.call(null,p1__10541_SHARP_));\n} else {\nreturn and__4120__auto____$1;\n}\n});})(and__4120__auto__))\n,args);\n} else {\nreturn and__4120__auto__;\n}\n})());\n};\nvar G__10562 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10563__i \x3d 0, G__10563__a \x3d new Array(arguments.length -  3);\nwhile (G__10563__i \x3c G__10563__a.length) {G__10563__a[G__10563__i] \x3d arguments[G__10563__i + 3]; ++G__10563__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10563__a,0,null);\n} \nreturn G__10562__delegate.call(this,x,y,z,args);};\nG__10562.cljs$lang$maxFixedArity \x3d 3;\nG__10562.cljs$lang$applyTo \x3d (function (arglist__10564){\nvar x \x3d cljs.core.first(arglist__10564);\narglist__10564 \x3d cljs.core.next(arglist__10564);\nvar y \x3d cljs.core.first(arglist__10564);\narglist__10564 \x3d cljs.core.next(arglist__10564);\nvar z \x3d cljs.core.first(arglist__10564);\nvar args \x3d cljs.core.rest(arglist__10564);\nreturn G__10562__delegate(x,y,z,args);\n});\nG__10562.cljs$core$IFn$_invoke$arity$variadic \x3d G__10562__delegate;\nreturn G__10562;\n})()\n;\ncljs$core$ep2 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$ep2__0.call(this);\ncase 1:\nreturn cljs$core$ep2__1.call(this,x);\ncase 2:\nreturn cljs$core$ep2__2.call(this,x,y);\ncase 3:\nreturn cljs$core$ep2__3.call(this,x,y,z);\ndefault:\nvar G__10565 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10566__i \x3d 0, G__10566__a \x3d new Array(arguments.length -  3);\nwhile (G__10566__i \x3c G__10566__a.length) {G__10566__a[G__10566__i] \x3d arguments[G__10566__i + 3]; ++G__10566__i;}\nG__10565 \x3d new cljs.core.IndexedSeq(G__10566__a,0,null);\n}\nreturn cljs$core$ep2__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10565);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\ncljs$core$ep2.cljs$lang$maxFixedArity \x3d 3;\ncljs$core$ep2.cljs$lang$applyTo \x3d cljs$core$ep2__4.cljs$lang$applyTo;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$0 \x3d cljs$core$ep2__0;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$1 \x3d cljs$core$ep2__1;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$2 \x3d cljs$core$ep2__2;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$3 \x3d cljs$core$ep2__3;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$variadic \x3d cljs$core$ep2__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$ep2;\n})()\n});\n\ncljs.core.every_pred.cljs$core$IFn$_invoke$arity$3 \x3d (function (p1,p2,p3){\nreturn (function() {\nvar cljs$core$ep3 \x3d null;\nvar cljs$core$ep3__0 \x3d (function (){\nreturn true;\n});\nvar cljs$core$ep3__1 \x3d (function (x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep3__2 \x3d (function (x,y){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 \x3d (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$2)){\nvar and__4120__auto____$3 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$3)){\nvar and__4120__auto____$4 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$4)){\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(y) : p3.call(null,y));\n} else {\nreturn and__4120__auto____$4;\n}\n} else {\nreturn and__4120__auto____$3;\n}\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep3__3 \x3d (function (x,y,z){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 \x3d (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$2)){\nvar and__4120__auto____$3 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$3)){\nvar and__4120__auto____$4 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$4)){\nvar and__4120__auto____$5 \x3d (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(y) : p3.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$5)){\nvar and__4120__auto____$6 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(z) : p1.call(null,z));\nif(cljs.core.truth_(and__4120__auto____$6)){\nvar and__4120__auto____$7 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(z) : p2.call(null,z));\nif(cljs.core.truth_(and__4120__auto____$7)){\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(z) : p3.call(null,z));\n} else {\nreturn and__4120__auto____$7;\n}\n} else {\nreturn and__4120__auto____$6;\n}\n} else {\nreturn and__4120__auto____$5;\n}\n} else {\nreturn and__4120__auto____$4;\n}\n} else {\nreturn and__4120__auto____$3;\n}\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep3__4 \x3d (function() { \nvar G__10567__delegate \x3d function (x,y,z,args){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d cljs$core$ep3.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.every_QMARK_(((function (and__4120__auto__){\nreturn (function (p1__10542_SHARP_){\nvar and__4120__auto____$1 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(p1__10542_SHARP_) : p1.call(null,p1__10542_SHARP_));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(p1__10542_SHARP_) : p2.call(null,p1__10542_SHARP_));\nif(cljs.core.truth_(and__4120__auto____$2)){\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(p1__10542_SHARP_) : p3.call(null,p1__10542_SHARP_));\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n});})(and__4120__auto__))\n,args);\n} else {\nreturn and__4120__auto__;\n}\n})());\n};\nvar G__10567 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10568__i \x3d 0, G__10568__a \x3d new Array(arguments.length -  3);\nwhile (G__10568__i \x3c G__10568__a.length) {G__10568__a[G__10568__i] \x3d arguments[G__10568__i + 3]; ++G__10568__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10568__a,0,null);\n} \nreturn G__10567__delegate.call(this,x,y,z,args);};\nG__10567.cljs$lang$maxFixedArity \x3d 3;\nG__10567.cljs$lang$applyTo \x3d (function (arglist__10569){\nvar x \x3d cljs.core.first(arglist__10569);\narglist__10569 \x3d cljs.core.next(arglist__10569);\nvar y \x3d cljs.core.first(arglist__10569);\narglist__10569 \x3d cljs.core.next(arglist__10569);\nvar z \x3d cljs.core.first(arglist__10569);\nvar args \x3d cljs.core.rest(arglist__10569);\nreturn G__10567__delegate(x,y,z,args);\n});\nG__10567.cljs$core$IFn$_invoke$arity$variadic \x3d G__10567__delegate;\nreturn G__10567;\n})()\n;\ncljs$core$ep3 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$ep3__0.call(this);\ncase 1:\nreturn cljs$core$ep3__1.call(this,x);\ncase 2:\nreturn cljs$core$ep3__2.call(this,x,y);\ncase 3:\nreturn cljs$core$ep3__3.call(this,x,y,z);\ndefault:\nvar G__10570 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10571__i \x3d 0, G__10571__a \x3d new Array(arguments.length -  3);\nwhile (G__10571__i \x3c G__10571__a.length) {G__10571__a[G__10571__i] \x3d arguments[G__10571__i + 3]; ++G__10571__i;}\nG__10570 \x3d new cljs.core.IndexedSeq(G__10571__a,0,null);\n}\nreturn cljs$core$ep3__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10570);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\ncljs$core$ep3.cljs$lang$maxFixedArity \x3d 3;\ncljs$core$ep3.cljs$lang$applyTo \x3d cljs$core$ep3__4.cljs$lang$applyTo;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$0 \x3d cljs$core$ep3__0;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$1 \x3d cljs$core$ep3__1;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$2 \x3d cljs$core$ep3__2;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$3 \x3d cljs$core$ep3__3;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$variadic \x3d cljs$core$ep3__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$ep3;\n})()\n});\n\ncljs.core.every_pred.cljs$core$IFn$_invoke$arity$variadic \x3d (function (p1,p2,p3,ps){\nvar ps__$1 \x3d cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(p1,p2,p3,ps);\nreturn ((function (ps__$1){\nreturn (function() {\nvar cljs$core$epn \x3d null;\nvar cljs$core$epn__0 \x3d (function (){\nreturn true;\n});\nvar cljs$core$epn__1 \x3d (function (x){\nreturn cljs.core.every_QMARK_(((function (ps__$1){\nreturn (function (p1__10543_SHARP_){\nreturn (p1__10543_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10543_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__10543_SHARP_.call(null,x));\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$epn__2 \x3d (function (x,y){\nreturn cljs.core.every_QMARK_(((function (ps__$1){\nreturn (function (p1__10544_SHARP_){\nvar and__4120__auto__ \x3d (p1__10544_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10544_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__10544_SHARP_.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (p1__10544_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10544_SHARP_.cljs$core$IFn$_invoke$arity$1(y) : p1__10544_SHARP_.call(null,y));\n} else {\nreturn and__4120__auto__;\n}\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$epn__3 \x3d (function (x,y,z){\nreturn cljs.core.every_QMARK_(((function (ps__$1){\nreturn (function (p1__10545_SHARP_){\nvar and__4120__auto__ \x3d (p1__10545_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10545_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__10545_SHARP_.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 \x3d (p1__10545_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10545_SHARP_.cljs$core$IFn$_invoke$arity$1(y) : p1__10545_SHARP_.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (p1__10545_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10545_SHARP_.cljs$core$IFn$_invoke$arity$1(z) : p1__10545_SHARP_.call(null,z));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$epn__4 \x3d (function() { \nvar G__10572__delegate \x3d function (x,y,z,args){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ \x3d cljs$core$epn.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.every_QMARK_(((function (and__4120__auto__,ps__$1){\nreturn (function (p1__10546_SHARP_){\nreturn cljs.core.every_QMARK_(p1__10546_SHARP_,args);\n});})(and__4120__auto__,ps__$1))\n,ps__$1);\n} else {\nreturn and__4120__auto__;\n}\n})());\n};\nvar G__10572 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10573__i \x3d 0, G__10573__a \x3d new Array(arguments.length -  3);\nwhile (G__10573__i \x3c G__10573__a.length) {G__10573__a[G__10573__i] \x3d arguments[G__10573__i + 3]; ++G__10573__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10573__a,0,null);\n} \nreturn G__10572__delegate.call(this,x,y,z,args);};\nG__10572.cljs$lang$maxFixedArity \x3d 3;\nG__10572.cljs$lang$applyTo \x3d (function (arglist__10574){\nvar x \x3d cljs.core.first(arglist__10574);\narglist__10574 \x3d cljs.core.next(arglist__10574);\nvar y \x3d cljs.core.first(arglist__10574);\narglist__10574 \x3d cljs.core.next(arglist__10574);\nvar z \x3d cljs.core.first(arglist__10574);\nvar args \x3d cljs.core.rest(arglist__10574);\nreturn G__10572__delegate(x,y,z,args);\n});\nG__10572.cljs$core$IFn$_invoke$arity$variadic \x3d G__10572__delegate;\nreturn G__10572;\n})()\n;\ncljs$core$epn \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$epn__0.call(this);\ncase 1:\nreturn cljs$core$epn__1.call(this,x);\ncase 2:\nreturn cljs$core$epn__2.call(this,x,y);\ncase 3:\nreturn cljs$core$epn__3.call(this,x,y,z);\ndefault:\nvar G__10575 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10576__i \x3d 0, G__10576__a \x3d new Array(arguments.length -  3);\nwhile (G__10576__i \x3c G__10576__a.length) {G__10576__a[G__10576__i] \x3d arguments[G__10576__i + 3]; ++G__10576__i;}\nG__10575 \x3d new cljs.core.IndexedSeq(G__10576__a,0,null);\n}\nreturn cljs$core$epn__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10575);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\ncljs$core$epn.cljs$lang$maxFixedArity \x3d 3;\ncljs$core$epn.cljs$lang$applyTo \x3d cljs$core$epn__4.cljs$lang$applyTo;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$0 \x3d cljs$core$epn__0;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$1 \x3d cljs$core$epn__1;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$2 \x3d cljs$core$epn__2;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$3 \x3d cljs$core$epn__3;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$variadic \x3d cljs$core$epn__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$epn;\n})()\n;})(ps__$1))\n});\n\n/** @this {Function} */\ncljs.core.every_pred.cljs$lang$applyTo \x3d (function (seq10548){\nvar G__10549 \x3d cljs.core.first(seq10548);\nvar seq10548__$1 \x3d cljs.core.next(seq10548);\nvar G__10550 \x3d cljs.core.first(seq10548__$1);\nvar seq10548__$2 \x3d cljs.core.next(seq10548__$1);\nvar G__10551 \x3d cljs.core.first(seq10548__$2);\nvar seq10548__$3 \x3d cljs.core.next(seq10548__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10549,G__10550,G__10551,seq10548__$3);\n});\n\ncljs.core.every_pred.cljs$lang$maxFixedArity \x3d (3);\n\n/**\n * Takes a set of predicates and returns a function f that returns the first logical true value\n *   returned by one of its composing predicates against any of its arguments, else it returns\n *   logical false. Note that f is short-circuiting in that it will stop execution on the first\n *   argument that triggers a logical true result against the original predicates.\n */\ncljs.core.some_fn \x3d (function cljs$core$some_fn(var_args){\nvar G__10588 \x3d arguments.length;\nswitch (G__10588) {\ncase 1:\nreturn cljs.core.some_fn.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.some_fn.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.some_fn.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10590 \x3d arguments.length;\nvar i__4731__auto___10591 \x3d (0);\nwhile(true){\nif((i__4731__auto___10591 \x3c len__4730__auto___10590)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10591]));\n\nvar G__10592 \x3d (i__4731__auto___10591 + (1));\ni__4731__auto___10591 \x3d G__10592;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.some_fn.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.some_fn.cljs$core$IFn$_invoke$arity$1 \x3d (function (p){\nreturn (function() {\nvar cljs$core$sp1 \x3d null;\nvar cljs$core$sp1__0 \x3d (function (){\nreturn null;\n});\nvar cljs$core$sp1__1 \x3d (function (x){\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\n});\nvar cljs$core$sp1__2 \x3d (function (x,y){\nvar or__4131__auto__ \x3d (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(y) : p.call(null,y));\n}\n});\nvar cljs$core$sp1__3 \x3d (function (x,y,z){\nvar or__4131__auto__ \x3d (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(y) : p.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(z) : p.call(null,z));\n}\n}\n});\nvar cljs$core$sp1__4 \x3d (function() { \nvar G__10593__delegate \x3d function (x,y,z,args){\nvar or__4131__auto__ \x3d cljs$core$sp1.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.some(p,args);\n}\n};\nvar G__10593 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10594__i \x3d 0, G__10594__a \x3d new Array(arguments.length -  3);\nwhile (G__10594__i \x3c G__10594__a.length) {G__10594__a[G__10594__i] \x3d arguments[G__10594__i + 3]; ++G__10594__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10594__a,0,null);\n} \nreturn G__10593__delegate.call(this,x,y,z,args);};\nG__10593.cljs$lang$maxFixedArity \x3d 3;\nG__10593.cljs$lang$applyTo \x3d (function (arglist__10595){\nvar x \x3d cljs.core.first(arglist__10595);\narglist__10595 \x3d cljs.core.next(arglist__10595);\nvar y \x3d cljs.core.first(arglist__10595);\narglist__10595 \x3d cljs.core.next(arglist__10595);\nvar z \x3d cljs.core.first(arglist__10595);\nvar args \x3d cljs.core.rest(arglist__10595);\nreturn G__10593__delegate(x,y,z,args);\n});\nG__10593.cljs$core$IFn$_invoke$arity$variadic \x3d G__10593__delegate;\nreturn G__10593;\n})()\n;\ncljs$core$sp1 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$sp1__0.call(this);\ncase 1:\nreturn cljs$core$sp1__1.call(this,x);\ncase 2:\nreturn cljs$core$sp1__2.call(this,x,y);\ncase 3:\nreturn cljs$core$sp1__3.call(this,x,y,z);\ndefault:\nvar G__10596 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10597__i \x3d 0, G__10597__a \x3d new Array(arguments.length -  3);\nwhile (G__10597__i \x3c G__10597__a.length) {G__10597__a[G__10597__i] \x3d arguments[G__10597__i + 3]; ++G__10597__i;}\nG__10596 \x3d new cljs.core.IndexedSeq(G__10597__a,0,null);\n}\nreturn cljs$core$sp1__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10596);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\ncljs$core$sp1.cljs$lang$maxFixedArity \x3d 3;\ncljs$core$sp1.cljs$lang$applyTo \x3d cljs$core$sp1__4.cljs$lang$applyTo;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$0 \x3d cljs$core$sp1__0;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$1 \x3d cljs$core$sp1__1;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$2 \x3d cljs$core$sp1__2;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$3 \x3d cljs$core$sp1__3;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$variadic \x3d cljs$core$sp1__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$sp1;\n})()\n});\n\ncljs.core.some_fn.cljs$core$IFn$_invoke$arity$2 \x3d (function (p1,p2){\nreturn (function() {\nvar cljs$core$sp2 \x3d null;\nvar cljs$core$sp2__0 \x3d (function (){\nreturn null;\n});\nvar cljs$core$sp2__1 \x3d (function (x){\nvar or__4131__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\n}\n});\nvar cljs$core$sp2__2 \x3d (function (x,y){\nvar or__4131__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\n}\n}\n}\n});\nvar cljs$core$sp2__3 \x3d (function (x,y,z){\nvar or__4131__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(z) : p1.call(null,z));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nvar or__4131__auto____$3 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$3)){\nreturn or__4131__auto____$3;\n} else {\nvar or__4131__auto____$4 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$4)){\nreturn or__4131__auto____$4;\n} else {\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(z) : p2.call(null,z));\n}\n}\n}\n}\n}\n});\nvar cljs$core$sp2__4 \x3d (function() { \nvar G__10598__delegate \x3d function (x,y,z,args){\nvar or__4131__auto__ \x3d cljs$core$sp2.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.some(((function (or__4131__auto__){\nreturn (function (p1__10577_SHARP_){\nvar or__4131__auto____$1 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(p1__10577_SHARP_) : p1.call(null,p1__10577_SHARP_));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(p1__10577_SHARP_) : p2.call(null,p1__10577_SHARP_));\n}\n});})(or__4131__auto__))\n,args);\n}\n};\nvar G__10598 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10599__i \x3d 0, G__10599__a \x3d new Array(arguments.length -  3);\nwhile (G__10599__i \x3c G__10599__a.length) {G__10599__a[G__10599__i] \x3d arguments[G__10599__i + 3]; ++G__10599__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10599__a,0,null);\n} \nreturn G__10598__delegate.call(this,x,y,z,args);};\nG__10598.cljs$lang$maxFixedArity \x3d 3;\nG__10598.cljs$lang$applyTo \x3d (function (arglist__10600){\nvar x \x3d cljs.core.first(arglist__10600);\narglist__10600 \x3d cljs.core.next(arglist__10600);\nvar y \x3d cljs.core.first(arglist__10600);\narglist__10600 \x3d cljs.core.next(arglist__10600);\nvar z \x3d cljs.core.first(arglist__10600);\nvar args \x3d cljs.core.rest(arglist__10600);\nreturn G__10598__delegate(x,y,z,args);\n});\nG__10598.cljs$core$IFn$_invoke$arity$variadic \x3d G__10598__delegate;\nreturn G__10598;\n})()\n;\ncljs$core$sp2 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$sp2__0.call(this);\ncase 1:\nreturn cljs$core$sp2__1.call(this,x);\ncase 2:\nreturn cljs$core$sp2__2.call(this,x,y);\ncase 3:\nreturn cljs$core$sp2__3.call(this,x,y,z);\ndefault:\nvar G__10601 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10602__i \x3d 0, G__10602__a \x3d new Array(arguments.length -  3);\nwhile (G__10602__i \x3c G__10602__a.length) {G__10602__a[G__10602__i] \x3d arguments[G__10602__i + 3]; ++G__10602__i;}\nG__10601 \x3d new cljs.core.IndexedSeq(G__10602__a,0,null);\n}\nreturn cljs$core$sp2__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10601);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\ncljs$core$sp2.cljs$lang$maxFixedArity \x3d 3;\ncljs$core$sp2.cljs$lang$applyTo \x3d cljs$core$sp2__4.cljs$lang$applyTo;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$0 \x3d cljs$core$sp2__0;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$1 \x3d cljs$core$sp2__1;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$2 \x3d cljs$core$sp2__2;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$3 \x3d cljs$core$sp2__3;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$variadic \x3d cljs$core$sp2__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$sp2;\n})()\n});\n\ncljs.core.some_fn.cljs$core$IFn$_invoke$arity$3 \x3d (function (p1,p2,p3){\nreturn (function() {\nvar cljs$core$sp3 \x3d null;\nvar cljs$core$sp3__0 \x3d (function (){\nreturn null;\n});\nvar cljs$core$sp3__1 \x3d (function (x){\nvar or__4131__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\n}\n}\n});\nvar cljs$core$sp3__2 \x3d (function (x,y){\nvar or__4131__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 \x3d (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nvar or__4131__auto____$3 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$3)){\nreturn or__4131__auto____$3;\n} else {\nvar or__4131__auto____$4 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$4)){\nreturn or__4131__auto____$4;\n} else {\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(y) : p3.call(null,y));\n}\n}\n}\n}\n}\n});\nvar cljs$core$sp3__3 \x3d (function (x,y,z){\nvar or__4131__auto__ \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 \x3d (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nvar or__4131__auto____$3 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$3)){\nreturn or__4131__auto____$3;\n} else {\nvar or__4131__auto____$4 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$4)){\nreturn or__4131__auto____$4;\n} else {\nvar or__4131__auto____$5 \x3d (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(y) : p3.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$5)){\nreturn or__4131__auto____$5;\n} else {\nvar or__4131__auto____$6 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(z) : p1.call(null,z));\nif(cljs.core.truth_(or__4131__auto____$6)){\nreturn or__4131__auto____$6;\n} else {\nvar or__4131__auto____$7 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(z) : p2.call(null,z));\nif(cljs.core.truth_(or__4131__auto____$7)){\nreturn or__4131__auto____$7;\n} else {\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(z) : p3.call(null,z));\n}\n}\n}\n}\n}\n}\n}\n}\n});\nvar cljs$core$sp3__4 \x3d (function() { \nvar G__10603__delegate \x3d function (x,y,z,args){\nvar or__4131__auto__ \x3d cljs$core$sp3.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.some(((function (or__4131__auto__){\nreturn (function (p1__10578_SHARP_){\nvar or__4131__auto____$1 \x3d (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(p1__10578_SHARP_) : p1.call(null,p1__10578_SHARP_));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 \x3d (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(p1__10578_SHARP_) : p2.call(null,p1__10578_SHARP_));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(p1__10578_SHARP_) : p3.call(null,p1__10578_SHARP_));\n}\n}\n});})(or__4131__auto__))\n,args);\n}\n};\nvar G__10603 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10604__i \x3d 0, G__10604__a \x3d new Array(arguments.length -  3);\nwhile (G__10604__i \x3c G__10604__a.length) {G__10604__a[G__10604__i] \x3d arguments[G__10604__i + 3]; ++G__10604__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10604__a,0,null);\n} \nreturn G__10603__delegate.call(this,x,y,z,args);};\nG__10603.cljs$lang$maxFixedArity \x3d 3;\nG__10603.cljs$lang$applyTo \x3d (function (arglist__10605){\nvar x \x3d cljs.core.first(arglist__10605);\narglist__10605 \x3d cljs.core.next(arglist__10605);\nvar y \x3d cljs.core.first(arglist__10605);\narglist__10605 \x3d cljs.core.next(arglist__10605);\nvar z \x3d cljs.core.first(arglist__10605);\nvar args \x3d cljs.core.rest(arglist__10605);\nreturn G__10603__delegate(x,y,z,args);\n});\nG__10603.cljs$core$IFn$_invoke$arity$variadic \x3d G__10603__delegate;\nreturn G__10603;\n})()\n;\ncljs$core$sp3 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$sp3__0.call(this);\ncase 1:\nreturn cljs$core$sp3__1.call(this,x);\ncase 2:\nreturn cljs$core$sp3__2.call(this,x,y);\ncase 3:\nreturn cljs$core$sp3__3.call(this,x,y,z);\ndefault:\nvar G__10606 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10607__i \x3d 0, G__10607__a \x3d new Array(arguments.length -  3);\nwhile (G__10607__i \x3c G__10607__a.length) {G__10607__a[G__10607__i] \x3d arguments[G__10607__i + 3]; ++G__10607__i;}\nG__10606 \x3d new cljs.core.IndexedSeq(G__10607__a,0,null);\n}\nreturn cljs$core$sp3__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10606);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\ncljs$core$sp3.cljs$lang$maxFixedArity \x3d 3;\ncljs$core$sp3.cljs$lang$applyTo \x3d cljs$core$sp3__4.cljs$lang$applyTo;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$0 \x3d cljs$core$sp3__0;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$1 \x3d cljs$core$sp3__1;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$2 \x3d cljs$core$sp3__2;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$3 \x3d cljs$core$sp3__3;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$variadic \x3d cljs$core$sp3__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$sp3;\n})()\n});\n\ncljs.core.some_fn.cljs$core$IFn$_invoke$arity$variadic \x3d (function (p1,p2,p3,ps){\nvar ps__$1 \x3d cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(p1,p2,p3,ps);\nreturn ((function (ps__$1){\nreturn (function() {\nvar cljs$core$spn \x3d null;\nvar cljs$core$spn__0 \x3d (function (){\nreturn null;\n});\nvar cljs$core$spn__1 \x3d (function (x){\nreturn cljs.core.some(((function (ps__$1){\nreturn (function (p1__10579_SHARP_){\nreturn (p1__10579_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10579_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__10579_SHARP_.call(null,x));\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$spn__2 \x3d (function (x,y){\nreturn cljs.core.some(((function (ps__$1){\nreturn (function (p1__10580_SHARP_){\nvar or__4131__auto__ \x3d (p1__10580_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10580_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__10580_SHARP_.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (p1__10580_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10580_SHARP_.cljs$core$IFn$_invoke$arity$1(y) : p1__10580_SHARP_.call(null,y));\n}\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$spn__3 \x3d (function (x,y,z){\nreturn cljs.core.some(((function (ps__$1){\nreturn (function (p1__10581_SHARP_){\nvar or__4131__auto__ \x3d (p1__10581_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10581_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__10581_SHARP_.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (p1__10581_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10581_SHARP_.cljs$core$IFn$_invoke$arity$1(y) : p1__10581_SHARP_.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (p1__10581_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__10581_SHARP_.cljs$core$IFn$_invoke$arity$1(z) : p1__10581_SHARP_.call(null,z));\n}\n}\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$spn__4 \x3d (function() { \nvar G__10608__delegate \x3d function (x,y,z,args){\nvar or__4131__auto__ \x3d cljs$core$spn.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.some(((function (or__4131__auto__,ps__$1){\nreturn (function (p1__10582_SHARP_){\nreturn cljs.core.some(p1__10582_SHARP_,args);\n});})(or__4131__auto__,ps__$1))\n,ps__$1);\n}\n};\nvar G__10608 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10609__i \x3d 0, G__10609__a \x3d new Array(arguments.length -  3);\nwhile (G__10609__i \x3c G__10609__a.length) {G__10609__a[G__10609__i] \x3d arguments[G__10609__i + 3]; ++G__10609__i;}\n  args \x3d new cljs.core.IndexedSeq(G__10609__a,0,null);\n} \nreturn G__10608__delegate.call(this,x,y,z,args);};\nG__10608.cljs$lang$maxFixedArity \x3d 3;\nG__10608.cljs$lang$applyTo \x3d (function (arglist__10610){\nvar x \x3d cljs.core.first(arglist__10610);\narglist__10610 \x3d cljs.core.next(arglist__10610);\nvar y \x3d cljs.core.first(arglist__10610);\narglist__10610 \x3d cljs.core.next(arglist__10610);\nvar z \x3d cljs.core.first(arglist__10610);\nvar args \x3d cljs.core.rest(arglist__10610);\nreturn G__10608__delegate(x,y,z,args);\n});\nG__10608.cljs$core$IFn$_invoke$arity$variadic \x3d G__10608__delegate;\nreturn G__10608;\n})()\n;\ncljs$core$spn \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$spn__0.call(this);\ncase 1:\nreturn cljs$core$spn__1.call(this,x);\ncase 2:\nreturn cljs$core$spn__2.call(this,x,y);\ncase 3:\nreturn cljs$core$spn__3.call(this,x,y,z);\ndefault:\nvar G__10611 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__10612__i \x3d 0, G__10612__a \x3d new Array(arguments.length -  3);\nwhile (G__10612__i \x3c G__10612__a.length) {G__10612__a[G__10612__i] \x3d arguments[G__10612__i + 3]; ++G__10612__i;}\nG__10611 \x3d new cljs.core.IndexedSeq(G__10612__a,0,null);\n}\nreturn cljs$core$spn__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__10611);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\ncljs$core$spn.cljs$lang$maxFixedArity \x3d 3;\ncljs$core$spn.cljs$lang$applyTo \x3d cljs$core$spn__4.cljs$lang$applyTo;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$0 \x3d cljs$core$spn__0;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$1 \x3d cljs$core$spn__1;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$2 \x3d cljs$core$spn__2;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$3 \x3d cljs$core$spn__3;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$variadic \x3d cljs$core$spn__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$spn;\n})()\n;})(ps__$1))\n});\n\n/** @this {Function} */\ncljs.core.some_fn.cljs$lang$applyTo \x3d (function (seq10584){\nvar G__10585 \x3d cljs.core.first(seq10584);\nvar seq10584__$1 \x3d cljs.core.next(seq10584);\nvar G__10586 \x3d cljs.core.first(seq10584__$1);\nvar seq10584__$2 \x3d cljs.core.next(seq10584__$1);\nvar G__10587 \x3d cljs.core.first(seq10584__$2);\nvar seq10584__$3 \x3d cljs.core.next(seq10584__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10585,G__10586,G__10587,seq10584__$3);\n});\n\ncljs.core.some_fn.cljs$lang$maxFixedArity \x3d (3);\n\n/**\n * Returns a lazy sequence consisting of the result of applying f to\n *   the set of first items of each coll, followed by applying f to the\n *   set of second items in each coll, until any one of the colls is\n *   exhausted.  Any remaining items in other colls are ignored. Function\n *   f should accept number-of-colls arguments. Returns a transducer when\n *   no collection is provided.\n */\ncljs.core.map \x3d (function cljs$core$map(var_args){\nvar G__10620 \x3d arguments.length;\nswitch (G__10620) {\ncase 1:\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10633 \x3d arguments.length;\nvar i__4731__auto___10634 \x3d (0);\nwhile(true){\nif((i__4731__auto___10634 \x3c len__4730__auto___10633)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10634]));\n\nvar G__10635 \x3d (i__4731__auto___10634 + (1));\ni__4731__auto___10634 \x3d G__10635;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn (function (rf){\nreturn (function() {\nvar G__10636 \x3d null;\nvar G__10636__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__10636__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__10636__2 \x3d (function (result,input){\nvar G__10621 \x3d result;\nvar G__10622 \x3d (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(input) : f.call(null,input));\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(G__10621,G__10622) : rf.call(null,G__10621,G__10622));\n});\nvar G__10636__3 \x3d (function() { \nvar G__10637__delegate \x3d function (result,input,inputs){\nvar G__10623 \x3d result;\nvar G__10624 \x3d cljs.core.apply.cljs$core$IFn$_invoke$arity$3(f,input,inputs);\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(G__10623,G__10624) : rf.call(null,G__10623,G__10624));\n};\nvar G__10637 \x3d function (result,input,var_args){\nvar inputs \x3d null;\nif (arguments.length \x3e 2) {\nvar G__10638__i \x3d 0, G__10638__a \x3d new Array(arguments.length -  2);\nwhile (G__10638__i \x3c G__10638__a.length) {G__10638__a[G__10638__i] \x3d arguments[G__10638__i + 2]; ++G__10638__i;}\n  inputs \x3d new cljs.core.IndexedSeq(G__10638__a,0,null);\n} \nreturn G__10637__delegate.call(this,result,input,inputs);};\nG__10637.cljs$lang$maxFixedArity \x3d 2;\nG__10637.cljs$lang$applyTo \x3d (function (arglist__10639){\nvar result \x3d cljs.core.first(arglist__10639);\narglist__10639 \x3d cljs.core.next(arglist__10639);\nvar input \x3d cljs.core.first(arglist__10639);\nvar inputs \x3d cljs.core.rest(arglist__10639);\nreturn G__10637__delegate(result,input,inputs);\n});\nG__10637.cljs$core$IFn$_invoke$arity$variadic \x3d G__10637__delegate;\nreturn G__10637;\n})()\n;\nG__10636 \x3d function(result,input,var_args){\nvar inputs \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__10636__0.call(this);\ncase 1:\nreturn G__10636__1.call(this,result);\ncase 2:\nreturn G__10636__2.call(this,result,input);\ndefault:\nvar G__10640 \x3d null;\nif (arguments.length \x3e 2) {\nvar G__10641__i \x3d 0, G__10641__a \x3d new Array(arguments.length -  2);\nwhile (G__10641__i \x3c G__10641__a.length) {G__10641__a[G__10641__i] \x3d arguments[G__10641__i + 2]; ++G__10641__i;}\nG__10640 \x3d new cljs.core.IndexedSeq(G__10641__a,0,null);\n}\nreturn G__10636__3.cljs$core$IFn$_invoke$arity$variadic(result,input, G__10640);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10636.cljs$lang$maxFixedArity \x3d 2;\nG__10636.cljs$lang$applyTo \x3d G__10636__3.cljs$lang$applyTo;\nG__10636.cljs$core$IFn$_invoke$arity$0 \x3d G__10636__0;\nG__10636.cljs$core$IFn$_invoke$arity$1 \x3d G__10636__1;\nG__10636.cljs$core$IFn$_invoke$arity$2 \x3d G__10636__2;\nG__10636.cljs$core$IFn$_invoke$arity$variadic \x3d G__10636__3.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__10636;\n})()\n});\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c \x3d cljs.core.chunk_first(s);\nvar size \x3d cljs.core.count(c);\nvar b \x3d cljs.core.chunk_buffer(size);\nvar n__4607__auto___10642 \x3d size;\nvar i_10643 \x3d (0);\nwhile(true){\nif((i_10643 \x3c n__4607__auto___10642)){\ncljs.core.chunk_append(b,(function (){var G__10625 \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_10643);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10625) : f.call(null,G__10625));\n})());\n\nvar G__10644 \x3d (i_10643 + (1));\ni_10643 \x3d G__10644;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,cljs.core.chunk_rest(s)));\n} else {\nreturn cljs.core.cons((function (){var G__10626 \x3d cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10626) : f.call(null,G__10626));\n})(),cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,cljs.core.rest(s)));\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,c1,c2){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s1 \x3d cljs.core.seq(c1);\nvar s2 \x3d cljs.core.seq(c2);\nif(((s1) \x26\x26 (s2))){\nreturn cljs.core.cons((function (){var G__10627 \x3d cljs.core.first(s1);\nvar G__10628 \x3d cljs.core.first(s2);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10627,G__10628) : f.call(null,G__10627,G__10628));\n})(),cljs.core.map.cljs$core$IFn$_invoke$arity$3(f,cljs.core.rest(s1),cljs.core.rest(s2)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$4 \x3d (function (f,c1,c2,c3){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s1 \x3d cljs.core.seq(c1);\nvar s2 \x3d cljs.core.seq(c2);\nvar s3 \x3d cljs.core.seq(c3);\nif(((s1) \x26\x26 (s2) \x26\x26 (s3))){\nreturn cljs.core.cons((function (){var G__10629 \x3d cljs.core.first(s1);\nvar G__10630 \x3d cljs.core.first(s2);\nvar G__10631 \x3d cljs.core.first(s3);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10629,G__10630,G__10631) : f.call(null,G__10629,G__10630,G__10631));\n})(),cljs.core.map.cljs$core$IFn$_invoke$arity$4(f,cljs.core.rest(s1),cljs.core.rest(s2),cljs.core.rest(s3)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,c1,c2,c3,colls){\nvar step \x3d (function cljs$core$step(cs){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar ss \x3d cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.seq,cs);\nif(cljs.core.every_QMARK_(cljs.core.identity,ss)){\nreturn cljs.core.cons(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,ss),cljs$core$step(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.rest,ss)));\n} else {\nreturn null;\n}\n}),null,null));\n});\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (step){\nreturn (function (p1__10613_SHARP_){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(f,p1__10613_SHARP_);\n});})(step))\n,step(cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic(colls,c3,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([c2,c1], 0))));\n});\n\n/** @this {Function} */\ncljs.core.map.cljs$lang$applyTo \x3d (function (seq10615){\nvar G__10616 \x3d cljs.core.first(seq10615);\nvar seq10615__$1 \x3d cljs.core.next(seq10615);\nvar G__10617 \x3d cljs.core.first(seq10615__$1);\nvar seq10615__$2 \x3d cljs.core.next(seq10615__$1);\nvar G__10618 \x3d cljs.core.first(seq10615__$2);\nvar seq10615__$3 \x3d cljs.core.next(seq10615__$2);\nvar G__10619 \x3d cljs.core.first(seq10615__$3);\nvar seq10615__$4 \x3d cljs.core.next(seq10615__$3);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10616,G__10617,G__10618,G__10619,seq10615__$4);\n});\n\ncljs.core.map.cljs$lang$maxFixedArity \x3d (4);\n\n/**\n * Returns a lazy sequence of the first n items in coll, or all items if\n *   there are fewer than n.  Returns a stateful transducer when\n *   no collection is provided.\n */\ncljs.core.take \x3d (function cljs$core$take(var_args){\nvar G__10646 \x3d arguments.length;\nswitch (G__10646) {\ncase 1:\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.take.cljs$core$IFn$_invoke$arity$1 \x3d (function (n){\nif(typeof n \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? n)"));\n}\n\nreturn (function (rf){\nvar na \x3d cljs.core.volatile_BANG_(n);\nreturn ((function (na){\nreturn (function() {\nvar G__10648 \x3d null;\nvar G__10648__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__10648__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__10648__2 \x3d (function (result,input){\nvar n__$1 \x3d cljs.core.deref(na);\nvar nn \x3d na.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(na.cljs$core$IDeref$_deref$arity$1(null) - (1)));\nvar result__$1 \x3d (((n__$1 \x3e (0)))?(rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input)):result);\nif((!((nn \x3e (0))))){\nreturn cljs.core.ensure_reduced(result__$1);\n} else {\nreturn result__$1;\n}\n});\nG__10648 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__10648__0.call(this);\ncase 1:\nreturn G__10648__1.call(this,result);\ncase 2:\nreturn G__10648__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10648.cljs$core$IFn$_invoke$arity$0 \x3d G__10648__0;\nG__10648.cljs$core$IFn$_invoke$arity$1 \x3d G__10648__1;\nG__10648.cljs$core$IFn$_invoke$arity$2 \x3d G__10648__2;\nreturn G__10648;\n})()\n;})(na))\n});\n});\n\ncljs.core.take.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,coll){\nif(typeof n \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? n)"));\n}\n\nreturn (new cljs.core.LazySeq(null,(function (){\nif((n \x3e (0))){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nreturn cljs.core.cons(cljs.core.first(s),cljs.core.take.cljs$core$IFn$_invoke$arity$2((n - (1)),cljs.core.rest(s)));\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.take.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a lazy sequence of all but the first n items in coll.\n *   Returns a stateful transducer when no collection is provided.\n */\ncljs.core.drop \x3d (function cljs$core$drop(var_args){\nvar G__10650 \x3d arguments.length;\nswitch (G__10650) {\ncase 1:\nreturn cljs.core.drop.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.drop.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.drop.cljs$core$IFn$_invoke$arity$1 \x3d (function (n){\nif(typeof n \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? n)"));\n}\n\nreturn (function (rf){\nvar na \x3d cljs.core.volatile_BANG_(n);\nreturn ((function (na){\nreturn (function() {\nvar G__10652 \x3d null;\nvar G__10652__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__10652__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__10652__2 \x3d (function (result,input){\nvar n__$1 \x3d cljs.core.deref(na);\nna.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(na.cljs$core$IDeref$_deref$arity$1(null) - (1)));\n\nif((n__$1 \x3e (0))){\nreturn result;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__10652 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__10652__0.call(this);\ncase 1:\nreturn G__10652__1.call(this,result);\ncase 2:\nreturn G__10652__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10652.cljs$core$IFn$_invoke$arity$0 \x3d G__10652__0;\nG__10652.cljs$core$IFn$_invoke$arity$1 \x3d G__10652__1;\nG__10652.cljs$core$IFn$_invoke$arity$2 \x3d G__10652__2;\nreturn G__10652;\n})()\n;})(na))\n});\n});\n\ncljs.core.drop.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,coll){\nif(typeof n \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? n)"));\n}\n\nvar step \x3d (function (n__$1,coll__$1){\nwhile(true){\nvar s \x3d cljs.core.seq(coll__$1);\nif((((n__$1 \x3e (0))) \x26\x26 (s))){\nvar G__10653 \x3d (n__$1 - (1));\nvar G__10654 \x3d cljs.core.rest(s);\nn__$1 \x3d G__10653;\ncoll__$1 \x3d G__10654;\ncontinue;\n} else {\nreturn s;\n}\nbreak;\n}\n});\nreturn (new cljs.core.LazySeq(null,((function (step){\nreturn (function (){\nreturn step(n,coll);\n});})(step))\n,null,null));\n});\n\ncljs.core.drop.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Return a lazy sequence of all but the last n (default 1) items in coll\n */\ncljs.core.drop_last \x3d (function cljs$core$drop_last(var_args){\nvar G__10656 \x3d arguments.length;\nswitch (G__10656) {\ncase 1:\nreturn cljs.core.drop_last.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.drop_last.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.drop_last.cljs$core$IFn$_invoke$arity$1 \x3d (function (s){\nreturn cljs.core.drop_last.cljs$core$IFn$_invoke$arity$2((1),s);\n});\n\ncljs.core.drop_last.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,s){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$3((function (x,_){\nreturn x;\n}),s,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(n,s));\n});\n\ncljs.core.drop_last.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a seq of the last n items in coll.  Depending on the type\n *   of coll may be no better than linear time.  For vectors, see also subvec.\n */\ncljs.core.take_last \x3d (function cljs$core$take_last(n,coll){\nvar s \x3d cljs.core.seq(coll);\nvar lead \x3d cljs.core.seq(cljs.core.drop.cljs$core$IFn$_invoke$arity$2(n,coll));\nwhile(true){\nif(lead){\nvar G__10658 \x3d cljs.core.next(s);\nvar G__10659 \x3d cljs.core.next(lead);\ns \x3d G__10658;\nlead \x3d G__10659;\ncontinue;\n} else {\nreturn s;\n}\nbreak;\n}\n});\n/**\n * Returns a lazy sequence of the items in coll starting from the\n *   first item for which (pred item) returns logical false.  Returns a\n *   stateful transducer when no collection is provided.\n */\ncljs.core.drop_while \x3d (function cljs$core$drop_while(var_args){\nvar G__10661 \x3d arguments.length;\nswitch (G__10661) {\ncase 1:\nreturn cljs.core.drop_while.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.drop_while.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.drop_while.cljs$core$IFn$_invoke$arity$1 \x3d (function (pred){\nreturn (function (rf){\nvar da \x3d cljs.core.volatile_BANG_(true);\nreturn ((function (da){\nreturn (function() {\nvar G__10665 \x3d null;\nvar G__10665__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__10665__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__10665__2 \x3d (function (result,input){\nvar drop_QMARK_ \x3d cljs.core.deref(da);\nif(cljs.core.truth_((function (){var and__4120__auto__ \x3d drop_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(input) : pred.call(null,input));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn result;\n} else {\ncljs.core.vreset_BANG_(da,null);\n\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__10665 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__10665__0.call(this);\ncase 1:\nreturn G__10665__1.call(this,result);\ncase 2:\nreturn G__10665__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10665.cljs$core$IFn$_invoke$arity$0 \x3d G__10665__0;\nG__10665.cljs$core$IFn$_invoke$arity$1 \x3d G__10665__1;\nG__10665.cljs$core$IFn$_invoke$arity$2 \x3d G__10665__2;\nreturn G__10665;\n})()\n;})(da))\n});\n});\n\ncljs.core.drop_while.cljs$core$IFn$_invoke$arity$2 \x3d (function (pred,coll){\nvar step \x3d (function (pred__$1,coll__$1){\nwhile(true){\nvar s \x3d cljs.core.seq(coll__$1);\nif(cljs.core.truth_((function (){var and__4120__auto__ \x3d s;\nif(and__4120__auto__){\nvar G__10663 \x3d cljs.core.first(s);\nreturn (pred__$1.cljs$core$IFn$_invoke$arity$1 ? pred__$1.cljs$core$IFn$_invoke$arity$1(G__10663) : pred__$1.call(null,G__10663));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar G__10666 \x3d pred__$1;\nvar G__10667 \x3d cljs.core.rest(s);\npred__$1 \x3d G__10666;\ncoll__$1 \x3d G__10667;\ncontinue;\n} else {\nreturn s;\n}\nbreak;\n}\n});\nreturn (new cljs.core.LazySeq(null,((function (step){\nreturn (function (){\nreturn step(pred,coll);\n});})(step))\n,null,null));\n});\n\ncljs.core.drop_while.cljs$lang$maxFixedArity \x3d 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Cycle \x3d (function (meta,all,prev,current,_next){\nthis.meta \x3d meta;\nthis.all \x3d all;\nthis.prev \x3d prev;\nthis.current \x3d current;\nthis._next \x3d _next;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 26083532;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 1;\n});\ncljs.core.Cycle.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Cycle.prototype.currentval \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nif(self__.current){\n} else {\nvar temp__5718__auto___10674 \x3d cljs.core.next(self__.prev);\nif(temp__5718__auto___10674){\nvar c_10675 \x3d temp__5718__auto___10674;\nself__.current \x3d c_10675;\n} else {\nself__.current \x3d self__.all;\n}\n}\n\nreturn self__.current;\n});\n\ncljs.core.Cycle.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.Cycle.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ISeq$_rest$arity$1(null);\n});\n\ncljs.core.Cycle.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Cycle.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (!((self__.current \x3d\x3d null)));\n});\n\ncljs.core.Cycle.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar s \x3d coll__$1.currentval();\nvar ret \x3d cljs.core.first(s);\nwhile(true){\nvar s__$1 \x3d (function (){var or__4131__auto__ \x3d cljs.core.next(s);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn self__.all;\n}\n})();\nvar ret__$1 \x3d (function (){var G__10670 \x3d ret;\nvar G__10671 \x3d cljs.core.first(s__$1);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10670,G__10671) : f.call(null,G__10670,G__10671));\n})();\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__10676 \x3d s__$1;\nvar G__10677 \x3d ret__$1;\ns \x3d G__10676;\nret \x3d G__10677;\ncontinue;\n}\nbreak;\n}\n});\n\ncljs.core.Cycle.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar s \x3d coll__$1.currentval();\nvar ret \x3d start;\nwhile(true){\nvar ret__$1 \x3d (function (){var G__10672 \x3d ret;\nvar G__10673 \x3d cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10672,G__10673) : f.call(null,G__10672,G__10673));\n})();\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__10678 \x3d (function (){var or__4131__auto__ \x3d cljs.core.next(s);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn self__.all;\n}\n})();\nvar G__10679 \x3d ret__$1;\ns \x3d G__10678;\nret \x3d G__10679;\ncontinue;\n}\nbreak;\n}\n});\n\ncljs.core.Cycle.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.first(coll__$1.currentval());\n});\n\ncljs.core.Cycle.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__._next \x3d\x3d null)){\nself__._next \x3d (new cljs.core.Cycle(null,self__.all,coll__$1.currentval(),null,null));\n} else {\n}\n\nreturn self__._next;\n});\n\ncljs.core.Cycle.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.Cycle.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.Cycle(new_meta,self__.all,self__.prev,self__.current,self__._next));\n}\n});\n\ncljs.core.Cycle.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.Cycle.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$all,cljs.core.cst$sym$prev,cljs.core.with_meta(cljs.core.cst$sym$current,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$_next,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Cycle.cljs$lang$type \x3d true;\n\ncljs.core.Cycle.cljs$lang$ctorStr \x3d "cljs.core/Cycle";\n\ncljs.core.Cycle.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Cycle");\n});\n\n/**\n * Positional factory function for cljs.core/Cycle.\n */\ncljs.core.__GT_Cycle \x3d (function cljs$core$__GT_Cycle(meta,all,prev,current,_next){\nreturn (new cljs.core.Cycle(meta,all,prev,current,_next));\n});\n\n/**\n * Returns a lazy (infinite!) sequence of repetitions of the items in coll.\n */\ncljs.core.cycle \x3d (function cljs$core$cycle(coll){\nvar temp__5718__auto__ \x3d cljs.core.seq(coll);\nif(temp__5718__auto__){\nvar vals \x3d temp__5718__auto__;\nreturn (new cljs.core.Cycle(null,vals,null,vals,null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n/**\n * Returns a vector of [(take n coll) (drop n coll)]\n */\ncljs.core.split_at \x3d (function cljs$core$split_at(n,coll){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,coll),cljs.core.drop.cljs$core$IFn$_invoke$arity$2(n,coll)], null);\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Repeat \x3d (function (meta,count,val,next,__hash){\nthis.meta \x3d meta;\nthis.count \x3d count;\nthis.val \x3d val;\nthis.next \x3d next;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32374988;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 1;\n});\ncljs.core.Repeat.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Repeat.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Repeat.prototype.indexOf \x3d (function() {\nvar G__10680 \x3d null;\nvar G__10680__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10680__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10680 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10680__1.call(this,x);\ncase 2:\nreturn G__10680__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10680.cljs$core$IFn$_invoke$arity$1 \x3d G__10680__1;\nG__10680.cljs$core$IFn$_invoke$arity$2 \x3d G__10680__2;\nreturn G__10680;\n})()\n;\n\ncljs.core.Repeat.prototype.lastIndexOf \x3d (function() {\nvar G__10681 \x3d null;\nvar G__10681__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,self__.count);\n});\nvar G__10681__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10681 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10681__1.call(this,x);\ncase 2:\nreturn G__10681__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10681.cljs$core$IFn$_invoke$arity$1 \x3d G__10681__1;\nG__10681.cljs$core$IFn$_invoke$arity$2 \x3d G__10681__2;\nreturn G__10681;\n})()\n;\n\ncljs.core.Repeat.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.Repeat.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.next \x3d\x3d null)){\nif((self__.count \x3e (1))){\nself__.next \x3d (new cljs.core.Repeat(null,(self__.count - (1)),self__.val,null,null));\n\nreturn self__.next;\n} else {\nif(((-1) \x3d\x3d\x3d self__.count)){\nreturn coll__$1;\n} else {\nreturn null;\n}\n}\n} else {\nreturn self__.next;\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.Repeat.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Repeat.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn false;\n});\n\ncljs.core.Repeat.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.count \x3d\x3d\x3d (-1))){\nvar ret \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(self__.val,self__.val) : f.call(null,self__.val,self__.val));\nwhile(true){\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.deref(ret);\n} else {\nvar G__10682 \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,self__.val) : f.call(null,ret,self__.val));\nret \x3d G__10682;\ncontinue;\n}\nbreak;\n}\n} else {\nvar i \x3d (1);\nvar ret \x3d self__.val;\nwhile(true){\nif((i \x3c self__.count)){\nvar ret__$1 \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,self__.val) : f.call(null,ret,self__.val));\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__10683 \x3d (i + (1));\nvar G__10684 \x3d ret__$1;\ni \x3d G__10683;\nret \x3d G__10684;\ncontinue;\n}\n} else {\nreturn ret;\n}\nbreak;\n}\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.count \x3d\x3d\x3d (-1))){\nvar ret \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(start,self__.val) : f.call(null,start,self__.val));\nwhile(true){\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.deref(ret);\n} else {\nvar G__10685 \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,self__.val) : f.call(null,ret,self__.val));\nret \x3d G__10685;\ncontinue;\n}\nbreak;\n}\n} else {\nvar i \x3d (0);\nvar ret \x3d start;\nwhile(true){\nif((i \x3c self__.count)){\nvar ret__$1 \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,self__.val) : f.call(null,ret,self__.val));\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__10686 \x3d (i + (1));\nvar G__10687 \x3d ret__$1;\ni \x3d G__10686;\nret \x3d G__10687;\ncontinue;\n}\n} else {\nreturn ret;\n}\nbreak;\n}\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.val;\n});\n\ncljs.core.Repeat.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.next \x3d\x3d null)){\nif((self__.count \x3e (1))){\nself__.next \x3d (new cljs.core.Repeat(null,(self__.count - (1)),self__.val,null,null));\n\nreturn self__.next;\n} else {\nif(((-1) \x3d\x3d\x3d self__.count)){\nreturn coll__$1;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n}\n} else {\nreturn self__.next;\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.Repeat.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.Repeat(new_meta,self__.count,self__.val,self__.next,null));\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.Repeat.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$count,cljs.core.cst$sym$val,cljs.core.with_meta(cljs.core.cst$sym$next,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Repeat.cljs$lang$type \x3d true;\n\ncljs.core.Repeat.cljs$lang$ctorStr \x3d "cljs.core/Repeat";\n\ncljs.core.Repeat.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Repeat");\n});\n\n/**\n * Positional factory function for cljs.core/Repeat.\n */\ncljs.core.__GT_Repeat \x3d (function cljs$core$__GT_Repeat(meta,count,val,next,__hash){\nreturn (new cljs.core.Repeat(meta,count,val,next,__hash));\n});\n\n/**\n * Returns a lazy (infinite!, or length n if supplied) sequence of xs.\n */\ncljs.core.repeat \x3d (function cljs$core$repeat(var_args){\nvar G__10689 \x3d arguments.length;\nswitch (G__10689) {\ncase 1:\nreturn cljs.core.repeat.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.repeat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.repeat.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn (new cljs.core.Repeat(null,(-1),x,null,null));\n});\n\ncljs.core.repeat.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,x){\nif((n \x3e (0))){\nreturn (new cljs.core.Repeat(null,n,x,null,null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.repeat.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * DEPRECATED: Use \'repeat\' instead.\n *   Returns a lazy seq of n xs.\n */\ncljs.core.replicate \x3d (function cljs$core$replicate(n,x){\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(x));\n});\n/**\n * Takes a function of no args, presumably with side effects, and\n *   returns an infinite (or length n if supplied) lazy sequence of calls\n *   to it\n */\ncljs.core.repeatedly \x3d (function cljs$core$repeatedly(var_args){\nvar G__10692 \x3d arguments.length;\nswitch (G__10692) {\ncase 1:\nreturn cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn cljs.core.cons((f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1(f));\n}),null,null));\n});\n\ncljs.core.repeatedly.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,f){\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1(f));\n});\n\ncljs.core.repeatedly.cljs$lang$maxFixedArity \x3d 2;\n\ncljs.core.UNREALIZED_SEED \x3d ({});\n\n/**\n* @constructor\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Iterate \x3d (function (meta,f,prev_seed,seed,next){\nthis.meta \x3d meta;\nthis.f \x3d f;\nthis.prev_seed \x3d prev_seed;\nthis.seed \x3d seed;\nthis.next \x3d next;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 26083532;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 1;\n});\ncljs.core.Iterate.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Iterate.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.Iterate.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ISeq$_rest$arity$1(null);\n});\n\ncljs.core.Iterate.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Iterate.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (!((self__.seed \x3d\x3d\x3d cljs.core.UNREALIZED_SEED)));\n});\n\ncljs.core.Iterate.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,rf){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar first \x3d coll__$1.cljs$core$ISeq$_first$arity$1(null);\nvar v \x3d (self__.f.cljs$core$IFn$_invoke$arity$1 ? self__.f.cljs$core$IFn$_invoke$arity$1(first) : self__.f.call(null,first));\nvar ret \x3d (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(first,v) : rf.call(null,first,v));\nvar v__$1 \x3d v;\nwhile(true){\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.deref(ret);\n} else {\nvar v__$2 \x3d (self__.f.cljs$core$IFn$_invoke$arity$1 ? self__.f.cljs$core$IFn$_invoke$arity$1(v__$1) : self__.f.call(null,v__$1));\nvar G__10694 \x3d (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(ret,v__$2) : rf.call(null,ret,v__$2));\nvar G__10695 \x3d v__$2;\nret \x3d G__10694;\nv__$1 \x3d G__10695;\ncontinue;\n}\nbreak;\n}\n});\n\ncljs.core.Iterate.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,rf,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar v \x3d coll__$1.cljs$core$ISeq$_first$arity$1(null);\nvar ret \x3d (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(start,v) : rf.call(null,start,v));\nvar v__$1 \x3d v;\nwhile(true){\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.deref(ret);\n} else {\nvar v__$2 \x3d (self__.f.cljs$core$IFn$_invoke$arity$1 ? self__.f.cljs$core$IFn$_invoke$arity$1(v__$1) : self__.f.call(null,v__$1));\nvar G__10696 \x3d (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(ret,v__$2) : rf.call(null,ret,v__$2));\nvar G__10697 \x3d v__$2;\nret \x3d G__10696;\nv__$1 \x3d G__10697;\ncontinue;\n}\nbreak;\n}\n});\n\ncljs.core.Iterate.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((cljs.core.UNREALIZED_SEED \x3d\x3d\x3d self__.seed)){\nself__.seed \x3d (self__.f.cljs$core$IFn$_invoke$arity$1 ? self__.f.cljs$core$IFn$_invoke$arity$1(self__.prev_seed) : self__.f.call(null,self__.prev_seed));\n} else {\n}\n\nreturn self__.seed;\n});\n\ncljs.core.Iterate.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.next \x3d\x3d null)){\nself__.next \x3d (new cljs.core.Iterate(null,self__.f,coll__$1.cljs$core$ISeq$_first$arity$1(null),cljs.core.UNREALIZED_SEED,null));\n} else {\n}\n\nreturn self__.next;\n});\n\ncljs.core.Iterate.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.Iterate.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.Iterate(new_meta,self__.f,self__.prev_seed,self__.seed,self__.next));\n}\n});\n\ncljs.core.Iterate.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.Iterate.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$f,cljs.core.cst$sym$prev_DASH_seed,cljs.core.with_meta(cljs.core.cst$sym$seed,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$next,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Iterate.cljs$lang$type \x3d true;\n\ncljs.core.Iterate.cljs$lang$ctorStr \x3d "cljs.core/Iterate";\n\ncljs.core.Iterate.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Iterate");\n});\n\n/**\n * Positional factory function for cljs.core/Iterate.\n */\ncljs.core.__GT_Iterate \x3d (function cljs$core$__GT_Iterate(meta,f,prev_seed,seed,next){\nreturn (new cljs.core.Iterate(meta,f,prev_seed,seed,next));\n});\n\n/**\n * Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\n */\ncljs.core.iterate \x3d (function cljs$core$iterate(f,x){\nreturn (new cljs.core.Iterate(null,f,null,x,null));\n});\n/**\n * Returns a lazy seq of the first item in each coll, then the second etc.\n */\ncljs.core.interleave \x3d (function cljs$core$interleave(var_args){\nvar G__10702 \x3d arguments.length;\nswitch (G__10702) {\ncase 0:\nreturn cljs.core.interleave.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.interleave.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.interleave.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10704 \x3d arguments.length;\nvar i__4731__auto___10705 \x3d (0);\nwhile(true){\nif((i__4731__auto___10705 \x3c len__4730__auto___10704)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10705]));\n\nvar G__10706 \x3d (i__4731__auto___10705 + (1));\ni__4731__auto___10705 \x3d G__10706;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.interleave.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.interleave.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.interleave.cljs$core$IFn$_invoke$arity$1 \x3d (function (c1){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn c1;\n}),null,null));\n});\n\ncljs.core.interleave.cljs$core$IFn$_invoke$arity$2 \x3d (function (c1,c2){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s1 \x3d cljs.core.seq(c1);\nvar s2 \x3d cljs.core.seq(c2);\nif(((s1) \x26\x26 (s2))){\nreturn cljs.core.cons(cljs.core.first(s1),cljs.core.cons(cljs.core.first(s2),cljs.core.interleave.cljs$core$IFn$_invoke$arity$2(cljs.core.rest(s1),cljs.core.rest(s2))));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.interleave.cljs$core$IFn$_invoke$arity$variadic \x3d (function (c1,c2,colls){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar ss \x3d cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.seq,cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic(colls,c2,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([c1], 0)));\nif(cljs.core.every_QMARK_(cljs.core.identity,ss)){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,ss),cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.interleave,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.rest,ss)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\n/** @this {Function} */\ncljs.core.interleave.cljs$lang$applyTo \x3d (function (seq10699){\nvar G__10700 \x3d cljs.core.first(seq10699);\nvar seq10699__$1 \x3d cljs.core.next(seq10699);\nvar G__10701 \x3d cljs.core.first(seq10699__$1);\nvar seq10699__$2 \x3d cljs.core.next(seq10699__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10700,G__10701,seq10699__$2);\n});\n\ncljs.core.interleave.cljs$lang$maxFixedArity \x3d (2);\n\n/**\n * Returns a lazy seq of the elements of coll separated by sep.\n *   Returns a stateful transducer when no collection is provided.\n */\ncljs.core.interpose \x3d (function cljs$core$interpose(var_args){\nvar G__10708 \x3d arguments.length;\nswitch (G__10708) {\ncase 1:\nreturn cljs.core.interpose.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.interpose.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.interpose.cljs$core$IFn$_invoke$arity$1 \x3d (function (sep){\nreturn (function (rf){\nvar started \x3d cljs.core.volatile_BANG_(false);\nreturn ((function (started){\nreturn (function() {\nvar G__10710 \x3d null;\nvar G__10710__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__10710__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__10710__2 \x3d (function (result,input){\nif(cljs.core.truth_(cljs.core.deref(started))){\nvar sepr \x3d (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,sep) : rf.call(null,result,sep));\nif(cljs.core.reduced_QMARK_(sepr)){\nreturn sepr;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(sepr,input) : rf.call(null,sepr,input));\n}\n} else {\ncljs.core.vreset_BANG_(started,true);\n\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__10710 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__10710__0.call(this);\ncase 1:\nreturn G__10710__1.call(this,result);\ncase 2:\nreturn G__10710__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10710.cljs$core$IFn$_invoke$arity$0 \x3d G__10710__0;\nG__10710.cljs$core$IFn$_invoke$arity$1 \x3d G__10710__1;\nG__10710.cljs$core$IFn$_invoke$arity$2 \x3d G__10710__2;\nreturn G__10710;\n})()\n;})(started))\n});\n});\n\ncljs.core.interpose.cljs$core$IFn$_invoke$arity$2 \x3d (function (sep,coll){\nreturn cljs.core.drop.cljs$core$IFn$_invoke$arity$2((1),cljs.core.interleave.cljs$core$IFn$_invoke$arity$2(cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(sep),coll));\n});\n\ncljs.core.interpose.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Take a collection of collections, and return a lazy seq\n *   of items from the inner collection\n */\ncljs.core.flatten1 \x3d (function cljs$core$flatten1(colls){\nvar cat \x3d (function cljs$core$flatten1_$_cat(coll,colls__$1){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5718__auto__ \x3d cljs.core.seq(coll);\nif(temp__5718__auto__){\nvar coll__$1 \x3d temp__5718__auto__;\nreturn cljs.core.cons(cljs.core.first(coll__$1),cljs$core$flatten1_$_cat(cljs.core.rest(coll__$1),colls__$1));\n} else {\nif(cljs.core.seq(colls__$1)){\nreturn cljs$core$flatten1_$_cat(cljs.core.first(colls__$1),cljs.core.rest(colls__$1));\n} else {\nreturn null;\n}\n}\n}),null,null));\n});\nreturn cat(null,colls);\n});\n/**\n * Returns the result of applying concat to the result of applying map\n *   to f and colls.  Thus function f should return a collection. Returns\n *   a transducer when no collections are provided\n */\ncljs.core.mapcat \x3d (function cljs$core$mapcat(var_args){\nvar G__10714 \x3d arguments.length;\nswitch (G__10714) {\ncase 1:\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10716 \x3d arguments.length;\nvar i__4731__auto___10717 \x3d (0);\nwhile(true){\nif((i__4731__auto___10717 \x3c len__4730__auto___10716)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10717]));\n\nvar G__10718 \x3d (i__4731__auto___10717 + (1));\ni__4731__auto___10717 \x3d G__10718;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.mapcat.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$1(f),cljs.core.cat);\n});\n\ncljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,colls){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.concat,cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.map,f,colls));\n});\n\n/** @this {Function} */\ncljs.core.mapcat.cljs$lang$applyTo \x3d (function (seq10712){\nvar G__10713 \x3d cljs.core.first(seq10712);\nvar seq10712__$1 \x3d cljs.core.next(seq10712);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10713,seq10712__$1);\n});\n\ncljs.core.mapcat.cljs$lang$maxFixedArity \x3d (1);\n\n/**\n * Returns a lazy sequence of the items in coll for which\n *   (pred item) returns logical true. pred must be free of side-effects.\n *   Returns a transducer when no collection is provided.\n */\ncljs.core.filter \x3d (function cljs$core$filter(var_args){\nvar G__10720 \x3d arguments.length;\nswitch (G__10720) {\ncase 1:\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.filter.cljs$core$IFn$_invoke$arity$1 \x3d (function (pred){\nreturn (function (rf){\nreturn (function() {\nvar G__10723 \x3d null;\nvar G__10723__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__10723__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__10723__2 \x3d (function (result,input){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(input) : pred.call(null,input)))){\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n} else {\nreturn result;\n}\n});\nG__10723 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__10723__0.call(this);\ncase 1:\nreturn G__10723__1.call(this,result);\ncase 2:\nreturn G__10723__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10723.cljs$core$IFn$_invoke$arity$0 \x3d G__10723__0;\nG__10723.cljs$core$IFn$_invoke$arity$1 \x3d G__10723__1;\nG__10723.cljs$core$IFn$_invoke$arity$2 \x3d G__10723__2;\nreturn G__10723;\n})()\n});\n});\n\ncljs.core.filter.cljs$core$IFn$_invoke$arity$2 \x3d (function (pred,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c \x3d cljs.core.chunk_first(s);\nvar size \x3d cljs.core.count(c);\nvar b \x3d cljs.core.chunk_buffer(size);\nvar n__4607__auto___10724 \x3d size;\nvar i_10725 \x3d (0);\nwhile(true){\nif((i_10725 \x3c n__4607__auto___10724)){\nif(cljs.core.truth_((function (){var G__10721 \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_10725);\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(G__10721) : pred.call(null,G__10721));\n})())){\ncljs.core.chunk_append(b,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_10725));\n} else {\n}\n\nvar G__10726 \x3d (i_10725 + (1));\ni_10725 \x3d G__10726;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs.core.filter.cljs$core$IFn$_invoke$arity$2(pred,cljs.core.chunk_rest(s)));\n} else {\nvar f \x3d cljs.core.first(s);\nvar r \x3d cljs.core.rest(s);\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(f) : pred.call(null,f)))){\nreturn cljs.core.cons(f,cljs.core.filter.cljs$core$IFn$_invoke$arity$2(pred,r));\n} else {\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2(pred,r);\n}\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.filter.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a lazy sequence of the items in coll for which\n *   (pred item) returns logical false. pred must be free of side-effects.\n *   Returns a transducer when no collection is provided.\n */\ncljs.core.remove \x3d (function cljs$core$remove(var_args){\nvar G__10728 \x3d arguments.length;\nswitch (G__10728) {\ncase 1:\nreturn cljs.core.remove.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.remove.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.remove.cljs$core$IFn$_invoke$arity$1 \x3d (function (pred){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$1(cljs.core.complement(pred));\n});\n\ncljs.core.remove.cljs$core$IFn$_invoke$arity$2 \x3d (function (pred,coll){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.complement(pred),coll);\n});\n\ncljs.core.remove.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n *   branch? must be a fn of one arg that returns true if passed a node\n *   that can have children (but may not).  children must be a fn of one\n *   arg that returns a sequence of the children. Will only be called on\n *   nodes for which branch? returns true. Root is the root node of the\n *   tree.\n */\ncljs.core.tree_seq \x3d (function cljs$core$tree_seq(branch_QMARK_,children,root){\nvar walk \x3d (function cljs$core$tree_seq_$_walk(node){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn cljs.core.cons(node,(cljs.core.truth_((branch_QMARK_.cljs$core$IFn$_invoke$arity$1 ? branch_QMARK_.cljs$core$IFn$_invoke$arity$1(node) : branch_QMARK_.call(null,node)))?cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(cljs$core$tree_seq_$_walk,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(children.cljs$core$IFn$_invoke$arity$1 ? children.cljs$core$IFn$_invoke$arity$1(node) : children.call(null,node))], 0)):null));\n}),null,null));\n});\nreturn walk(root);\n});\n/**\n * Takes any nested combination of sequential things (lists, vectors,\n *   etc.) and returns their contents as a single, flat sequence.\n *   (flatten nil) returns nil.\n */\ncljs.core.flatten \x3d (function cljs$core$flatten(x){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2((function (p1__10730_SHARP_){\nreturn (!(cljs.core.sequential_QMARK_(p1__10730_SHARP_)));\n}),cljs.core.rest(cljs.core.tree_seq(cljs.core.sequential_QMARK_,cljs.core.seq,x)));\n});\n/**\n * Returns a new coll consisting of to-coll with all of the items of\n *   from-coll conjoined. A transducer may be supplied.\n */\ncljs.core.into \x3d (function cljs$core$into(var_args){\nvar G__10732 \x3d arguments.length;\nswitch (G__10732) {\ncase 0:\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.into.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.PersistentVector.EMPTY;\n});\n\ncljs.core.into.cljs$core$IFn$_invoke$arity$1 \x3d (function (to){\nreturn to;\n});\n\ncljs.core.into.cljs$core$IFn$_invoke$arity$2 \x3d (function (to,from){\nif((!((to \x3d\x3d null)))){\nif((((!((to \x3d\x3d null))))?(((((to.cljs$lang$protocol_mask$partition1$ \x26 (4))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d to.cljs$core$IEditableCollection$))))?true:false):false)){\nreturn cljs.core._with_meta(cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj_BANG_,cljs.core.transient$(to),from)),cljs.core.meta(to));\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,to,from);\n}\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,cljs.core.List.EMPTY,from);\n}\n});\n\ncljs.core.into.cljs$core$IFn$_invoke$arity$3 \x3d (function (to,xform,from){\nif((((!((to \x3d\x3d null))))?(((((to.cljs$lang$protocol_mask$partition1$ \x26 (4))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d to.cljs$core$IEditableCollection$))))?true:false):false)){\nreturn cljs.core._with_meta(cljs.core.persistent_BANG_(cljs.core.transduce.cljs$core$IFn$_invoke$arity$4(xform,cljs.core.conj_BANG_,cljs.core.transient$(to),from)),cljs.core.meta(to));\n} else {\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$4(xform,cljs.core.conj,to,from);\n}\n});\n\ncljs.core.into.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Returns a vector consisting of the result of applying f to the\n *   set of first items of each coll, followed by applying f to the set\n *   of second items in each coll, until any one of the colls is\n *   exhausted.  Any remaining items in other colls are ignored. Function\n *   f should accept number-of-colls arguments.\n */\ncljs.core.mapv \x3d (function cljs$core$mapv(var_args){\nvar G__10742 \x3d arguments.length;\nswitch (G__10742) {\ncase 2:\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10744 \x3d arguments.length;\nvar i__4731__auto___10745 \x3d (0);\nwhile(true){\nif((i__4731__auto___10745 \x3c len__4730__auto___10744)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10745]));\n\nvar G__10746 \x3d (i__4731__auto___10745 + (1));\ni__4731__auto___10745 \x3d G__10746;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.mapv.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,coll){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (v,o){\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(v,(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(o) : f.call(null,o)));\n}),cljs.core.transient$(cljs.core.PersistentVector.EMPTY),coll));\n});\n\ncljs.core.mapv.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,c1,c2){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$3(f,c1,c2));\n});\n\ncljs.core.mapv.cljs$core$IFn$_invoke$arity$4 \x3d (function (f,c1,c2,c3){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$4(f,c1,c2,c3));\n});\n\ncljs.core.mapv.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,c1,c2,c3,colls){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(cljs.core.map,f,c1,c2,c3,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([colls], 0)));\n});\n\n/** @this {Function} */\ncljs.core.mapv.cljs$lang$applyTo \x3d (function (seq10737){\nvar G__10738 \x3d cljs.core.first(seq10737);\nvar seq10737__$1 \x3d cljs.core.next(seq10737);\nvar G__10739 \x3d cljs.core.first(seq10737__$1);\nvar seq10737__$2 \x3d cljs.core.next(seq10737__$1);\nvar G__10740 \x3d cljs.core.first(seq10737__$2);\nvar seq10737__$3 \x3d cljs.core.next(seq10737__$2);\nvar G__10741 \x3d cljs.core.first(seq10737__$3);\nvar seq10737__$4 \x3d cljs.core.next(seq10737__$3);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10738,G__10739,G__10740,G__10741,seq10737__$4);\n});\n\ncljs.core.mapv.cljs$lang$maxFixedArity \x3d (4);\n\n/**\n * Returns a vector of the items in coll for which\n *   (pred item) returns logical true. pred must be free of side-effects.\n */\ncljs.core.filterv \x3d (function cljs$core$filterv(pred,coll){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (v,o){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(o) : pred.call(null,o)))){\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(v,o);\n} else {\nreturn v;\n}\n}),cljs.core.transient$(cljs.core.PersistentVector.EMPTY),coll));\n});\n/**\n * Returns a lazy sequence of lists of n items each, at offsets step\n *   apart. If step is not supplied, defaults to n, i.e. the partitions\n *   do not overlap. If a pad collection is supplied, use its elements as\n *   necessary to complete last partition up to n items. In case there are\n *   not enough padding elements, return a partition with less than n items.\n */\ncljs.core.partition \x3d (function cljs$core$partition(var_args){\nvar G__10748 \x3d arguments.length;\nswitch (G__10748) {\ncase 2:\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.partition.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,coll){\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$3(n,n,coll);\n});\n\ncljs.core.partition.cljs$core$IFn$_invoke$arity$3 \x3d (function (n,step,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nvar p \x3d cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,s);\nif((n \x3d\x3d\x3d cljs.core.count(p))){\nreturn cljs.core.cons(p,cljs.core.partition.cljs$core$IFn$_invoke$arity$3(n,step,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(step,s)));\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.partition.cljs$core$IFn$_invoke$arity$4 \x3d (function (n,step,pad,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nvar p \x3d cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,s);\nif((n \x3d\x3d\x3d cljs.core.count(p))){\nreturn cljs.core.cons(p,cljs.core.partition.cljs$core$IFn$_invoke$arity$4(n,step,pad,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(step,s)));\n} else {\nreturn (new cljs.core.List(null,cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(p,pad)),null,(1),null));\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.partition.cljs$lang$maxFixedArity \x3d 4;\n\n/**\n * Returns the value in a nested associative structure,\n *   where ks is a sequence of keys. Returns nil if the key is not present,\n *   or the not-found value if supplied.\n */\ncljs.core.get_in \x3d (function cljs$core$get_in(var_args){\nvar G__10751 \x3d arguments.length;\nswitch (G__10751) {\ncase 2:\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.get_in.cljs$core$IFn$_invoke$arity$2 \x3d (function (m,ks){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.get,m,ks);\n});\n\ncljs.core.get_in.cljs$core$IFn$_invoke$arity$3 \x3d (function (m,ks,not_found){\nvar sentinel \x3d cljs.core.lookup_sentinel;\nvar m__$1 \x3d m;\nvar ks__$1 \x3d cljs.core.seq(ks);\nwhile(true){\nif((!((ks__$1 \x3d\x3d null)))){\nvar m__$2 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$3(m__$1,cljs.core.first(ks__$1),sentinel);\nif((sentinel \x3d\x3d\x3d m__$2)){\nreturn not_found;\n} else {\nvar G__10753 \x3d sentinel;\nvar G__10754 \x3d m__$2;\nvar G__10755 \x3d cljs.core.next(ks__$1);\nsentinel \x3d G__10753;\nm__$1 \x3d G__10754;\nks__$1 \x3d G__10755;\ncontinue;\n}\n} else {\nreturn m__$1;\n}\nbreak;\n}\n});\n\ncljs.core.get_in.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Associates a value in a nested associative structure, where ks is a\n *   sequence of keys and v is the new value and returns a new nested structure.\n *   If any levels do not exist, hash-maps will be created.\n */\ncljs.core.assoc_in \x3d (function cljs$core$assoc_in(m,p__10756,v){\nvar vec__10757 \x3d p__10756;\nvar seq__10758 \x3d cljs.core.seq(vec__10757);\nvar first__10759 \x3d cljs.core.first(seq__10758);\nvar seq__10758__$1 \x3d cljs.core.next(seq__10758);\nvar k \x3d first__10759;\nvar ks \x3d seq__10758__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__10760 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__10761 \x3d ks;\nvar G__10762 \x3d v;\nreturn (cljs.core.assoc_in.cljs$core$IFn$_invoke$arity$3 ? cljs.core.assoc_in.cljs$core$IFn$_invoke$arity$3(G__10760,G__10761,G__10762) : cljs.core.assoc_in.call(null,G__10760,G__10761,G__10762));\n})());\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,v);\n}\n});\n/**\n * \'Updates\' a value in a nested associative structure, where ks is a\n *   sequence of keys and f is a function that will take the old value\n *   and any supplied args and return the new value, and returns a new\n *   nested structure.  If any levels do not exist, hash-maps will be\n *   created.\n */\ncljs.core.update_in \x3d (function cljs$core$update_in(var_args){\nvar G__10771 \x3d arguments.length;\nswitch (G__10771) {\ncase 3:\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10803 \x3d arguments.length;\nvar i__4731__auto___10804 \x3d (0);\nwhile(true){\nif((i__4731__auto___10804 \x3c len__4730__auto___10803)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10804]));\n\nvar G__10805 \x3d (i__4731__auto___10804 + (1));\ni__4731__auto___10804 \x3d G__10805;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((6)),(0),null));\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$3 \x3d (function (m,p__10772,f){\nvar vec__10773 \x3d p__10772;\nvar seq__10774 \x3d cljs.core.seq(vec__10773);\nvar first__10775 \x3d cljs.core.first(seq__10774);\nvar seq__10774__$1 \x3d cljs.core.next(seq__10774);\nvar k \x3d first__10775;\nvar ks \x3d seq__10774__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.update_in.cljs$core$IFn$_invoke$arity$3(cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__10776 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10776) : f.call(null,G__10776));\n})());\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$4 \x3d (function (m,p__10777,f,a){\nvar vec__10778 \x3d p__10777;\nvar seq__10779 \x3d cljs.core.seq(vec__10778);\nvar first__10780 \x3d cljs.core.first(seq__10779);\nvar seq__10779__$1 \x3d cljs.core.next(seq__10779);\nvar k \x3d first__10780;\nvar ks \x3d seq__10779__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.update_in.cljs$core$IFn$_invoke$arity$4(cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f,a));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__10781 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__10782 \x3d a;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10781,G__10782) : f.call(null,G__10781,G__10782));\n})());\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$5 \x3d (function (m,p__10783,f,a,b){\nvar vec__10784 \x3d p__10783;\nvar seq__10785 \x3d cljs.core.seq(vec__10784);\nvar first__10786 \x3d cljs.core.first(seq__10785);\nvar seq__10785__$1 \x3d cljs.core.next(seq__10785);\nvar k \x3d first__10786;\nvar ks \x3d seq__10785__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.update_in.cljs$core$IFn$_invoke$arity$5(cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f,a,b));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__10787 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__10788 \x3d a;\nvar G__10789 \x3d b;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10787,G__10788,G__10789) : f.call(null,G__10787,G__10788,G__10789));\n})());\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$6 \x3d (function (m,p__10790,f,a,b,c){\nvar vec__10791 \x3d p__10790;\nvar seq__10792 \x3d cljs.core.seq(vec__10791);\nvar first__10793 \x3d cljs.core.first(seq__10792);\nvar seq__10792__$1 \x3d cljs.core.next(seq__10792);\nvar k \x3d first__10793;\nvar ks \x3d seq__10792__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.update_in.cljs$core$IFn$_invoke$arity$6(cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f,a,b,c));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__10794 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__10795 \x3d a;\nvar G__10796 \x3d b;\nvar G__10797 \x3d c;\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(G__10794,G__10795,G__10796,G__10797) : f.call(null,G__10794,G__10795,G__10796,G__10797));\n})());\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$variadic \x3d (function (m,p__10798,f,a,b,c,args){\nvar vec__10799 \x3d p__10798;\nvar seq__10800 \x3d cljs.core.seq(vec__10799);\nvar first__10801 \x3d cljs.core.first(seq__10800);\nvar seq__10800__$1 \x3d cljs.core.next(seq__10800);\nvar k \x3d first__10801;\nvar ks \x3d seq__10800__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(cljs.core.update_in,cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f,a,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([b,c,args], 0)));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),a,b,c,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([args], 0)));\n}\n});\n\n/** @this {Function} */\ncljs.core.update_in.cljs$lang$applyTo \x3d (function (seq10764){\nvar G__10765 \x3d cljs.core.first(seq10764);\nvar seq10764__$1 \x3d cljs.core.next(seq10764);\nvar G__10766 \x3d cljs.core.first(seq10764__$1);\nvar seq10764__$2 \x3d cljs.core.next(seq10764__$1);\nvar G__10767 \x3d cljs.core.first(seq10764__$2);\nvar seq10764__$3 \x3d cljs.core.next(seq10764__$2);\nvar G__10768 \x3d cljs.core.first(seq10764__$3);\nvar seq10764__$4 \x3d cljs.core.next(seq10764__$3);\nvar G__10769 \x3d cljs.core.first(seq10764__$4);\nvar seq10764__$5 \x3d cljs.core.next(seq10764__$4);\nvar G__10770 \x3d cljs.core.first(seq10764__$5);\nvar seq10764__$6 \x3d cljs.core.next(seq10764__$5);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10765,G__10766,G__10767,G__10768,G__10769,G__10770,seq10764__$6);\n});\n\ncljs.core.update_in.cljs$lang$maxFixedArity \x3d (6);\n\n/**\n * \'Updates\' a value in an associative structure, where k is a\n *   key and f is a function that will take the old value\n *   and any supplied args and return the new value, and returns a new\n *   structure.  If the key does not exist, nil is passed as the old value.\n */\ncljs.core.update \x3d (function cljs$core$update(var_args){\nvar G__10814 \x3d arguments.length;\nswitch (G__10814) {\ncase 3:\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___10826 \x3d arguments.length;\nvar i__4731__auto___10827 \x3d (0);\nwhile(true){\nif((i__4731__auto___10827 \x3c len__4730__auto___10826)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___10827]));\n\nvar G__10828 \x3d (i__4731__auto___10827 + (1));\ni__4731__auto___10827 \x3d G__10828;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((6)),(0),null));\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$3 \x3d (function (m,k,f){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__10815 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__10815) : f.call(null,G__10815));\n})());\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$4 \x3d (function (m,k,f,x){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__10816 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__10817 \x3d x;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10816,G__10817) : f.call(null,G__10816,G__10817));\n})());\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$5 \x3d (function (m,k,f,x,y){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__10818 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__10819 \x3d x;\nvar G__10820 \x3d y;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10818,G__10819,G__10820) : f.call(null,G__10818,G__10819,G__10820));\n})());\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$6 \x3d (function (m,k,f,x,y,z){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__10821 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__10822 \x3d x;\nvar G__10823 \x3d y;\nvar G__10824 \x3d z;\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(G__10821,G__10822,G__10823,G__10824) : f.call(null,G__10821,G__10822,G__10823,G__10824));\n})());\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$variadic \x3d (function (m,k,f,x,y,z,more){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),x,y,z,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([more], 0)));\n});\n\n/** @this {Function} */\ncljs.core.update.cljs$lang$applyTo \x3d (function (seq10807){\nvar G__10808 \x3d cljs.core.first(seq10807);\nvar seq10807__$1 \x3d cljs.core.next(seq10807);\nvar G__10809 \x3d cljs.core.first(seq10807__$1);\nvar seq10807__$2 \x3d cljs.core.next(seq10807__$1);\nvar G__10810 \x3d cljs.core.first(seq10807__$2);\nvar seq10807__$3 \x3d cljs.core.next(seq10807__$2);\nvar G__10811 \x3d cljs.core.first(seq10807__$3);\nvar seq10807__$4 \x3d cljs.core.next(seq10807__$3);\nvar G__10812 \x3d cljs.core.first(seq10807__$4);\nvar seq10807__$5 \x3d cljs.core.next(seq10807__$4);\nvar G__10813 \x3d cljs.core.first(seq10807__$5);\nvar seq10807__$6 \x3d cljs.core.next(seq10807__$5);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__10808,G__10809,G__10810,G__10811,G__10812,G__10813,seq10807__$6);\n});\n\ncljs.core.update.cljs$lang$maxFixedArity \x3d (6);\n\n\n/**\n* @constructor\n*/\ncljs.core.VectorNode \x3d (function (edit,arr){\nthis.edit \x3d edit;\nthis.arr \x3d arr;\n});\n\ncljs.core.VectorNode.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$edit,cljs.core.cst$sym$arr], null);\n});\n\ncljs.core.VectorNode.cljs$lang$type \x3d true;\n\ncljs.core.VectorNode.cljs$lang$ctorStr \x3d "cljs.core/VectorNode";\n\ncljs.core.VectorNode.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/VectorNode");\n});\n\n/**\n * Positional factory function for cljs.core/VectorNode.\n */\ncljs.core.__GT_VectorNode \x3d (function cljs$core$__GT_VectorNode(edit,arr){\nreturn (new cljs.core.VectorNode(edit,arr));\n});\n\ncljs.core.pv_fresh_node \x3d (function cljs$core$pv_fresh_node(edit){\nreturn (new cljs.core.VectorNode(edit,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]));\n});\ncljs.core.pv_aget \x3d (function cljs$core$pv_aget(node,idx){\nreturn (node.arr[idx]);\n});\ncljs.core.pv_aset \x3d (function cljs$core$pv_aset(node,idx,val){\nreturn (node.arr[idx] \x3d val);\n});\ncljs.core.pv_clone_node \x3d (function cljs$core$pv_clone_node(node){\nreturn (new cljs.core.VectorNode(node.edit,cljs.core.aclone(node.arr)));\n});\ncljs.core.tail_off \x3d (function cljs$core$tail_off(pv){\nvar cnt \x3d pv.cnt;\nif((cnt \x3c (32))){\nreturn (0);\n} else {\nreturn (((cnt - (1)) \x3e\x3e\x3e (5)) \x3c\x3c (5));\n}\n});\ncljs.core.new_path \x3d (function cljs$core$new_path(edit,level,node){\nvar ll \x3d level;\nvar ret \x3d node;\nwhile(true){\nif((ll \x3d\x3d\x3d (0))){\nreturn ret;\n} else {\nvar embed \x3d ret;\nvar r \x3d cljs.core.pv_fresh_node(edit);\nvar _ \x3d cljs.core.pv_aset(r,(0),embed);\nvar G__10829 \x3d (ll - (5));\nvar G__10830 \x3d r;\nll \x3d G__10829;\nret \x3d G__10830;\ncontinue;\n}\nbreak;\n}\n});\ncljs.core.push_tail \x3d (function cljs$core$push_tail(pv,level,parent,tailnode){\nvar ret \x3d cljs.core.pv_clone_node(parent);\nvar subidx \x3d (((pv.cnt - (1)) \x3e\x3e\x3e level) \x26 (31));\nif(((5) \x3d\x3d\x3d level)){\ncljs.core.pv_aset(ret,subidx,tailnode);\n\nreturn ret;\n} else {\nvar child \x3d cljs.core.pv_aget(parent,subidx);\nif((!((child \x3d\x3d null)))){\nvar node_to_insert \x3d (function (){var G__10831 \x3d pv;\nvar G__10832 \x3d (level - (5));\nvar G__10833 \x3d child;\nvar G__10834 \x3d tailnode;\nreturn (cljs.core.push_tail.cljs$core$IFn$_invoke$arity$4 ? cljs.core.push_tail.cljs$core$IFn$_invoke$arity$4(G__10831,G__10832,G__10833,G__10834) : cljs.core.push_tail.call(null,G__10831,G__10832,G__10833,G__10834));\n})();\ncljs.core.pv_aset(ret,subidx,node_to_insert);\n\nreturn ret;\n} else {\nvar node_to_insert \x3d cljs.core.new_path(null,(level - (5)),tailnode);\ncljs.core.pv_aset(ret,subidx,node_to_insert);\n\nreturn ret;\n}\n}\n});\ncljs.core.vector_index_out_of_bounds \x3d (function cljs$core$vector_index_out_of_bounds(i,cnt){\nthrow (new Error(["No item ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(i)," in vector of length ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cnt)].join(\'\')));\n});\ncljs.core.first_array_for_longvec \x3d (function cljs$core$first_array_for_longvec(pv){\nvar node \x3d pv.root;\nvar level \x3d pv.shift;\nwhile(true){\nif((level \x3e (0))){\nvar G__10835 \x3d cljs.core.pv_aget(node,(0));\nvar G__10836 \x3d (level - (5));\nnode \x3d G__10835;\nlevel \x3d G__10836;\ncontinue;\n} else {\nreturn node.arr;\n}\nbreak;\n}\n});\ncljs.core.unchecked_array_for \x3d (function cljs$core$unchecked_array_for(pv,i){\nif((i \x3e\x3d cljs.core.tail_off(pv))){\nreturn pv.tail;\n} else {\nvar node \x3d pv.root;\nvar level \x3d pv.shift;\nwhile(true){\nif((level \x3e (0))){\nvar G__10837 \x3d cljs.core.pv_aget(node,((i \x3e\x3e\x3e level) \x26 (31)));\nvar G__10838 \x3d (level - (5));\nnode \x3d G__10837;\nlevel \x3d G__10838;\ncontinue;\n} else {\nreturn node.arr;\n}\nbreak;\n}\n}\n});\ncljs.core.array_for \x3d (function cljs$core$array_for(pv,i){\nif(((((0) \x3c\x3d i)) \x26\x26 ((i \x3c pv.cnt)))){\nreturn cljs.core.unchecked_array_for(pv,i);\n} else {\nreturn cljs.core.vector_index_out_of_bounds(i,pv.cnt);\n}\n});\ncljs.core.do_assoc \x3d (function cljs$core$do_assoc(pv,level,node,i,val){\nvar ret \x3d cljs.core.pv_clone_node(node);\nif((level \x3d\x3d\x3d (0))){\ncljs.core.pv_aset(ret,(i \x26 (31)),val);\n\nreturn ret;\n} else {\nvar subidx \x3d ((i \x3e\x3e\x3e level) \x26 (31));\ncljs.core.pv_aset(ret,subidx,(function (){var G__10839 \x3d pv;\nvar G__10840 \x3d (level - (5));\nvar G__10841 \x3d cljs.core.pv_aget(node,subidx);\nvar G__10842 \x3d i;\nvar G__10843 \x3d val;\nreturn (cljs.core.do_assoc.cljs$core$IFn$_invoke$arity$5 ? cljs.core.do_assoc.cljs$core$IFn$_invoke$arity$5(G__10839,G__10840,G__10841,G__10842,G__10843) : cljs.core.do_assoc.call(null,G__10839,G__10840,G__10841,G__10842,G__10843));\n})());\n\nreturn ret;\n}\n});\ncljs.core.pop_tail \x3d (function cljs$core$pop_tail(pv,level,node){\nvar subidx \x3d (((pv.cnt - (2)) \x3e\x3e\x3e level) \x26 (31));\nif((level \x3e (5))){\nvar new_child \x3d (function (){var G__10844 \x3d pv;\nvar G__10845 \x3d (level - (5));\nvar G__10846 \x3d cljs.core.pv_aget(node,subidx);\nreturn (cljs.core.pop_tail.cljs$core$IFn$_invoke$arity$3 ? cljs.core.pop_tail.cljs$core$IFn$_invoke$arity$3(G__10844,G__10845,G__10846) : cljs.core.pop_tail.call(null,G__10844,G__10845,G__10846));\n})();\nif((((new_child \x3d\x3d null)) \x26\x26 ((subidx \x3d\x3d\x3d (0))))){\nreturn null;\n} else {\nvar ret \x3d cljs.core.pv_clone_node(node);\ncljs.core.pv_aset(ret,subidx,new_child);\n\nreturn ret;\n}\n} else {\nif((subidx \x3d\x3d\x3d (0))){\nreturn null;\n} else {\nvar ret \x3d cljs.core.pv_clone_node(node);\ncljs.core.pv_aset(ret,subidx,null);\n\nreturn ret;\n\n}\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.RangedIterator \x3d (function (i,base,arr,v,start,end){\nthis.i \x3d i;\nthis.base \x3d base;\nthis.arr \x3d arr;\nthis.v \x3d v;\nthis.start \x3d start;\nthis.end \x3d end;\n});\ncljs.core.RangedIterator.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn (self__.i \x3c self__.end);\n});\n\ncljs.core.RangedIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nif(((self__.i - self__.base) \x3d\x3d\x3d (32))){\nself__.arr \x3d cljs.core.unchecked_array_for(self__.v,self__.i);\n\nself__.base \x3d (self__.base + (32));\n} else {\n}\n\nvar ret \x3d (self__.arr[(self__.i \x26 (31))]);\nself__.i \x3d (self__.i + (1));\n\nreturn ret;\n});\n\ncljs.core.RangedIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$i,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$base,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$arr,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.cst$sym$v,cljs.core.cst$sym$start,cljs.core.cst$sym$end], null);\n});\n\ncljs.core.RangedIterator.cljs$lang$type \x3d true;\n\ncljs.core.RangedIterator.cljs$lang$ctorStr \x3d "cljs.core/RangedIterator";\n\ncljs.core.RangedIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/RangedIterator");\n});\n\n/**\n * Positional factory function for cljs.core/RangedIterator.\n */\ncljs.core.__GT_RangedIterator \x3d (function cljs$core$__GT_RangedIterator(i,base,arr,v,start,end){\nreturn (new cljs.core.RangedIterator(i,base,arr,v,start,end));\n});\n\ncljs.core.ranged_iterator \x3d (function cljs$core$ranged_iterator(v,start,end){\nvar i \x3d start;\nreturn (new cljs.core.RangedIterator(i,(i - (i % (32))),(((start \x3c cljs.core.count(v)))?cljs.core.unchecked_array_for(v,i):null),v,start,end));\n});\ncljs.core.pv_reduce \x3d (function cljs$core$pv_reduce(var_args){\nvar G__10848 \x3d arguments.length;\nswitch (G__10848) {\ncase 4:\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4 \x3d (function (pv,f,start,end){\nif((start \x3c end)){\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5(pv,f,cljs.core.nth.cljs$core$IFn$_invoke$arity$2(pv,start),(start + (1)),end);\n} else {\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n}\n});\n\ncljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5 \x3d (function (pv,f,init,start,end){\nvar acc \x3d init;\nvar i \x3d start;\nvar arr \x3d cljs.core.unchecked_array_for(pv,start);\nwhile(true){\nif((i \x3c end)){\nvar j \x3d (i \x26 (31));\nvar arr__$1 \x3d (((j \x3d\x3d\x3d (0)))?cljs.core.unchecked_array_for(pv,i):arr);\nvar nacc \x3d (function (){var G__10849 \x3d acc;\nvar G__10850 \x3d (arr__$1[j]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10849,G__10850) : f.call(null,G__10849,G__10850));\n})();\nif(cljs.core.reduced_QMARK_(nacc)){\nreturn cljs.core.deref(nacc);\n} else {\nvar G__10852 \x3d nacc;\nvar G__10853 \x3d (i + (1));\nvar G__10854 \x3d arr__$1;\nacc \x3d G__10852;\ni \x3d G__10853;\narr \x3d G__10854;\ncontinue;\n}\n} else {\nreturn acc;\n}\nbreak;\n}\n});\n\ncljs.core.pv_reduce.cljs$lang$maxFixedArity \x3d 5;\n\n\n\n\n\n\n\n\n/**\n * Marker protocol\n * @interface\n */\ncljs.core.APersistentVector \x3d function(){};\n\n\n/**\n* @constructor\n * @implements {cljs.core.APersistentVector}\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.PersistentVector \x3d (function (meta,cnt,shift,root,tail,__hash){\nthis.meta \x3d meta;\nthis.cnt \x3d cnt;\nthis.shift \x3d shift;\nthis.root \x3d root;\nthis.tail \x3d tail;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 167666463;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 139268;\n});\ncljs.core.PersistentVector.prototype.cljs$core$IFind$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentVector.prototype.cljs$core$IFind$_find$arity$2 \x3d (function (coll,n){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((((0) \x3c\x3d n)) \x26\x26 ((n \x3c self__.cnt)))){\nreturn (new cljs.core.MapEntry(n,(cljs.core.unchecked_array_for(coll__$1,n)[(n \x26 (31))]),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentVector.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentVector.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentVector.prototype.indexOf \x3d (function() {\nvar G__10861 \x3d null;\nvar G__10861__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10861__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10861 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10861__1.call(this,x);\ncase 2:\nreturn G__10861__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10861.cljs$core$IFn$_invoke$arity$1 \x3d G__10861__1;\nG__10861.cljs$core$IFn$_invoke$arity$2 \x3d G__10861__2;\nreturn G__10861;\n})()\n;\n\ncljs.core.PersistentVector.prototype.lastIndexOf \x3d (function() {\nvar G__10862 \x3d null;\nvar G__10862__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10862__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10862 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10862__1.call(this,x);\ncase 2:\nreturn G__10862__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10862.cljs$core$IFn$_invoke$arity$1 \x3d G__10862__1;\nG__10862.cljs$core$IFn$_invoke$arity$2 \x3d G__10862__2;\nreturn G__10862;\n})()\n;\n\ncljs.core.PersistentVector.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (coll,k,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(typeof k \x3d\x3d\x3d \'number\'){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 \x3d (function (v,f,init){\nvar self__ \x3d this;\nvar v__$1 \x3d this;\nvar i \x3d (0);\nvar init__$1 \x3d init;\nwhile(true){\nif((i \x3c self__.cnt)){\nvar arr \x3d cljs.core.unchecked_array_for(v__$1,i);\nvar len \x3d arr.length;\nvar init__$2 \x3d (function (){var j \x3d (0);\nvar init__$2 \x3d init__$1;\nwhile(true){\nif((j \x3c len)){\nvar init__$3 \x3d (function (){var G__10856 \x3d init__$2;\nvar G__10857 \x3d (j + i);\nvar G__10858 \x3d (arr[j]);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10856,G__10857,G__10858) : f.call(null,G__10856,G__10857,G__10858));\n})();\nif(cljs.core.reduced_QMARK_(init__$3)){\nreturn init__$3;\n} else {\nvar G__10863 \x3d (j + (1));\nvar G__10864 \x3d init__$3;\nj \x3d G__10863;\ninit__$2 \x3d G__10864;\ncontinue;\n}\n} else {\nreturn init__$2;\n}\nbreak;\n}\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__10865 \x3d (i + len);\nvar G__10866 \x3d init__$2;\ni \x3d G__10865;\ninit__$1 \x3d G__10866;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$APersistentVector$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentVector.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (coll,n){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (cljs.core.array_for(coll__$1,n)[(n \x26 (31))]);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (coll,n,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((((0) \x3c\x3d n)) \x26\x26 ((n \x3c self__.cnt)))){\nreturn (cljs.core.unchecked_array_for(coll__$1,n)[(n \x26 (31))]);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IVector$_assoc_n$arity$3 \x3d (function (coll,n,val){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((((0) \x3c\x3d n)) \x26\x26 ((n \x3c self__.cnt)))){\nif((cljs.core.tail_off(coll__$1) \x3c\x3d n)){\nvar new_tail \x3d cljs.core.aclone(self__.tail);\n(new_tail[(n \x26 (31))] \x3d val);\n\nreturn (new cljs.core.PersistentVector(self__.meta,self__.cnt,self__.shift,self__.root,new_tail,null));\n} else {\nreturn (new cljs.core.PersistentVector(self__.meta,self__.cnt,self__.shift,cljs.core.do_assoc(coll__$1,self__.shift,self__.root,n,val),self__.tail,null));\n}\n} else {\nif((n \x3d\x3d\x3d self__.cnt)){\nreturn coll__$1.cljs$core$ICollection$_conj$arity$2(null,val);\n} else {\nthrow (new Error(["Index ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(n)," out of bounds  [0,",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.cnt),"]"].join(\'\')));\n\n}\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn cljs.core.ranged_iterator(this$__$1,(0),self__.cnt);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.PersistentVector(self__.meta,self__.cnt,self__.shift,self__.root,self__.tail,self__.__hash));\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.cnt;\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IStack$_peek$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3e (0))){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$2(null,(self__.cnt - (1)));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IStack$_pop$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3d\x3d\x3d (0))){\nthrow (new Error("Can\'t pop empty vector"));\n} else {\nif(((1) \x3d\x3d\x3d self__.cnt)){\nreturn cljs.core._with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\n} else {\nif(((1) \x3c (self__.cnt - cljs.core.tail_off(coll__$1)))){\nreturn (new cljs.core.PersistentVector(self__.meta,(self__.cnt - (1)),self__.shift,self__.root,self__.tail.slice((0),(-1)),null));\n} else {\nvar new_tail \x3d cljs.core.unchecked_array_for(coll__$1,(self__.cnt - (2)));\nvar nr \x3d cljs.core.pop_tail(coll__$1,self__.shift,self__.root);\nvar new_root \x3d (((nr \x3d\x3d null))?cljs.core.PersistentVector.EMPTY_NODE:nr);\nvar cnt_1 \x3d (self__.cnt - (1));\nif(((((5) \x3c self__.shift)) \x26\x26 ((cljs.core.pv_aget(new_root,(1)) \x3d\x3d null)))){\nreturn (new cljs.core.PersistentVector(self__.meta,cnt_1,(self__.shift - (5)),cljs.core.pv_aget(new_root,(0)),new_tail,null));\n} else {\nreturn (new cljs.core.PersistentVector(self__.meta,cnt_1,self__.shift,new_root,new_tail,null));\n}\n\n}\n}\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IReversible$_rseq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3e (0))){\nreturn (new cljs.core.RSeq(coll__$1,(self__.cnt - (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((other instanceof cljs.core.PersistentVector)){\nif((self__.cnt \x3d\x3d\x3d cljs.core.count(other))){\nvar me_iter \x3d coll__$1.cljs$core$IIterable$_iterator$arity$1(null);\nvar you_iter \x3d other.cljs$core$IIterable$_iterator$arity$1(null);\nwhile(true){\nif(me_iter.hasNext()){\nvar x \x3d me_iter.next();\nvar y \x3d you_iter.next();\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)){\ncontinue;\n} else {\nreturn false;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n} else {\nreturn false;\n}\n} else {\nreturn cljs.core.equiv_sequential(coll__$1,other);\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.TransientVector(self__.cnt,self__.shift,cljs.core.tv_editable_root(self__.root),cljs.core.tv_editable_tail(self__.tail)));\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (v,f){\nvar self__ \x3d this;\nvar v__$1 \x3d this;\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4(v__$1,f,(0),self__.cnt);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (v,f,init){\nvar self__ \x3d this;\nvar v__$1 \x3d this;\nvar i \x3d (0);\nvar init__$1 \x3d init;\nwhile(true){\nif((i \x3c self__.cnt)){\nvar arr \x3d cljs.core.unchecked_array_for(v__$1,i);\nvar len \x3d arr.length;\nvar init__$2 \x3d (function (){var j \x3d (0);\nvar init__$2 \x3d init__$1;\nwhile(true){\nif((j \x3c len)){\nvar init__$3 \x3d (function (){var G__10859 \x3d init__$2;\nvar G__10860 \x3d (arr[j]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__10859,G__10860) : f.call(null,G__10859,G__10860));\n})();\nif(cljs.core.reduced_QMARK_(init__$3)){\nreturn init__$3;\n} else {\nvar G__10867 \x3d (j + (1));\nvar G__10868 \x3d init__$3;\nj \x3d G__10867;\ninit__$2 \x3d G__10868;\ncontinue;\n}\n} else {\nreturn init__$2;\n}\nbreak;\n}\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__10869 \x3d (i + len);\nvar G__10870 \x3d init__$2;\ni \x3d G__10869;\ninit__$1 \x3d G__10870;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IAssociative$_assoc$arity$3 \x3d (function (coll,k,v){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(typeof k \x3d\x3d\x3d \'number\'){\nreturn coll__$1.cljs$core$IVector$_assoc_n$arity$3(null,k,v);\n} else {\nthrow (new Error("Vector\'s key for assoc must be a number."));\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(cljs.core.integer_QMARK_(k)){\nreturn ((((0) \x3c\x3d k)) \x26\x26 ((k \x3c self__.cnt)));\n} else {\nreturn false;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3d\x3d\x3d (0))){\nreturn null;\n} else {\nif((self__.cnt \x3c\x3d (32))){\nreturn (new cljs.core.IndexedSeq(self__.tail,(0),null));\n} else {\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(coll__$1,cljs.core.first_array_for_longvec(coll__$1),(0),(0));\n\n}\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentVector(new_meta,self__.cnt,self__.shift,self__.root,self__.tail,self__.__hash));\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((self__.cnt - cljs.core.tail_off(coll__$1)) \x3c (32))){\nvar len \x3d self__.tail.length;\nvar new_tail \x3d (new Array((len + (1))));\nvar n__4607__auto___10871 \x3d len;\nvar i_10872 \x3d (0);\nwhile(true){\nif((i_10872 \x3c n__4607__auto___10871)){\n(new_tail[i_10872] \x3d (self__.tail[i_10872]));\n\nvar G__10873 \x3d (i_10872 + (1));\ni_10872 \x3d G__10873;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(new_tail[len] \x3d o);\n\nreturn (new cljs.core.PersistentVector(self__.meta,(self__.cnt + (1)),self__.shift,self__.root,new_tail,null));\n} else {\nvar root_overflow_QMARK_ \x3d ((self__.cnt \x3e\x3e\x3e (5)) \x3e ((1) \x3c\x3c self__.shift));\nvar new_shift \x3d ((root_overflow_QMARK_)?(self__.shift + (5)):self__.shift);\nvar new_root \x3d ((root_overflow_QMARK_)?(function (){var n_r \x3d cljs.core.pv_fresh_node(null);\ncljs.core.pv_aset(n_r,(0),self__.root);\n\ncljs.core.pv_aset(n_r,(1),cljs.core.new_path(null,self__.shift,(new cljs.core.VectorNode(null,self__.tail))));\n\nreturn n_r;\n})():cljs.core.push_tail(coll__$1,self__.shift,self__.root,(new cljs.core.VectorNode(null,self__.tail))));\nreturn (new cljs.core.PersistentVector(self__.meta,(self__.cnt + (1)),new_shift,new_root,[o],null));\n}\n});\n\ncljs.core.PersistentVector.prototype.call \x3d (function() {\nvar G__10874 \x3d null;\nvar G__10874__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__10874__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__10874 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__10874__2.call(this,self__,k);\ncase 3:\nreturn G__10874__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__10874.cljs$core$IFn$_invoke$arity$2 \x3d G__10874__2;\nG__10874.cljs$core$IFn$_invoke$arity$3 \x3d G__10874__3;\nreturn G__10874;\n})()\n;\n\ncljs.core.PersistentVector.prototype.apply \x3d (function (self__,args10855){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args10855)));\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentVector.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$cnt,cljs.core.cst$sym$shift,cljs.core.cst$sym$root,cljs.core.cst$sym$tail,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.PersistentVector.cljs$lang$type \x3d true;\n\ncljs.core.PersistentVector.cljs$lang$ctorStr \x3d "cljs.core/PersistentVector";\n\ncljs.core.PersistentVector.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentVector");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentVector.\n */\ncljs.core.__GT_PersistentVector \x3d (function cljs$core$__GT_PersistentVector(meta,cnt,shift,root,tail,__hash){\nreturn (new cljs.core.PersistentVector(meta,cnt,shift,root,tail,__hash));\n});\n\ncljs.core.PersistentVector.EMPTY_NODE \x3d (new cljs.core.VectorNode(null,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]));\ncljs.core.PersistentVector.EMPTY \x3d (new cljs.core.PersistentVector(null,(0),(5),cljs.core.PersistentVector.EMPTY_NODE,[],cljs.core.empty_ordered_hash));\ncljs.core.PersistentVector.fromArray \x3d (function (xs,no_clone){\nvar l \x3d xs.length;\nvar xs__$1 \x3d ((no_clone)?xs:cljs.core.aclone(xs));\nif((l \x3c (32))){\nreturn (new cljs.core.PersistentVector(null,l,(5),cljs.core.PersistentVector.EMPTY_NODE,xs__$1,null));\n} else {\nvar node \x3d xs__$1.slice((0),(32));\nvar v \x3d (new cljs.core.PersistentVector(null,(32),(5),cljs.core.PersistentVector.EMPTY_NODE,node,null));\nvar i \x3d (32);\nvar out \x3d v.cljs$core$IEditableCollection$_as_transient$arity$1(null);\nwhile(true){\nif((i \x3c l)){\nvar G__10875 \x3d (i + (1));\nvar G__10876 \x3d cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,(xs__$1[i]));\ni \x3d G__10875;\nout \x3d G__10876;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(out);\n}\nbreak;\n}\n}\n});\nvar G__10877_10880 \x3d cljs.core.PersistentVector.prototype;\nvar G__10878_10881 \x3d cljs.core.ITER_SYMBOL;\nvar G__10879_10882 \x3d ((function (G__10877_10880,G__10878_10881){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10877_10880,G__10878_10881))\n;\ngoog.object.set(G__10877_10880,G__10878_10881,G__10879_10882);\n/**\n * Creates a new vector containing the contents of coll. JavaScript arrays\n *   will be aliased and should not be modified.\n */\ncljs.core.vec \x3d (function cljs$core$vec(coll){\nif(cljs.core.map_entry_QMARK_(coll)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.key(coll),cljs.core.val(coll)], null);\n} else {\nif(cljs.core.vector_QMARK_(coll)){\nreturn cljs.core.with_meta(coll,null);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn cljs.core.PersistentVector.fromArray(coll,true);\n} else {\nreturn cljs.core._persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj_BANG_,cljs.core._as_transient(cljs.core.PersistentVector.EMPTY),coll));\n\n}\n}\n}\n});\n/**\n * Creates a new vector containing the args.\n */\ncljs.core.vector \x3d (function cljs$core$vector(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___10884 \x3d arguments.length;\nvar i__4731__auto___10885 \x3d (0);\nwhile(true){\nif((i__4731__auto___10885 \x3c len__4730__auto___10884)){\nargs__4736__auto__.push((arguments[i__4731__auto___10885]));\n\nvar G__10886 \x3d (i__4731__auto___10885 + (1));\ni__4731__auto___10885 \x3d G__10886;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.vector.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.vector.cljs$core$IFn$_invoke$arity$variadic \x3d (function (args){\nif((((args instanceof cljs.core.IndexedSeq)) \x26\x26 ((args.i \x3d\x3d\x3d (0))))){\nreturn cljs.core.PersistentVector.fromArray(args.arr,true);\n} else {\nreturn cljs.core.vec(args);\n}\n});\n\ncljs.core.vector.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.vector.cljs$lang$applyTo \x3d (function (seq10883){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq10883));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IChunkedNext}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IChunkedSeq}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.ChunkedSeq \x3d (function (vec,node,i,off,meta,__hash){\nthis.vec \x3d vec;\nthis.node \x3d node;\nthis.i \x3d i;\nthis.off \x3d off;\nthis.meta \x3d meta;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32375020;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 1536;\n});\ncljs.core.ChunkedSeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ChunkedSeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ChunkedSeq.prototype.indexOf \x3d (function() {\nvar G__10887 \x3d null;\nvar G__10887__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10887__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10887 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10887__1.call(this,x);\ncase 2:\nreturn G__10887__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10887.cljs$core$IFn$_invoke$arity$1 \x3d G__10887__1;\nG__10887.cljs$core$IFn$_invoke$arity$2 \x3d G__10887__2;\nreturn G__10887;\n})()\n;\n\ncljs.core.ChunkedSeq.prototype.lastIndexOf \x3d (function() {\nvar G__10888 \x3d null;\nvar G__10888__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10888__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10888 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10888__1.call(this,x);\ncase 2:\nreturn G__10888__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10888.cljs$core$IFn$_invoke$arity$1 \x3d G__10888__1;\nG__10888.cljs$core$IFn$_invoke$arity$2 \x3d G__10888__2;\nreturn G__10888;\n})()\n;\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((self__.off + (1)) \x3c self__.node.length)){\nvar s \x3d cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(self__.vec,self__.node,self__.i,(self__.off + (1)));\nif((s \x3d\x3d null)){\nreturn null;\n} else {\nreturn s;\n}\n} else {\nreturn coll__$1.cljs$core$IChunkedNext$_chunked_next$arity$1(null);\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4(self__.vec,f,(self__.i + self__.off),cljs.core.count(self__.vec));\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5(self__.vec,f,start,(self__.i + self__.off),cljs.core.count(self__.vec));\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (self__.node[self__.off]);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((self__.off + (1)) \x3c self__.node.length)){\nvar s \x3d cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(self__.vec,self__.node,self__.i,(self__.off + (1)));\nif((s \x3d\x3d null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn s;\n}\n} else {\nreturn coll__$1.cljs$core$IChunkedSeq$_chunked_rest$arity$1(null);\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IChunkedSeq$_chunked_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$2(self__.node,self__.off);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IChunkedSeq$_chunked_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar end \x3d (self__.i + self__.node.length);\nif((end \x3c cljs.core._count(self__.vec))){\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(self__.vec,cljs.core.unchecked_array_for(self__.vec,end),end,(0));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$5(self__.vec,self__.node,self__.i,self__.off,new_meta);\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IChunkedNext$_chunked_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar end \x3d (self__.i + self__.node.length);\nif((end \x3c cljs.core._count(self__.vec))){\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(self__.vec,cljs.core.unchecked_array_for(self__.vec,end),end,(0));\n} else {\nreturn null;\n}\n});\n\ncljs.core.ChunkedSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$vec,cljs.core.cst$sym$node,cljs.core.cst$sym$i,cljs.core.cst$sym$off,cljs.core.cst$sym$meta,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ChunkedSeq.cljs$lang$type \x3d true;\n\ncljs.core.ChunkedSeq.cljs$lang$ctorStr \x3d "cljs.core/ChunkedSeq";\n\ncljs.core.ChunkedSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ChunkedSeq");\n});\n\n/**\n * Positional factory function for cljs.core/ChunkedSeq.\n */\ncljs.core.__GT_ChunkedSeq \x3d (function cljs$core$__GT_ChunkedSeq(vec,node,i,off,meta,__hash){\nreturn (new cljs.core.ChunkedSeq(vec,node,i,off,meta,__hash));\n});\n\nvar G__10889_10892 \x3d cljs.core.ChunkedSeq.prototype;\nvar G__10890_10893 \x3d cljs.core.ITER_SYMBOL;\nvar G__10891_10894 \x3d ((function (G__10889_10892,G__10890_10893){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10889_10892,G__10890_10893))\n;\ngoog.object.set(G__10889_10892,G__10890_10893,G__10891_10894);\ncljs.core.chunked_seq \x3d (function cljs$core$chunked_seq(var_args){\nvar G__10896 \x3d arguments.length;\nswitch (G__10896) {\ncase 3:\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$3 \x3d (function (vec,i,off){\nreturn (new cljs.core.ChunkedSeq(vec,cljs.core.array_for(vec,i),i,off,null,null));\n});\n\ncljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4 \x3d (function (vec,node,i,off){\nreturn (new cljs.core.ChunkedSeq(vec,node,i,off,null,null));\n});\n\ncljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$5 \x3d (function (vec,node,i,off,meta){\nreturn (new cljs.core.ChunkedSeq(vec,node,i,off,meta,null));\n});\n\ncljs.core.chunked_seq.cljs$lang$maxFixedArity \x3d 5;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Subvec \x3d (function (meta,v,start,end,__hash){\nthis.meta \x3d meta;\nthis.v \x3d v;\nthis.start \x3d start;\nthis.end \x3d end;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 167666463;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 139264;\n});\ncljs.core.Subvec.prototype.cljs$core$IFind$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Subvec.prototype.cljs$core$IFind$_find$arity$2 \x3d (function (coll,n){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((n \x3c (0))){\nreturn null;\n} else {\nvar idx \x3d (self__.start + n);\nif((idx \x3c self__.end)){\nreturn (new cljs.core.MapEntry(n,cljs.core._lookup.cljs$core$IFn$_invoke$arity$2(self__.v,idx),null));\n} else {\nreturn null;\n}\n}\n});\n\ncljs.core.Subvec.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Subvec.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Subvec.prototype.indexOf \x3d (function() {\nvar G__10905 \x3d null;\nvar G__10905__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10905__2 \x3d (function (x,start__$1){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start__$1);\n});\nG__10905 \x3d function(x,start__$1){\nswitch(arguments.length){\ncase 1:\nreturn G__10905__1.call(this,x);\ncase 2:\nreturn G__10905__2.call(this,x,start__$1);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10905.cljs$core$IFn$_invoke$arity$1 \x3d G__10905__1;\nG__10905.cljs$core$IFn$_invoke$arity$2 \x3d G__10905__2;\nreturn G__10905;\n})()\n;\n\ncljs.core.Subvec.prototype.lastIndexOf \x3d (function() {\nvar G__10906 \x3d null;\nvar G__10906__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10906__2 \x3d (function (x,start__$1){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start__$1);\n});\nG__10906 \x3d function(x,start__$1){\nswitch(arguments.length){\ncase 1:\nreturn G__10906__1.call(this,x);\ncase 2:\nreturn G__10906__2.call(this,x,start__$1);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10906.cljs$core$IFn$_invoke$arity$1 \x3d G__10906__1;\nG__10906.cljs$core$IFn$_invoke$arity$2 \x3d G__10906__2;\nreturn G__10906;\n})()\n;\n\ncljs.core.Subvec.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.Subvec.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (coll,k,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(typeof k \x3d\x3d\x3d \'number\'){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 \x3d (function (coll,f,init){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar i \x3d self__.start;\nvar j \x3d (0);\nvar init__$1 \x3d init;\nwhile(true){\nif((i \x3c self__.end)){\nvar init__$2 \x3d (function (){var G__10899 \x3d init__$1;\nvar G__10900 \x3d j;\nvar G__10901 \x3d cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.v,i);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10899,G__10900,G__10901) : f.call(null,G__10899,G__10900,G__10901));\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__10907 \x3d (i + (1));\nvar G__10908 \x3d (j + (1));\nvar G__10909 \x3d init__$2;\ni \x3d G__10907;\nj \x3d G__10908;\ninit__$1 \x3d G__10909;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (coll,n){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((((n \x3c (0))) || ((self__.end \x3c\x3d (self__.start + n))))){\nreturn cljs.core.vector_index_out_of_bounds(n,(self__.end - self__.start));\n} else {\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.v,(self__.start + n));\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (coll,n,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((((n \x3c (0))) || ((self__.end \x3c\x3d (self__.start + n))))){\nreturn not_found;\n} else {\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3(self__.v,(self__.start + n),not_found);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IVector$_assoc_n$arity$3 \x3d (function (coll,n,val){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar v_pos \x3d (self__.start + n);\nif((((n \x3c (0))) || (((self__.end + (1)) \x3c\x3d v_pos)))){\nthrow (new Error(["Index ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(n)," out of bounds [0,",cljs.core.str.cljs$core$IFn$_invoke$arity$1(coll__$1.cljs$core$ICounted$_count$arity$1(null)),"]"].join(\'\')));\n} else {\nreturn cljs.core.build_subvec(self__.meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.v,v_pos,val),self__.start,(function (){var x__4219__auto__ \x3d self__.end;\nvar y__4220__auto__ \x3d (v_pos + (1));\nreturn ((x__4219__auto__ \x3e y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})(),null);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((((!((self__.v \x3d\x3d null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d self__.v.cljs$core$APersistentVector$))))?true:false):false)){\nreturn cljs.core.ranged_iterator(self__.v,self__.start,self__.end);\n} else {\nreturn cljs.core.seq_iter(coll__$1);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.Subvec.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.Subvec(self__.meta,self__.v,self__.start,self__.end,self__.__hash));\n});\n\ncljs.core.Subvec.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (self__.end - self__.start);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IStack$_peek$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.v,(self__.end - (1)));\n});\n\ncljs.core.Subvec.prototype.cljs$core$IStack$_pop$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.start \x3d\x3d\x3d self__.end)){\nthrow (new Error("Can\'t pop empty vector"));\n} else {\nreturn cljs.core.build_subvec(self__.meta,self__.v,self__.start,(self__.end - (1)),null);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IReversible$_rseq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((!((self__.start \x3d\x3d\x3d self__.end)))){\nreturn (new cljs.core.RSeq(coll__$1,((self__.end - self__.start) - (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((((!((self__.v \x3d\x3d null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d self__.v.cljs$core$APersistentVector$))))?true:false):false)){\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4(self__.v,f,self__.start,self__.end);\n} else {\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(coll__$1,f);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,init){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((((!((self__.v \x3d\x3d null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d self__.v.cljs$core$APersistentVector$))))?true:false):false)){\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5(self__.v,f,init,self__.start,self__.end);\n} else {\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(coll__$1,f,init);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IAssociative$_assoc$arity$3 \x3d (function (coll,key,val){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(typeof key \x3d\x3d\x3d \'number\'){\nreturn coll__$1.cljs$core$IVector$_assoc_n$arity$3(null,key,val);\n} else {\nthrow (new Error("Subvec\'s key for assoc must be a number."));\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar subvec_seq \x3d ((function (coll__$1){\nreturn (function cljs$core$subvec_seq(i){\nif((i \x3d\x3d\x3d self__.end)){\nreturn null;\n} else {\nreturn cljs.core.cons(cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.v,i),(new cljs.core.LazySeq(null,((function (coll__$1){\nreturn (function (){\nreturn cljs$core$subvec_seq((i + (1)));\n});})(coll__$1))\n,null,null)));\n}\n});})(coll__$1))\n;\nreturn subvec_seq(self__.start);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn cljs.core.build_subvec(new_meta,self__.v,self__.start,self__.end,self__.__hash);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.build_subvec(self__.meta,cljs.core._assoc_n(self__.v,self__.end,o),self__.start,(self__.end + (1)),null);\n});\n\ncljs.core.Subvec.prototype.call \x3d (function() {\nvar G__10910 \x3d null;\nvar G__10910__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__10910__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__10910 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__10910__2.call(this,self__,k);\ncase 3:\nreturn G__10910__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__10910.cljs$core$IFn$_invoke$arity$2 \x3d G__10910__2;\nG__10910.cljs$core$IFn$_invoke$arity$3 \x3d G__10910__3;\nreturn G__10910;\n})()\n;\n\ncljs.core.Subvec.prototype.apply \x3d (function (self__,args10898){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args10898)));\n});\n\ncljs.core.Subvec.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.Subvec.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$v,cljs.core.cst$sym$start,cljs.core.cst$sym$end,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Subvec.cljs$lang$type \x3d true;\n\ncljs.core.Subvec.cljs$lang$ctorStr \x3d "cljs.core/Subvec";\n\ncljs.core.Subvec.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Subvec");\n});\n\n/**\n * Positional factory function for cljs.core/Subvec.\n */\ncljs.core.__GT_Subvec \x3d (function cljs$core$__GT_Subvec(meta,v,start,end,__hash){\nreturn (new cljs.core.Subvec(meta,v,start,end,__hash));\n});\n\nvar G__10911_10914 \x3d cljs.core.Subvec.prototype;\nvar G__10912_10915 \x3d cljs.core.ITER_SYMBOL;\nvar G__10913_10916 \x3d ((function (G__10911_10914,G__10912_10915){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10911_10914,G__10912_10915))\n;\ngoog.object.set(G__10911_10914,G__10912_10915,G__10913_10916);\ncljs.core.build_subvec \x3d (function cljs$core$build_subvec(meta,v,start,end,__hash){\nwhile(true){\nif((v instanceof cljs.core.Subvec)){\nvar G__10917 \x3d meta;\nvar G__10918 \x3d v.v;\nvar G__10919 \x3d (v.start + start);\nvar G__10920 \x3d (v.start + end);\nvar G__10921 \x3d __hash;\nmeta \x3d G__10917;\nv \x3d G__10918;\nstart \x3d G__10919;\nend \x3d G__10920;\n__hash \x3d G__10921;\ncontinue;\n} else {\nif(cljs.core.vector_QMARK_(v)){\n} else {\nthrow (new Error("v must satisfy IVector"));\n}\n\nvar c_10922 \x3d cljs.core.count(v);\nif((((start \x3c (0))) || ((end \x3c (0))) || ((start \x3e c_10922)) || ((end \x3e c_10922)))){\nthrow (new Error("Index out of bounds"));\n} else {\n}\n\nreturn (new cljs.core.Subvec(meta,v,start,end,__hash));\n}\nbreak;\n}\n});\n/**\n * Returns a persistent vector of the items in vector from\n *   start (inclusive) to end (exclusive).  If end is not supplied,\n *   defaults to (count vector). This operation is O(1) and very fast, as\n *   the resulting vector shares structure with the original and no\n *   trimming is done.\n */\ncljs.core.subvec \x3d (function cljs$core$subvec(var_args){\nvar G__10924 \x3d arguments.length;\nswitch (G__10924) {\ncase 2:\nreturn cljs.core.subvec.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.subvec.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.subvec.cljs$core$IFn$_invoke$arity$2 \x3d (function (v,start){\nreturn cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(v,start,cljs.core.count(v));\n});\n\ncljs.core.subvec.cljs$core$IFn$_invoke$arity$3 \x3d (function (v,start,end){\nif((((!((start \x3d\x3d null)))) \x26\x26 ((!((end \x3d\x3d null)))))){\n} else {\nthrow (new Error("Assert failed: (and (not (nil? start)) (not (nil? end)))"));\n}\n\nreturn cljs.core.build_subvec(null,v,(start | (0)),(end | (0)),null);\n});\n\ncljs.core.subvec.cljs$lang$maxFixedArity \x3d 3;\n\ncljs.core.tv_ensure_editable \x3d (function cljs$core$tv_ensure_editable(edit,node){\nif((edit \x3d\x3d\x3d node.edit)){\nreturn node;\n} else {\nreturn (new cljs.core.VectorNode(edit,cljs.core.aclone(node.arr)));\n}\n});\ncljs.core.tv_editable_root \x3d (function cljs$core$tv_editable_root(node){\nreturn (new cljs.core.VectorNode(({}),cljs.core.aclone(node.arr)));\n});\ncljs.core.tv_editable_tail \x3d (function cljs$core$tv_editable_tail(tl){\nvar ret \x3d [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\ncljs.core.array_copy(tl,(0),ret,(0),tl.length);\n\nreturn ret;\n});\ncljs.core.tv_push_tail \x3d (function cljs$core$tv_push_tail(tv,level,parent,tail_node){\nvar ret \x3d cljs.core.tv_ensure_editable(tv.root.edit,parent);\nvar subidx \x3d (((tv.cnt - (1)) \x3e\x3e\x3e level) \x26 (31));\ncljs.core.pv_aset(ret,subidx,(((level \x3d\x3d\x3d (5)))?tail_node:(function (){var child \x3d cljs.core.pv_aget(ret,subidx);\nif((!((child \x3d\x3d null)))){\nvar G__10928 \x3d tv;\nvar G__10929 \x3d (level - (5));\nvar G__10930 \x3d child;\nvar G__10931 \x3d tail_node;\nreturn (cljs.core.tv_push_tail.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tv_push_tail.cljs$core$IFn$_invoke$arity$4(G__10928,G__10929,G__10930,G__10931) : cljs.core.tv_push_tail.call(null,G__10928,G__10929,G__10930,G__10931));\n} else {\nreturn cljs.core.new_path(tv.root.edit,(level - (5)),tail_node);\n}\n})()));\n\nreturn ret;\n});\ncljs.core.tv_pop_tail \x3d (function cljs$core$tv_pop_tail(tv,level,node){\nvar node__$1 \x3d cljs.core.tv_ensure_editable(tv.root.edit,node);\nvar subidx \x3d (((tv.cnt - (2)) \x3e\x3e\x3e level) \x26 (31));\nif((level \x3e (5))){\nvar new_child \x3d (function (){var G__10932 \x3d tv;\nvar G__10933 \x3d (level - (5));\nvar G__10934 \x3d cljs.core.pv_aget(node__$1,subidx);\nreturn (cljs.core.tv_pop_tail.cljs$core$IFn$_invoke$arity$3 ? cljs.core.tv_pop_tail.cljs$core$IFn$_invoke$arity$3(G__10932,G__10933,G__10934) : cljs.core.tv_pop_tail.call(null,G__10932,G__10933,G__10934));\n})();\nif((((new_child \x3d\x3d null)) \x26\x26 ((subidx \x3d\x3d\x3d (0))))){\nreturn null;\n} else {\ncljs.core.pv_aset(node__$1,subidx,new_child);\n\nreturn node__$1;\n}\n} else {\nif((subidx \x3d\x3d\x3d (0))){\nreturn null;\n} else {\ncljs.core.pv_aset(node__$1,subidx,null);\n\nreturn node__$1;\n\n}\n}\n});\ncljs.core.unchecked_editable_array_for \x3d (function cljs$core$unchecked_editable_array_for(tv,i){\nif((i \x3e\x3d cljs.core.tail_off(tv))){\nreturn tv.tail;\n} else {\nvar root \x3d tv.root;\nvar node \x3d root;\nvar level \x3d tv.shift;\nwhile(true){\nif((level \x3e (0))){\nvar G__10935 \x3d cljs.core.tv_ensure_editable(root.edit,cljs.core.pv_aget(node,((i \x3e\x3e\x3e level) \x26 (31))));\nvar G__10936 \x3d (level - (5));\nnode \x3d G__10935;\nlevel \x3d G__10936;\ncontinue;\n} else {\nreturn node.arr;\n}\nbreak;\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ITransientCollection}\n * @implements {cljs.core.ITransientVector}\n * @implements {cljs.core.ITransientAssociative}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TransientVector \x3d (function (cnt,shift,root,tail){\nthis.cnt \x3d cnt;\nthis.shift \x3d shift;\nthis.root \x3d root;\nthis.tail \x3d tail;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 88;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 275;\n});\ncljs.core.TransientVector.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 \x3d (function (tcoll,o){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(self__.root.edit){\nif(((self__.cnt - cljs.core.tail_off(tcoll__$1)) \x3c (32))){\n(self__.tail[(self__.cnt \x26 (31))] \x3d o);\n\nself__.cnt \x3d (self__.cnt + (1));\n\nreturn tcoll__$1;\n} else {\nvar tail_node \x3d (new cljs.core.VectorNode(self__.root.edit,self__.tail));\nvar new_tail \x3d [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(new_tail[(0)] \x3d o);\n\nself__.tail \x3d new_tail;\n\nif(((self__.cnt \x3e\x3e\x3e (5)) \x3e ((1) \x3c\x3c self__.shift))){\nvar new_root_array \x3d [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_shift \x3d (self__.shift + (5));\n(new_root_array[(0)] \x3d self__.root);\n\n(new_root_array[(1)] \x3d cljs.core.new_path(self__.root.edit,self__.shift,tail_node));\n\nself__.root \x3d (new cljs.core.VectorNode(self__.root.edit,new_root_array));\n\nself__.shift \x3d new_shift;\n\nself__.cnt \x3d (self__.cnt + (1));\n\nreturn tcoll__$1;\n} else {\nvar new_root \x3d cljs.core.tv_push_tail(tcoll__$1,self__.shift,self__.root,tail_node);\nself__.root \x3d new_root;\n\nself__.cnt \x3d (self__.cnt + (1));\n\nreturn tcoll__$1;\n}\n}\n} else {\nthrow (new Error("conj! after persistent!"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 \x3d (function (tcoll){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(self__.root.edit){\nself__.root.edit \x3d null;\n\nvar len \x3d (self__.cnt - cljs.core.tail_off(tcoll__$1));\nvar trimmed_tail \x3d (new Array(len));\ncljs.core.array_copy(self__.tail,(0),trimmed_tail,(0),len);\n\nreturn (new cljs.core.PersistentVector(null,self__.cnt,self__.shift,self__.root,trimmed_tail,null));\n} else {\nthrow (new Error("persistent! called twice"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 \x3d (function (tcoll,key,val){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(typeof key \x3d\x3d\x3d \'number\'){\nreturn tcoll__$1.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3(null,key,val);\n} else {\nthrow (new Error("TransientVector\'s key for assoc! must be a number."));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3 \x3d (function (tcoll,n,val){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(self__.root.edit){\nif(((((0) \x3c\x3d n)) \x26\x26 ((n \x3c self__.cnt)))){\nif((cljs.core.tail_off(tcoll__$1) \x3c\x3d n)){\n(self__.tail[(n \x26 (31))] \x3d val);\n\nreturn tcoll__$1;\n} else {\nvar new_root \x3d (function (){var fexpr__10938 \x3d ((function (tcoll__$1){\nreturn (function cljs$core$go(level,node){\nvar node__$1 \x3d cljs.core.tv_ensure_editable(self__.root.edit,node);\nif((level \x3d\x3d\x3d (0))){\ncljs.core.pv_aset(node__$1,(n \x26 (31)),val);\n\nreturn node__$1;\n} else {\nvar subidx \x3d ((n \x3e\x3e\x3e level) \x26 (31));\ncljs.core.pv_aset(node__$1,subidx,cljs$core$go((level - (5)),cljs.core.pv_aget(node__$1,subidx)));\n\nreturn node__$1;\n}\n});})(tcoll__$1))\n;\nreturn fexpr__10938(self__.shift,self__.root);\n})();\nself__.root \x3d new_root;\n\nreturn tcoll__$1;\n}\n} else {\nif((n \x3d\x3d\x3d self__.cnt)){\nreturn tcoll__$1.cljs$core$ITransientCollection$_conj_BANG_$arity$2(null,val);\n} else {\nthrow (new Error(["Index ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(n)," out of bounds for TransientVector of length",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.cnt)].join(\'\')));\n\n}\n}\n} else {\nthrow (new Error("assoc! after persistent!"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ITransientVector$_pop_BANG_$arity$1 \x3d (function (tcoll){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(self__.root.edit){\nif((self__.cnt \x3d\x3d\x3d (0))){\nthrow (new Error("Can\'t pop empty vector"));\n} else {\nif(((1) \x3d\x3d\x3d self__.cnt)){\nself__.cnt \x3d (0);\n\nreturn tcoll__$1;\n} else {\nif((((self__.cnt - (1)) \x26 (31)) \x3e (0))){\nself__.cnt \x3d (self__.cnt - (1));\n\nreturn tcoll__$1;\n} else {\nvar new_tail \x3d cljs.core.unchecked_editable_array_for(tcoll__$1,(self__.cnt - (2)));\nvar new_root \x3d (function (){var nr \x3d cljs.core.tv_pop_tail(tcoll__$1,self__.shift,self__.root);\nif((!((nr \x3d\x3d null)))){\nreturn nr;\n} else {\nreturn (new cljs.core.VectorNode(self__.root.edit,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]));\n}\n})();\nif(((((5) \x3c self__.shift)) \x26\x26 ((cljs.core.pv_aget(new_root,(1)) \x3d\x3d null)))){\nvar new_root__$1 \x3d cljs.core.tv_ensure_editable(self__.root.edit,cljs.core.pv_aget(new_root,(0)));\nself__.root \x3d new_root__$1;\n\nself__.shift \x3d (self__.shift - (5));\n\nself__.cnt \x3d (self__.cnt - (1));\n\nself__.tail \x3d new_tail;\n\nreturn tcoll__$1;\n} else {\nself__.root \x3d new_root;\n\nself__.cnt \x3d (self__.cnt - (1));\n\nself__.tail \x3d new_tail;\n\nreturn tcoll__$1;\n}\n\n}\n}\n}\n} else {\nthrow (new Error("pop! after persistent!"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(self__.root.edit){\nreturn self__.cnt;\n} else {\nthrow (new Error("count after persistent!"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (coll,n){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(self__.root.edit){\nreturn (cljs.core.array_for(coll__$1,n)[(n \x26 (31))]);\n} else {\nthrow (new Error("nth after persistent!"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (coll,n,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((((0) \x3c\x3d n)) \x26\x26 ((n \x3c self__.cnt)))){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$2(null,n);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (coll,k,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(typeof k \x3d\x3d\x3d \'number\'){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.TransientVector.prototype.call \x3d (function() {\nvar G__10939 \x3d null;\nvar G__10939__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__10939__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__10939 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__10939__2.call(this,self__,k);\ncase 3:\nreturn G__10939__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__10939.cljs$core$IFn$_invoke$arity$2 \x3d G__10939__2;\nG__10939.cljs$core$IFn$_invoke$arity$3 \x3d G__10939__3;\nreturn G__10939;\n})()\n;\n\ncljs.core.TransientVector.prototype.apply \x3d (function (self__,args10937){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args10937)));\n});\n\ncljs.core.TransientVector.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.TransientVector.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.TransientVector.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$cnt,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$shift,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$root,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$tail,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.TransientVector.cljs$lang$type \x3d true;\n\ncljs.core.TransientVector.cljs$lang$ctorStr \x3d "cljs.core/TransientVector";\n\ncljs.core.TransientVector.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/TransientVector");\n});\n\n/**\n * Positional factory function for cljs.core/TransientVector.\n */\ncljs.core.__GT_TransientVector \x3d (function cljs$core$__GT_TransientVector(cnt,shift,root,tail){\nreturn (new cljs.core.TransientVector(cnt,shift,root,tail));\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.PersistentQueueIter \x3d (function (fseq,riter){\nthis.fseq \x3d fseq;\nthis.riter \x3d riter;\n});\ncljs.core.PersistentQueueIter.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar or__4131__auto__ \x3d (((!((self__.fseq \x3d\x3d null)))) \x26\x26 (cljs.core.seq(self__.fseq)));\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar and__4120__auto__ \x3d (!((self__.riter \x3d\x3d null)));\nif(and__4120__auto__){\nreturn self__.riter.hasNext();\n} else {\nreturn and__4120__auto__;\n}\n}\n});\n\ncljs.core.PersistentQueueIter.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nif((!((self__.fseq \x3d\x3d null)))){\nvar ret \x3d cljs.core.first(self__.fseq);\nself__.fseq \x3d cljs.core.next(self__.fseq);\n\nreturn ret;\n} else {\nif((((!((self__.riter \x3d\x3d null)))) \x26\x26 (self__.riter.hasNext()))){\nreturn self__.riter.next();\n} else {\nthrow (new Error("No such element"));\n\n}\n}\n});\n\ncljs.core.PersistentQueueIter.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.PersistentQueueIter.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$fseq,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.cst$sym$riter], null);\n});\n\ncljs.core.PersistentQueueIter.cljs$lang$type \x3d true;\n\ncljs.core.PersistentQueueIter.cljs$lang$ctorStr \x3d "cljs.core/PersistentQueueIter";\n\ncljs.core.PersistentQueueIter.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentQueueIter");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentQueueIter.\n */\ncljs.core.__GT_PersistentQueueIter \x3d (function cljs$core$__GT_PersistentQueueIter(fseq,riter){\nreturn (new cljs.core.PersistentQueueIter(fseq,riter));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.PersistentQueueSeq \x3d (function (meta,front,rear,__hash){\nthis.meta \x3d meta;\nthis.front \x3d front;\nthis.rear \x3d rear;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 31850700;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.PersistentQueueSeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentQueueSeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentQueueSeq.prototype.indexOf \x3d (function() {\nvar G__10940 \x3d null;\nvar G__10940__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10940__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10940 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10940__1.call(this,x);\ncase 2:\nreturn G__10940__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10940.cljs$core$IFn$_invoke$arity$1 \x3d G__10940__1;\nG__10940.cljs$core$IFn$_invoke$arity$2 \x3d G__10940__2;\nreturn G__10940;\n})()\n;\n\ncljs.core.PersistentQueueSeq.prototype.lastIndexOf \x3d (function() {\nvar G__10941 \x3d null;\nvar G__10941__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10941__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10941 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10941__1.call(this,x);\ncase 2:\nreturn G__10941__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10941.cljs$core$IFn$_invoke$arity$1 \x3d G__10941__1;\nG__10941.cljs$core$IFn$_invoke$arity$2 \x3d G__10941__2;\nreturn G__10941;\n})()\n;\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar temp__5718__auto__ \x3d cljs.core.next(self__.front);\nif(temp__5718__auto__){\nvar f1 \x3d temp__5718__auto__;\nreturn (new cljs.core.PersistentQueueSeq(self__.meta,f1,self__.rear,null));\n} else {\nif((!((self__.rear \x3d\x3d null)))){\nreturn (new cljs.core.PersistentQueueSeq(self__.meta,self__.rear,null,null));\n} else {\nreturn null;\n}\n}\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.List.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.first(self__.front);\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar temp__5718__auto__ \x3d cljs.core.next(self__.front);\nif(temp__5718__auto__){\nvar f1 \x3d temp__5718__auto__;\nreturn (new cljs.core.PersistentQueueSeq(self__.meta,f1,self__.rear,null));\n} else {\nif((self__.rear \x3d\x3d null)){\nreturn coll__$1.cljs$core$IEmptyableCollection$_empty$arity$1(null);\n} else {\nreturn (new cljs.core.PersistentQueueSeq(self__.meta,self__.rear,null,null));\n}\n}\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentQueueSeq(new_meta,self__.front,self__.rear,self__.__hash));\n}\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.PersistentQueueSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$front,cljs.core.cst$sym$rear,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.PersistentQueueSeq.cljs$lang$type \x3d true;\n\ncljs.core.PersistentQueueSeq.cljs$lang$ctorStr \x3d "cljs.core/PersistentQueueSeq";\n\ncljs.core.PersistentQueueSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentQueueSeq");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentQueueSeq.\n */\ncljs.core.__GT_PersistentQueueSeq \x3d (function cljs$core$__GT_PersistentQueueSeq(meta,front,rear,__hash){\nreturn (new cljs.core.PersistentQueueSeq(meta,front,rear,__hash));\n});\n\nvar G__10942_10945 \x3d cljs.core.PersistentQueueSeq.prototype;\nvar G__10943_10946 \x3d cljs.core.ITER_SYMBOL;\nvar G__10944_10947 \x3d ((function (G__10942_10945,G__10943_10946){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10942_10945,G__10943_10946))\n;\ngoog.object.set(G__10942_10945,G__10943_10946,G__10944_10947);\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.PersistentQueue \x3d (function (meta,count,front,rear,__hash){\nthis.meta \x3d meta;\nthis.count \x3d count;\nthis.front \x3d front;\nthis.rear \x3d rear;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 139264;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 31858766;\n});\ncljs.core.PersistentQueue.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentQueue.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentQueue.prototype.indexOf \x3d (function() {\nvar G__10948 \x3d null;\nvar G__10948__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10948__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10948 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10948__1.call(this,x);\ncase 2:\nreturn G__10948__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10948.cljs$core$IFn$_invoke$arity$1 \x3d G__10948__1;\nG__10948.cljs$core$IFn$_invoke$arity$2 \x3d G__10948__2;\nreturn G__10948;\n})()\n;\n\ncljs.core.PersistentQueue.prototype.lastIndexOf \x3d (function() {\nvar G__10949 \x3d null;\nvar G__10949__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(self__.count.cljs$core$IFn$_invoke$arity$1 ? self__.count.cljs$core$IFn$_invoke$arity$1(coll) : self__.count.call(null,coll)));\n});\nvar G__10949__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10949 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10949__1.call(this,x);\ncase 2:\nreturn G__10949__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10949.cljs$core$IFn$_invoke$arity$1 \x3d G__10949__1;\nG__10949.cljs$core$IFn$_invoke$arity$2 \x3d G__10949__2;\nreturn G__10949;\n})()\n;\n\ncljs.core.PersistentQueue.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.PersistentQueueIter(self__.front,cljs.core._iterator(self__.rear)));\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.PersistentQueue(self__.meta,self__.count,self__.front,self__.rear,self__.__hash));\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.count;\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IStack$_peek$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.first(self__.front);\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IStack$_pop$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(cljs.core.truth_(self__.front)){\nvar temp__5718__auto__ \x3d cljs.core.next(self__.front);\nif(temp__5718__auto__){\nvar f1 \x3d temp__5718__auto__;\nreturn (new cljs.core.PersistentQueue(self__.meta,(self__.count - (1)),f1,self__.rear,null));\n} else {\nreturn (new cljs.core.PersistentQueue(self__.meta,(self__.count - (1)),cljs.core.seq(self__.rear),cljs.core.PersistentVector.EMPTY,null));\n}\n} else {\nreturn coll__$1;\n}\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.PersistentQueue.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.first(self__.front);\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.rest(cljs.core.seq(coll__$1));\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar rear__$1 \x3d cljs.core.seq(self__.rear);\nif(cljs.core.truth_((function (){var or__4131__auto__ \x3d self__.front;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn rear__$1;\n}\n})())){\nreturn (new cljs.core.PersistentQueueSeq(null,self__.front,cljs.core.seq(rear__$1),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentQueue(new_meta,self__.count,self__.front,self__.rear,self__.__hash));\n}\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(cljs.core.truth_(self__.front)){\nreturn (new cljs.core.PersistentQueue(self__.meta,(self__.count + (1)),self__.front,cljs.core.conj.cljs$core$IFn$_invoke$arity$2((function (){var or__4131__auto__ \x3d self__.rear;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.PersistentVector.EMPTY;\n}\n})(),o),null));\n} else {\nreturn (new cljs.core.PersistentQueue(self__.meta,(self__.count + (1)),cljs.core.conj.cljs$core$IFn$_invoke$arity$2(self__.front,o),cljs.core.PersistentVector.EMPTY,null));\n}\n});\n\ncljs.core.PersistentQueue.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$count,cljs.core.cst$sym$front,cljs.core.cst$sym$rear,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.PersistentQueue.cljs$lang$type \x3d true;\n\ncljs.core.PersistentQueue.cljs$lang$ctorStr \x3d "cljs.core/PersistentQueue";\n\ncljs.core.PersistentQueue.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentQueue");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentQueue.\n */\ncljs.core.__GT_PersistentQueue \x3d (function cljs$core$__GT_PersistentQueue(meta,count,front,rear,__hash){\nreturn (new cljs.core.PersistentQueue(meta,count,front,rear,__hash));\n});\n\ncljs.core.PersistentQueue.EMPTY \x3d (new cljs.core.PersistentQueue(null,(0),null,cljs.core.PersistentVector.EMPTY,cljs.core.empty_ordered_hash));\nvar G__10950_10953 \x3d cljs.core.PersistentQueue.prototype;\nvar G__10951_10954 \x3d cljs.core.ITER_SYMBOL;\nvar G__10952_10955 \x3d ((function (G__10950_10953,G__10951_10954){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__10950_10953,G__10951_10954))\n;\ngoog.object.set(G__10950_10953,G__10951_10954,G__10952_10955);\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n*/\ncljs.core.NeverEquiv \x3d (function (){\nthis.cljs$lang$protocol_mask$partition0$ \x3d 2097152;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.NeverEquiv.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.NeverEquiv.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (o,other){\nvar self__ \x3d this;\nvar o__$1 \x3d this;\nreturn false;\n});\n\ncljs.core.NeverEquiv.getBasis \x3d (function (){\nreturn cljs.core.PersistentVector.EMPTY;\n});\n\ncljs.core.NeverEquiv.cljs$lang$type \x3d true;\n\ncljs.core.NeverEquiv.cljs$lang$ctorStr \x3d "cljs.core/NeverEquiv";\n\ncljs.core.NeverEquiv.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/NeverEquiv");\n});\n\n/**\n * Positional factory function for cljs.core/NeverEquiv.\n */\ncljs.core.__GT_NeverEquiv \x3d (function cljs$core$__GT_NeverEquiv(){\nreturn (new cljs.core.NeverEquiv());\n});\n\ncljs.core.never_equiv \x3d (new cljs.core.NeverEquiv());\n/**\n * Test map equivalence. Returns true if x equals y, otherwise returns false.\n */\ncljs.core.equiv_map \x3d (function cljs$core$equiv_map(x,y){\nreturn cljs.core.boolean$(((((cljs.core.map_QMARK_(y)) \x26\x26 ((!(cljs.core.record_QMARK_(y))))))?(((cljs.core.count(x) \x3d\x3d\x3d cljs.core.count(y)))?(((((!((x \x3d\x3d null))))?(((((x.cljs$lang$protocol_mask$partition0$ \x26 (1048576))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IKVReduce$))))?true:(((!x.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.IKVReduce,x):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IKVReduce,x)))?cljs.core.reduce_kv((function (_,k,v){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(y,k,cljs.core.never_equiv),v)){\nreturn true;\n} else {\nreturn cljs.core.reduced(false);\n}\n}),true,x):cljs.core.every_QMARK_((function (xkv){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(y,cljs.core.first(xkv),cljs.core.never_equiv),cljs.core.second(xkv));\n}),x)):null):null));\n});\ncljs.core.scan_array \x3d (function cljs$core$scan_array(incr,k,array){\nvar len \x3d array.length;\nvar i \x3d (0);\nwhile(true){\nif((i \x3c len)){\nif((k \x3d\x3d\x3d (array[i]))){\nreturn i;\n} else {\nvar G__10957 \x3d (i + incr);\ni \x3d G__10957;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\ncljs.core.obj_map_compare_keys \x3d (function cljs$core$obj_map_compare_keys(a,b){\nvar a__$1 \x3d cljs.core.hash(a);\nvar b__$1 \x3d cljs.core.hash(b);\nif((a__$1 \x3c b__$1)){\nreturn (-1);\n} else {\nif((a__$1 \x3e b__$1)){\nreturn (1);\n} else {\nreturn (0);\n\n}\n}\n});\ncljs.core.obj_map__GT_hash_map \x3d (function cljs$core$obj_map__GT_hash_map(m,k,v){\nvar ks \x3d m.keys;\nvar len \x3d ks.length;\nvar so \x3d m.strobj;\nvar mm \x3d cljs.core.meta(m);\nvar i \x3d (0);\nvar out \x3d cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nwhile(true){\nif((i \x3c len)){\nvar k__$1 \x3d (ks[i]);\nvar G__10958 \x3d (i + (1));\nvar G__10959 \x3d cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(out,k__$1,goog.object.get(so,k__$1));\ni \x3d G__10958;\nout \x3d G__10959;\ncontinue;\n} else {\nreturn cljs.core._with_meta(cljs.core.persistent_BANG_(cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(out,k,v)),mm);\n}\nbreak;\n}\n});\ncljs.core.obj_clone \x3d (function cljs$core$obj_clone(obj,ks){\nvar new_obj \x3d ({});\nvar l \x3d ks.length;\nvar i_10965 \x3d (0);\nwhile(true){\nif((i_10965 \x3c l)){\nvar k_10966 \x3d (ks[i_10965]);\nvar G__10962_10967 \x3d new_obj;\nvar G__10963_10968 \x3d k_10966;\nvar G__10964_10969 \x3d goog.object.get(obj,k_10966);\ngoog.object.set(G__10962_10967,G__10963_10968,G__10964_10969);\n\nvar G__10970 \x3d (i_10965 + (1));\ni_10965 \x3d G__10970;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn new_obj;\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.ObjMap \x3d (function (meta,keys,strobj,update_count,__hash){\nthis.meta \x3d meta;\nthis.keys \x3d keys;\nthis.strobj \x3d strobj;\nthis.update_count \x3d update_count;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 16123663;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 4;\n});\ncljs.core.ObjMap.prototype.cljs$core$IFind$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ObjMap.prototype.cljs$core$IFind$_find$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((goog.isString(k)) \x26\x26 ((!((cljs.core.scan_array((1),k,self__.keys) \x3d\x3d null)))))){\nreturn (new cljs.core.MapEntry(k,(self__.strobj[k]),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.ObjMap.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ObjMap.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (coll,k,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((goog.isString(k)) \x26\x26 ((!((cljs.core.scan_array((1),k,self__.keys) \x3d\x3d null)))))){\nreturn (self__.strobj[k]);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 \x3d (function (coll,f,init){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar len \x3d self__.keys.length;\nvar keys__$1 \x3d self__.keys.sort(cljs.core.obj_map_compare_keys);\nvar init__$1 \x3d init;\nwhile(true){\nif(cljs.core.seq(keys__$1)){\nvar k \x3d cljs.core.first(keys__$1);\nvar init__$2 \x3d (function (){var G__10973 \x3d init__$1;\nvar G__10974 \x3d k;\nvar G__10975 \x3d (self__.strobj[k]);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__10973,G__10974,G__10975) : f.call(null,G__10973,G__10974,G__10975));\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__10976 \x3d cljs.core.rest(keys__$1);\nvar G__10977 \x3d init__$2;\nkeys__$1 \x3d G__10976;\ninit__$1 \x3d G__10977;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.keys.length;\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_map(coll__$1,other);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.transient$(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashMap.EMPTY,coll__$1));\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.ObjMap.EMPTY,self__.meta);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IMap$_dissoc$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((goog.isString(k)) \x26\x26 ((!((cljs.core.scan_array((1),k,self__.keys) \x3d\x3d null)))))){\nvar new_keys \x3d cljs.core.aclone(self__.keys);\nvar new_strobj \x3d cljs.core.obj_clone(self__.strobj,self__.keys);\nnew_keys.splice(cljs.core.scan_array((1),k,new_keys),(1));\n\ndelete new_strobj[k];\n\nreturn (new cljs.core.ObjMap(self__.meta,new_keys,new_strobj,(self__.update_count + (1)),null));\n} else {\nreturn coll__$1;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IAssociative$_assoc$arity$3 \x3d (function (coll,k,v){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(goog.isString(k)){\nif((((self__.update_count \x3e cljs.core.ObjMap.HASHMAP_THRESHOLD)) || ((self__.keys.length \x3e\x3d cljs.core.ObjMap.HASHMAP_THRESHOLD)))){\nreturn cljs.core.obj_map__GT_hash_map(coll__$1,k,v);\n} else {\nif((!((cljs.core.scan_array((1),k,self__.keys) \x3d\x3d null)))){\nvar new_strobj \x3d cljs.core.obj_clone(self__.strobj,self__.keys);\ngoog.object.set(new_strobj,k,v);\n\nreturn (new cljs.core.ObjMap(self__.meta,self__.keys,new_strobj,(self__.update_count + (1)),null));\n} else {\nvar new_strobj \x3d cljs.core.obj_clone(self__.strobj,self__.keys);\nvar new_keys \x3d cljs.core.aclone(self__.keys);\ngoog.object.set(new_strobj,k,v);\n\nnew_keys.push(k);\n\nreturn (new cljs.core.ObjMap(self__.meta,new_keys,new_strobj,(self__.update_count + (1)),null));\n}\n}\n} else {\nreturn cljs.core.obj_map__GT_hash_map(coll__$1,k,v);\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((goog.isString(k)) \x26\x26 ((!((cljs.core.scan_array((1),k,self__.keys) \x3d\x3d null)))))){\nreturn true;\n} else {\nreturn false;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.keys.length \x3e (0))){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (coll__$1){\nreturn (function (p1__10971_SHARP_){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__10971_SHARP_,(self__.strobj[p1__10971_SHARP_])],null));\n});})(coll__$1))\n,self__.keys.sort(cljs.core.obj_map_compare_keys));\n} else {\nreturn null;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.ObjMap(new_meta,self__.keys,self__.strobj,self__.update_count,self__.__hash));\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,entry){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(cljs.core.vector_QMARK_(entry)){\nreturn coll__$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(1)));\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,coll__$1,entry);\n}\n});\n\ncljs.core.ObjMap.prototype.call \x3d (function() {\nvar G__10978 \x3d null;\nvar G__10978__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__10978__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__10978 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__10978__2.call(this,self__,k);\ncase 3:\nreturn G__10978__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__10978.cljs$core$IFn$_invoke$arity$2 \x3d G__10978__2;\nG__10978.cljs$core$IFn$_invoke$arity$3 \x3d G__10978__3;\nreturn G__10978;\n})()\n;\n\ncljs.core.ObjMap.prototype.apply \x3d (function (self__,args10972){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args10972)));\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.ObjMap.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$keys,cljs.core.cst$sym$strobj,cljs.core.cst$sym$update_DASH_count,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ObjMap.cljs$lang$type \x3d true;\n\ncljs.core.ObjMap.cljs$lang$ctorStr \x3d "cljs.core/ObjMap";\n\ncljs.core.ObjMap.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ObjMap");\n});\n\n/**\n * Positional factory function for cljs.core/ObjMap.\n */\ncljs.core.__GT_ObjMap \x3d (function cljs$core$__GT_ObjMap(meta,keys,strobj,update_count,__hash){\nreturn (new cljs.core.ObjMap(meta,keys,strobj,update_count,__hash));\n});\n\ncljs.core.ObjMap.EMPTY \x3d (new cljs.core.ObjMap(null,[],({}),(0),cljs.core.empty_unordered_hash));\ncljs.core.ObjMap.HASHMAP_THRESHOLD \x3d (8);\ncljs.core.ObjMap.fromObject \x3d (function (ks,obj){\nreturn (new cljs.core.ObjMap(null,ks,obj,(0),null));\n});\n\n/**\n* @constructor\n*/\ncljs.core.RecordIter \x3d (function (i,record,base_count,fields,ext_map_iter){\nthis.i \x3d i;\nthis.record \x3d record;\nthis.base_count \x3d base_count;\nthis.fields \x3d fields;\nthis.ext_map_iter \x3d ext_map_iter;\n});\ncljs.core.RecordIter.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar or__4131__auto__ \x3d (self__.i \x3c self__.base_count);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn self__.ext_map_iter.hasNext();\n}\n});\n\ncljs.core.RecordIter.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nif((self__.i \x3c self__.base_count)){\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$2(self__.fields,self__.i);\nself__.i \x3d (self__.i + (1));\n\nreturn (new cljs.core.MapEntry(k,cljs.core._lookup.cljs$core$IFn$_invoke$arity$2(self__.record,k),null));\n} else {\nreturn self__.ext_map_iter.next();\n}\n});\n\ncljs.core.RecordIter.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.RecordIter.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$i,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.cst$sym$record,cljs.core.cst$sym$base_DASH_count,cljs.core.cst$sym$fields,cljs.core.cst$sym$ext_DASH_map_DASH_iter], null);\n});\n\ncljs.core.RecordIter.cljs$lang$type \x3d true;\n\ncljs.core.RecordIter.cljs$lang$ctorStr \x3d "cljs.core/RecordIter";\n\ncljs.core.RecordIter.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/RecordIter");\n});\n\n/**\n * Positional factory function for cljs.core/RecordIter.\n */\ncljs.core.__GT_RecordIter \x3d (function cljs$core$__GT_RecordIter(i,record,base_count,fields,ext_map_iter){\nreturn (new cljs.core.RecordIter(i,record,base_count,fields,ext_map_iter));\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.ES6EntriesIterator \x3d (function (s){\nthis.s \x3d s;\n});\ncljs.core.ES6EntriesIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nif((!((self__.s \x3d\x3d null)))){\nvar vec__10981 \x3d cljs.core.first(self__.s);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10981,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__10981,(1),null);\nself__.s \x3d cljs.core.next(self__.s);\n\nreturn ({"value": [k,v], "done": false});\n} else {\nreturn ({"value": null, "done": true});\n}\n});\n\ncljs.core.ES6EntriesIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$s,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ES6EntriesIterator.cljs$lang$type \x3d true;\n\ncljs.core.ES6EntriesIterator.cljs$lang$ctorStr \x3d "cljs.core/ES6EntriesIterator";\n\ncljs.core.ES6EntriesIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ES6EntriesIterator");\n});\n\n/**\n * Positional factory function for cljs.core/ES6EntriesIterator.\n */\ncljs.core.__GT_ES6EntriesIterator \x3d (function cljs$core$__GT_ES6EntriesIterator(s){\nreturn (new cljs.core.ES6EntriesIterator(s));\n});\n\ncljs.core.es6_entries_iterator \x3d (function cljs$core$es6_entries_iterator(coll){\nreturn (new cljs.core.ES6EntriesIterator(cljs.core.seq(coll)));\n});\n\n/**\n* @constructor\n*/\ncljs.core.ES6SetEntriesIterator \x3d (function (s){\nthis.s \x3d s;\n});\ncljs.core.ES6SetEntriesIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nif((!((self__.s \x3d\x3d null)))){\nvar x \x3d cljs.core.first(self__.s);\nself__.s \x3d cljs.core.next(self__.s);\n\nreturn ({"value": [x,x], "done": false});\n} else {\nreturn ({"value": null, "done": true});\n}\n});\n\ncljs.core.ES6SetEntriesIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$s,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ES6SetEntriesIterator.cljs$lang$type \x3d true;\n\ncljs.core.ES6SetEntriesIterator.cljs$lang$ctorStr \x3d "cljs.core/ES6SetEntriesIterator";\n\ncljs.core.ES6SetEntriesIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ES6SetEntriesIterator");\n});\n\n/**\n * Positional factory function for cljs.core/ES6SetEntriesIterator.\n */\ncljs.core.__GT_ES6SetEntriesIterator \x3d (function cljs$core$__GT_ES6SetEntriesIterator(s){\nreturn (new cljs.core.ES6SetEntriesIterator(s));\n});\n\ncljs.core.es6_set_entries_iterator \x3d (function cljs$core$es6_set_entries_iterator(coll){\nreturn (new cljs.core.ES6SetEntriesIterator(cljs.core.seq(coll)));\n});\ncljs.core.array_index_of_nil_QMARK_ \x3d (function cljs$core$array_index_of_nil_QMARK_(arr){\nvar len \x3d arr.length;\nvar i \x3d (0);\nwhile(true){\nif((len \x3c\x3d i)){\nreturn (-1);\n} else {\nif(((arr[i]) \x3d\x3d null)){\nreturn i;\n} else {\nvar G__10984 \x3d (i + (2));\ni \x3d G__10984;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of_keyword_QMARK_ \x3d (function cljs$core$array_index_of_keyword_QMARK_(arr,k){\nvar len \x3d arr.length;\nvar kstr \x3d k.fqn;\nvar i \x3d (0);\nwhile(true){\nif((len \x3c\x3d i)){\nreturn (-1);\n} else {\nif(((((arr[i]) instanceof cljs.core.Keyword)) \x26\x26 ((kstr \x3d\x3d\x3d (arr[i]).fqn)))){\nreturn i;\n} else {\nvar G__10985 \x3d (i + (2));\ni \x3d G__10985;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of_symbol_QMARK_ \x3d (function cljs$core$array_index_of_symbol_QMARK_(arr,k){\nvar len \x3d arr.length;\nvar kstr \x3d k.str;\nvar i \x3d (0);\nwhile(true){\nif((len \x3c\x3d i)){\nreturn (-1);\n} else {\nif(((((arr[i]) instanceof cljs.core.Symbol)) \x26\x26 ((kstr \x3d\x3d\x3d (arr[i]).str)))){\nreturn i;\n} else {\nvar G__10986 \x3d (i + (2));\ni \x3d G__10986;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of_identical_QMARK_ \x3d (function cljs$core$array_index_of_identical_QMARK_(arr,k){\nvar len \x3d arr.length;\nvar i \x3d (0);\nwhile(true){\nif((len \x3c\x3d i)){\nreturn (-1);\n} else {\nif((k \x3d\x3d\x3d (arr[i]))){\nreturn i;\n} else {\nvar G__10987 \x3d (i + (2));\ni \x3d G__10987;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of_equiv_QMARK_ \x3d (function cljs$core$array_index_of_equiv_QMARK_(arr,k){\nvar len \x3d arr.length;\nvar i \x3d (0);\nwhile(true){\nif((len \x3c\x3d i)){\nreturn (-1);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(k,(arr[i]))){\nreturn i;\n} else {\nvar G__10988 \x3d (i + (2));\ni \x3d G__10988;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of \x3d (function cljs$core$array_index_of(arr,k){\nif((k instanceof cljs.core.Keyword)){\nreturn cljs.core.array_index_of_keyword_QMARK_(arr,k);\n} else {\nif(((goog.isString(k)) || (typeof k \x3d\x3d\x3d \'number\'))){\nreturn cljs.core.array_index_of_identical_QMARK_(arr,k);\n} else {\nif((k instanceof cljs.core.Symbol)){\nreturn cljs.core.array_index_of_symbol_QMARK_(arr,k);\n} else {\nif((k \x3d\x3d null)){\nreturn cljs.core.array_index_of_nil_QMARK_(arr);\n} else {\nreturn cljs.core.array_index_of_equiv_QMARK_(arr,k);\n\n}\n}\n}\n}\n});\ncljs.core.array_map_index_of \x3d (function cljs$core$array_map_index_of(m,k){\nreturn cljs.core.array_index_of(m.arr,k);\n});\ncljs.core.array_extend_kv \x3d (function cljs$core$array_extend_kv(arr,k,v){\nvar l \x3d arr.length;\nvar narr \x3d (new Array((l + (2))));\nvar i_10989 \x3d (0);\nwhile(true){\nif((i_10989 \x3c l)){\n(narr[i_10989] \x3d (arr[i_10989]));\n\nvar G__10990 \x3d (i_10989 + (1));\ni_10989 \x3d G__10990;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(narr[l] \x3d k);\n\n(narr[(l + (1))] \x3d v);\n\nreturn narr;\n});\ncljs.core.array_map_extend_kv \x3d (function cljs$core$array_map_extend_kv(m,k,v){\nreturn cljs.core.array_extend_kv(m.arr,k,v);\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IMapEntry}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.MapEntry \x3d (function (key,val,__hash){\nthis.key \x3d key;\nthis.val \x3d val;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 166619935;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.MapEntry.prototype.cljs$core$IFind$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.MapEntry.prototype.cljs$core$IFind$_find$arity$2 \x3d (function (node,k){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nvar G__10992 \x3d k;\nswitch (G__10992) {\ncase (0):\nreturn (new cljs.core.MapEntry((0),self__.key,null));\n\nbreak;\ncase (1):\nreturn (new cljs.core.MapEntry((1),self__.val,null));\n\nbreak;\ndefault:\nreturn null;\n\n}\n});\n\ncljs.core.MapEntry.prototype.indexOf \x3d (function() {\nvar G__10994 \x3d null;\nvar G__10994__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10994__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10994 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10994__1.call(this,x);\ncase 2:\nreturn G__10994__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10994.cljs$core$IFn$_invoke$arity$1 \x3d G__10994__1;\nG__10994.cljs$core$IFn$_invoke$arity$2 \x3d G__10994__2;\nreturn G__10994;\n})()\n;\n\ncljs.core.MapEntry.prototype.lastIndexOf \x3d (function() {\nvar G__10995 \x3d null;\nvar G__10995__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10995__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10995 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10995__1.call(this,x);\ncase 2:\nreturn G__10995__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10995.cljs$core$IFn$_invoke$arity$1 \x3d G__10995__1;\nG__10995.cljs$core$IFn$_invoke$arity$2 \x3d G__10995__2;\nreturn G__10995;\n})()\n;\n\ncljs.core.MapEntry.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (node,k){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,null);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (node,k,not_found){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (node,n){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nif((n \x3d\x3d\x3d (0))){\nreturn self__.key;\n} else {\nif((n \x3d\x3d\x3d (1))){\nreturn self__.val;\n} else {\nthrow (new Error("Index out of bounds"));\n\n}\n}\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (node,n,not_found){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nif((n \x3d\x3d\x3d (0))){\nreturn self__.key;\n} else {\nif((n \x3d\x3d\x3d (1))){\nreturn self__.val;\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IVector$_assoc_n$arity$3 \x3d (function (node,n,v){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null).cljs$core$IVector$_assoc_n$arity$3(null,n,v);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (2);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IMapEntry$_key$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn self__.key;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IMapEntry$_val$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn self__.val;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IStack$_peek$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn self__.val;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IStack$_pop$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key], null);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IReversible$_rseq$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (new cljs.core.IndexedSeq([self__.val,self__.key],(0),null));\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (node,f){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(node__$1,f);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (node,f,start){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(node__$1,f,start);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IAssociative$_assoc$arity$3 \x3d (function (node,k,v){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),k,v);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 \x3d (function (node,k){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (((k \x3d\x3d\x3d (0))) || ((k \x3d\x3d\x3d (1))));\n});\n\ncljs.core.MapEntry.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (new cljs.core.IndexedSeq([self__.key,self__.val],(0),null));\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (node,meta){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.with_meta(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),meta);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (node,o){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val,o], null);\n});\n\ncljs.core.MapEntry.prototype.call \x3d (function() {\nvar G__10996 \x3d null;\nvar G__10996__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar node \x3d self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__10996__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar node \x3d self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__10996 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__10996__2.call(this,self__,k);\ncase 3:\nreturn G__10996__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__10996.cljs$core$IFn$_invoke$arity$2 \x3d G__10996__2;\nG__10996.cljs$core$IFn$_invoke$arity$3 \x3d G__10996__3;\nreturn G__10996;\n})()\n;\n\ncljs.core.MapEntry.prototype.apply \x3d (function (self__,args10991){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args10991)));\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.MapEntry.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$key,cljs.core.cst$sym$val,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.MapEntry.cljs$lang$type \x3d true;\n\ncljs.core.MapEntry.cljs$lang$ctorStr \x3d "cljs.core/MapEntry";\n\ncljs.core.MapEntry.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/MapEntry");\n});\n\n/**\n * Positional factory function for cljs.core/MapEntry.\n */\ncljs.core.__GT_MapEntry \x3d (function cljs$core$__GT_MapEntry(key,val,__hash){\nreturn (new cljs.core.MapEntry(key,val,__hash));\n});\n\n/**\n * Returns true if x satisfies IMapEntry\n */\ncljs.core.map_entry_QMARK_ \x3d (function cljs$core$map_entry_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (2048))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IMapEntry$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.PersistentArrayMapSeq \x3d (function (arr,i,_meta){\nthis.arr \x3d arr;\nthis.i \x3d i;\nthis._meta \x3d _meta;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32374990;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.PersistentArrayMapSeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.indexOf \x3d (function() {\nvar G__10998 \x3d null;\nvar G__10998__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__10998__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10998 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10998__1.call(this,x);\ncase 2:\nreturn G__10998__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10998.cljs$core$IFn$_invoke$arity$1 \x3d G__10998__1;\nG__10998.cljs$core$IFn$_invoke$arity$2 \x3d G__10998__2;\nreturn G__10998;\n})()\n;\n\ncljs.core.PersistentArrayMapSeq.prototype.lastIndexOf \x3d (function() {\nvar G__10999 \x3d null;\nvar G__10999__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__10999__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__10999 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__10999__1.call(this,x);\ncase 2:\nreturn G__10999__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__10999.cljs$core$IFn$_invoke$arity$1 \x3d G__10999__1;\nG__10999.cljs$core$IFn$_invoke$arity$2 \x3d G__10999__2;\nreturn G__10999;\n})()\n;\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__._meta;\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.i \x3c (self__.arr.length - (2)))){\nreturn (new cljs.core.PersistentArrayMapSeq(self__.arr,(self__.i + (2)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn ((self__.arr.length - self__.i) / (2));\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.MapEntry((self__.arr[self__.i]),(self__.arr[(self__.i + (1))]),null));\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.i \x3c (self__.arr.length - (2)))){\nreturn (new cljs.core.PersistentArrayMapSeq(self__.arr,(self__.i + (2)),null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__._meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentArrayMapSeq(self__.arr,self__.i,new_meta));\n}\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$arr,cljs.core.cst$sym$i,cljs.core.cst$sym$_meta], null);\n});\n\ncljs.core.PersistentArrayMapSeq.cljs$lang$type \x3d true;\n\ncljs.core.PersistentArrayMapSeq.cljs$lang$ctorStr \x3d "cljs.core/PersistentArrayMapSeq";\n\ncljs.core.PersistentArrayMapSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentArrayMapSeq");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentArrayMapSeq.\n */\ncljs.core.__GT_PersistentArrayMapSeq \x3d (function cljs$core$__GT_PersistentArrayMapSeq(arr,i,_meta){\nreturn (new cljs.core.PersistentArrayMapSeq(arr,i,_meta));\n});\n\nvar G__11000_11003 \x3d cljs.core.PersistentArrayMapSeq.prototype;\nvar G__11001_11004 \x3d cljs.core.ITER_SYMBOL;\nvar G__11002_11005 \x3d ((function (G__11000_11003,G__11001_11004){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11000_11003,G__11001_11004))\n;\ngoog.object.set(G__11000_11003,G__11001_11004,G__11002_11005);\ncljs.core.persistent_array_map_seq \x3d (function cljs$core$persistent_array_map_seq(arr,i,_meta){\nif((i \x3c\x3d (arr.length - (2)))){\nreturn (new cljs.core.PersistentArrayMapSeq(arr,i,_meta));\n} else {\nreturn null;\n}\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.PersistentArrayMapIterator \x3d (function (arr,i,cnt){\nthis.arr \x3d arr;\nthis.i \x3d i;\nthis.cnt \x3d cnt;\n});\ncljs.core.PersistentArrayMapIterator.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.i \x3c self__.cnt);\n});\n\ncljs.core.PersistentArrayMapIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar ret \x3d (new cljs.core.MapEntry((self__.arr[self__.i]),(self__.arr[(self__.i + (1))]),null));\nself__.i \x3d (self__.i + (2));\n\nreturn ret;\n});\n\ncljs.core.PersistentArrayMapIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$arr,cljs.core.with_meta(cljs.core.cst$sym$i,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.cst$sym$cnt], null);\n});\n\ncljs.core.PersistentArrayMapIterator.cljs$lang$type \x3d true;\n\ncljs.core.PersistentArrayMapIterator.cljs$lang$ctorStr \x3d "cljs.core/PersistentArrayMapIterator";\n\ncljs.core.PersistentArrayMapIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentArrayMapIterator");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentArrayMapIterator.\n */\ncljs.core.__GT_PersistentArrayMapIterator \x3d (function cljs$core$__GT_PersistentArrayMapIterator(arr,i,cnt){\nreturn (new cljs.core.PersistentArrayMapIterator(arr,i,cnt));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.PersistentArrayMap \x3d (function (meta,cnt,arr,__hash){\nthis.meta \x3d meta;\nthis.cnt \x3d cnt;\nthis.arr \x3d arr;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 16647951;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 139268;\n});\ncljs.core.PersistentArrayMap.prototype.cljs$core$IFind$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IFind$_find$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar idx \x3d cljs.core.array_map_index_of(coll__$1,k);\nif((idx \x3d\x3d\x3d (-1))){\nreturn null;\n} else {\nreturn (new cljs.core.MapEntry((self__.arr[idx]),(self__.arr[(idx + (1))]),null));\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentArrayMap.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentArrayMap.prototype.keys \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.keys(coll));\n});\n\ncljs.core.PersistentArrayMap.prototype.entries \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentArrayMap.prototype.values \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.vals(coll));\n});\n\ncljs.core.PersistentArrayMap.prototype.has \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentArrayMap.prototype.get \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentArrayMap.prototype.forEach \x3d (function (f){\nvar self__ \x3d this;\nvar coll \x3d this;\nvar seq__11007 \x3d cljs.core.seq(coll);\nvar chunk__11008 \x3d null;\nvar count__11009 \x3d (0);\nvar i__11010 \x3d (0);\nwhile(true){\nif((i__11010 \x3c count__11009)){\nvar vec__11017 \x3d chunk__11008.cljs$core$IIndexed$_nth$arity$2(null,i__11010);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11017,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11017,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11029 \x3d seq__11007;\nvar G__11030 \x3d chunk__11008;\nvar G__11031 \x3d count__11009;\nvar G__11032 \x3d (i__11010 + (1));\nseq__11007 \x3d G__11029;\nchunk__11008 \x3d G__11030;\ncount__11009 \x3d G__11031;\ni__11010 \x3d G__11032;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__11007);\nif(temp__5720__auto__){\nvar seq__11007__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__11007__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__11007__$1);\nvar G__11033 \x3d cljs.core.chunk_rest(seq__11007__$1);\nvar G__11034 \x3d c__4550__auto__;\nvar G__11035 \x3d cljs.core.count(c__4550__auto__);\nvar G__11036 \x3d (0);\nseq__11007 \x3d G__11033;\nchunk__11008 \x3d G__11034;\ncount__11009 \x3d G__11035;\ni__11010 \x3d G__11036;\ncontinue;\n} else {\nvar vec__11020 \x3d cljs.core.first(seq__11007__$1);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11020,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11020,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11037 \x3d cljs.core.next(seq__11007__$1);\nvar G__11038 \x3d null;\nvar G__11039 \x3d (0);\nvar G__11040 \x3d (0);\nseq__11007 \x3d G__11037;\nchunk__11008 \x3d G__11038;\ncount__11009 \x3d G__11039;\ni__11010 \x3d G__11040;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (coll,k,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar idx \x3d cljs.core.array_map_index_of(coll__$1,k);\nif((idx \x3d\x3d\x3d (-1))){\nreturn not_found;\n} else {\nreturn (self__.arr[(idx + (1))]);\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 \x3d (function (coll,f,init){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar len \x3d self__.arr.length;\nvar i \x3d (0);\nvar init__$1 \x3d init;\nwhile(true){\nif((i \x3c len)){\nvar init__$2 \x3d (function (){var G__11023 \x3d init__$1;\nvar G__11024 \x3d (self__.arr[i]);\nvar G__11025 \x3d (self__.arr[(i + (1))]);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__11023,G__11024,G__11025) : f.call(null,G__11023,G__11024,G__11025));\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__11041 \x3d (i + (2));\nvar G__11042 \x3d init__$2;\ni \x3d G__11041;\ninit__$1 \x3d G__11042;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn (new cljs.core.PersistentArrayMapIterator(self__.arr,(0),(self__.cnt * (2))));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.PersistentArrayMap(self__.meta,self__.cnt,self__.arr,self__.__hash));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.cnt;\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(((cljs.core.map_QMARK_(other)) \x26\x26 ((!(cljs.core.record_QMARK_(other)))))){\nvar alen \x3d self__.arr.length;\nvar other__$1 \x3d other;\nif((self__.cnt \x3d\x3d\x3d other__$1.cljs$core$ICounted$_count$arity$1(null))){\nvar i \x3d (0);\nwhile(true){\nif((i \x3c alen)){\nvar v \x3d other__$1.cljs$core$ILookup$_lookup$arity$3(null,(self__.arr[i]),cljs.core.lookup_sentinel);\nif((!((v \x3d\x3d\x3d cljs.core.lookup_sentinel)))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((self__.arr[(i + (1))]),v)){\nvar G__11043 \x3d (i + (2));\ni \x3d G__11043;\ncontinue;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.TransientArrayMap(({}),self__.arr.length,cljs.core.aclone(self__.arr)));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.PersistentArrayMap.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$2(coll__$1,f);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$3(coll__$1,f,start);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IMap$_dissoc$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar idx \x3d cljs.core.array_map_index_of(coll__$1,k);\nif((idx \x3e\x3d (0))){\nvar len \x3d self__.arr.length;\nvar new_len \x3d (len - (2));\nif((new_len \x3d\x3d\x3d (0))){\nreturn coll__$1.cljs$core$IEmptyableCollection$_empty$arity$1(null);\n} else {\nvar new_arr \x3d (new Array(new_len));\nvar s \x3d (0);\nvar d \x3d (0);\nwhile(true){\nif((s \x3e\x3d len)){\nreturn (new cljs.core.PersistentArrayMap(self__.meta,(self__.cnt - (1)),new_arr,null));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(k,(self__.arr[s]))){\nvar G__11044 \x3d (s + (2));\nvar G__11045 \x3d d;\ns \x3d G__11044;\nd \x3d G__11045;\ncontinue;\n} else {\n(new_arr[d] \x3d (self__.arr[s]));\n\n(new_arr[(d + (1))] \x3d (self__.arr[(s + (1))]));\n\nvar G__11046 \x3d (s + (2));\nvar G__11047 \x3d (d + (2));\ns \x3d G__11046;\nd \x3d G__11047;\ncontinue;\n\n}\n}\nbreak;\n}\n}\n} else {\nreturn coll__$1;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IAssociative$_assoc$arity$3 \x3d (function (coll,k,v){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar idx \x3d cljs.core.array_map_index_of(coll__$1,k);\nif((idx \x3d\x3d\x3d (-1))){\nif((self__.cnt \x3c cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD)){\nvar arr__$1 \x3d cljs.core.array_map_extend_kv(coll__$1,k,v);\nreturn (new cljs.core.PersistentArrayMap(self__.meta,(self__.cnt + (1)),arr__$1,null));\n} else {\nreturn cljs.core._with_meta(cljs.core._assoc(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashMap.EMPTY,coll__$1),k,v),self__.meta);\n}\n} else {\nif((v \x3d\x3d\x3d (self__.arr[(idx + (1))]))){\nreturn coll__$1;\n} else {\nvar arr__$1 \x3d (function (){var G__11028 \x3d cljs.core.aclone(self__.arr);\n(G__11028[(idx + (1))] \x3d v);\n\nreturn G__11028;\n})();\nreturn (new cljs.core.PersistentArrayMap(self__.meta,self__.cnt,arr__$1,null));\n\n}\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (!((cljs.core.array_map_index_of(coll__$1,k) \x3d\x3d\x3d (-1))));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.persistent_array_map_seq(self__.arr,(0),null);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentArrayMap(new_meta,self__.cnt,self__.arr,self__.__hash));\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,entry){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(cljs.core.vector_QMARK_(entry)){\nreturn coll__$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(1)));\n} else {\nvar ret \x3d coll__$1;\nvar es \x3d cljs.core.seq(entry);\nwhile(true){\nif((es \x3d\x3d null)){\nreturn ret;\n} else {\nvar e \x3d cljs.core.first(es);\nif(cljs.core.vector_QMARK_(e)){\nvar G__11048 \x3d cljs.core._assoc(ret,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(1)));\nvar G__11049 \x3d cljs.core.next(es);\nret \x3d G__11048;\nes \x3d G__11049;\ncontinue;\n} else {\nthrow (new Error("conj on a map takes map entries or seqables of map entries"));\n}\n}\nbreak;\n}\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.call \x3d (function() {\nvar G__11050 \x3d null;\nvar G__11050__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__11050__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__11050 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11050__2.call(this,self__,k);\ncase 3:\nreturn G__11050__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11050.cljs$core$IFn$_invoke$arity$2 \x3d G__11050__2;\nG__11050.cljs$core$IFn$_invoke$arity$3 \x3d G__11050__3;\nreturn G__11050;\n})()\n;\n\ncljs.core.PersistentArrayMap.prototype.apply \x3d (function (self__,args11006){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11006)));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentArrayMap.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$cnt,cljs.core.cst$sym$arr,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.PersistentArrayMap.cljs$lang$type \x3d true;\n\ncljs.core.PersistentArrayMap.cljs$lang$ctorStr \x3d "cljs.core/PersistentArrayMap";\n\ncljs.core.PersistentArrayMap.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentArrayMap");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentArrayMap.\n */\ncljs.core.__GT_PersistentArrayMap \x3d (function cljs$core$__GT_PersistentArrayMap(meta,cnt,arr,__hash){\nreturn (new cljs.core.PersistentArrayMap(meta,cnt,arr,__hash));\n});\n\ncljs.core.PersistentArrayMap.EMPTY \x3d (new cljs.core.PersistentArrayMap(null,(0),[],cljs.core.empty_unordered_hash));\ncljs.core.PersistentArrayMap.HASHMAP_THRESHOLD \x3d (8);\ncljs.core.PersistentArrayMap.fromArray \x3d (function (arr,no_clone,no_check){\nvar arr__$1 \x3d ((no_clone)?arr:cljs.core.aclone(arr));\nvar arr__$2 \x3d ((no_check)?arr__$1:(function (){var ret \x3d [];\nvar i_11051 \x3d (0);\nwhile(true){\nif((i_11051 \x3c arr__$1.length)){\nvar k_11052 \x3d (arr__$1[i_11051]);\nvar v_11053 \x3d (arr__$1[(i_11051 + (1))]);\nvar idx_11054 \x3d cljs.core.array_index_of(ret,k_11052);\nif((idx_11054 \x3d\x3d\x3d (-1))){\nret.push(k_11052);\n\nret.push(v_11053);\n} else {\n}\n\nvar G__11055 \x3d (i_11051 + (2));\ni_11051 \x3d G__11055;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn ret;\n})());\nvar cnt \x3d (arr__$2.length / (2));\nreturn (new cljs.core.PersistentArrayMap(null,cnt,arr__$2,null));\n});\ncljs.core.PersistentArrayMap.createWithCheck \x3d (function (arr){\nvar ret \x3d [];\nvar i_11057 \x3d (0);\nwhile(true){\nif((i_11057 \x3c arr.length)){\nvar k_11058 \x3d (arr[i_11057]);\nvar v_11059 \x3d (arr[(i_11057 + (1))]);\nvar idx_11060 \x3d cljs.core.array_index_of(ret,k_11058);\nif((idx_11060 \x3d\x3d\x3d (-1))){\nvar G__11056_11061 \x3d ret;\nG__11056_11061.push(k_11058);\n\nG__11056_11061.push(v_11059);\n\n} else {\nthrow (new Error(["Duplicate key: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(k_11058)].join(\'\')));\n}\n\nvar G__11062 \x3d (i_11057 + (2));\ni_11057 \x3d G__11062;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar cnt \x3d (arr.length / (2));\nreturn (new cljs.core.PersistentArrayMap(null,cnt,arr,null));\n});\ncljs.core.PersistentArrayMap.createAsIfByAssoc \x3d (function (arr){\nvar ret \x3d [];\nvar i_11064 \x3d (0);\nwhile(true){\nif((i_11064 \x3c arr.length)){\nvar k_11065 \x3d (arr[i_11064]);\nvar v_11066 \x3d (arr[(i_11064 + (1))]);\nvar idx_11067 \x3d cljs.core.array_index_of(ret,k_11065);\nif((idx_11067 \x3d\x3d\x3d (-1))){\nvar G__11063_11068 \x3d ret;\nG__11063_11068.push(k_11065);\n\nG__11063_11068.push(v_11066);\n\n} else {\n(ret[(idx_11067 + (1))] \x3d v_11066);\n}\n\nvar G__11069 \x3d (i_11064 + (2));\ni_11064 \x3d G__11069;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn (new cljs.core.PersistentArrayMap(null,(ret.length / (2)),ret,null));\n});\nvar G__11070_11073 \x3d cljs.core.PersistentArrayMap.prototype;\nvar G__11071_11074 \x3d cljs.core.ITER_SYMBOL;\nvar G__11072_11075 \x3d ((function (G__11070_11073,G__11071_11074){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11070_11073,G__11071_11074))\n;\ngoog.object.set(G__11070_11073,G__11071_11074,G__11072_11075);\n\n/**\n* @constructor\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ITransientMap}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ITransientCollection}\n * @implements {cljs.core.ITransientAssociative}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TransientArrayMap \x3d (function (editable_QMARK_,len,arr){\nthis.editable_QMARK_ \x3d editable_QMARK_;\nthis.len \x3d len;\nthis.arr \x3d arr;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 259;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 56;\n});\ncljs.core.TransientArrayMap.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (tcoll){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nreturn cljs.core.quot(self__.len,(2));\n} else {\nthrow (new Error("count after persistent!"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (tcoll,k){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nreturn tcoll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (tcoll,k,not_found){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nvar idx \x3d cljs.core.array_map_index_of(tcoll__$1,k);\nif((idx \x3d\x3d\x3d (-1))){\nreturn not_found;\n} else {\nreturn (self__.arr[(idx + (1))]);\n}\n} else {\nthrow (new Error("lookup after persistent!"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 \x3d (function (tcoll,o){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nif(cljs.core.map_entry_QMARK_(o)){\nreturn tcoll__$1.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3(null,cljs.core.key(o),cljs.core.val(o));\n} else {\nif(cljs.core.vector_QMARK_(o)){\nreturn tcoll__$1.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3(null,(o.cljs$core$IFn$_invoke$arity$1 ? o.cljs$core$IFn$_invoke$arity$1((0)) : o.call(null,(0))),(o.cljs$core$IFn$_invoke$arity$1 ? o.cljs$core$IFn$_invoke$arity$1((1)) : o.call(null,(1))));\n} else {\nvar es \x3d cljs.core.seq(o);\nvar tcoll__$2 \x3d tcoll__$1;\nwhile(true){\nvar temp__5718__auto__ \x3d cljs.core.first(es);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e \x3d temp__5718__auto__;\nvar G__11078 \x3d cljs.core.next(es);\nvar G__11079 \x3d cljs.core._assoc_BANG_(tcoll__$2,cljs.core.key(e),cljs.core.val(e));\nes \x3d G__11078;\ntcoll__$2 \x3d G__11079;\ncontinue;\n} else {\nreturn tcoll__$2;\n}\nbreak;\n}\n\n}\n}\n} else {\nthrow (new Error("conj! after persistent!"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 \x3d (function (tcoll){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nself__.editable_QMARK_ \x3d false;\n\nreturn (new cljs.core.PersistentArrayMap(null,cljs.core.quot(self__.len,(2)),self__.arr,null));\n} else {\nthrow (new Error("persistent! called twice"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 \x3d (function (tcoll,key,val){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nvar idx \x3d cljs.core.array_map_index_of(tcoll__$1,key);\nif((idx \x3d\x3d\x3d (-1))){\nif(((self__.len + (2)) \x3c\x3d ((2) * cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD))){\nself__.len \x3d (self__.len + (2));\n\nself__.arr.push(key);\n\nself__.arr.push(val);\n\nreturn tcoll__$1;\n} else {\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(cljs.core.array__GT_transient_hash_map(self__.len,self__.arr),key,val);\n}\n} else {\nif((val \x3d\x3d\x3d (self__.arr[(idx + (1))]))){\nreturn tcoll__$1;\n} else {\n(self__.arr[(idx + (1))] \x3d val);\n\nreturn tcoll__$1;\n}\n}\n} else {\nthrow (new Error("assoc! after persistent!"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ITransientMap$_dissoc_BANG_$arity$2 \x3d (function (tcoll,key){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nvar idx \x3d cljs.core.array_map_index_of(tcoll__$1,key);\nif((idx \x3e\x3d (0))){\n(self__.arr[idx] \x3d (self__.arr[(self__.len - (2))]));\n\n(self__.arr[(idx + (1))] \x3d (self__.arr[(self__.len - (1))]));\n\nvar G__11077_11080 \x3d self__.arr;\nG__11077_11080.pop();\n\nG__11077_11080.pop();\n\n\nself__.len \x3d (self__.len - (2));\n} else {\n}\n\nreturn tcoll__$1;\n} else {\nthrow (new Error("dissoc! after persistent!"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.call \x3d (function() {\nvar G__11081 \x3d null;\nvar G__11081__2 \x3d (function (self__,key){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar tcoll \x3d self____$1;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,null);\n});\nvar G__11081__3 \x3d (function (self__,key,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar tcoll \x3d self____$1;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,not_found);\n});\nG__11081 \x3d function(self__,key,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11081__2.call(this,self__,key);\ncase 3:\nreturn G__11081__3.call(this,self__,key,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11081.cljs$core$IFn$_invoke$arity$2 \x3d G__11081__2;\nG__11081.cljs$core$IFn$_invoke$arity$3 \x3d G__11081__3;\nreturn G__11081;\n})()\n;\n\ncljs.core.TransientArrayMap.prototype.apply \x3d (function (self__,args11076){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11076)));\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (key){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,null);\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (key,not_found){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,not_found);\n});\n\ncljs.core.TransientArrayMap.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$editable_QMARK_,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$len,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.cst$sym$arr], null);\n});\n\ncljs.core.TransientArrayMap.cljs$lang$type \x3d true;\n\ncljs.core.TransientArrayMap.cljs$lang$ctorStr \x3d "cljs.core/TransientArrayMap";\n\ncljs.core.TransientArrayMap.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/TransientArrayMap");\n});\n\n/**\n * Positional factory function for cljs.core/TransientArrayMap.\n */\ncljs.core.__GT_TransientArrayMap \x3d (function cljs$core$__GT_TransientArrayMap(editable_QMARK_,len,arr){\nreturn (new cljs.core.TransientArrayMap(editable_QMARK_,len,arr));\n});\n\ncljs.core.array__GT_transient_hash_map \x3d (function cljs$core$array__GT_transient_hash_map(len,arr){\nvar out \x3d cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nvar i \x3d (0);\nwhile(true){\nif((i \x3c len)){\nvar G__11082 \x3d cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(out,(arr[i]),(arr[(i + (1))]));\nvar G__11083 \x3d (i + (2));\nout \x3d G__11082;\ni \x3d G__11083;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.Box \x3d (function (val){\nthis.val \x3d val;\n});\n\ncljs.core.Box.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$val,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Box.cljs$lang$type \x3d true;\n\ncljs.core.Box.cljs$lang$ctorStr \x3d "cljs.core/Box";\n\ncljs.core.Box.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Box");\n});\n\n/**\n * Positional factory function for cljs.core/Box.\n */\ncljs.core.__GT_Box \x3d (function cljs$core$__GT_Box(val){\nreturn (new cljs.core.Box(val));\n});\n\n\n\n\n\n\ncljs.core.key_test \x3d (function cljs$core$key_test(key,other){\nif((key \x3d\x3d\x3d other)){\nreturn true;\n} else {\nif(cljs.core.keyword_identical_QMARK_(key,other)){\nreturn true;\n} else {\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(key,other);\n\n}\n}\n});\ncljs.core.mask \x3d (function cljs$core$mask(hash,shift){\nreturn ((hash \x3e\x3e\x3e shift) \x26 (31));\n});\ncljs.core.clone_and_set \x3d (function cljs$core$clone_and_set(var_args){\nvar G__11085 \x3d arguments.length;\nswitch (G__11085) {\ncase 3:\nreturn cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 5:\nreturn cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3 \x3d (function (arr,i,a){\nvar G__11086 \x3d cljs.core.aclone(arr);\n(G__11086[i] \x3d a);\n\nreturn G__11086;\n});\n\ncljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$5 \x3d (function (arr,i,a,j,b){\nvar G__11087 \x3d cljs.core.aclone(arr);\n(G__11087[i] \x3d a);\n\n(G__11087[j] \x3d b);\n\nreturn G__11087;\n});\n\ncljs.core.clone_and_set.cljs$lang$maxFixedArity \x3d 5;\n\ncljs.core.remove_pair \x3d (function cljs$core$remove_pair(arr,i){\nvar new_arr \x3d (new Array((arr.length - (2))));\ncljs.core.array_copy(arr,(0),new_arr,(0),((2) * i));\n\ncljs.core.array_copy(arr,((2) * (i + (1))),new_arr,((2) * i),(new_arr.length - ((2) * i)));\n\nreturn new_arr;\n});\ncljs.core.bitmap_indexed_node_index \x3d (function cljs$core$bitmap_indexed_node_index(bitmap,bit){\nreturn cljs.core.bit_count((bitmap \x26 (bit - (1))));\n});\ncljs.core.bitpos \x3d (function cljs$core$bitpos(hash,shift){\nreturn ((1) \x3c\x3c ((hash \x3e\x3e\x3e shift) \x26 0x01f));\n});\ncljs.core.edit_and_set \x3d (function cljs$core$edit_and_set(var_args){\nvar G__11090 \x3d arguments.length;\nswitch (G__11090) {\ncase 4:\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 6:\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4 \x3d (function (inode,edit,i,a){\nvar editable \x3d inode.ensure_editable(edit);\n(editable.arr[i] \x3d a);\n\nreturn editable;\n});\n\ncljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$6 \x3d (function (inode,edit,i,a,j,b){\nvar editable \x3d inode.ensure_editable(edit);\n(editable.arr[i] \x3d a);\n\n(editable.arr[j] \x3d b);\n\nreturn editable;\n});\n\ncljs.core.edit_and_set.cljs$lang$maxFixedArity \x3d 6;\n\ncljs.core.inode_kv_reduce \x3d (function cljs$core$inode_kv_reduce(arr,f,init){\nvar len \x3d arr.length;\nvar i \x3d (0);\nvar init__$1 \x3d init;\nwhile(true){\nif((i \x3c len)){\nvar init__$2 \x3d (function (){var k \x3d (arr[i]);\nif((!((k \x3d\x3d null)))){\nvar G__11092 \x3d init__$1;\nvar G__11093 \x3d k;\nvar G__11094 \x3d (arr[(i + (1))]);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__11092,G__11093,G__11094) : f.call(null,G__11092,G__11093,G__11094));\n} else {\nvar node \x3d (arr[(i + (1))]);\nif((!((node \x3d\x3d null)))){\nreturn node.kv_reduce(f,init__$1);\n} else {\nreturn init__$1;\n}\n}\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn init__$2;\n} else {\nvar G__11095 \x3d (i + (2));\nvar G__11096 \x3d init__$2;\ni \x3d G__11095;\ninit__$1 \x3d G__11096;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.NodeIterator \x3d (function (arr,i,next_entry,next_iter){\nthis.arr \x3d arr;\nthis.i \x3d i;\nthis.next_entry \x3d next_entry;\nthis.next_iter \x3d next_iter;\n});\ncljs.core.NodeIterator.prototype.advance \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nvar len \x3d self__.arr.length;\nwhile(true){\nif((self__.i \x3c len)){\nvar key \x3d (self__.arr[self__.i]);\nvar node_or_val \x3d (self__.arr[(self__.i + (1))]);\nvar found \x3d (((!((key \x3d\x3d null))))?self__.next_entry \x3d (new cljs.core.MapEntry(key,node_or_val,null)):(((!((node_or_val \x3d\x3d null))))?(function (){var new_iter \x3d cljs.core._iterator(node_or_val);\nif(new_iter.hasNext()){\nreturn self__.next_iter \x3d new_iter;\n} else {\nreturn false;\n}\n})():false\n));\nself__.i \x3d (self__.i + (2));\n\nif(found){\nreturn true;\n} else {\ncontinue;\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\ncljs.core.NodeIterator.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nvar or__4131__auto__ \x3d (!((self__.next_entry \x3d\x3d null)));\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (!((self__.next_iter \x3d\x3d null)));\nif(or__4131__auto____$1){\nreturn or__4131__auto____$1;\n} else {\nreturn this$.advance();\n}\n}\n});\n\ncljs.core.NodeIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nif((!((self__.next_entry \x3d\x3d null)))){\nvar ret \x3d self__.next_entry;\nself__.next_entry \x3d null;\n\nreturn ret;\n} else {\nif((!((self__.next_iter \x3d\x3d null)))){\nvar ret \x3d self__.next_iter.next();\nif(self__.next_iter.hasNext()){\n} else {\nself__.next_iter \x3d null;\n}\n\nreturn ret;\n} else {\nif(this$.advance()){\nreturn this$.next();\n} else {\nthrow (new Error("No such element"));\n\n}\n}\n}\n});\n\ncljs.core.NodeIterator.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.NodeIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$arr,cljs.core.with_meta(cljs.core.cst$sym$i,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$next_DASH_entry,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$next_DASH_iter,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.NodeIterator.cljs$lang$type \x3d true;\n\ncljs.core.NodeIterator.cljs$lang$ctorStr \x3d "cljs.core/NodeIterator";\n\ncljs.core.NodeIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/NodeIterator");\n});\n\n/**\n * Positional factory function for cljs.core/NodeIterator.\n */\ncljs.core.__GT_NodeIterator \x3d (function cljs$core$__GT_NodeIterator(arr,i,next_entry,next_iter){\nreturn (new cljs.core.NodeIterator(arr,i,next_entry,next_iter));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIterable}\n*/\ncljs.core.BitmapIndexedNode \x3d (function (edit,bitmap,arr){\nthis.edit \x3d edit;\nthis.bitmap \x3d bitmap;\nthis.arr \x3d arr;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 131072;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 0;\n});\ncljs.core.BitmapIndexedNode.prototype.ensure_editable \x3d (function (e){\nvar self__ \x3d this;\nvar inode \x3d this;\nif((e \x3d\x3d\x3d self__.edit)){\nreturn inode;\n} else {\nvar n \x3d cljs.core.bit_count(self__.bitmap);\nvar new_arr \x3d (new Array((((n \x3c (0)))?(4):((2) * (n + (1))))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),((2) * n));\n\nreturn (new cljs.core.BitmapIndexedNode(e,self__.bitmap,new_arr));\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_without_BANG_ \x3d (function (edit__$1,shift,hash,key,removed_leaf_QMARK_){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar bit \x3d (1 \x3c\x3c ((hash \x3e\x3e\x3e shift) \x26 0x01f));\nif(((self__.bitmap \x26 bit) \x3d\x3d\x3d (0))){\nreturn inode;\n} else {\nvar idx \x3d cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nvar key_or_nil \x3d (self__.arr[((2) * idx)]);\nvar val_or_node \x3d (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil \x3d\x3d null)){\nvar n \x3d val_or_node.inode_without_BANG_(edit__$1,(shift + (5)),hash,key,removed_leaf_QMARK_);\nif((n \x3d\x3d\x3d val_or_node)){\nreturn inode;\n} else {\nif((!((n \x3d\x3d null)))){\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,(((2) * idx) + (1)),n);\n} else {\nif((self__.bitmap \x3d\x3d\x3d bit)){\nreturn null;\n} else {\nreturn inode.edit_and_remove_pair(edit__$1,bit,idx);\n\n}\n}\n}\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nremoved_leaf_QMARK_.val \x3d true;\n\nreturn inode.edit_and_remove_pair(edit__$1,bit,idx);\n} else {\nreturn inode;\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.edit_and_remove_pair \x3d (function (e,bit,i){\nvar self__ \x3d this;\nvar inode \x3d this;\nif((self__.bitmap \x3d\x3d\x3d bit)){\nreturn null;\n} else {\nvar editable \x3d inode.ensure_editable(e);\nvar earr \x3d editable.arr;\nvar len \x3d earr.length;\neditable.bitmap \x3d (bit ^ editable.bitmap);\n\ncljs.core.array_copy(earr,((2) * (i + (1))),earr,((2) * i),(len - ((2) * (i + (1)))));\n\n(earr[(len - (2))] \x3d null);\n\n(earr[(len - (1))] \x3d null);\n\nreturn editable;\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_seq \x3d (function (){\nvar self__ \x3d this;\nvar inode \x3d this;\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$1(self__.arr);\n});\n\ncljs.core.BitmapIndexedNode.prototype.kv_reduce \x3d (function (f,init){\nvar self__ \x3d this;\nvar inode \x3d this;\nreturn cljs.core.inode_kv_reduce(self__.arr,f,init);\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_lookup \x3d (function (shift,hash,key,not_found){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar bit \x3d (1 \x3c\x3c ((hash \x3e\x3e\x3e shift) \x26 0x01f));\nif(((self__.bitmap \x26 bit) \x3d\x3d\x3d (0))){\nreturn not_found;\n} else {\nvar idx \x3d cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nvar key_or_nil \x3d (self__.arr[((2) * idx)]);\nvar val_or_node \x3d (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil \x3d\x3d null)){\nreturn val_or_node.inode_lookup((shift + (5)),hash,key,not_found);\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nreturn val_or_node;\n} else {\nreturn not_found;\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_assoc_BANG_ \x3d (function (edit__$1,shift,hash,key,val,added_leaf_QMARK_){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar bit \x3d (1 \x3c\x3c ((hash \x3e\x3e\x3e shift) \x26 0x01f));\nvar idx \x3d cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nif(((self__.bitmap \x26 bit) \x3d\x3d\x3d (0))){\nvar n \x3d cljs.core.bit_count(self__.bitmap);\nif((((2) * n) \x3c self__.arr.length)){\nvar editable \x3d inode.ensure_editable(edit__$1);\nvar earr \x3d editable.arr;\nadded_leaf_QMARK_.val \x3d true;\n\ncljs.core.array_copy_downward(earr,((2) * idx),earr,((2) * (idx + (1))),((2) * (n - idx)));\n\n(earr[((2) * idx)] \x3d key);\n\n(earr[(((2) * idx) + (1))] \x3d val);\n\neditable.bitmap \x3d (editable.bitmap | bit);\n\nreturn editable;\n} else {\nif((n \x3e\x3d (16))){\nvar nodes \x3d [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar jdx \x3d ((hash \x3e\x3e\x3e shift) \x26 0x01f);\n(nodes[jdx] \x3d cljs.core.BitmapIndexedNode.EMPTY.inode_assoc_BANG_(edit__$1,(shift + (5)),hash,key,val,added_leaf_QMARK_));\n\nvar i_11097 \x3d (0);\nvar j_11098 \x3d (0);\nwhile(true){\nif((i_11097 \x3c (32))){\nif((((self__.bitmap \x3e\x3e\x3e i_11097) \x26 (1)) \x3d\x3d\x3d (0))){\nvar G__11099 \x3d (i_11097 + (1));\nvar G__11100 \x3d j_11098;\ni_11097 \x3d G__11099;\nj_11098 \x3d G__11100;\ncontinue;\n} else {\n(nodes[i_11097] \x3d (((!(((self__.arr[j_11098]) \x3d\x3d null))))?cljs.core.BitmapIndexedNode.EMPTY.inode_assoc_BANG_(edit__$1,(shift + (5)),cljs.core.hash((self__.arr[j_11098])),(self__.arr[j_11098]),(self__.arr[(j_11098 + (1))]),added_leaf_QMARK_):(self__.arr[(j_11098 + (1))])));\n\nvar G__11101 \x3d (i_11097 + (1));\nvar G__11102 \x3d (j_11098 + (2));\ni_11097 \x3d G__11101;\nj_11098 \x3d G__11102;\ncontinue;\n}\n} else {\n}\nbreak;\n}\n\nreturn (new cljs.core.ArrayNode(edit__$1,(n + (1)),nodes));\n} else {\nvar new_arr \x3d (new Array(((2) * (n + (4)))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),((2) * idx));\n\n(new_arr[((2) * idx)] \x3d key);\n\n(new_arr[(((2) * idx) + (1))] \x3d val);\n\ncljs.core.array_copy(self__.arr,((2) * idx),new_arr,((2) * (idx + (1))),((2) * (n - idx)));\n\nadded_leaf_QMARK_.val \x3d true;\n\nvar editable \x3d inode.ensure_editable(edit__$1);\neditable.arr \x3d new_arr;\n\neditable.bitmap \x3d (editable.bitmap | bit);\n\nreturn editable;\n\n}\n}\n} else {\nvar key_or_nil \x3d (self__.arr[((2) * idx)]);\nvar val_or_node \x3d (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil \x3d\x3d null)){\nvar n \x3d val_or_node.inode_assoc_BANG_(edit__$1,(shift + (5)),hash,key,val,added_leaf_QMARK_);\nif((n \x3d\x3d\x3d val_or_node)){\nreturn inode;\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,(((2) * idx) + (1)),n);\n}\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nif((val \x3d\x3d\x3d val_or_node)){\nreturn inode;\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,(((2) * idx) + (1)),val);\n}\n} else {\nadded_leaf_QMARK_.val \x3d true;\n\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$6(inode,edit__$1,((2) * idx),null,(((2) * idx) + (1)),cljs.core.create_node.cljs$core$IFn$_invoke$arity$7(edit__$1,(shift + (5)),key_or_nil,val_or_node,hash,key,val));\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_assoc \x3d (function (shift,hash,key,val,added_leaf_QMARK_){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar bit \x3d (1 \x3c\x3c ((hash \x3e\x3e\x3e shift) \x26 0x01f));\nvar idx \x3d cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nif(((self__.bitmap \x26 bit) \x3d\x3d\x3d (0))){\nvar n \x3d cljs.core.bit_count(self__.bitmap);\nif((n \x3e\x3d (16))){\nvar nodes \x3d [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar jdx \x3d ((hash \x3e\x3e\x3e shift) \x26 0x01f);\n(nodes[jdx] \x3d cljs.core.BitmapIndexedNode.EMPTY.inode_assoc((shift + (5)),hash,key,val,added_leaf_QMARK_));\n\nvar i_11103 \x3d (0);\nvar j_11104 \x3d (0);\nwhile(true){\nif((i_11103 \x3c (32))){\nif((((self__.bitmap \x3e\x3e\x3e i_11103) \x26 (1)) \x3d\x3d\x3d (0))){\nvar G__11105 \x3d (i_11103 + (1));\nvar G__11106 \x3d j_11104;\ni_11103 \x3d G__11105;\nj_11104 \x3d G__11106;\ncontinue;\n} else {\n(nodes[i_11103] \x3d (((!(((self__.arr[j_11104]) \x3d\x3d null))))?cljs.core.BitmapIndexedNode.EMPTY.inode_assoc((shift + (5)),cljs.core.hash((self__.arr[j_11104])),(self__.arr[j_11104]),(self__.arr[(j_11104 + (1))]),added_leaf_QMARK_):(self__.arr[(j_11104 + (1))])));\n\nvar G__11107 \x3d (i_11103 + (1));\nvar G__11108 \x3d (j_11104 + (2));\ni_11103 \x3d G__11107;\nj_11104 \x3d G__11108;\ncontinue;\n}\n} else {\n}\nbreak;\n}\n\nreturn (new cljs.core.ArrayNode(null,(n + (1)),nodes));\n} else {\nvar new_arr \x3d (new Array(((2) * (n + (1)))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),((2) * idx));\n\n(new_arr[((2) * idx)] \x3d key);\n\n(new_arr[(((2) * idx) + (1))] \x3d val);\n\ncljs.core.array_copy(self__.arr,((2) * idx),new_arr,((2) * (idx + (1))),((2) * (n - idx)));\n\nadded_leaf_QMARK_.val \x3d true;\n\nreturn (new cljs.core.BitmapIndexedNode(null,(self__.bitmap | bit),new_arr));\n}\n} else {\nvar key_or_nil \x3d (self__.arr[((2) * idx)]);\nvar val_or_node \x3d (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil \x3d\x3d null)){\nvar n \x3d val_or_node.inode_assoc((shift + (5)),hash,key,val,added_leaf_QMARK_);\nif((n \x3d\x3d\x3d val_or_node)){\nreturn inode;\n} else {\nreturn (new cljs.core.BitmapIndexedNode(null,self__.bitmap,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,(((2) * idx) + (1)),n)));\n}\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nif((val \x3d\x3d\x3d val_or_node)){\nreturn inode;\n} else {\nreturn (new cljs.core.BitmapIndexedNode(null,self__.bitmap,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,(((2) * idx) + (1)),val)));\n}\n} else {\nadded_leaf_QMARK_.val \x3d true;\n\nreturn (new cljs.core.BitmapIndexedNode(null,self__.bitmap,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$5(self__.arr,((2) * idx),null,(((2) * idx) + (1)),cljs.core.create_node.cljs$core$IFn$_invoke$arity$6((shift + (5)),key_or_nil,val_or_node,hash,key,val))));\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_find \x3d (function (shift,hash,key,not_found){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar bit \x3d (1 \x3c\x3c ((hash \x3e\x3e\x3e shift) \x26 0x01f));\nif(((self__.bitmap \x26 bit) \x3d\x3d\x3d (0))){\nreturn not_found;\n} else {\nvar idx \x3d cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nvar key_or_nil \x3d (self__.arr[((2) * idx)]);\nvar val_or_node \x3d (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil \x3d\x3d null)){\nreturn val_or_node.inode_find((shift + (5)),hash,key,not_found);\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nreturn (new cljs.core.MapEntry(key_or_nil,val_or_node,null));\n} else {\nreturn not_found;\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_without \x3d (function (shift,hash,key){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar bit \x3d (1 \x3c\x3c ((hash \x3e\x3e\x3e shift) \x26 0x01f));\nif(((self__.bitmap \x26 bit) \x3d\x3d\x3d (0))){\nreturn inode;\n} else {\nvar idx \x3d cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nvar key_or_nil \x3d (self__.arr[((2) * idx)]);\nvar val_or_node \x3d (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil \x3d\x3d null)){\nvar n \x3d val_or_node.inode_without((shift + (5)),hash,key);\nif((n \x3d\x3d\x3d val_or_node)){\nreturn inode;\n} else {\nif((!((n \x3d\x3d null)))){\nreturn (new cljs.core.BitmapIndexedNode(null,self__.bitmap,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,(((2) * idx) + (1)),n)));\n} else {\nif((self__.bitmap \x3d\x3d\x3d bit)){\nreturn null;\n} else {\nreturn (new cljs.core.BitmapIndexedNode(null,(self__.bitmap ^ bit),cljs.core.remove_pair(self__.arr,idx)));\n\n}\n}\n}\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nreturn (new cljs.core.BitmapIndexedNode(null,(self__.bitmap ^ bit),cljs.core.remove_pair(self__.arr,idx)));\n} else {\nreturn inode;\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.NodeIterator(self__.arr,(0),null,null));\n});\n\ncljs.core.BitmapIndexedNode.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$edit,cljs.core.with_meta(cljs.core.cst$sym$bitmap,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$arr,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.BitmapIndexedNode.cljs$lang$type \x3d true;\n\ncljs.core.BitmapIndexedNode.cljs$lang$ctorStr \x3d "cljs.core/BitmapIndexedNode";\n\ncljs.core.BitmapIndexedNode.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/BitmapIndexedNode");\n});\n\n/**\n * Positional factory function for cljs.core/BitmapIndexedNode.\n */\ncljs.core.__GT_BitmapIndexedNode \x3d (function cljs$core$__GT_BitmapIndexedNode(edit,bitmap,arr){\nreturn (new cljs.core.BitmapIndexedNode(edit,bitmap,arr));\n});\n\ncljs.core.BitmapIndexedNode.EMPTY \x3d (new cljs.core.BitmapIndexedNode(null,(0),[]));\ncljs.core.pack_array_node \x3d (function cljs$core$pack_array_node(array_node,edit,idx){\nvar arr \x3d array_node.arr;\nvar len \x3d arr.length;\nvar new_arr \x3d (new Array(((2) * (array_node.cnt - (1)))));\nvar i \x3d (0);\nvar j \x3d (1);\nvar bitmap \x3d (0);\nwhile(true){\nif((i \x3c len)){\nif((((!((i \x3d\x3d\x3d idx)))) \x26\x26 ((!(((arr[i]) \x3d\x3d null)))))){\n(new_arr[j] \x3d (arr[i]));\n\nvar G__11109 \x3d (i + (1));\nvar G__11110 \x3d (j + (2));\nvar G__11111 \x3d (bitmap | ((1) \x3c\x3c i));\ni \x3d G__11109;\nj \x3d G__11110;\nbitmap \x3d G__11111;\ncontinue;\n} else {\nvar G__11112 \x3d (i + (1));\nvar G__11113 \x3d j;\nvar G__11114 \x3d bitmap;\ni \x3d G__11112;\nj \x3d G__11113;\nbitmap \x3d G__11114;\ncontinue;\n}\n} else {\nreturn (new cljs.core.BitmapIndexedNode(edit,bitmap,new_arr));\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.ArrayNodeIterator \x3d (function (arr,i,next_iter){\nthis.arr \x3d arr;\nthis.i \x3d i;\nthis.next_iter \x3d next_iter;\n});\ncljs.core.ArrayNodeIterator.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nvar len \x3d self__.arr.length;\nwhile(true){\nif((!((((!((self__.next_iter \x3d\x3d null)))) \x26\x26 (self__.next_iter.hasNext()))))){\nif((self__.i \x3c len)){\nvar node \x3d (self__.arr[self__.i]);\nself__.i \x3d (self__.i + (1));\n\nif((!((node \x3d\x3d null)))){\nself__.next_iter \x3d cljs.core._iterator(node);\n} else {\n}\n\ncontinue;\n} else {\nreturn false;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n});\n\ncljs.core.ArrayNodeIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar this$ \x3d this;\nif(this$.hasNext()){\nreturn self__.next_iter.next();\n} else {\nthrow (new Error("No such element"));\n}\n});\n\ncljs.core.ArrayNodeIterator.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.ArrayNodeIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$arr,cljs.core.with_meta(cljs.core.cst$sym$i,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$next_DASH_iter,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ArrayNodeIterator.cljs$lang$type \x3d true;\n\ncljs.core.ArrayNodeIterator.cljs$lang$ctorStr \x3d "cljs.core/ArrayNodeIterator";\n\ncljs.core.ArrayNodeIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ArrayNodeIterator");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayNodeIterator.\n */\ncljs.core.__GT_ArrayNodeIterator \x3d (function cljs$core$__GT_ArrayNodeIterator(arr,i,next_iter){\nreturn (new cljs.core.ArrayNodeIterator(arr,i,next_iter));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIterable}\n*/\ncljs.core.ArrayNode \x3d (function (edit,cnt,arr){\nthis.edit \x3d edit;\nthis.cnt \x3d cnt;\nthis.arr \x3d arr;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 131072;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 0;\n});\ncljs.core.ArrayNode.prototype.ensure_editable \x3d (function (e){\nvar self__ \x3d this;\nvar inode \x3d this;\nif((e \x3d\x3d\x3d self__.edit)){\nreturn inode;\n} else {\nreturn (new cljs.core.ArrayNode(e,self__.cnt,cljs.core.aclone(self__.arr)));\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_without_BANG_ \x3d (function (edit__$1,shift,hash,key,removed_leaf_QMARK_){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d ((hash \x3e\x3e\x3e shift) \x26 0x01f);\nvar node \x3d (self__.arr[idx]);\nif((node \x3d\x3d null)){\nreturn inode;\n} else {\nvar n \x3d node.inode_without_BANG_(edit__$1,(shift + (5)),hash,key,removed_leaf_QMARK_);\nif((n \x3d\x3d\x3d node)){\nreturn inode;\n} else {\nif((n \x3d\x3d null)){\nif((self__.cnt \x3c\x3d (8))){\nreturn cljs.core.pack_array_node(inode,edit__$1,idx);\n} else {\nvar editable \x3d cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,idx,n);\neditable.cnt \x3d (editable.cnt - (1));\n\nreturn editable;\n}\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,idx,n);\n\n}\n}\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_seq \x3d (function (){\nvar self__ \x3d this;\nvar inode \x3d this;\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$1(self__.arr);\n});\n\ncljs.core.ArrayNode.prototype.kv_reduce \x3d (function (f,init){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar len \x3d self__.arr.length;\nvar i \x3d (0);\nvar init__$1 \x3d init;\nwhile(true){\nif((i \x3c len)){\nvar node \x3d (self__.arr[i]);\nif((!((node \x3d\x3d null)))){\nvar init__$2 \x3d node.kv_reduce(f,init__$1);\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn init__$2;\n} else {\nvar G__11115 \x3d (i + (1));\nvar G__11116 \x3d init__$2;\ni \x3d G__11115;\ninit__$1 \x3d G__11116;\ncontinue;\n}\n} else {\nvar G__11117 \x3d (i + (1));\nvar G__11118 \x3d init__$1;\ni \x3d G__11117;\ninit__$1 \x3d G__11118;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_lookup \x3d (function (shift,hash,key,not_found){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d ((hash \x3e\x3e\x3e shift) \x26 0x01f);\nvar node \x3d (self__.arr[idx]);\nif((!((node \x3d\x3d null)))){\nreturn node.inode_lookup((shift + (5)),hash,key,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_assoc_BANG_ \x3d (function (edit__$1,shift,hash,key,val,added_leaf_QMARK_){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d ((hash \x3e\x3e\x3e shift) \x26 0x01f);\nvar node \x3d (self__.arr[idx]);\nif((node \x3d\x3d null)){\nvar editable \x3d cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,idx,cljs.core.BitmapIndexedNode.EMPTY.inode_assoc_BANG_(edit__$1,(shift + (5)),hash,key,val,added_leaf_QMARK_));\neditable.cnt \x3d (editable.cnt + (1));\n\nreturn editable;\n} else {\nvar n \x3d node.inode_assoc_BANG_(edit__$1,(shift + (5)),hash,key,val,added_leaf_QMARK_);\nif((n \x3d\x3d\x3d node)){\nreturn inode;\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,idx,n);\n}\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_assoc \x3d (function (shift,hash,key,val,added_leaf_QMARK_){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d ((hash \x3e\x3e\x3e shift) \x26 0x01f);\nvar node \x3d (self__.arr[idx]);\nif((node \x3d\x3d null)){\nreturn (new cljs.core.ArrayNode(null,(self__.cnt + (1)),cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,idx,cljs.core.BitmapIndexedNode.EMPTY.inode_assoc((shift + (5)),hash,key,val,added_leaf_QMARK_))));\n} else {\nvar n \x3d node.inode_assoc((shift + (5)),hash,key,val,added_leaf_QMARK_);\nif((n \x3d\x3d\x3d node)){\nreturn inode;\n} else {\nreturn (new cljs.core.ArrayNode(null,self__.cnt,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,idx,n)));\n}\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_find \x3d (function (shift,hash,key,not_found){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d ((hash \x3e\x3e\x3e shift) \x26 0x01f);\nvar node \x3d (self__.arr[idx]);\nif((!((node \x3d\x3d null)))){\nreturn node.inode_find((shift + (5)),hash,key,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_without \x3d (function (shift,hash,key){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d ((hash \x3e\x3e\x3e shift) \x26 0x01f);\nvar node \x3d (self__.arr[idx]);\nif((!((node \x3d\x3d null)))){\nvar n \x3d node.inode_without((shift + (5)),hash,key);\nif((n \x3d\x3d\x3d node)){\nreturn inode;\n} else {\nif((n \x3d\x3d null)){\nif((self__.cnt \x3c\x3d (8))){\nreturn cljs.core.pack_array_node(inode,null,idx);\n} else {\nreturn (new cljs.core.ArrayNode(null,(self__.cnt - (1)),cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,idx,n)));\n}\n} else {\nreturn (new cljs.core.ArrayNode(null,self__.cnt,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,idx,n)));\n\n}\n}\n} else {\nreturn inode;\n}\n});\n\ncljs.core.ArrayNode.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.ArrayNodeIterator(self__.arr,(0),null));\n});\n\ncljs.core.ArrayNode.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$edit,cljs.core.with_meta(cljs.core.cst$sym$cnt,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$arr,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ArrayNode.cljs$lang$type \x3d true;\n\ncljs.core.ArrayNode.cljs$lang$ctorStr \x3d "cljs.core/ArrayNode";\n\ncljs.core.ArrayNode.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ArrayNode");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayNode.\n */\ncljs.core.__GT_ArrayNode \x3d (function cljs$core$__GT_ArrayNode(edit,cnt,arr){\nreturn (new cljs.core.ArrayNode(edit,cnt,arr));\n});\n\ncljs.core.hash_collision_node_find_index \x3d (function cljs$core$hash_collision_node_find_index(arr,cnt,key){\nvar lim \x3d ((2) * cnt);\nvar i \x3d (0);\nwhile(true){\nif((i \x3c lim)){\nif(cljs.core.key_test(key,(arr[i]))){\nreturn i;\n} else {\nvar G__11119 \x3d (i + (2));\ni \x3d G__11119;\ncontinue;\n}\n} else {\nreturn (-1);\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIterable}\n*/\ncljs.core.HashCollisionNode \x3d (function (edit,collision_hash,cnt,arr){\nthis.edit \x3d edit;\nthis.collision_hash \x3d collision_hash;\nthis.cnt \x3d cnt;\nthis.arr \x3d arr;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 131072;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 0;\n});\ncljs.core.HashCollisionNode.prototype.ensure_editable \x3d (function (e){\nvar self__ \x3d this;\nvar inode \x3d this;\nif((e \x3d\x3d\x3d self__.edit)){\nreturn inode;\n} else {\nvar new_arr \x3d (new Array(((2) * (self__.cnt + (1)))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),((2) * self__.cnt));\n\nreturn (new cljs.core.HashCollisionNode(e,self__.collision_hash,self__.cnt,new_arr));\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_without_BANG_ \x3d (function (edit__$1,shift,hash,key,removed_leaf_QMARK_){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx \x3d\x3d\x3d (-1))){\nreturn inode;\n} else {\nremoved_leaf_QMARK_.val \x3d true;\n\nif((self__.cnt \x3d\x3d\x3d (1))){\nreturn null;\n} else {\nvar editable \x3d inode.ensure_editable(edit__$1);\nvar earr \x3d editable.arr;\n(earr[idx] \x3d (earr[(((2) * self__.cnt) - (2))]));\n\n(earr[(idx + (1))] \x3d (earr[(((2) * self__.cnt) - (1))]));\n\n(earr[(((2) * self__.cnt) - (1))] \x3d null);\n\n(earr[(((2) * self__.cnt) - (2))] \x3d null);\n\neditable.cnt \x3d (editable.cnt - (1));\n\nreturn editable;\n}\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_seq \x3d (function (){\nvar self__ \x3d this;\nvar inode \x3d this;\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$1(self__.arr);\n});\n\ncljs.core.HashCollisionNode.prototype.kv_reduce \x3d (function (f,init){\nvar self__ \x3d this;\nvar inode \x3d this;\nreturn cljs.core.inode_kv_reduce(self__.arr,f,init);\n});\n\ncljs.core.HashCollisionNode.prototype.inode_lookup \x3d (function (shift,hash,key,not_found){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx \x3c (0))){\nreturn not_found;\n} else {\nif(cljs.core.key_test(key,(self__.arr[idx]))){\nreturn (self__.arr[(idx + (1))]);\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_assoc_BANG_ \x3d (function (edit__$1,shift,hash,key,val,added_leaf_QMARK_){\nvar self__ \x3d this;\nvar inode \x3d this;\nif((hash \x3d\x3d\x3d self__.collision_hash)){\nvar idx \x3d cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx \x3d\x3d\x3d (-1))){\nif((self__.arr.length \x3e ((2) * self__.cnt))){\nvar editable \x3d cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$6(inode,edit__$1,((2) * self__.cnt),key,(((2) * self__.cnt) + (1)),val);\nadded_leaf_QMARK_.val \x3d true;\n\neditable.cnt \x3d (editable.cnt + (1));\n\nreturn editable;\n} else {\nvar len \x3d self__.arr.length;\nvar new_arr \x3d (new Array((len + (2))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),len);\n\n(new_arr[len] \x3d key);\n\n(new_arr[(len + (1))] \x3d val);\n\nadded_leaf_QMARK_.val \x3d true;\n\nreturn inode.ensure_editable_array(edit__$1,(self__.cnt + (1)),new_arr);\n}\n} else {\nif(((self__.arr[(idx + (1))]) \x3d\x3d\x3d val)){\nreturn inode;\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,(idx + (1)),val);\n}\n}\n} else {\nreturn (new cljs.core.BitmapIndexedNode(edit__$1,(1 \x3c\x3c ((self__.collision_hash \x3e\x3e\x3e shift) \x26 0x01f)),[null,inode,null,null])).inode_assoc_BANG_(edit__$1,shift,hash,key,val,added_leaf_QMARK_);\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_assoc \x3d (function (shift,hash,key,val,added_leaf_QMARK_){\nvar self__ \x3d this;\nvar inode \x3d this;\nif((hash \x3d\x3d\x3d self__.collision_hash)){\nvar idx \x3d cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx \x3d\x3d\x3d (-1))){\nvar len \x3d ((2) * self__.cnt);\nvar new_arr \x3d (new Array((len + (2))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),len);\n\n(new_arr[len] \x3d key);\n\n(new_arr[(len + (1))] \x3d val);\n\nadded_leaf_QMARK_.val \x3d true;\n\nreturn (new cljs.core.HashCollisionNode(null,self__.collision_hash,(self__.cnt + (1)),new_arr));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((self__.arr[(idx + (1))]),val)){\nreturn inode;\n} else {\nreturn (new cljs.core.HashCollisionNode(null,self__.collision_hash,self__.cnt,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,(idx + (1)),val)));\n}\n}\n} else {\nreturn (new cljs.core.BitmapIndexedNode(null,(1 \x3c\x3c ((self__.collision_hash \x3e\x3e\x3e shift) \x26 0x01f)),[null,inode])).inode_assoc(shift,hash,key,val,added_leaf_QMARK_);\n}\n});\n\ncljs.core.HashCollisionNode.prototype.ensure_editable_array \x3d (function (e,count,array){\nvar self__ \x3d this;\nvar inode \x3d this;\nif((e \x3d\x3d\x3d self__.edit)){\nself__.arr \x3d array;\n\nself__.cnt \x3d count;\n\nreturn inode;\n} else {\nreturn (new cljs.core.HashCollisionNode(self__.edit,self__.collision_hash,count,array));\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_find \x3d (function (shift,hash,key,not_found){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx \x3c (0))){\nreturn not_found;\n} else {\nif(cljs.core.key_test(key,(self__.arr[idx]))){\nreturn (new cljs.core.MapEntry((self__.arr[idx]),(self__.arr[(idx + (1))]),null));\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_without \x3d (function (shift,hash,key){\nvar self__ \x3d this;\nvar inode \x3d this;\nvar idx \x3d cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx \x3d\x3d\x3d (-1))){\nreturn inode;\n} else {\nif((self__.cnt \x3d\x3d\x3d (1))){\nreturn null;\n} else {\nreturn (new cljs.core.HashCollisionNode(null,self__.collision_hash,(self__.cnt - (1)),cljs.core.remove_pair(self__.arr,cljs.core.quot(idx,(2)))));\n\n}\n}\n});\n\ncljs.core.HashCollisionNode.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.NodeIterator(self__.arr,(0),null,null));\n});\n\ncljs.core.HashCollisionNode.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$edit,cljs.core.with_meta(cljs.core.cst$sym$collision_DASH_hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$cnt,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$arr,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.HashCollisionNode.cljs$lang$type \x3d true;\n\ncljs.core.HashCollisionNode.cljs$lang$ctorStr \x3d "cljs.core/HashCollisionNode";\n\ncljs.core.HashCollisionNode.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/HashCollisionNode");\n});\n\n/**\n * Positional factory function for cljs.core/HashCollisionNode.\n */\ncljs.core.__GT_HashCollisionNode \x3d (function cljs$core$__GT_HashCollisionNode(edit,collision_hash,cnt,arr){\nreturn (new cljs.core.HashCollisionNode(edit,collision_hash,cnt,arr));\n});\n\ncljs.core.create_node \x3d (function cljs$core$create_node(var_args){\nvar G__11121 \x3d arguments.length;\nswitch (G__11121) {\ncase 6:\nreturn cljs.core.create_node.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ncase 7:\nreturn cljs.core.create_node.cljs$core$IFn$_invoke$arity$7((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.create_node.cljs$core$IFn$_invoke$arity$6 \x3d (function (shift,key1,val1,key2hash,key2,val2){\nvar key1hash \x3d cljs.core.hash(key1);\nif((key1hash \x3d\x3d\x3d key2hash)){\nreturn (new cljs.core.HashCollisionNode(null,key1hash,(2),[key1,val1,key2,val2]));\n} else {\nvar added_leaf_QMARK_ \x3d (new cljs.core.Box(false));\nreturn cljs.core.BitmapIndexedNode.EMPTY.inode_assoc(shift,key1hash,key1,val1,added_leaf_QMARK_).inode_assoc(shift,key2hash,key2,val2,added_leaf_QMARK_);\n}\n});\n\ncljs.core.create_node.cljs$core$IFn$_invoke$arity$7 \x3d (function (edit,shift,key1,val1,key2hash,key2,val2){\nvar key1hash \x3d cljs.core.hash(key1);\nif((key1hash \x3d\x3d\x3d key2hash)){\nreturn (new cljs.core.HashCollisionNode(null,key1hash,(2),[key1,val1,key2,val2]));\n} else {\nvar added_leaf_QMARK_ \x3d (new cljs.core.Box(false));\nreturn cljs.core.BitmapIndexedNode.EMPTY.inode_assoc_BANG_(edit,shift,key1hash,key1,val1,added_leaf_QMARK_).inode_assoc_BANG_(edit,shift,key2hash,key2,val2,added_leaf_QMARK_);\n}\n});\n\ncljs.core.create_node.cljs$lang$maxFixedArity \x3d 7;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.NodeSeq \x3d (function (meta,nodes,i,s,__hash){\nthis.meta \x3d meta;\nthis.nodes \x3d nodes;\nthis.i \x3d i;\nthis.s \x3d s;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32374988;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.NodeSeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.NodeSeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.NodeSeq.prototype.indexOf \x3d (function() {\nvar G__11123 \x3d null;\nvar G__11123__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__11123__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11123 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11123__1.call(this,x);\ncase 2:\nreturn G__11123__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11123.cljs$core$IFn$_invoke$arity$1 \x3d G__11123__1;\nG__11123.cljs$core$IFn$_invoke$arity$2 \x3d G__11123__2;\nreturn G__11123;\n})()\n;\n\ncljs.core.NodeSeq.prototype.lastIndexOf \x3d (function() {\nvar G__11124 \x3d null;\nvar G__11124__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__11124__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11124 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11124__1.call(this,x);\ncase 2:\nreturn G__11124__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11124.cljs$core$IFn$_invoke$arity$1 \x3d G__11124__1;\nG__11124.cljs$core$IFn$_invoke$arity$2 \x3d G__11124__2;\nreturn G__11124;\n})()\n;\n\ncljs.core.NodeSeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.s \x3d\x3d null)){\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,(self__.i + (2)),null);\n} else {\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,self__.i,cljs.core.next(self__.s));\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.s \x3d\x3d null)){\nreturn (new cljs.core.MapEntry((self__.nodes[self__.i]),(self__.nodes[(self__.i + (1))]),null));\n} else {\nreturn cljs.core.first(self__.s);\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar ret \x3d (((self__.s \x3d\x3d null))?cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,(self__.i + (2)),null):cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,self__.i,cljs.core.next(self__.s)));\nif((!((ret \x3d\x3d null)))){\nreturn ret;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn this$__$1;\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.NodeSeq(new_meta,self__.nodes,self__.i,self__.s,self__.__hash));\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.NodeSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$nodes,cljs.core.cst$sym$i,cljs.core.cst$sym$s,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.NodeSeq.cljs$lang$type \x3d true;\n\ncljs.core.NodeSeq.cljs$lang$ctorStr \x3d "cljs.core/NodeSeq";\n\ncljs.core.NodeSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/NodeSeq");\n});\n\n/**\n * Positional factory function for cljs.core/NodeSeq.\n */\ncljs.core.__GT_NodeSeq \x3d (function cljs$core$__GT_NodeSeq(meta,nodes,i,s,__hash){\nreturn (new cljs.core.NodeSeq(meta,nodes,i,s,__hash));\n});\n\nvar G__11125_11128 \x3d cljs.core.NodeSeq.prototype;\nvar G__11126_11129 \x3d cljs.core.ITER_SYMBOL;\nvar G__11127_11130 \x3d ((function (G__11125_11128,G__11126_11129){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11125_11128,G__11126_11129))\n;\ngoog.object.set(G__11125_11128,G__11126_11129,G__11127_11130);\ncljs.core.create_inode_seq \x3d (function cljs$core$create_inode_seq(var_args){\nvar G__11132 \x3d arguments.length;\nswitch (G__11132) {\ncase 1:\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 3:\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$1 \x3d (function (nodes){\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(nodes,(0),null);\n});\n\ncljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3 \x3d (function (nodes,i,s){\nif((s \x3d\x3d null)){\nvar len \x3d nodes.length;\nvar j \x3d i;\nwhile(true){\nif((j \x3c len)){\nif((!(((nodes[j]) \x3d\x3d null)))){\nreturn (new cljs.core.NodeSeq(null,nodes,j,null,null));\n} else {\nvar temp__5718__auto__ \x3d (nodes[(j + (1))]);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar node \x3d temp__5718__auto__;\nvar temp__5718__auto____$1 \x3d node.inode_seq();\nif(cljs.core.truth_(temp__5718__auto____$1)){\nvar node_seq \x3d temp__5718__auto____$1;\nreturn (new cljs.core.NodeSeq(null,nodes,(j + (2)),node_seq,null));\n} else {\nvar G__11134 \x3d (j + (2));\nj \x3d G__11134;\ncontinue;\n}\n} else {\nvar G__11135 \x3d (j + (2));\nj \x3d G__11135;\ncontinue;\n}\n}\n} else {\nreturn null;\n}\nbreak;\n}\n} else {\nreturn (new cljs.core.NodeSeq(null,nodes,i,s,null));\n}\n});\n\ncljs.core.create_inode_seq.cljs$lang$maxFixedArity \x3d 3;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.ArrayNodeSeq \x3d (function (meta,nodes,i,s,__hash){\nthis.meta \x3d meta;\nthis.nodes \x3d nodes;\nthis.i \x3d i;\nthis.s \x3d s;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32374988;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.ArrayNodeSeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ArrayNodeSeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ArrayNodeSeq.prototype.indexOf \x3d (function() {\nvar G__11136 \x3d null;\nvar G__11136__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__11136__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11136 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11136__1.call(this,x);\ncase 2:\nreturn G__11136__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11136.cljs$core$IFn$_invoke$arity$1 \x3d G__11136__1;\nG__11136.cljs$core$IFn$_invoke$arity$2 \x3d G__11136__2;\nreturn G__11136;\n})()\n;\n\ncljs.core.ArrayNodeSeq.prototype.lastIndexOf \x3d (function() {\nvar G__11137 \x3d null;\nvar G__11137__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__11137__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11137 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11137__1.call(this,x);\ncase 2:\nreturn G__11137__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11137.cljs$core$IFn$_invoke$arity$1 \x3d G__11137__1;\nG__11137.cljs$core$IFn$_invoke$arity$2 \x3d G__11137__2;\nreturn G__11137;\n})()\n;\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,self__.i,cljs.core.next(self__.s));\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.first(self__.s);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar ret \x3d cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,self__.i,cljs.core.next(self__.s));\nif((!((ret \x3d\x3d null)))){\nreturn ret;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn this$__$1;\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.ArrayNodeSeq(new_meta,self__.nodes,self__.i,self__.s,self__.__hash));\n}\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.ArrayNodeSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$nodes,cljs.core.cst$sym$i,cljs.core.cst$sym$s,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ArrayNodeSeq.cljs$lang$type \x3d true;\n\ncljs.core.ArrayNodeSeq.cljs$lang$ctorStr \x3d "cljs.core/ArrayNodeSeq";\n\ncljs.core.ArrayNodeSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ArrayNodeSeq");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayNodeSeq.\n */\ncljs.core.__GT_ArrayNodeSeq \x3d (function cljs$core$__GT_ArrayNodeSeq(meta,nodes,i,s,__hash){\nreturn (new cljs.core.ArrayNodeSeq(meta,nodes,i,s,__hash));\n});\n\nvar G__11138_11141 \x3d cljs.core.ArrayNodeSeq.prototype;\nvar G__11139_11142 \x3d cljs.core.ITER_SYMBOL;\nvar G__11140_11143 \x3d ((function (G__11138_11141,G__11139_11142){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11138_11141,G__11139_11142))\n;\ngoog.object.set(G__11138_11141,G__11139_11142,G__11140_11143);\ncljs.core.create_array_node_seq \x3d (function cljs$core$create_array_node_seq(var_args){\nvar G__11145 \x3d arguments.length;\nswitch (G__11145) {\ncase 1:\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 3:\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$1 \x3d (function (nodes){\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3(nodes,(0),null);\n});\n\ncljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3 \x3d (function (nodes,i,s){\nif((s \x3d\x3d null)){\nvar len \x3d nodes.length;\nvar j \x3d i;\nwhile(true){\nif((j \x3c len)){\nvar temp__5718__auto__ \x3d (nodes[j]);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar nj \x3d temp__5718__auto__;\nvar temp__5718__auto____$1 \x3d nj.inode_seq();\nif(cljs.core.truth_(temp__5718__auto____$1)){\nvar ns \x3d temp__5718__auto____$1;\nreturn (new cljs.core.ArrayNodeSeq(null,nodes,(j + (1)),ns,null));\n} else {\nvar G__11147 \x3d (j + (1));\nj \x3d G__11147;\ncontinue;\n}\n} else {\nvar G__11148 \x3d (j + (1));\nj \x3d G__11148;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n} else {\nreturn (new cljs.core.ArrayNodeSeq(null,nodes,i,s,null));\n}\n});\n\ncljs.core.create_array_node_seq.cljs$lang$maxFixedArity \x3d 3;\n\n\n/**\n* @constructor\n*/\ncljs.core.HashMapIter \x3d (function (nil_val,root_iter,seen){\nthis.nil_val \x3d nil_val;\nthis.root_iter \x3d root_iter;\nthis.seen \x3d seen;\n});\ncljs.core.HashMapIter.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (((!(self__.seen))) || (self__.root_iter.hasNext()));\n});\n\ncljs.core.HashMapIter.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nif((!(self__.seen))){\nself__.seen \x3d true;\n\nreturn (new cljs.core.MapEntry(null,self__.nil_val,null));\n} else {\nreturn self__.root_iter.next();\n}\n});\n\ncljs.core.HashMapIter.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.HashMapIter.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$nil_DASH_val,cljs.core.cst$sym$root_DASH_iter,cljs.core.with_meta(cljs.core.cst$sym$seen,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.HashMapIter.cljs$lang$type \x3d true;\n\ncljs.core.HashMapIter.cljs$lang$ctorStr \x3d "cljs.core/HashMapIter";\n\ncljs.core.HashMapIter.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/HashMapIter");\n});\n\n/**\n * Positional factory function for cljs.core/HashMapIter.\n */\ncljs.core.__GT_HashMapIter \x3d (function cljs$core$__GT_HashMapIter(nil_val,root_iter,seen){\nreturn (new cljs.core.HashMapIter(nil_val,root_iter,seen));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.PersistentHashMap \x3d (function (meta,cnt,root,has_nil_QMARK_,nil_val,__hash){\nthis.meta \x3d meta;\nthis.cnt \x3d cnt;\nthis.root \x3d root;\nthis.has_nil_QMARK_ \x3d has_nil_QMARK_;\nthis.nil_val \x3d nil_val;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 16123663;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 139268;\n});\ncljs.core.PersistentHashMap.prototype.cljs$core$IFind$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IFind$_find$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((k \x3d\x3d null)){\nif(self__.has_nil_QMARK_){\nreturn (new cljs.core.MapEntry(null,self__.nil_val,null));\n} else {\nreturn null;\n}\n} else {\nif((self__.root \x3d\x3d null)){\nreturn null;\n} else {\nreturn self__.root.inode_find((0),cljs.core.hash(k),k,null);\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentHashMap.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentHashMap.prototype.keys \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.keys(coll));\n});\n\ncljs.core.PersistentHashMap.prototype.entries \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentHashMap.prototype.values \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.vals(coll));\n});\n\ncljs.core.PersistentHashMap.prototype.has \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentHashMap.prototype.get \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentHashMap.prototype.forEach \x3d (function (f){\nvar self__ \x3d this;\nvar coll \x3d this;\nvar seq__11150 \x3d cljs.core.seq(coll);\nvar chunk__11151 \x3d null;\nvar count__11152 \x3d (0);\nvar i__11153 \x3d (0);\nwhile(true){\nif((i__11153 \x3c count__11152)){\nvar vec__11160 \x3d chunk__11151.cljs$core$IIndexed$_nth$arity$2(null,i__11153);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11160,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11160,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11168 \x3d seq__11150;\nvar G__11169 \x3d chunk__11151;\nvar G__11170 \x3d count__11152;\nvar G__11171 \x3d (i__11153 + (1));\nseq__11150 \x3d G__11168;\nchunk__11151 \x3d G__11169;\ncount__11152 \x3d G__11170;\ni__11153 \x3d G__11171;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__11150);\nif(temp__5720__auto__){\nvar seq__11150__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__11150__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__11150__$1);\nvar G__11172 \x3d cljs.core.chunk_rest(seq__11150__$1);\nvar G__11173 \x3d c__4550__auto__;\nvar G__11174 \x3d cljs.core.count(c__4550__auto__);\nvar G__11175 \x3d (0);\nseq__11150 \x3d G__11172;\nchunk__11151 \x3d G__11173;\ncount__11152 \x3d G__11174;\ni__11153 \x3d G__11175;\ncontinue;\n} else {\nvar vec__11163 \x3d cljs.core.first(seq__11150__$1);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11163,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11163,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11176 \x3d cljs.core.next(seq__11150__$1);\nvar G__11177 \x3d null;\nvar G__11178 \x3d (0);\nvar G__11179 \x3d (0);\nseq__11150 \x3d G__11176;\nchunk__11151 \x3d G__11177;\ncount__11152 \x3d G__11178;\ni__11153 \x3d G__11179;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (coll,k,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((k \x3d\x3d null)){\nif(self__.has_nil_QMARK_){\nreturn self__.nil_val;\n} else {\nreturn not_found;\n}\n} else {\nif((self__.root \x3d\x3d null)){\nreturn not_found;\n} else {\nreturn self__.root.inode_lookup((0),cljs.core.hash(k),k,not_found);\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 \x3d (function (coll,f,init){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar init__$1 \x3d ((self__.has_nil_QMARK_)?(f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(init,null,self__.nil_val) : f.call(null,init,null,self__.nil_val)):init);\nif(cljs.core.reduced_QMARK_(init__$1)){\nreturn cljs.core.deref(init__$1);\n} else {\nif((!((self__.root \x3d\x3d null)))){\nreturn cljs.core.unreduced(self__.root.kv_reduce(f,init__$1));\n} else {\nreturn init__$1;\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar root_iter \x3d ((self__.root)?cljs.core._iterator(self__.root):cljs.core.nil_iter());\nif(self__.has_nil_QMARK_){\nreturn (new cljs.core.HashMapIter(self__.nil_val,root_iter,false));\n} else {\nreturn root_iter;\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.PersistentHashMap(self__.meta,self__.cnt,self__.root,self__.has_nil_QMARK_,self__.nil_val,self__.__hash));\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.cnt;\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_map(coll__$1,other);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.TransientHashMap(({}),self__.root,self__.cnt,self__.has_nil_QMARK_,self__.nil_val));\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.PersistentHashMap.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IMap$_dissoc$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((k \x3d\x3d null)){\nif(self__.has_nil_QMARK_){\nreturn (new cljs.core.PersistentHashMap(self__.meta,(self__.cnt - (1)),self__.root,false,null,null));\n} else {\nreturn coll__$1;\n}\n} else {\nif((self__.root \x3d\x3d null)){\nreturn coll__$1;\n} else {\nvar new_root \x3d self__.root.inode_without((0),cljs.core.hash(k),k);\nif((new_root \x3d\x3d\x3d self__.root)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashMap(self__.meta,(self__.cnt - (1)),new_root,self__.has_nil_QMARK_,self__.nil_val,null));\n}\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IAssociative$_assoc$arity$3 \x3d (function (coll,k,v){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((k \x3d\x3d null)){\nif(((self__.has_nil_QMARK_) \x26\x26 ((v \x3d\x3d\x3d self__.nil_val)))){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashMap(self__.meta,((self__.has_nil_QMARK_)?self__.cnt:(self__.cnt + (1))),self__.root,true,v,null));\n}\n} else {\nvar added_leaf_QMARK_ \x3d (new cljs.core.Box(false));\nvar new_root \x3d (((self__.root \x3d\x3d null))?cljs.core.BitmapIndexedNode.EMPTY:self__.root).inode_assoc((0),cljs.core.hash(k),k,v,added_leaf_QMARK_);\nif((new_root \x3d\x3d\x3d self__.root)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashMap(self__.meta,((added_leaf_QMARK_.val)?(self__.cnt + (1)):self__.cnt),new_root,self__.has_nil_QMARK_,self__.nil_val,null));\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((k \x3d\x3d null)){\nreturn self__.has_nil_QMARK_;\n} else {\nif((self__.root \x3d\x3d null)){\nreturn false;\n} else {\nreturn (!((self__.root.inode_lookup((0),cljs.core.hash(k),k,cljs.core.lookup_sentinel) \x3d\x3d\x3d cljs.core.lookup_sentinel)));\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3e (0))){\nvar s \x3d (((!((self__.root \x3d\x3d null))))?self__.root.inode_seq():null);\nif(self__.has_nil_QMARK_){\nreturn cljs.core.cons((new cljs.core.MapEntry(null,self__.nil_val,null)),s);\n} else {\nreturn s;\n}\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashMap(new_meta,self__.cnt,self__.root,self__.has_nil_QMARK_,self__.nil_val,self__.__hash));\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,entry){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(cljs.core.vector_QMARK_(entry)){\nreturn coll__$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(1)));\n} else {\nvar ret \x3d coll__$1;\nvar es \x3d cljs.core.seq(entry);\nwhile(true){\nif((es \x3d\x3d null)){\nreturn ret;\n} else {\nvar e \x3d cljs.core.first(es);\nif(cljs.core.vector_QMARK_(e)){\nvar G__11180 \x3d cljs.core._assoc(ret,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(1)));\nvar G__11181 \x3d cljs.core.next(es);\nret \x3d G__11180;\nes \x3d G__11181;\ncontinue;\n} else {\nthrow (new Error("conj on a map takes map entries or seqables of map entries"));\n}\n}\nbreak;\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.call \x3d (function() {\nvar G__11182 \x3d null;\nvar G__11182__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__11182__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__11182 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11182__2.call(this,self__,k);\ncase 3:\nreturn G__11182__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11182.cljs$core$IFn$_invoke$arity$2 \x3d G__11182__2;\nG__11182.cljs$core$IFn$_invoke$arity$3 \x3d G__11182__3;\nreturn G__11182;\n})()\n;\n\ncljs.core.PersistentHashMap.prototype.apply \x3d (function (self__,args11149){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11149)));\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentHashMap.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$cnt,cljs.core.cst$sym$root,cljs.core.with_meta(cljs.core.cst$sym$has_DASH_nil_QMARK_,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$tag,cljs.core.cst$sym$boolean], null)),cljs.core.cst$sym$nil_DASH_val,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.PersistentHashMap.cljs$lang$type \x3d true;\n\ncljs.core.PersistentHashMap.cljs$lang$ctorStr \x3d "cljs.core/PersistentHashMap";\n\ncljs.core.PersistentHashMap.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentHashMap");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentHashMap.\n */\ncljs.core.__GT_PersistentHashMap \x3d (function cljs$core$__GT_PersistentHashMap(meta,cnt,root,has_nil_QMARK_,nil_val,__hash){\nreturn (new cljs.core.PersistentHashMap(meta,cnt,root,has_nil_QMARK_,nil_val,__hash));\n});\n\ncljs.core.PersistentHashMap.EMPTY \x3d (new cljs.core.PersistentHashMap(null,(0),null,false,null,cljs.core.empty_unordered_hash));\ncljs.core.PersistentHashMap.fromArray \x3d (function (arr,no_clone){\nvar arr__$1 \x3d ((no_clone)?arr:cljs.core.aclone(arr));\nvar len \x3d arr__$1.length;\nvar i \x3d (0);\nvar ret \x3d cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nwhile(true){\nif((i \x3c len)){\nvar G__11183 \x3d (i + (2));\nvar G__11184 \x3d cljs.core._assoc_BANG_(ret,(arr__$1[i]),(arr__$1[(i + (1))]));\ni \x3d G__11183;\nret \x3d G__11184;\ncontinue;\n} else {\nreturn cljs.core._persistent_BANG_(ret);\n}\nbreak;\n}\n});\ncljs.core.PersistentHashMap.fromArrays \x3d (function (ks,vs){\nvar len \x3d ks.length;\nvar i \x3d (0);\nvar out \x3d cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nwhile(true){\nif((i \x3c len)){\nvar G__11185 \x3d (i + (1));\nvar G__11186 \x3d cljs.core._assoc_BANG_(out,(ks[i]),(vs[i]));\ni \x3d G__11185;\nout \x3d G__11186;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(out);\n}\nbreak;\n}\n});\ncljs.core.PersistentHashMap.createWithCheck \x3d (function (arr){\nvar len \x3d arr.length;\nvar ret \x3d cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nvar i_11187 \x3d (0);\nwhile(true){\nif((i_11187 \x3c len)){\ncljs.core._assoc_BANG_(ret,(arr[i_11187]),(arr[(i_11187 + (1))]));\n\nif(cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core._count(ret),((i_11187 / (2)) + (1)))){\nthrow (new Error(["Duplicate key: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1((arr[i_11187]))].join(\'\')));\n} else {\nvar G__11188 \x3d (i_11187 + (2));\ni_11187 \x3d G__11188;\ncontinue;\n}\n} else {\n}\nbreak;\n}\n\nreturn cljs.core._persistent_BANG_(ret);\n});\nvar G__11189_11192 \x3d cljs.core.PersistentHashMap.prototype;\nvar G__11190_11193 \x3d cljs.core.ITER_SYMBOL;\nvar G__11191_11194 \x3d ((function (G__11189_11192,G__11190_11193){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11189_11192,G__11190_11193))\n;\ngoog.object.set(G__11189_11192,G__11190_11193,G__11191_11194);\n\n/**\n* @constructor\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ITransientMap}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ITransientCollection}\n * @implements {cljs.core.ITransientAssociative}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TransientHashMap \x3d (function (edit,root,count,has_nil_QMARK_,nil_val){\nthis.edit \x3d edit;\nthis.root \x3d root;\nthis.count \x3d count;\nthis.has_nil_QMARK_ \x3d has_nil_QMARK_;\nthis.nil_val \x3d nil_val;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 259;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 56;\n});\ncljs.core.TransientHashMap.prototype.conj_BANG_ \x3d (function (o){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nif(self__.edit){\nif(cljs.core.map_entry_QMARK_(o)){\nreturn tcoll.assoc_BANG_(cljs.core.key(o),cljs.core.val(o));\n} else {\nif(cljs.core.vector_QMARK_(o)){\nreturn tcoll.assoc_BANG_((o.cljs$core$IFn$_invoke$arity$1 ? o.cljs$core$IFn$_invoke$arity$1((0)) : o.call(null,(0))),(o.cljs$core$IFn$_invoke$arity$1 ? o.cljs$core$IFn$_invoke$arity$1((1)) : o.call(null,(1))));\n} else {\nvar es \x3d cljs.core.seq(o);\nvar tcoll__$1 \x3d tcoll;\nwhile(true){\nvar temp__5718__auto__ \x3d cljs.core.first(es);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e \x3d temp__5718__auto__;\nvar G__11196 \x3d cljs.core.next(es);\nvar G__11197 \x3d tcoll__$1.assoc_BANG_(cljs.core.key(e),cljs.core.val(e));\nes \x3d G__11196;\ntcoll__$1 \x3d G__11197;\ncontinue;\n} else {\nreturn tcoll__$1;\n}\nbreak;\n}\n\n}\n}\n} else {\nthrow (new Error("conj! after persistent"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.assoc_BANG_ \x3d (function (k,v){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nif(self__.edit){\nif((k \x3d\x3d null)){\nif((self__.nil_val \x3d\x3d\x3d v)){\n} else {\nself__.nil_val \x3d v;\n}\n\nif(self__.has_nil_QMARK_){\n} else {\nself__.count \x3d (self__.count + (1));\n\nself__.has_nil_QMARK_ \x3d true;\n}\n\nreturn tcoll;\n} else {\nvar added_leaf_QMARK_ \x3d (new cljs.core.Box(false));\nvar node \x3d (((self__.root \x3d\x3d null))?cljs.core.BitmapIndexedNode.EMPTY:self__.root).inode_assoc_BANG_(self__.edit,(0),cljs.core.hash(k),k,v,added_leaf_QMARK_);\nif((node \x3d\x3d\x3d self__.root)){\n} else {\nself__.root \x3d node;\n}\n\nif(added_leaf_QMARK_.val){\nself__.count \x3d (self__.count + (1));\n} else {\n}\n\nreturn tcoll;\n}\n} else {\nthrow (new Error("assoc! after persistent!"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.without_BANG_ \x3d (function (k){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nif(self__.edit){\nif((k \x3d\x3d null)){\nif(self__.has_nil_QMARK_){\nself__.has_nil_QMARK_ \x3d false;\n\nself__.nil_val \x3d null;\n\nself__.count \x3d (self__.count - (1));\n\nreturn tcoll;\n} else {\nreturn tcoll;\n}\n} else {\nif((self__.root \x3d\x3d null)){\nreturn tcoll;\n} else {\nvar removed_leaf_QMARK_ \x3d (new cljs.core.Box(false));\nvar node \x3d self__.root.inode_without_BANG_(self__.edit,(0),cljs.core.hash(k),k,removed_leaf_QMARK_);\nif((node \x3d\x3d\x3d self__.root)){\n} else {\nself__.root \x3d node;\n}\n\nif(removed_leaf_QMARK_.val){\nself__.count \x3d (self__.count - (1));\n} else {\n}\n\nreturn tcoll;\n}\n}\n} else {\nthrow (new Error("dissoc! after persistent!"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.persistent_BANG_ \x3d (function (){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nif(self__.edit){\nself__.edit \x3d null;\n\nreturn (new cljs.core.PersistentHashMap(null,self__.count,self__.root,self__.has_nil_QMARK_,self__.nil_val,null));\n} else {\nthrow (new Error("persistent! called twice"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(self__.edit){\nreturn self__.count;\n} else {\nthrow (new Error("count after persistent!"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (tcoll,k){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif((k \x3d\x3d null)){\nif(self__.has_nil_QMARK_){\nreturn self__.nil_val;\n} else {\nreturn null;\n}\n} else {\nif((self__.root \x3d\x3d null)){\nreturn null;\n} else {\nreturn self__.root.inode_lookup((0),cljs.core.hash(k),k);\n}\n}\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (tcoll,k,not_found){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif((k \x3d\x3d null)){\nif(self__.has_nil_QMARK_){\nreturn self__.nil_val;\n} else {\nreturn not_found;\n}\n} else {\nif((self__.root \x3d\x3d null)){\nreturn not_found;\n} else {\nreturn self__.root.inode_lookup((0),cljs.core.hash(k),k,not_found);\n}\n}\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 \x3d (function (tcoll,val){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nreturn tcoll__$1.conj_BANG_(val);\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 \x3d (function (tcoll){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nreturn tcoll__$1.persistent_BANG_();\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 \x3d (function (tcoll,key,val){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nreturn tcoll__$1.assoc_BANG_(key,val);\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ITransientMap$_dissoc_BANG_$arity$2 \x3d (function (tcoll,key){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nreturn tcoll__$1.without_BANG_(key);\n});\n\ncljs.core.TransientHashMap.prototype.call \x3d (function() {\nvar G__11198 \x3d null;\nvar G__11198__2 \x3d (function (self__,key){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar tcoll \x3d self____$1;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$2(null,key);\n});\nvar G__11198__3 \x3d (function (self__,key,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar tcoll \x3d self____$1;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,not_found);\n});\nG__11198 \x3d function(self__,key,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11198__2.call(this,self__,key);\ncase 3:\nreturn G__11198__3.call(this,self__,key,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11198.cljs$core$IFn$_invoke$arity$2 \x3d G__11198__2;\nG__11198.cljs$core$IFn$_invoke$arity$3 \x3d G__11198__3;\nreturn G__11198;\n})()\n;\n\ncljs.core.TransientHashMap.prototype.apply \x3d (function (self__,args11195){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11195)));\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (key){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$2(null,key);\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (key,not_found){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,not_found);\n});\n\ncljs.core.TransientHashMap.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$edit,new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$tag,cljs.core.cst$sym$boolean,cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$root,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$count,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$has_DASH_nil_QMARK_,new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$tag,cljs.core.cst$sym$boolean,cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$nil_DASH_val,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.TransientHashMap.cljs$lang$type \x3d true;\n\ncljs.core.TransientHashMap.cljs$lang$ctorStr \x3d "cljs.core/TransientHashMap";\n\ncljs.core.TransientHashMap.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/TransientHashMap");\n});\n\n/**\n * Positional factory function for cljs.core/TransientHashMap.\n */\ncljs.core.__GT_TransientHashMap \x3d (function cljs$core$__GT_TransientHashMap(edit,root,count,has_nil_QMARK_,nil_val){\nreturn (new cljs.core.TransientHashMap(edit,root,count,has_nil_QMARK_,nil_val));\n});\n\ncljs.core.tree_map_seq_push \x3d (function cljs$core$tree_map_seq_push(node,stack,ascending_QMARK_){\nvar t \x3d node;\nvar stack__$1 \x3d stack;\nwhile(true){\nif((!((t \x3d\x3d null)))){\nvar G__11199 \x3d ((ascending_QMARK_)?t.left:t.right);\nvar G__11200 \x3d cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack__$1,t);\nt \x3d G__11199;\nstack__$1 \x3d G__11200;\ncontinue;\n} else {\nreturn stack__$1;\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.PersistentTreeMapSeq \x3d (function (meta,stack,ascending_QMARK_,cnt,__hash){\nthis.meta \x3d meta;\nthis.stack \x3d stack;\nthis.ascending_QMARK_ \x3d ascending_QMARK_;\nthis.cnt \x3d cnt;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32374990;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.PersistentTreeMapSeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.indexOf \x3d (function() {\nvar G__11201 \x3d null;\nvar G__11201__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__11201__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11201 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11201__1.call(this,x);\ncase 2:\nreturn G__11201__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11201.cljs$core$IFn$_invoke$arity$1 \x3d G__11201__1;\nG__11201.cljs$core$IFn$_invoke$arity$2 \x3d G__11201__2;\nreturn G__11201;\n})()\n;\n\ncljs.core.PersistentTreeMapSeq.prototype.lastIndexOf \x3d (function() {\nvar G__11202 \x3d null;\nvar G__11202__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__11202__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11202 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11202__1.call(this,x);\ncase 2:\nreturn G__11202__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11202.cljs$core$IFn$_invoke$arity$1 \x3d G__11202__1;\nG__11202.cljs$core$IFn$_invoke$arity$2 \x3d G__11202__2;\nreturn G__11202;\n})()\n;\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nvar t \x3d cljs.core.first(self__.stack);\nvar next_stack \x3d cljs.core.tree_map_seq_push(((self__.ascending_QMARK_)?t.right:t.left),cljs.core.next(self__.stack),self__.ascending_QMARK_);\nif((next_stack \x3d\x3d null)){\nreturn null;\n} else {\nreturn (new cljs.core.PersistentTreeMapSeq(null,next_stack,self__.ascending_QMARK_,(self__.cnt - (1)),null));\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3c (0))){\nreturn (cljs.core.count(cljs.core.next(coll__$1)) + (1));\n} else {\nreturn self__.cnt;\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn cljs.core.peek(self__.stack);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nvar t \x3d cljs.core.first(self__.stack);\nvar next_stack \x3d cljs.core.tree_map_seq_push(((self__.ascending_QMARK_)?t.right:t.left),cljs.core.next(self__.stack),self__.ascending_QMARK_);\nif((!((next_stack \x3d\x3d null)))){\nreturn (new cljs.core.PersistentTreeMapSeq(null,next_stack,self__.ascending_QMARK_,(self__.cnt - (1)),null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn this$__$1;\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeMapSeq(new_meta,self__.stack,self__.ascending_QMARK_,self__.cnt,self__.__hash));\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.PersistentTreeMapSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$stack,cljs.core.with_meta(cljs.core.cst$sym$ascending_QMARK_,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$tag,cljs.core.cst$sym$boolean], null)),cljs.core.cst$sym$cnt,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.PersistentTreeMapSeq.cljs$lang$type \x3d true;\n\ncljs.core.PersistentTreeMapSeq.cljs$lang$ctorStr \x3d "cljs.core/PersistentTreeMapSeq";\n\ncljs.core.PersistentTreeMapSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentTreeMapSeq");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentTreeMapSeq.\n */\ncljs.core.__GT_PersistentTreeMapSeq \x3d (function cljs$core$__GT_PersistentTreeMapSeq(meta,stack,ascending_QMARK_,cnt,__hash){\nreturn (new cljs.core.PersistentTreeMapSeq(meta,stack,ascending_QMARK_,cnt,__hash));\n});\n\nvar G__11203_11206 \x3d cljs.core.PersistentTreeMapSeq.prototype;\nvar G__11204_11207 \x3d cljs.core.ITER_SYMBOL;\nvar G__11205_11208 \x3d ((function (G__11203_11206,G__11204_11207){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11203_11206,G__11204_11207))\n;\ngoog.object.set(G__11203_11206,G__11204_11207,G__11205_11208);\ncljs.core.create_tree_map_seq \x3d (function cljs$core$create_tree_map_seq(tree,ascending_QMARK_,cnt){\nreturn (new cljs.core.PersistentTreeMapSeq(null,cljs.core.tree_map_seq_push(tree,null,ascending_QMARK_),ascending_QMARK_,cnt,null));\n});\n\ncljs.core.balance_left \x3d (function cljs$core$balance_left(key,val,ins,right){\nif((ins instanceof cljs.core.RedNode)){\nif((ins.left instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(ins.key,ins.val,ins.left.blacken(),(new cljs.core.BlackNode(key,val,ins.right,right,null)),null));\n} else {\nif((ins.right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(ins.right.key,ins.right.val,(new cljs.core.BlackNode(ins.key,ins.val,ins.left,ins.right.left,null)),(new cljs.core.BlackNode(key,val,ins.right.right,right,null)),null));\n} else {\nreturn (new cljs.core.BlackNode(key,val,ins,right,null));\n\n}\n}\n} else {\nreturn (new cljs.core.BlackNode(key,val,ins,right,null));\n}\n});\ncljs.core.balance_right \x3d (function cljs$core$balance_right(key,val,left,ins){\nif((ins instanceof cljs.core.RedNode)){\nif((ins.right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(ins.key,ins.val,(new cljs.core.BlackNode(key,val,left,ins.left,null)),ins.right.blacken(),null));\n} else {\nif((ins.left instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(ins.left.key,ins.left.val,(new cljs.core.BlackNode(key,val,left,ins.left.left,null)),(new cljs.core.BlackNode(ins.key,ins.val,ins.left.right,ins.right,null)),null));\n} else {\nreturn (new cljs.core.BlackNode(key,val,left,ins,null));\n\n}\n}\n} else {\nreturn (new cljs.core.BlackNode(key,val,left,ins,null));\n}\n});\ncljs.core.balance_left_del \x3d (function cljs$core$balance_left_del(key,val,del,right){\nif((del instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(key,val,del.blacken(),right,null));\n} else {\nif((right instanceof cljs.core.BlackNode)){\nreturn cljs.core.balance_right(key,val,del,right.redden());\n} else {\nif((((right instanceof cljs.core.RedNode)) \x26\x26 ((right.left instanceof cljs.core.BlackNode)))){\nreturn (new cljs.core.RedNode(right.left.key,right.left.val,(new cljs.core.BlackNode(key,val,del,right.left.left,null)),cljs.core.balance_right(right.key,right.val,right.left.right,right.right.redden()),null));\n} else {\nthrow (new Error("red-black tree invariant violation"));\n\n}\n}\n}\n});\ncljs.core.balance_right_del \x3d (function cljs$core$balance_right_del(key,val,left,del){\nif((del instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(key,val,left,del.blacken(),null));\n} else {\nif((left instanceof cljs.core.BlackNode)){\nreturn cljs.core.balance_left(key,val,left.redden(),del);\n} else {\nif((((left instanceof cljs.core.RedNode)) \x26\x26 ((left.right instanceof cljs.core.BlackNode)))){\nreturn (new cljs.core.RedNode(left.right.key,left.right.val,cljs.core.balance_left(left.key,left.val,left.left.redden(),left.right.left),(new cljs.core.BlackNode(key,val,left.right.right,del,null)),null));\n} else {\nthrow (new Error("red-black tree invariant violation"));\n\n}\n}\n}\n});\ncljs.core.tree_map_kv_reduce \x3d (function cljs$core$tree_map_kv_reduce(node,f,init){\nvar init__$1 \x3d (((!((node.left \x3d\x3d null))))?(function (){var G__11209 \x3d node.left;\nvar G__11210 \x3d f;\nvar G__11211 \x3d init;\nreturn (cljs.core.tree_map_kv_reduce.cljs$core$IFn$_invoke$arity$3 ? cljs.core.tree_map_kv_reduce.cljs$core$IFn$_invoke$arity$3(G__11209,G__11210,G__11211) : cljs.core.tree_map_kv_reduce.call(null,G__11209,G__11210,G__11211));\n})():init);\nif(cljs.core.reduced_QMARK_(init__$1)){\nreturn init__$1;\n} else {\nvar init__$2 \x3d (function (){var G__11212 \x3d init__$1;\nvar G__11213 \x3d node.key;\nvar G__11214 \x3d node.val;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__11212,G__11213,G__11214) : f.call(null,G__11212,G__11213,G__11214));\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn init__$2;\n} else {\nif((!((node.right \x3d\x3d null)))){\nvar G__11215 \x3d node.right;\nvar G__11216 \x3d f;\nvar G__11217 \x3d init__$2;\nreturn (cljs.core.tree_map_kv_reduce.cljs$core$IFn$_invoke$arity$3 ? cljs.core.tree_map_kv_reduce.cljs$core$IFn$_invoke$arity$3(G__11215,G__11216,G__11217) : cljs.core.tree_map_kv_reduce.call(null,G__11215,G__11216,G__11217));\n} else {\nreturn init__$2;\n}\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IMapEntry}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.BlackNode \x3d (function (key,val,left,right,__hash){\nthis.key \x3d key;\nthis.val \x3d val;\nthis.left \x3d left;\nthis.right \x3d right;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 166619935;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.BlackNode.prototype.cljs$core$IFind$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.BlackNode.prototype.cljs$core$IFind$_find$arity$2 \x3d (function (node,k){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nvar G__11219 \x3d k;\nswitch (G__11219) {\ncase (0):\nreturn (new cljs.core.MapEntry((0),self__.key,null));\n\nbreak;\ncase (1):\nreturn (new cljs.core.MapEntry((1),self__.val,null));\n\nbreak;\ndefault:\nreturn null;\n\n}\n});\n\ncljs.core.BlackNode.prototype.lastIndexOf \x3d (function() {\nvar G__11221 \x3d null;\nvar G__11221__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__11221__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11221 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11221__1.call(this,x);\ncase 2:\nreturn G__11221__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11221.cljs$core$IFn$_invoke$arity$1 \x3d G__11221__1;\nG__11221.cljs$core$IFn$_invoke$arity$2 \x3d G__11221__2;\nreturn G__11221;\n})()\n;\n\ncljs.core.BlackNode.prototype.indexOf \x3d (function() {\nvar G__11222 \x3d null;\nvar G__11222__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__11222__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11222 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11222__1.call(this,x);\ncase 2:\nreturn G__11222__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11222.cljs$core$IFn$_invoke$arity$1 \x3d G__11222__1;\nG__11222.cljs$core$IFn$_invoke$arity$2 \x3d G__11222__2;\nreturn G__11222;\n})()\n;\n\ncljs.core.BlackNode.prototype.add_right \x3d (function (ins){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn ins.balance_right(node);\n});\n\ncljs.core.BlackNode.prototype.redden \x3d (function (){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,self__.left,self__.right,null));\n});\n\ncljs.core.BlackNode.prototype.blacken \x3d (function (){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn node;\n});\n\ncljs.core.BlackNode.prototype.add_left \x3d (function (ins){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn ins.balance_left(node);\n});\n\ncljs.core.BlackNode.prototype.replace \x3d (function (key__$1,val__$1,left__$1,right__$1){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.BlackNode(key__$1,val__$1,left__$1,right__$1,null));\n});\n\ncljs.core.BlackNode.prototype.balance_left \x3d (function (parent){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.BlackNode(parent.key,parent.val,node,parent.right,null));\n});\n\ncljs.core.BlackNode.prototype.balance_right \x3d (function (parent){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.BlackNode(parent.key,parent.val,parent.left,node,null));\n});\n\ncljs.core.BlackNode.prototype.remove_left \x3d (function (del){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn cljs.core.balance_left_del(self__.key,self__.val,del,self__.right);\n});\n\ncljs.core.BlackNode.prototype.kv_reduce \x3d (function (f,init){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn cljs.core.tree_map_kv_reduce(node,f,init);\n});\n\ncljs.core.BlackNode.prototype.remove_right \x3d (function (del){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn cljs.core.balance_right_del(self__.key,self__.val,self__.left,del);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (node,k){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,null);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (node,k,not_found){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (node,n){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nif((n \x3d\x3d\x3d (0))){\nreturn self__.key;\n} else {\nif((n \x3d\x3d\x3d (1))){\nreturn self__.val;\n} else {\nthrow (new Error("Index out of bounds"));\n\n}\n}\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (node,n,not_found){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nif((n \x3d\x3d\x3d (0))){\nreturn self__.key;\n} else {\nif((n \x3d\x3d\x3d (1))){\nreturn self__.val;\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IVector$_assoc_n$arity$3 \x3d (function (node,n,v){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null).cljs$core$IVector$_assoc_n$arity$3(null,n,v);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (2);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IMapEntry$_key$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn self__.key;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IMapEntry$_val$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn self__.val;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IStack$_peek$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn self__.val;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IStack$_pop$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key], null);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IReversible$_rseq$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (new cljs.core.IndexedSeq([self__.val,self__.key],(0),null));\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (node,f){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(node__$1,f);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (node,f,start){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(node__$1,f,start);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IAssociative$_assoc$arity$3 \x3d (function (node,k,v){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),k,v);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 \x3d (function (node,k){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (((k \x3d\x3d\x3d (0))) || ((k \x3d\x3d\x3d (1))));\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (new cljs.core.IndexedSeq([self__.key,self__.val],(0),null));\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (node,meta){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core._with_meta(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),meta);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (node,o){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val,o], null);\n});\n\ncljs.core.BlackNode.prototype.call \x3d (function() {\nvar G__11223 \x3d null;\nvar G__11223__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar node \x3d self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__11223__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar node \x3d self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__11223 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11223__2.call(this,self__,k);\ncase 3:\nreturn G__11223__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11223.cljs$core$IFn$_invoke$arity$2 \x3d G__11223__2;\nG__11223.cljs$core$IFn$_invoke$arity$3 \x3d G__11223__3;\nreturn G__11223;\n})()\n;\n\ncljs.core.BlackNode.prototype.apply \x3d (function (self__,args11218){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11218)));\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.BlackNode.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$key,cljs.core.cst$sym$val,cljs.core.cst$sym$left,cljs.core.cst$sym$right,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.BlackNode.cljs$lang$type \x3d true;\n\ncljs.core.BlackNode.cljs$lang$ctorStr \x3d "cljs.core/BlackNode";\n\ncljs.core.BlackNode.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/BlackNode");\n});\n\n/**\n * Positional factory function for cljs.core/BlackNode.\n */\ncljs.core.__GT_BlackNode \x3d (function cljs$core$__GT_BlackNode(key,val,left,right,__hash){\nreturn (new cljs.core.BlackNode(key,val,left,right,__hash));\n});\n\nvar G__11224_11227 \x3d cljs.core.BlackNode.prototype;\nvar G__11225_11228 \x3d cljs.core.ITER_SYMBOL;\nvar G__11226_11229 \x3d ((function (G__11224_11227,G__11225_11228){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11224_11227,G__11225_11228))\n;\ngoog.object.set(G__11224_11227,G__11225_11228,G__11226_11229);\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IMapEntry}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.RedNode \x3d (function (key,val,left,right,__hash){\nthis.key \x3d key;\nthis.val \x3d val;\nthis.left \x3d left;\nthis.right \x3d right;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 166619935;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.RedNode.prototype.cljs$core$IFind$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RedNode.prototype.cljs$core$IFind$_find$arity$2 \x3d (function (node,k){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nvar G__11231 \x3d k;\nswitch (G__11231) {\ncase (0):\nreturn (new cljs.core.MapEntry((0),self__.key,null));\n\nbreak;\ncase (1):\nreturn (new cljs.core.MapEntry((1),self__.val,null));\n\nbreak;\ndefault:\nreturn null;\n\n}\n});\n\ncljs.core.RedNode.prototype.lastIndexOf \x3d (function() {\nvar G__11233 \x3d null;\nvar G__11233__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__11233__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11233 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11233__1.call(this,x);\ncase 2:\nreturn G__11233__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11233.cljs$core$IFn$_invoke$arity$1 \x3d G__11233__1;\nG__11233.cljs$core$IFn$_invoke$arity$2 \x3d G__11233__2;\nreturn G__11233;\n})()\n;\n\ncljs.core.RedNode.prototype.indexOf \x3d (function() {\nvar G__11234 \x3d null;\nvar G__11234__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__11234__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11234 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11234__1.call(this,x);\ncase 2:\nreturn G__11234__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11234.cljs$core$IFn$_invoke$arity$1 \x3d G__11234__1;\nG__11234.cljs$core$IFn$_invoke$arity$2 \x3d G__11234__2;\nreturn G__11234;\n})()\n;\n\ncljs.core.RedNode.prototype.add_right \x3d (function (ins){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,self__.left,ins,null));\n});\n\ncljs.core.RedNode.prototype.redden \x3d (function (){\nvar self__ \x3d this;\nvar node \x3d this;\nthrow (new Error("red-black tree invariant violation"));\n});\n\ncljs.core.RedNode.prototype.blacken \x3d (function (){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.BlackNode(self__.key,self__.val,self__.left,self__.right,null));\n});\n\ncljs.core.RedNode.prototype.add_left \x3d (function (ins){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,ins,self__.right,null));\n});\n\ncljs.core.RedNode.prototype.replace \x3d (function (key__$1,val__$1,left__$1,right__$1){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.RedNode(key__$1,val__$1,left__$1,right__$1,null));\n});\n\ncljs.core.RedNode.prototype.balance_left \x3d (function (parent){\nvar self__ \x3d this;\nvar node \x3d this;\nif((self__.left instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(self__.key,self__.val,self__.left.blacken(),(new cljs.core.BlackNode(parent.key,parent.val,self__.right,parent.right,null)),null));\n} else {\nif((self__.right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(self__.right.key,self__.right.val,(new cljs.core.BlackNode(self__.key,self__.val,self__.left,self__.right.left,null)),(new cljs.core.BlackNode(parent.key,parent.val,self__.right.right,parent.right,null)),null));\n} else {\nreturn (new cljs.core.BlackNode(parent.key,parent.val,node,parent.right,null));\n\n}\n}\n});\n\ncljs.core.RedNode.prototype.balance_right \x3d (function (parent){\nvar self__ \x3d this;\nvar node \x3d this;\nif((self__.right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(self__.key,self__.val,(new cljs.core.BlackNode(parent.key,parent.val,parent.left,self__.left,null)),self__.right.blacken(),null));\n} else {\nif((self__.left instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(self__.left.key,self__.left.val,(new cljs.core.BlackNode(parent.key,parent.val,parent.left,self__.left.left,null)),(new cljs.core.BlackNode(self__.key,self__.val,self__.left.right,self__.right,null)),null));\n} else {\nreturn (new cljs.core.BlackNode(parent.key,parent.val,parent.left,node,null));\n\n}\n}\n});\n\ncljs.core.RedNode.prototype.remove_left \x3d (function (del){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,del,self__.right,null));\n});\n\ncljs.core.RedNode.prototype.kv_reduce \x3d (function (f,init){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn cljs.core.tree_map_kv_reduce(node,f,init);\n});\n\ncljs.core.RedNode.prototype.remove_right \x3d (function (del){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,self__.left,del,null));\n});\n\ncljs.core.RedNode.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (node,k){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,null);\n});\n\ncljs.core.RedNode.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (node,k,not_found){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (node,n){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nif((n \x3d\x3d\x3d (0))){\nreturn self__.key;\n} else {\nif((n \x3d\x3d\x3d (1))){\nreturn self__.val;\n} else {\nthrow (new Error("Index out of bounds"));\n\n}\n}\n});\n\ncljs.core.RedNode.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (node,n,not_found){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nif((n \x3d\x3d\x3d (0))){\nreturn self__.key;\n} else {\nif((n \x3d\x3d\x3d (1))){\nreturn self__.val;\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.RedNode.prototype.cljs$core$IVector$_assoc_n$arity$3 \x3d (function (node,n,v){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null).cljs$core$IVector$_assoc_n$arity$3(null,n,v);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.RedNode.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (2);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IMapEntry$_key$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn self__.key;\n});\n\ncljs.core.RedNode.prototype.cljs$core$IMapEntry$_val$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn self__.val;\n});\n\ncljs.core.RedNode.prototype.cljs$core$IStack$_peek$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn self__.val;\n});\n\ncljs.core.RedNode.prototype.cljs$core$IStack$_pop$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key], null);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IReversible$_rseq$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (new cljs.core.IndexedSeq([self__.val,self__.key],(0),null));\n});\n\ncljs.core.RedNode.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.RedNode.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn null;\n});\n\ncljs.core.RedNode.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (node,f){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(node__$1,f);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (node,f,start){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(node__$1,f,start);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IAssociative$_assoc$arity$3 \x3d (function (node,k,v){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),k,v);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 \x3d (function (node,k){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (((k \x3d\x3d\x3d (0))) || ((k \x3d\x3d\x3d (1))));\n});\n\ncljs.core.RedNode.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (node){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn (new cljs.core.IndexedSeq([self__.key,self__.val],(0),null));\n});\n\ncljs.core.RedNode.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (node,meta){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn cljs.core._with_meta(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),meta);\n});\n\ncljs.core.RedNode.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (node,o){\nvar self__ \x3d this;\nvar node__$1 \x3d this;\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val,o], null);\n});\n\ncljs.core.RedNode.prototype.call \x3d (function() {\nvar G__11235 \x3d null;\nvar G__11235__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar node \x3d self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__11235__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar node \x3d self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__11235 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11235__2.call(this,self__,k);\ncase 3:\nreturn G__11235__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11235.cljs$core$IFn$_invoke$arity$2 \x3d G__11235__2;\nG__11235.cljs$core$IFn$_invoke$arity$3 \x3d G__11235__3;\nreturn G__11235;\n})()\n;\n\ncljs.core.RedNode.prototype.apply \x3d (function (self__,args11230){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11230)));\n});\n\ncljs.core.RedNode.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar node \x3d this;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.RedNode.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$key,cljs.core.cst$sym$val,cljs.core.cst$sym$left,cljs.core.cst$sym$right,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.RedNode.cljs$lang$type \x3d true;\n\ncljs.core.RedNode.cljs$lang$ctorStr \x3d "cljs.core/RedNode";\n\ncljs.core.RedNode.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/RedNode");\n});\n\n/**\n * Positional factory function for cljs.core/RedNode.\n */\ncljs.core.__GT_RedNode \x3d (function cljs$core$__GT_RedNode(key,val,left,right,__hash){\nreturn (new cljs.core.RedNode(key,val,left,right,__hash));\n});\n\nvar G__11236_11239 \x3d cljs.core.RedNode.prototype;\nvar G__11237_11240 \x3d cljs.core.ITER_SYMBOL;\nvar G__11238_11241 \x3d ((function (G__11236_11239,G__11237_11240){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11236_11239,G__11237_11240))\n;\ngoog.object.set(G__11236_11239,G__11237_11240,G__11238_11241);\ncljs.core.tree_map_add \x3d (function cljs$core$tree_map_add(comp,tree,k,v,found){\nif((tree \x3d\x3d null)){\nreturn (new cljs.core.RedNode(k,v,null,null,null));\n} else {\nvar c \x3d (function (){var G__11242 \x3d k;\nvar G__11243 \x3d tree.key;\nreturn (comp.cljs$core$IFn$_invoke$arity$2 ? comp.cljs$core$IFn$_invoke$arity$2(G__11242,G__11243) : comp.call(null,G__11242,G__11243));\n})();\nif((c \x3d\x3d\x3d (0))){\n(found[(0)] \x3d tree);\n\nreturn null;\n} else {\nif((c \x3c (0))){\nvar ins \x3d (function (){var G__11244 \x3d comp;\nvar G__11245 \x3d tree.left;\nvar G__11246 \x3d k;\nvar G__11247 \x3d v;\nvar G__11248 \x3d found;\nreturn (cljs.core.tree_map_add.cljs$core$IFn$_invoke$arity$5 ? cljs.core.tree_map_add.cljs$core$IFn$_invoke$arity$5(G__11244,G__11245,G__11246,G__11247,G__11248) : cljs.core.tree_map_add.call(null,G__11244,G__11245,G__11246,G__11247,G__11248));\n})();\nif((!((ins \x3d\x3d null)))){\nreturn tree.add_left(ins);\n} else {\nreturn null;\n}\n} else {\nvar ins \x3d (function (){var G__11249 \x3d comp;\nvar G__11250 \x3d tree.right;\nvar G__11251 \x3d k;\nvar G__11252 \x3d v;\nvar G__11253 \x3d found;\nreturn (cljs.core.tree_map_add.cljs$core$IFn$_invoke$arity$5 ? cljs.core.tree_map_add.cljs$core$IFn$_invoke$arity$5(G__11249,G__11250,G__11251,G__11252,G__11253) : cljs.core.tree_map_add.call(null,G__11249,G__11250,G__11251,G__11252,G__11253));\n})();\nif((!((ins \x3d\x3d null)))){\nreturn tree.add_right(ins);\n} else {\nreturn null;\n}\n\n}\n}\n}\n});\ncljs.core.tree_map_append \x3d (function cljs$core$tree_map_append(left,right){\nif((left \x3d\x3d null)){\nreturn right;\n} else {\nif((right \x3d\x3d null)){\nreturn left;\n} else {\nif((left instanceof cljs.core.RedNode)){\nif((right instanceof cljs.core.RedNode)){\nvar app \x3d (function (){var G__11254 \x3d left.right;\nvar G__11255 \x3d right.left;\nreturn (cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2 ? cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2(G__11254,G__11255) : cljs.core.tree_map_append.call(null,G__11254,G__11255));\n})();\nif((app instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(app.key,app.val,(new cljs.core.RedNode(left.key,left.val,left.left,app.left,null)),(new cljs.core.RedNode(right.key,right.val,app.right,right.right,null)),null));\n} else {\nreturn (new cljs.core.RedNode(left.key,left.val,left.left,(new cljs.core.RedNode(right.key,right.val,app,right.right,null)),null));\n}\n} else {\nreturn (new cljs.core.RedNode(left.key,left.val,left.left,(function (){var G__11256 \x3d left.right;\nvar G__11257 \x3d right;\nreturn (cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2 ? cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2(G__11256,G__11257) : cljs.core.tree_map_append.call(null,G__11256,G__11257));\n})(),null));\n}\n} else {\nif((right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(right.key,right.val,(function (){var G__11258 \x3d left;\nvar G__11259 \x3d right.left;\nreturn (cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2 ? cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2(G__11258,G__11259) : cljs.core.tree_map_append.call(null,G__11258,G__11259));\n})(),right.right,null));\n} else {\nvar app \x3d (function (){var G__11260 \x3d left.right;\nvar G__11261 \x3d right.left;\nreturn (cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2 ? cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2(G__11260,G__11261) : cljs.core.tree_map_append.call(null,G__11260,G__11261));\n})();\nif((app instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(app.key,app.val,(new cljs.core.BlackNode(left.key,left.val,left.left,app.left,null)),(new cljs.core.BlackNode(right.key,right.val,app.right,right.right,null)),null));\n} else {\nreturn cljs.core.balance_left_del(left.key,left.val,left.left,(new cljs.core.BlackNode(right.key,right.val,app,right.right,null)));\n}\n\n}\n}\n}\n}\n});\ncljs.core.tree_map_remove \x3d (function cljs$core$tree_map_remove(comp,tree,k,found){\nif((!((tree \x3d\x3d null)))){\nvar c \x3d (function (){var G__11262 \x3d k;\nvar G__11263 \x3d tree.key;\nreturn (comp.cljs$core$IFn$_invoke$arity$2 ? comp.cljs$core$IFn$_invoke$arity$2(G__11262,G__11263) : comp.call(null,G__11262,G__11263));\n})();\nif((c \x3d\x3d\x3d (0))){\n(found[(0)] \x3d tree);\n\nreturn cljs.core.tree_map_append(tree.left,tree.right);\n} else {\nif((c \x3c (0))){\nvar del \x3d (function (){var G__11264 \x3d comp;\nvar G__11265 \x3d tree.left;\nvar G__11266 \x3d k;\nvar G__11267 \x3d found;\nreturn (cljs.core.tree_map_remove.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tree_map_remove.cljs$core$IFn$_invoke$arity$4(G__11264,G__11265,G__11266,G__11267) : cljs.core.tree_map_remove.call(null,G__11264,G__11265,G__11266,G__11267));\n})();\nif((((!((del \x3d\x3d null)))) || ((!(((found[(0)]) \x3d\x3d null)))))){\nif((tree.left instanceof cljs.core.BlackNode)){\nreturn cljs.core.balance_left_del(tree.key,tree.val,del,tree.right);\n} else {\nreturn (new cljs.core.RedNode(tree.key,tree.val,del,tree.right,null));\n}\n} else {\nreturn null;\n}\n} else {\nvar del \x3d (function (){var G__11268 \x3d comp;\nvar G__11269 \x3d tree.right;\nvar G__11270 \x3d k;\nvar G__11271 \x3d found;\nreturn (cljs.core.tree_map_remove.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tree_map_remove.cljs$core$IFn$_invoke$arity$4(G__11268,G__11269,G__11270,G__11271) : cljs.core.tree_map_remove.call(null,G__11268,G__11269,G__11270,G__11271));\n})();\nif((((!((del \x3d\x3d null)))) || ((!(((found[(0)]) \x3d\x3d null)))))){\nif((tree.right instanceof cljs.core.BlackNode)){\nreturn cljs.core.balance_right_del(tree.key,tree.val,tree.left,del);\n} else {\nreturn (new cljs.core.RedNode(tree.key,tree.val,tree.left,del,null));\n}\n} else {\nreturn null;\n}\n\n}\n}\n} else {\nreturn null;\n}\n});\ncljs.core.tree_map_replace \x3d (function cljs$core$tree_map_replace(comp,tree,k,v){\nvar tk \x3d tree.key;\nvar c \x3d (comp.cljs$core$IFn$_invoke$arity$2 ? comp.cljs$core$IFn$_invoke$arity$2(k,tk) : comp.call(null,k,tk));\nif((c \x3d\x3d\x3d (0))){\nreturn tree.replace(tk,v,tree.left,tree.right);\n} else {\nif((c \x3c (0))){\nreturn tree.replace(tk,tree.val,(function (){var G__11272 \x3d comp;\nvar G__11273 \x3d tree.left;\nvar G__11274 \x3d k;\nvar G__11275 \x3d v;\nreturn (cljs.core.tree_map_replace.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tree_map_replace.cljs$core$IFn$_invoke$arity$4(G__11272,G__11273,G__11274,G__11275) : cljs.core.tree_map_replace.call(null,G__11272,G__11273,G__11274,G__11275));\n})(),tree.right);\n} else {\nreturn tree.replace(tk,tree.val,tree.left,(function (){var G__11276 \x3d comp;\nvar G__11277 \x3d tree.right;\nvar G__11278 \x3d k;\nvar G__11279 \x3d v;\nreturn (cljs.core.tree_map_replace.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tree_map_replace.cljs$core$IFn$_invoke$arity$4(G__11276,G__11277,G__11278,G__11279) : cljs.core.tree_map_replace.call(null,G__11276,G__11277,G__11278,G__11279));\n})());\n\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISorted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.PersistentTreeMap \x3d (function (comp,tree,cnt,meta,__hash){\nthis.comp \x3d comp;\nthis.tree \x3d tree;\nthis.cnt \x3d cnt;\nthis.meta \x3d meta;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 418776847;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 8192;\n});\ncljs.core.PersistentTreeMap.prototype.cljs$core$IFind$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IFind$_find$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.entry_at(k);\n});\n\ncljs.core.PersistentTreeMap.prototype.forEach \x3d (function (f){\nvar self__ \x3d this;\nvar coll \x3d this;\nvar seq__11281 \x3d cljs.core.seq(coll);\nvar chunk__11282 \x3d null;\nvar count__11283 \x3d (0);\nvar i__11284 \x3d (0);\nwhile(true){\nif((i__11284 \x3c count__11283)){\nvar vec__11291 \x3d chunk__11282.cljs$core$IIndexed$_nth$arity$2(null,i__11284);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11291,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11291,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11303 \x3d seq__11281;\nvar G__11304 \x3d chunk__11282;\nvar G__11305 \x3d count__11283;\nvar G__11306 \x3d (i__11284 + (1));\nseq__11281 \x3d G__11303;\nchunk__11282 \x3d G__11304;\ncount__11283 \x3d G__11305;\ni__11284 \x3d G__11306;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__11281);\nif(temp__5720__auto__){\nvar seq__11281__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__11281__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__11281__$1);\nvar G__11307 \x3d cljs.core.chunk_rest(seq__11281__$1);\nvar G__11308 \x3d c__4550__auto__;\nvar G__11309 \x3d cljs.core.count(c__4550__auto__);\nvar G__11310 \x3d (0);\nseq__11281 \x3d G__11307;\nchunk__11282 \x3d G__11308;\ncount__11283 \x3d G__11309;\ni__11284 \x3d G__11310;\ncontinue;\n} else {\nvar vec__11294 \x3d cljs.core.first(seq__11281__$1);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11294,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11294,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11311 \x3d cljs.core.next(seq__11281__$1);\nvar G__11312 \x3d null;\nvar G__11313 \x3d (0);\nvar G__11314 \x3d (0);\nseq__11281 \x3d G__11311;\nchunk__11282 \x3d G__11312;\ncount__11283 \x3d G__11313;\ni__11284 \x3d G__11314;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.get \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentTreeMap.prototype.entries \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentTreeMap.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentTreeMap.prototype.keys \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.keys(coll));\n});\n\ncljs.core.PersistentTreeMap.prototype.values \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.vals(coll));\n});\n\ncljs.core.PersistentTreeMap.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentTreeMap.prototype.entry_at \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nvar t \x3d self__.tree;\nwhile(true){\nif((!((t \x3d\x3d null)))){\nvar c \x3d (function (){var G__11297 \x3d k;\nvar G__11298 \x3d t.key;\nreturn (self__.comp.cljs$core$IFn$_invoke$arity$2 ? self__.comp.cljs$core$IFn$_invoke$arity$2(G__11297,G__11298) : self__.comp.call(null,G__11297,G__11298));\n})();\nif((c \x3d\x3d\x3d (0))){\nreturn t;\n} else {\nif((c \x3c (0))){\nvar G__11315 \x3d t.left;\nt \x3d G__11315;\ncontinue;\n} else {\nvar G__11316 \x3d t.right;\nt \x3d G__11316;\ncontinue;\n\n}\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.has \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (coll,k,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar n \x3d coll__$1.entry_at(k);\nif((!((n \x3d\x3d null)))){\nreturn n.val;\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 \x3d (function (coll,f,init){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((!((self__.tree \x3d\x3d null)))){\nreturn cljs.core.unreduced(cljs.core.tree_map_kv_reduce(self__.tree,f,init));\n} else {\nreturn init;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.PersistentTreeMap(self__.comp,self__.tree,self__.cnt,self__.meta,self__.__hash));\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.cnt;\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IReversible$_rseq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3e (0))){\nreturn cljs.core.create_tree_map_seq(self__.tree,false,self__.cnt);\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_map(coll__$1,other);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.PersistentTreeMap(self__.comp,null,(0),self__.meta,(0)));\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IMap$_dissoc$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar found \x3d [null];\nvar t \x3d cljs.core.tree_map_remove(self__.comp,self__.tree,k,found);\nif((t \x3d\x3d null)){\nif((cljs.core.nth.cljs$core$IFn$_invoke$arity$2(found,(0)) \x3d\x3d null)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,null,(0),self__.meta,null));\n}\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,t.blacken(),(self__.cnt - (1)),self__.meta,null));\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IAssociative$_assoc$arity$3 \x3d (function (coll,k,v){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar found \x3d [null];\nvar t \x3d cljs.core.tree_map_add(self__.comp,self__.tree,k,v,found);\nif((t \x3d\x3d null)){\nvar found_node \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$2(found,(0));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(v,found_node.val)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,cljs.core.tree_map_replace(self__.comp,self__.tree,k,v),self__.cnt,self__.meta,null));\n}\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,t.blacken(),(self__.cnt + (1)),self__.meta,null));\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 \x3d (function (coll,k){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (!((coll__$1.entry_at(k) \x3d\x3d null)));\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3e (0))){\nreturn cljs.core.create_tree_map_seq(self__.tree,true,self__.cnt);\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,self__.tree,self__.cnt,new_meta,self__.__hash));\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,entry){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif(cljs.core.vector_QMARK_(entry)){\nreturn coll__$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(1)));\n} else {\nvar ret \x3d coll__$1;\nvar es \x3d cljs.core.seq(entry);\nwhile(true){\nif((es \x3d\x3d null)){\nreturn ret;\n} else {\nvar e \x3d cljs.core.first(es);\nif(cljs.core.vector_QMARK_(e)){\nvar G__11317 \x3d cljs.core._assoc(ret,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(1)));\nvar G__11318 \x3d cljs.core.next(es);\nret \x3d G__11317;\nes \x3d G__11318;\ncontinue;\n} else {\nthrow (new Error("conj on a map takes map entries or seqables of map entries"));\n}\n}\nbreak;\n}\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.call \x3d (function() {\nvar G__11319 \x3d null;\nvar G__11319__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__11319__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__11319 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11319__2.call(this,self__,k);\ncase 3:\nreturn G__11319__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11319.cljs$core$IFn$_invoke$arity$2 \x3d G__11319__2;\nG__11319.cljs$core$IFn$_invoke$arity$3 \x3d G__11319__3;\nreturn G__11319;\n})()\n;\n\ncljs.core.PersistentTreeMap.prototype.apply \x3d (function (self__,args11280){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11280)));\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISorted$_sorted_seq$arity$2 \x3d (function (coll,ascending_QMARK_){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3e (0))){\nreturn cljs.core.create_tree_map_seq(self__.tree,ascending_QMARK_,self__.cnt);\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISorted$_sorted_seq_from$arity$3 \x3d (function (coll,k,ascending_QMARK_){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.cnt \x3e (0))){\nvar stack \x3d null;\nvar t \x3d self__.tree;\nwhile(true){\nif((!((t \x3d\x3d null)))){\nvar c \x3d (function (){var G__11301 \x3d k;\nvar G__11302 \x3d t.key;\nreturn (self__.comp.cljs$core$IFn$_invoke$arity$2 ? self__.comp.cljs$core$IFn$_invoke$arity$2(G__11301,G__11302) : self__.comp.call(null,G__11301,G__11302));\n})();\nif((c \x3d\x3d\x3d (0))){\nreturn (new cljs.core.PersistentTreeMapSeq(null,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack,t),ascending_QMARK_,(-1),null));\n} else {\nif(cljs.core.truth_(ascending_QMARK_)){\nif((c \x3c (0))){\nvar G__11320 \x3d cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack,t);\nvar G__11321 \x3d t.left;\nstack \x3d G__11320;\nt \x3d G__11321;\ncontinue;\n} else {\nvar G__11322 \x3d stack;\nvar G__11323 \x3d t.right;\nstack \x3d G__11322;\nt \x3d G__11323;\ncontinue;\n}\n} else {\nif((c \x3e (0))){\nvar G__11324 \x3d cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack,t);\nvar G__11325 \x3d t.right;\nstack \x3d G__11324;\nt \x3d G__11325;\ncontinue;\n} else {\nvar G__11326 \x3d stack;\nvar G__11327 \x3d t.left;\nstack \x3d G__11326;\nt \x3d G__11327;\ncontinue;\n}\n\n}\n}\n} else {\nif((stack \x3d\x3d null)){\nreturn null;\n} else {\nreturn (new cljs.core.PersistentTreeMapSeq(null,stack,ascending_QMARK_,(-1),null));\n}\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISorted$_entry_key$arity$2 \x3d (function (coll,entry){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.key(entry);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISorted$_comparator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.comp;\n});\n\ncljs.core.PersistentTreeMap.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$comp,cljs.core.cst$sym$tree,cljs.core.cst$sym$cnt,cljs.core.cst$sym$meta,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.PersistentTreeMap.cljs$lang$type \x3d true;\n\ncljs.core.PersistentTreeMap.cljs$lang$ctorStr \x3d "cljs.core/PersistentTreeMap";\n\ncljs.core.PersistentTreeMap.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentTreeMap");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentTreeMap.\n */\ncljs.core.__GT_PersistentTreeMap \x3d (function cljs$core$__GT_PersistentTreeMap(comp,tree,cnt,meta,__hash){\nreturn (new cljs.core.PersistentTreeMap(comp,tree,cnt,meta,__hash));\n});\n\ncljs.core.PersistentTreeMap.EMPTY \x3d (new cljs.core.PersistentTreeMap(cljs.core.compare,null,(0),null,cljs.core.empty_unordered_hash));\nvar G__11328_11331 \x3d cljs.core.PersistentTreeMap.prototype;\nvar G__11329_11332 \x3d cljs.core.ITER_SYMBOL;\nvar G__11330_11333 \x3d ((function (G__11328_11331,G__11329_11332){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11328_11331,G__11329_11332))\n;\ngoog.object.set(G__11328_11331,G__11329_11332,G__11330_11333);\n/**\n * keyval \x3d\x3e key val\n *   Returns a new hash map with supplied mappings.\n */\ncljs.core.hash_map \x3d (function cljs$core$hash_map(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11335 \x3d arguments.length;\nvar i__4731__auto___11336 \x3d (0);\nwhile(true){\nif((i__4731__auto___11336 \x3c len__4730__auto___11335)){\nargs__4736__auto__.push((arguments[i__4731__auto___11336]));\n\nvar G__11337 \x3d (i__4731__auto___11336 + (1));\ni__4731__auto___11336 \x3d G__11337;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.hash_map.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.hash_map.cljs$core$IFn$_invoke$arity$variadic \x3d (function (keyvals){\nvar in$ \x3d cljs.core.seq(keyvals);\nvar out \x3d cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nwhile(true){\nif(in$){\nvar G__11338 \x3d cljs.core.nnext(in$);\nvar G__11339 \x3d cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(out,cljs.core.first(in$),cljs.core.second(in$));\nin$ \x3d G__11338;\nout \x3d G__11339;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(out);\n}\nbreak;\n}\n});\n\ncljs.core.hash_map.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.hash_map.cljs$lang$applyTo \x3d (function (seq11334){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11334));\n});\n\n/**\n * keyval \x3d\x3e key val\n *   Returns a new array map with supplied mappings.\n */\ncljs.core.array_map \x3d (function cljs$core$array_map(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11341 \x3d arguments.length;\nvar i__4731__auto___11342 \x3d (0);\nwhile(true){\nif((i__4731__auto___11342 \x3c len__4730__auto___11341)){\nargs__4736__auto__.push((arguments[i__4731__auto___11342]));\n\nvar G__11343 \x3d (i__4731__auto___11342 + (1));\ni__4731__auto___11342 \x3d G__11343;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.array_map.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.array_map.cljs$core$IFn$_invoke$arity$variadic \x3d (function (keyvals){\nvar arr \x3d (((((keyvals instanceof cljs.core.IndexedSeq)) \x26\x26 ((keyvals.i \x3d\x3d\x3d (0)))))?keyvals.arr:cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(keyvals));\nreturn cljs.core.PersistentArrayMap.createAsIfByAssoc(arr);\n});\n\ncljs.core.array_map.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.array_map.cljs$lang$applyTo \x3d (function (seq11340){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11340));\n});\n\n/**\n * keyval \x3d\x3e key val\n *   Returns a new object map with supplied mappings.\n */\ncljs.core.obj_map \x3d (function cljs$core$obj_map(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11350 \x3d arguments.length;\nvar i__4731__auto___11351 \x3d (0);\nwhile(true){\nif((i__4731__auto___11351 \x3c len__4730__auto___11350)){\nargs__4736__auto__.push((arguments[i__4731__auto___11351]));\n\nvar G__11352 \x3d (i__4731__auto___11351 + (1));\ni__4731__auto___11351 \x3d G__11352;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.obj_map.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.obj_map.cljs$core$IFn$_invoke$arity$variadic \x3d (function (keyvals){\nvar ks \x3d [];\nvar obj \x3d ({});\nvar kvs \x3d cljs.core.seq(keyvals);\nwhile(true){\nif(kvs){\nks.push(cljs.core.first(kvs));\n\nvar G__11347_11353 \x3d obj;\nvar G__11348_11354 \x3d cljs.core.first(kvs);\nvar G__11349_11355 \x3d cljs.core.second(kvs);\ngoog.object.set(G__11347_11353,G__11348_11354,G__11349_11355);\n\nvar G__11356 \x3d cljs.core.nnext(kvs);\nkvs \x3d G__11356;\ncontinue;\n} else {\nreturn cljs.core.ObjMap.fromObject(ks,obj);\n}\nbreak;\n}\n});\n\ncljs.core.obj_map.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.obj_map.cljs$lang$applyTo \x3d (function (seq11344){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11344));\n});\n\n/**\n * keyval \x3d\x3e key val\n *   Returns a new sorted map with supplied mappings.\n */\ncljs.core.sorted_map \x3d (function cljs$core$sorted_map(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11358 \x3d arguments.length;\nvar i__4731__auto___11359 \x3d (0);\nwhile(true){\nif((i__4731__auto___11359 \x3c len__4730__auto___11358)){\nargs__4736__auto__.push((arguments[i__4731__auto___11359]));\n\nvar G__11360 \x3d (i__4731__auto___11359 + (1));\ni__4731__auto___11359 \x3d G__11360;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.sorted_map.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.sorted_map.cljs$core$IFn$_invoke$arity$variadic \x3d (function (keyvals){\nvar in$ \x3d cljs.core.seq(keyvals);\nvar out \x3d cljs.core.PersistentTreeMap.EMPTY;\nwhile(true){\nif(in$){\nvar G__11361 \x3d cljs.core.nnext(in$);\nvar G__11362 \x3d cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(out,cljs.core.first(in$),cljs.core.second(in$));\nin$ \x3d G__11361;\nout \x3d G__11362;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n});\n\ncljs.core.sorted_map.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.sorted_map.cljs$lang$applyTo \x3d (function (seq11357){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11357));\n});\n\n/**\n * keyval \x3d\x3e key val\n *   Returns a new sorted map with supplied mappings, using the supplied comparator.\n */\ncljs.core.sorted_map_by \x3d (function cljs$core$sorted_map_by(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11365 \x3d arguments.length;\nvar i__4731__auto___11366 \x3d (0);\nwhile(true){\nif((i__4731__auto___11366 \x3c len__4730__auto___11365)){\nargs__4736__auto__.push((arguments[i__4731__auto___11366]));\n\nvar G__11367 \x3d (i__4731__auto___11366 + (1));\ni__4731__auto___11366 \x3d G__11367;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((1) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.sorted_map_by.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.sorted_map_by.cljs$core$IFn$_invoke$arity$variadic \x3d (function (comparator,keyvals){\nvar in$ \x3d cljs.core.seq(keyvals);\nvar out \x3d (new cljs.core.PersistentTreeMap(cljs.core.fn__GT_comparator(comparator),null,(0),null,(0)));\nwhile(true){\nif(in$){\nvar G__11368 \x3d cljs.core.nnext(in$);\nvar G__11369 \x3d cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(out,cljs.core.first(in$),cljs.core.second(in$));\nin$ \x3d G__11368;\nout \x3d G__11369;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n});\n\ncljs.core.sorted_map_by.cljs$lang$maxFixedArity \x3d (1);\n\n/** @this {Function} */\ncljs.core.sorted_map_by.cljs$lang$applyTo \x3d (function (seq11363){\nvar G__11364 \x3d cljs.core.first(seq11363);\nvar seq11363__$1 \x3d cljs.core.next(seq11363);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11364,seq11363__$1);\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.KeySeq \x3d (function (mseq,_meta){\nthis.mseq \x3d mseq;\nthis._meta \x3d _meta;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32374988;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.KeySeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.KeySeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.KeySeq.prototype.indexOf \x3d (function() {\nvar G__11372 \x3d null;\nvar G__11372__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__11372__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11372 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11372__1.call(this,x);\ncase 2:\nreturn G__11372__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11372.cljs$core$IFn$_invoke$arity$1 \x3d G__11372__1;\nG__11372.cljs$core$IFn$_invoke$arity$2 \x3d G__11372__2;\nreturn G__11372;\n})()\n;\n\ncljs.core.KeySeq.prototype.lastIndexOf \x3d (function() {\nvar G__11373 \x3d null;\nvar G__11373__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__11373__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11373 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11373__1.call(this,x);\ncase 2:\nreturn G__11373__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11373.cljs$core$IFn$_invoke$arity$1 \x3d G__11373__1;\nG__11373.cljs$core$IFn$_invoke$arity$2 \x3d G__11373__2;\nreturn G__11373;\n})()\n;\n\ncljs.core.KeySeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__._meta;\n});\n\ncljs.core.KeySeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar nseq \x3d (((((!((self__.mseq \x3d\x3d null))))?(((((self__.mseq.cljs$lang$protocol_mask$partition0$ \x26 (128))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d self__.mseq.cljs$core$INext$))))?true:(((!self__.mseq.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq):false)):cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq)))?self__.mseq.cljs$core$INext$_next$arity$1(null):cljs.core.next(self__.mseq));\nif((nseq \x3d\x3d null)){\nreturn null;\n} else {\nreturn (new cljs.core.KeySeq(nseq,null));\n}\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar me \x3d self__.mseq.cljs$core$ISeq$_first$arity$1(null);\nreturn me.cljs$core$IMapEntry$_key$arity$1(null);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar nseq \x3d (((((!((self__.mseq \x3d\x3d null))))?(((((self__.mseq.cljs$lang$protocol_mask$partition0$ \x26 (128))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d self__.mseq.cljs$core$INext$))))?true:(((!self__.mseq.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq):false)):cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq)))?self__.mseq.cljs$core$INext$_next$arity$1(null):cljs.core.next(self__.mseq));\nif((!((nseq \x3d\x3d null)))){\nreturn (new cljs.core.KeySeq(nseq,null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.KeySeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__._meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.KeySeq(self__.mseq,new_meta));\n}\n});\n\ncljs.core.KeySeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.KeySeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$mseq,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$tag,cljs.core.cst$sym$not_DASH_native], null)),cljs.core.cst$sym$_meta], null);\n});\n\ncljs.core.KeySeq.cljs$lang$type \x3d true;\n\ncljs.core.KeySeq.cljs$lang$ctorStr \x3d "cljs.core/KeySeq";\n\ncljs.core.KeySeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/KeySeq");\n});\n\n/**\n * Positional factory function for cljs.core/KeySeq.\n */\ncljs.core.__GT_KeySeq \x3d (function cljs$core$__GT_KeySeq(mseq,_meta){\nreturn (new cljs.core.KeySeq(mseq,_meta));\n});\n\nvar G__11374_11377 \x3d cljs.core.KeySeq.prototype;\nvar G__11375_11378 \x3d cljs.core.ITER_SYMBOL;\nvar G__11376_11379 \x3d ((function (G__11374_11377,G__11375_11378){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11374_11377,G__11375_11378))\n;\ngoog.object.set(G__11374_11377,G__11375_11378,G__11376_11379);\n/**\n * Returns a sequence of the map\'s keys, in the same order as (seq map).\n */\ncljs.core.keys \x3d (function cljs$core$keys(map){\nvar temp__5720__auto__ \x3d cljs.core.seq(map);\nif(temp__5720__auto__){\nvar mseq \x3d temp__5720__auto__;\nreturn (new cljs.core.KeySeq(mseq,null));\n} else {\nreturn null;\n}\n});\n/**\n * Returns the key of the map entry.\n */\ncljs.core.key \x3d (function cljs$core$key(map_entry){\nreturn cljs.core._key(map_entry);\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.ValSeq \x3d (function (mseq,_meta){\nthis.mseq \x3d mseq;\nthis._meta \x3d _meta;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32374988;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.ValSeq.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ValSeq.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ValSeq.prototype.indexOf \x3d (function() {\nvar G__11382 \x3d null;\nvar G__11382__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__11382__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11382 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11382__1.call(this,x);\ncase 2:\nreturn G__11382__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11382.cljs$core$IFn$_invoke$arity$1 \x3d G__11382__1;\nG__11382.cljs$core$IFn$_invoke$arity$2 \x3d G__11382__2;\nreturn G__11382;\n})()\n;\n\ncljs.core.ValSeq.prototype.lastIndexOf \x3d (function() {\nvar G__11383 \x3d null;\nvar G__11383__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__11383__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__11383 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11383__1.call(this,x);\ncase 2:\nreturn G__11383__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11383.cljs$core$IFn$_invoke$arity$1 \x3d G__11383__1;\nG__11383.cljs$core$IFn$_invoke$arity$2 \x3d G__11383__2;\nreturn G__11383;\n})()\n;\n\ncljs.core.ValSeq.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__._meta;\n});\n\ncljs.core.ValSeq.prototype.cljs$core$INext$_next$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar nseq \x3d (((((!((self__.mseq \x3d\x3d null))))?(((((self__.mseq.cljs$lang$protocol_mask$partition0$ \x26 (128))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d self__.mseq.cljs$core$INext$))))?true:(((!self__.mseq.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq):false)):cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq)))?self__.mseq.cljs$core$INext$_next$arity$1(null):cljs.core.next(self__.mseq));\nif((nseq \x3d\x3d null)){\nreturn null;\n} else {\nreturn (new cljs.core.ValSeq(nseq,null));\n}\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (coll,f){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (coll,f,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar me \x3d self__.mseq.cljs$core$ISeq$_first$arity$1(null);\nreturn me.cljs$core$IMapEntry$_val$arity$1(null);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar nseq \x3d (((((!((self__.mseq \x3d\x3d null))))?(((((self__.mseq.cljs$lang$protocol_mask$partition0$ \x26 (128))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d self__.mseq.cljs$core$INext$))))?true:(((!self__.mseq.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq):false)):cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq)))?self__.mseq.cljs$core$INext$_next$arity$1(null):cljs.core.next(self__.mseq));\nif((!((nseq \x3d\x3d null)))){\nreturn (new cljs.core.ValSeq(nseq,null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.ValSeq.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1;\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__._meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.ValSeq(self__.mseq,new_meta));\n}\n});\n\ncljs.core.ValSeq.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.ValSeq.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$mseq,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$tag,cljs.core.cst$sym$not_DASH_native], null)),cljs.core.cst$sym$_meta], null);\n});\n\ncljs.core.ValSeq.cljs$lang$type \x3d true;\n\ncljs.core.ValSeq.cljs$lang$ctorStr \x3d "cljs.core/ValSeq";\n\ncljs.core.ValSeq.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ValSeq");\n});\n\n/**\n * Positional factory function for cljs.core/ValSeq.\n */\ncljs.core.__GT_ValSeq \x3d (function cljs$core$__GT_ValSeq(mseq,_meta){\nreturn (new cljs.core.ValSeq(mseq,_meta));\n});\n\nvar G__11384_11387 \x3d cljs.core.ValSeq.prototype;\nvar G__11385_11388 \x3d cljs.core.ITER_SYMBOL;\nvar G__11386_11389 \x3d ((function (G__11384_11387,G__11385_11388){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11384_11387,G__11385_11388))\n;\ngoog.object.set(G__11384_11387,G__11385_11388,G__11386_11389);\n/**\n * Returns a sequence of the map\'s values, in the same order as (seq map).\n */\ncljs.core.vals \x3d (function cljs$core$vals(map){\nvar temp__5720__auto__ \x3d cljs.core.seq(map);\nif(temp__5720__auto__){\nvar mseq \x3d temp__5720__auto__;\nreturn (new cljs.core.ValSeq(mseq,null));\n} else {\nreturn null;\n}\n});\n/**\n * Returns the value in the map entry.\n */\ncljs.core.val \x3d (function cljs$core$val(map_entry){\nreturn cljs.core._val(map_entry);\n});\n/**\n * Returns a map that consists of the rest of the maps conj-ed onto\n *   the first.  If a key occurs in more than one map, the mapping from\n *   the latter (left-to-right) will be the mapping in the result.\n */\ncljs.core.merge \x3d (function cljs$core$merge(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11393 \x3d arguments.length;\nvar i__4731__auto___11394 \x3d (0);\nwhile(true){\nif((i__4731__auto___11394 \x3c len__4730__auto___11393)){\nargs__4736__auto__.push((arguments[i__4731__auto___11394]));\n\nvar G__11395 \x3d (i__4731__auto___11394 + (1));\ni__4731__auto___11394 \x3d G__11395;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.merge.cljs$core$IFn$_invoke$arity$variadic \x3d (function (maps){\nif(cljs.core.truth_(cljs.core.some(cljs.core.identity,maps))){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2((function (p1__11390_SHARP_,p2__11391_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2((function (){var or__4131__auto__ \x3d p1__11390_SHARP_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.PersistentArrayMap.EMPTY;\n}\n})(),p2__11391_SHARP_);\n}),maps);\n} else {\nreturn null;\n}\n});\n\ncljs.core.merge.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.merge.cljs$lang$applyTo \x3d (function (seq11392){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11392));\n});\n\n/**\n * Returns a map that consists of the rest of the maps conj-ed onto\n *   the first.  If a key occurs in more than one map, the mapping(s)\n *   from the latter (left-to-right) will be combined with the mapping in\n *   the result by calling (f val-in-result val-in-latter).\n */\ncljs.core.merge_with \x3d (function cljs$core$merge_with(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11400 \x3d arguments.length;\nvar i__4731__auto___11401 \x3d (0);\nwhile(true){\nif((i__4731__auto___11401 \x3c len__4730__auto___11400)){\nargs__4736__auto__.push((arguments[i__4731__auto___11401]));\n\nvar G__11402 \x3d (i__4731__auto___11401 + (1));\ni__4731__auto___11401 \x3d G__11402;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((1) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,maps){\nif(cljs.core.truth_(cljs.core.some(cljs.core.identity,maps))){\nvar merge_entry \x3d (function (m,e){\nvar k \x3d cljs.core.key(e);\nvar v \x3d cljs.core.val(e);\nif(cljs.core.contains_QMARK_(m,k)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__11398 \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__11399 \x3d v;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__11398,G__11399) : f.call(null,G__11398,G__11399));\n})());\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,v);\n}\n});\nvar merge2 \x3d ((function (merge_entry){\nreturn (function (m1,m2){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(merge_entry,(function (){var or__4131__auto__ \x3d m1;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.PersistentArrayMap.EMPTY;\n}\n})(),cljs.core.seq(m2));\n});})(merge_entry))\n;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(merge2,maps);\n} else {\nreturn null;\n}\n});\n\ncljs.core.merge_with.cljs$lang$maxFixedArity \x3d (1);\n\n/** @this {Function} */\ncljs.core.merge_with.cljs$lang$applyTo \x3d (function (seq11396){\nvar G__11397 \x3d cljs.core.first(seq11396);\nvar seq11396__$1 \x3d cljs.core.next(seq11396);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11397,seq11396__$1);\n});\n\n/**\n * Returns a map containing only those entries in map whose key is in keys\n */\ncljs.core.select_keys \x3d (function cljs$core$select_keys(map,keyseq){\nvar ret \x3d cljs.core.PersistentArrayMap.EMPTY;\nvar keys \x3d cljs.core.seq(keyseq);\nwhile(true){\nif(keys){\nvar key \x3d cljs.core.first(keys);\nvar entry \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$3(map,key,cljs.core.cst$kw$cljs$core_SLASH_not_DASH_found);\nvar G__11403 \x3d ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(entry,cljs.core.cst$kw$cljs$core_SLASH_not_DASH_found))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(ret,key,entry):ret);\nvar G__11404 \x3d cljs.core.next(keys);\nret \x3d G__11403;\nkeys \x3d G__11404;\ncontinue;\n} else {\nreturn cljs.core._with_meta(ret,cljs.core.meta(map));\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.HashSetIter \x3d (function (iter){\nthis.iter \x3d iter;\n});\ncljs.core.HashSetIter.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn self__.iter.hasNext();\n});\n\ncljs.core.HashSetIter.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nif(self__.iter.hasNext()){\nreturn self__.iter.next().key;\n} else {\nthrow (new Error("No such element"));\n}\n});\n\ncljs.core.HashSetIter.prototype.remove \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (new Error("Unsupported operation"));\n});\n\ncljs.core.HashSetIter.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$iter], null);\n});\n\ncljs.core.HashSetIter.cljs$lang$type \x3d true;\n\ncljs.core.HashSetIter.cljs$lang$ctorStr \x3d "cljs.core/HashSetIter";\n\ncljs.core.HashSetIter.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/HashSetIter");\n});\n\n/**\n * Positional factory function for cljs.core/HashSetIter.\n */\ncljs.core.__GT_HashSetIter \x3d (function cljs$core$__GT_HashSetIter(iter){\nreturn (new cljs.core.HashSetIter(iter));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.ISet}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.PersistentHashSet \x3d (function (meta,hash_map,__hash){\nthis.meta \x3d meta;\nthis.hash_map \x3d hash_map;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 15077647;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 139268;\n});\ncljs.core.PersistentHashSet.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentHashSet.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentHashSet.prototype.keys \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentHashSet.prototype.entries \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_set_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentHashSet.prototype.values \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentHashSet.prototype.has \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentHashSet.prototype.forEach \x3d (function (f){\nvar self__ \x3d this;\nvar coll \x3d this;\nvar seq__11408 \x3d cljs.core.seq(coll);\nvar chunk__11409 \x3d null;\nvar count__11410 \x3d (0);\nvar i__11411 \x3d (0);\nwhile(true){\nif((i__11411 \x3c count__11410)){\nvar vec__11418 \x3d chunk__11409.cljs$core$IIndexed$_nth$arity$2(null,i__11411);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11418,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11418,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11427 \x3d seq__11408;\nvar G__11428 \x3d chunk__11409;\nvar G__11429 \x3d count__11410;\nvar G__11430 \x3d (i__11411 + (1));\nseq__11408 \x3d G__11427;\nchunk__11409 \x3d G__11428;\ncount__11410 \x3d G__11429;\ni__11411 \x3d G__11430;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__11408);\nif(temp__5720__auto__){\nvar seq__11408__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__11408__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__11408__$1);\nvar G__11431 \x3d cljs.core.chunk_rest(seq__11408__$1);\nvar G__11432 \x3d c__4550__auto__;\nvar G__11433 \x3d cljs.core.count(c__4550__auto__);\nvar G__11434 \x3d (0);\nseq__11408 \x3d G__11431;\nchunk__11409 \x3d G__11432;\ncount__11410 \x3d G__11433;\ni__11411 \x3d G__11434;\ncontinue;\n} else {\nvar vec__11421 \x3d cljs.core.first(seq__11408__$1);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11421,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11421,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11435 \x3d cljs.core.next(seq__11408__$1);\nvar G__11436 \x3d null;\nvar G__11437 \x3d (0);\nvar G__11438 \x3d (0);\nseq__11408 \x3d G__11435;\nchunk__11409 \x3d G__11436;\ncount__11410 \x3d G__11437;\ni__11411 \x3d G__11438;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (coll,v){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,v,null);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (coll,v,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar temp__5718__auto__ \x3d cljs.core._find(self__.hash_map,v);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar entry \x3d temp__5718__auto__;\nreturn cljs.core.key(entry);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.HashSetIter(cljs.core._iterator(self__.hash_map)));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.PersistentHashSet(self__.meta,self__.hash_map,self__.__hash));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._count(self__.hash_map);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar and__4120__auto__ \x3d cljs.core.set_QMARK_(other);\nif(and__4120__auto__){\nvar and__4120__auto____$1 \x3d (cljs.core.count(coll__$1) \x3d\x3d\x3d cljs.core.count(other));\nif(and__4120__auto____$1){\ntry{return cljs.core.reduce_kv(((function (and__4120__auto____$1,and__4120__auto__,coll__$1){\nreturn (function (p1__11406_SHARP_,p2__11405_SHARP_){\nvar or__4131__auto__ \x3d cljs.core.contains_QMARK_(other,p2__11405_SHARP_);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.reduced(false);\n}\n});})(and__4120__auto____$1,and__4120__auto__,coll__$1))\n,true,self__.hash_map);\n}catch (e11426){if((e11426 instanceof Error)){\nvar ex \x3d e11426;\nreturn false;\n} else {\nthrow e11426;\n\n}\n}} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.TransientHashSet(cljs.core._as_transient(self__.hash_map)));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._with_meta(cljs.core.PersistentHashSet.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ISet$_disjoin$arity$2 \x3d (function (coll,v){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.PersistentHashSet(self__.meta,cljs.core._dissoc(self__.hash_map,v),null));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.keys(self__.hash_map);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashSet(new_meta,self__.hash_map,self__.__hash));\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.PersistentHashSet(self__.meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.hash_map,o,null),null));\n});\n\ncljs.core.PersistentHashSet.prototype.call \x3d (function() {\nvar G__11439 \x3d null;\nvar G__11439__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__11439__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__11439 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11439__2.call(this,self__,k);\ncase 3:\nreturn G__11439__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11439.cljs$core$IFn$_invoke$arity$2 \x3d G__11439__2;\nG__11439.cljs$core$IFn$_invoke$arity$3 \x3d G__11439__3;\nreturn G__11439;\n})()\n;\n\ncljs.core.PersistentHashSet.prototype.apply \x3d (function (self__,args11407){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11407)));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentHashSet.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$hash_DASH_map,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.PersistentHashSet.cljs$lang$type \x3d true;\n\ncljs.core.PersistentHashSet.cljs$lang$ctorStr \x3d "cljs.core/PersistentHashSet";\n\ncljs.core.PersistentHashSet.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentHashSet");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentHashSet.\n */\ncljs.core.__GT_PersistentHashSet \x3d (function cljs$core$__GT_PersistentHashSet(meta,hash_map,__hash){\nreturn (new cljs.core.PersistentHashSet(meta,hash_map,__hash));\n});\n\ncljs.core.PersistentHashSet.EMPTY \x3d (new cljs.core.PersistentHashSet(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.empty_unordered_hash));\ncljs.core.PersistentHashSet.fromArray \x3d (function (items,no_clone){\nvar len \x3d items.length;\nif((len \x3c\x3d cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD)){\nvar arr \x3d ((no_clone)?items:cljs.core.aclone(items));\nvar i \x3d (0);\nvar out \x3d cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY);\nwhile(true){\nif((i \x3c len)){\nvar G__11440 \x3d (i + (1));\nvar G__11441 \x3d cljs.core._assoc_BANG_(out,(items[i]),null);\ni \x3d G__11440;\nout \x3d G__11441;\ncontinue;\n} else {\nreturn (new cljs.core.PersistentHashSet(null,cljs.core._persistent_BANG_(out),null));\n}\nbreak;\n}\n} else {\nvar i \x3d (0);\nvar out \x3d cljs.core.transient$(cljs.core.PersistentHashSet.EMPTY);\nwhile(true){\nif((i \x3c len)){\nvar G__11442 \x3d (i + (1));\nvar G__11443 \x3d cljs.core._conj_BANG_(out,(items[i]));\ni \x3d G__11442;\nout \x3d G__11443;\ncontinue;\n} else {\nreturn cljs.core._persistent_BANG_(out);\n}\nbreak;\n}\n}\n});\ncljs.core.PersistentHashSet.createWithCheck \x3d (function (items){\nvar len \x3d items.length;\nvar t \x3d cljs.core._as_transient(cljs.core.PersistentHashSet.EMPTY);\nvar n__4607__auto___11444 \x3d len;\nvar i_11445 \x3d (0);\nwhile(true){\nif((i_11445 \x3c n__4607__auto___11444)){\ncljs.core._conj_BANG_(t,(items[i_11445]));\n\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(t),(i_11445 + (1)))){\n} else {\nthrow (new Error(["Duplicate key: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1((items[i_11445]))].join(\'\')));\n}\n\nvar G__11446 \x3d (i_11445 + (1));\ni_11445 \x3d G__11446;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core._persistent_BANG_(t);\n});\ncljs.core.PersistentHashSet.createAsIfByAssoc \x3d (function (items){\nvar len \x3d items.length;\nvar t \x3d cljs.core._as_transient(cljs.core.PersistentHashSet.EMPTY);\nvar n__4607__auto___11447 \x3d len;\nvar i_11448 \x3d (0);\nwhile(true){\nif((i_11448 \x3c n__4607__auto___11447)){\ncljs.core._conj_BANG_(t,(items[i_11448]));\n\nvar G__11449 \x3d (i_11448 + (1));\ni_11448 \x3d G__11449;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core._persistent_BANG_(t);\n});\nvar G__11450_11453 \x3d cljs.core.PersistentHashSet.prototype;\nvar G__11451_11454 \x3d cljs.core.ITER_SYMBOL;\nvar G__11452_11455 \x3d ((function (G__11450_11453,G__11451_11454){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11450_11453,G__11451_11454))\n;\ngoog.object.set(G__11450_11453,G__11451_11454,G__11452_11455);\n\n/**\n* @constructor\n * @implements {cljs.core.ITransientSet}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ITransientCollection}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TransientHashSet \x3d (function (transient_map){\nthis.transient_map \x3d transient_map;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 136;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 259;\n});\ncljs.core.TransientHashSet.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 \x3d (function (tcoll,o){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nself__.transient_map \x3d cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(self__.transient_map,o,null);\n\nreturn tcoll__$1;\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 \x3d (function (tcoll){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nreturn (new cljs.core.PersistentHashSet(null,cljs.core.persistent_BANG_(self__.transient_map),null));\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ITransientSet$_disjoin_BANG_$arity$2 \x3d (function (tcoll,v){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nself__.transient_map \x3d cljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$2(self__.transient_map,v);\n\nreturn tcoll__$1;\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (tcoll){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nreturn cljs.core.count(self__.transient_map);\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (tcoll,v){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nreturn tcoll__$1.cljs$core$ILookup$_lookup$arity$3(null,v,null);\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (tcoll,v,not_found){\nvar self__ \x3d this;\nvar tcoll__$1 \x3d this;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,v,cljs.core.lookup_sentinel) \x3d\x3d\x3d cljs.core.lookup_sentinel)){\nreturn not_found;\n} else {\nreturn v;\n}\n});\n\ncljs.core.TransientHashSet.prototype.call \x3d (function() {\nvar G__11457 \x3d null;\nvar G__11457__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar tcoll \x3d self____$1;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,k,cljs.core.lookup_sentinel) \x3d\x3d\x3d cljs.core.lookup_sentinel)){\nreturn null;\n} else {\nreturn k;\n}\n});\nvar G__11457__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar tcoll \x3d self____$1;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,k,cljs.core.lookup_sentinel) \x3d\x3d\x3d cljs.core.lookup_sentinel)){\nreturn not_found;\n} else {\nreturn k;\n}\n});\nG__11457 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11457__2.call(this,self__,k);\ncase 3:\nreturn G__11457__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11457.cljs$core$IFn$_invoke$arity$2 \x3d G__11457__2;\nG__11457.cljs$core$IFn$_invoke$arity$3 \x3d G__11457__3;\nreturn G__11457;\n})()\n;\n\ncljs.core.TransientHashSet.prototype.apply \x3d (function (self__,args11456){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11456)));\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,k,cljs.core.lookup_sentinel) \x3d\x3d\x3d cljs.core.lookup_sentinel)){\nreturn null;\n} else {\nreturn k;\n}\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar tcoll \x3d this;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,k,cljs.core.lookup_sentinel) \x3d\x3d\x3d cljs.core.lookup_sentinel)){\nreturn not_found;\n} else {\nreturn k;\n}\n});\n\ncljs.core.TransientHashSet.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$transient_DASH_map,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.TransientHashSet.cljs$lang$type \x3d true;\n\ncljs.core.TransientHashSet.cljs$lang$ctorStr \x3d "cljs.core/TransientHashSet";\n\ncljs.core.TransientHashSet.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/TransientHashSet");\n});\n\n/**\n * Positional factory function for cljs.core/TransientHashSet.\n */\ncljs.core.__GT_TransientHashSet \x3d (function cljs$core$__GT_TransientHashSet(transient_map){\nreturn (new cljs.core.TransientHashSet(transient_map));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.ISet}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISorted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.PersistentTreeSet \x3d (function (meta,tree_map,__hash){\nthis.meta \x3d meta;\nthis.tree_map \x3d tree_map;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 417730831;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 8192;\n});\ncljs.core.PersistentTreeSet.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentTreeSet.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentTreeSet.prototype.keys \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentTreeSet.prototype.entries \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_set_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentTreeSet.prototype.values \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.es6_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentTreeSet.prototype.has \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentTreeSet.prototype.forEach \x3d (function (f){\nvar self__ \x3d this;\nvar coll \x3d this;\nvar seq__11461 \x3d cljs.core.seq(coll);\nvar chunk__11462 \x3d null;\nvar count__11463 \x3d (0);\nvar i__11464 \x3d (0);\nwhile(true){\nif((i__11464 \x3c count__11463)){\nvar vec__11471 \x3d chunk__11462.cljs$core$IIndexed$_nth$arity$2(null,i__11464);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11471,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11471,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11480 \x3d seq__11461;\nvar G__11481 \x3d chunk__11462;\nvar G__11482 \x3d count__11463;\nvar G__11483 \x3d (i__11464 + (1));\nseq__11461 \x3d G__11480;\nchunk__11462 \x3d G__11481;\ncount__11463 \x3d G__11482;\ni__11464 \x3d G__11483;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__11461);\nif(temp__5720__auto__){\nvar seq__11461__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__11461__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__11461__$1);\nvar G__11484 \x3d cljs.core.chunk_rest(seq__11461__$1);\nvar G__11485 \x3d c__4550__auto__;\nvar G__11486 \x3d cljs.core.count(c__4550__auto__);\nvar G__11487 \x3d (0);\nseq__11461 \x3d G__11484;\nchunk__11462 \x3d G__11485;\ncount__11463 \x3d G__11486;\ni__11464 \x3d G__11487;\ncontinue;\n} else {\nvar vec__11474 \x3d cljs.core.first(seq__11461__$1);\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11474,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11474,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__11488 \x3d cljs.core.next(seq__11461__$1);\nvar G__11489 \x3d null;\nvar G__11490 \x3d (0);\nvar G__11491 \x3d (0);\nseq__11461 \x3d G__11488;\nchunk__11462 \x3d G__11489;\ncount__11463 \x3d G__11490;\ni__11464 \x3d G__11491;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (coll,v){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,v,null);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (coll,v,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar n \x3d self__.tree_map.entry_at(v);\nif((!((n \x3d\x3d null)))){\nreturn n.key;\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.PersistentTreeSet(self__.meta,self__.tree_map,self__.__hash));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.count(self__.tree_map);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IReversible$_rseq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((cljs.core.count(self__.tree_map) \x3e (0))){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.key,cljs.core.rseq(self__.tree_map));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (coll,other){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nvar and__4120__auto__ \x3d cljs.core.set_QMARK_(other);\nif(and__4120__auto__){\nvar and__4120__auto____$1 \x3d (cljs.core.count(coll__$1) \x3d\x3d\x3d cljs.core.count(other));\nif(and__4120__auto____$1){\ntry{return cljs.core.reduce_kv(((function (and__4120__auto____$1,and__4120__auto__,coll__$1){\nreturn (function (p1__11459_SHARP_,p2__11458_SHARP_){\nvar or__4131__auto__ \x3d cljs.core.contains_QMARK_(other,p2__11458_SHARP_);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.reduced(false);\n}\n});})(and__4120__auto____$1,and__4120__auto__,coll__$1))\n,true,self__.tree_map);\n}catch (e11479){if((e11479 instanceof Error)){\nvar ex \x3d e11479;\nreturn false;\n} else {\nthrow e11479;\n\n}\n}} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.PersistentTreeSet(self__.meta,cljs.core._empty(self__.tree_map),(0)));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISet$_disjoin$arity$2 \x3d (function (coll,v){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.PersistentTreeSet(self__.meta,cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(self__.tree_map,v),null));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.keys(self__.tree_map);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (coll,new_meta){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeSet(new_meta,self__.tree_map,self__.__hash));\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (coll,o){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (new cljs.core.PersistentTreeSet(self__.meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.tree_map,o,null),null));\n});\n\ncljs.core.PersistentTreeSet.prototype.call \x3d (function() {\nvar G__11492 \x3d null;\nvar G__11492__2 \x3d (function (self__,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__11492__3 \x3d (function (self__,k,not_found){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar coll \x3d self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__11492 \x3d function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__11492__2.call(this,self__,k);\ncase 3:\nreturn G__11492__3.call(this,self__,k,not_found);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__11492.cljs$core$IFn$_invoke$arity$2 \x3d G__11492__2;\nG__11492.cljs$core$IFn$_invoke$arity$3 \x3d G__11492__3;\nreturn G__11492;\n})()\n;\n\ncljs.core.PersistentTreeSet.prototype.apply \x3d (function (self__,args11460){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args11460)));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,not_found){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISorted$_sorted_seq$arity$2 \x3d (function (coll,ascending_QMARK_){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.key,cljs.core._sorted_seq(self__.tree_map,ascending_QMARK_));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISorted$_sorted_seq_from$arity$3 \x3d (function (coll,k,ascending_QMARK_){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.key,cljs.core._sorted_seq_from(self__.tree_map,k,ascending_QMARK_));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISorted$_entry_key$arity$2 \x3d (function (coll,entry){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn entry;\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISorted$_comparator$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._comparator(self__.tree_map);\n});\n\ncljs.core.PersistentTreeSet.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$tree_DASH_map,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.PersistentTreeSet.cljs$lang$type \x3d true;\n\ncljs.core.PersistentTreeSet.cljs$lang$ctorStr \x3d "cljs.core/PersistentTreeSet";\n\ncljs.core.PersistentTreeSet.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/PersistentTreeSet");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentTreeSet.\n */\ncljs.core.__GT_PersistentTreeSet \x3d (function cljs$core$__GT_PersistentTreeSet(meta,tree_map,__hash){\nreturn (new cljs.core.PersistentTreeSet(meta,tree_map,__hash));\n});\n\ncljs.core.PersistentTreeSet.EMPTY \x3d (new cljs.core.PersistentTreeSet(null,cljs.core.PersistentTreeMap.EMPTY,cljs.core.empty_unordered_hash));\nvar G__11493_11496 \x3d cljs.core.PersistentTreeSet.prototype;\nvar G__11494_11497 \x3d cljs.core.ITER_SYMBOL;\nvar G__11495_11498 \x3d ((function (G__11493_11496,G__11494_11497){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11493_11496,G__11494_11497))\n;\ngoog.object.set(G__11493_11496,G__11494_11497,G__11495_11498);\ncljs.core.set_from_indexed_seq \x3d (function cljs$core$set_from_indexed_seq(iseq){\nvar arr \x3d iseq.arr;\nvar ret \x3d (function (){var a__4604__auto__ \x3d arr;\nvar l__4605__auto__ \x3d a__4604__auto__.length;\nvar i \x3d (0);\nvar res \x3d cljs.core._as_transient(cljs.core.PersistentHashSet.EMPTY);\nwhile(true){\nif((i \x3c l__4605__auto__)){\nvar G__11499 \x3d (i + (1));\nvar G__11500 \x3d cljs.core._conj_BANG_(res,(arr[i]));\ni \x3d G__11499;\nres \x3d G__11500;\ncontinue;\n} else {\nreturn res;\n}\nbreak;\n}\n})();\nreturn ret.cljs$core$ITransientCollection$_persistent_BANG_$arity$1(null);\n});\n/**\n * Returns a set of the distinct elements of coll.\n */\ncljs.core.set \x3d (function cljs$core$set(coll){\nif(cljs.core.set_QMARK_(coll)){\nreturn cljs.core.with_meta(coll,null);\n} else {\nvar in$ \x3d cljs.core.seq(coll);\nif((in$ \x3d\x3d null)){\nreturn cljs.core.PersistentHashSet.EMPTY;\n} else {\nif((((in$ instanceof cljs.core.IndexedSeq)) \x26\x26 ((in$.i \x3d\x3d\x3d (0))))){\nreturn cljs.core.PersistentHashSet.createAsIfByAssoc(in$.arr);\n} else {\nvar in$__$1 \x3d in$;\nvar out \x3d cljs.core._as_transient(cljs.core.PersistentHashSet.EMPTY);\nwhile(true){\nif((!((in$__$1 \x3d\x3d null)))){\nvar G__11501 \x3d cljs.core.next(in$__$1);\nvar G__11502 \x3d cljs.core._conj_BANG_(out,cljs.core._first(in$__$1));\nin$__$1 \x3d G__11501;\nout \x3d G__11502;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(out);\n}\nbreak;\n}\n\n}\n}\n}\n});\n/**\n * Returns a new hash set with supplied keys.  Any equal keys are\n *   handled as if by repeated uses of conj.\n */\ncljs.core.hash_set \x3d (function cljs$core$hash_set(var_args){\nvar G__11505 \x3d arguments.length;\nswitch (G__11505) {\ncase 0:\nreturn cljs.core.hash_set.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___11507 \x3d arguments.length;\nvar i__4731__auto___11508 \x3d (0);\nwhile(true){\nif((i__4731__auto___11508 \x3c len__4730__auto___11507)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___11508]));\n\nvar G__11509 \x3d (i__4731__auto___11508 + (1));\ni__4731__auto___11508 \x3d G__11509;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((0)),(0),null));\nreturn cljs.core.hash_set.cljs$core$IFn$_invoke$arity$variadic(argseq__4752__auto__);\n\n}\n});\n\ncljs.core.hash_set.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.PersistentHashSet.EMPTY;\n});\n\ncljs.core.hash_set.cljs$core$IFn$_invoke$arity$variadic \x3d (function (keys){\nreturn cljs.core.set(keys);\n});\n\n/** @this {Function} */\ncljs.core.hash_set.cljs$lang$applyTo \x3d (function (seq11504){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11504));\n});\n\ncljs.core.hash_set.cljs$lang$maxFixedArity \x3d (0);\n\n/**\n * Returns a new sorted set with supplied keys.\n */\ncljs.core.sorted_set \x3d (function cljs$core$sorted_set(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11511 \x3d arguments.length;\nvar i__4731__auto___11512 \x3d (0);\nwhile(true){\nif((i__4731__auto___11512 \x3c len__4730__auto___11511)){\nargs__4736__auto__.push((arguments[i__4731__auto___11512]));\n\nvar G__11513 \x3d (i__4731__auto___11512 + (1));\ni__4731__auto___11512 \x3d G__11513;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.sorted_set.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.sorted_set.cljs$core$IFn$_invoke$arity$variadic \x3d (function (keys){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,cljs.core.PersistentTreeSet.EMPTY,keys);\n});\n\ncljs.core.sorted_set.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.sorted_set.cljs$lang$applyTo \x3d (function (seq11510){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11510));\n});\n\n/**\n * Returns a new sorted set with supplied keys, using the supplied comparator.\n */\ncljs.core.sorted_set_by \x3d (function cljs$core$sorted_set_by(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11516 \x3d arguments.length;\nvar i__4731__auto___11517 \x3d (0);\nwhile(true){\nif((i__4731__auto___11517 \x3c len__4730__auto___11516)){\nargs__4736__auto__.push((arguments[i__4731__auto___11517]));\n\nvar G__11518 \x3d (i__4731__auto___11517 + (1));\ni__4731__auto___11517 \x3d G__11518;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((1) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.sorted_set_by.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.sorted_set_by.cljs$core$IFn$_invoke$arity$variadic \x3d (function (comparator,keys){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,(new cljs.core.PersistentTreeSet(null,cljs.core.sorted_map_by(comparator),(0))),keys);\n});\n\ncljs.core.sorted_set_by.cljs$lang$maxFixedArity \x3d (1);\n\n/** @this {Function} */\ncljs.core.sorted_set_by.cljs$lang$applyTo \x3d (function (seq11514){\nvar G__11515 \x3d cljs.core.first(seq11514);\nvar seq11514__$1 \x3d cljs.core.next(seq11514);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11515,seq11514__$1);\n});\n\n/**\n * Given a map of replacement pairs and a vector/collection, returns a\n *   vector/seq with any elements \x3d a key in smap replaced with the\n *   corresponding val in smap.  Returns a transducer when no collection\n *   is provided.\n */\ncljs.core.replace \x3d (function cljs$core$replace(var_args){\nvar G__11522 \x3d arguments.length;\nswitch (G__11522) {\ncase 1:\nreturn cljs.core.replace.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.replace.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.replace.cljs$core$IFn$_invoke$arity$1 \x3d (function (smap){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$1((function (p1__11519_SHARP_){\nvar temp__5718__auto__ \x3d cljs.core.find(smap,p1__11519_SHARP_);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e \x3d temp__5718__auto__;\nreturn cljs.core.val(e);\n} else {\nreturn p1__11519_SHARP_;\n}\n}));\n});\n\ncljs.core.replace.cljs$core$IFn$_invoke$arity$2 \x3d (function (smap,coll){\nif(cljs.core.vector_QMARK_(coll)){\nvar n \x3d cljs.core.count(coll);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (n){\nreturn (function (v,i){\nvar temp__5718__auto__ \x3d cljs.core.find(smap,cljs.core.nth.cljs$core$IFn$_invoke$arity$2(v,i));\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e \x3d temp__5718__auto__;\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(v,i,cljs.core.second(e));\n} else {\nreturn v;\n}\n});})(n))\n,coll,cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,cljs.core.iterate(cljs.core.inc,(0))));\n} else {\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__11520_SHARP_){\nvar temp__5718__auto__ \x3d cljs.core.find(smap,p1__11520_SHARP_);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e \x3d temp__5718__auto__;\nreturn cljs.core.second(e);\n} else {\nreturn p1__11520_SHARP_;\n}\n}),coll);\n}\n});\n\ncljs.core.replace.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a lazy sequence of the elements of coll with duplicates removed.\n *   Returns a stateful transducer when no collection is provided.\n */\ncljs.core.distinct \x3d (function cljs$core$distinct(var_args){\nvar G__11525 \x3d arguments.length;\nswitch (G__11525) {\ncase 0:\nreturn cljs.core.distinct.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.distinct.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.distinct.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn (function (rf){\nvar seen \x3d cljs.core.volatile_BANG_(cljs.core.PersistentHashSet.EMPTY);\nreturn ((function (seen){\nreturn (function() {\nvar G__11536 \x3d null;\nvar G__11536__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__11536__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__11536__2 \x3d (function (result,input){\nif(cljs.core.contains_QMARK_(cljs.core.deref(seen),input)){\nreturn result;\n} else {\nseen.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(seen.cljs$core$IDeref$_deref$arity$1(null),input));\n\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__11536 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__11536__0.call(this);\ncase 1:\nreturn G__11536__1.call(this,result);\ncase 2:\nreturn G__11536__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11536.cljs$core$IFn$_invoke$arity$0 \x3d G__11536__0;\nG__11536.cljs$core$IFn$_invoke$arity$1 \x3d G__11536__1;\nG__11536.cljs$core$IFn$_invoke$arity$2 \x3d G__11536__2;\nreturn G__11536;\n})()\n;})(seen))\n});\n});\n\ncljs.core.distinct.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nvar step \x3d (function cljs$core$step(xs,seen){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar fexpr__11530 \x3d (function (p__11531,seen__$1){\nwhile(true){\nvar vec__11532 \x3d p__11531;\nvar f \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11532,(0),null);\nvar xs__$1 \x3d vec__11532;\nvar temp__5720__auto__ \x3d cljs.core.seq(xs__$1);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nif(cljs.core.contains_QMARK_(seen__$1,f)){\nvar G__11537 \x3d cljs.core.rest(s);\nvar G__11538 \x3d seen__$1;\np__11531 \x3d G__11537;\nseen__$1 \x3d G__11538;\ncontinue;\n} else {\nreturn cljs.core.cons(f,cljs$core$step(cljs.core.rest(s),cljs.core.conj.cljs$core$IFn$_invoke$arity$2(seen__$1,f)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\nreturn fexpr__11530(xs,seen);\n}),null,null));\n});\nreturn step(coll,cljs.core.PersistentHashSet.EMPTY);\n});\n\ncljs.core.distinct.cljs$lang$maxFixedArity \x3d 1;\n\n/**\n * Return a seq of all but the last item in coll, in linear time\n */\ncljs.core.butlast \x3d (function cljs$core$butlast(s){\nvar ret \x3d cljs.core.PersistentVector.EMPTY;\nvar s__$1 \x3d s;\nwhile(true){\nif(cljs.core.next(s__$1)){\nvar G__11539 \x3d cljs.core.conj.cljs$core$IFn$_invoke$arity$2(ret,cljs.core.first(s__$1));\nvar G__11540 \x3d cljs.core.next(s__$1);\nret \x3d G__11539;\ns__$1 \x3d G__11540;\ncontinue;\n} else {\nreturn cljs.core.seq(ret);\n}\nbreak;\n}\n});\n/**\n * Returns the name String of a string, symbol or keyword.\n */\ncljs.core.name \x3d (function cljs$core$name(x){\nif((((!((x \x3d\x3d null))))?(((((x.cljs$lang$protocol_mask$partition1$ \x26 (4096))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$INamed$))))?true:false):false)){\nreturn cljs.core._name(x);\n} else {\nif(typeof x \x3d\x3d\x3d \'string\'){\nreturn x;\n} else {\nthrow (new Error(["Doesn\'t support name: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x)].join(\'\')));\n}\n}\n});\n/**\n * Returns a map with the keys mapped to the corresponding vals.\n */\ncljs.core.zipmap \x3d (function cljs$core$zipmap(keys,vals){\nvar map \x3d cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY);\nvar ks \x3d cljs.core.seq(keys);\nvar vs \x3d cljs.core.seq(vals);\nwhile(true){\nif(((ks) \x26\x26 (vs))){\nvar G__11542 \x3d cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(map,cljs.core.first(ks),cljs.core.first(vs));\nvar G__11543 \x3d cljs.core.next(ks);\nvar G__11544 \x3d cljs.core.next(vs);\nmap \x3d G__11542;\nks \x3d G__11543;\nvs \x3d G__11544;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(map);\n}\nbreak;\n}\n});\n/**\n * Returns the x for which (k x), a number, is greatest.\n *   \n *   If there are multiple such xs, the last one is returned.\n */\ncljs.core.max_key \x3d (function cljs$core$max_key(var_args){\nvar G__11552 \x3d arguments.length;\nswitch (G__11552) {\ncase 2:\nreturn cljs.core.max_key.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.max_key.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___11554 \x3d arguments.length;\nvar i__4731__auto___11555 \x3d (0);\nwhile(true){\nif((i__4731__auto___11555 \x3c len__4730__auto___11554)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___11555]));\n\nvar G__11556 \x3d (i__4731__auto___11555 + (1));\ni__4731__auto___11555 \x3d G__11556;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.max_key.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.max_key.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,x){\nreturn x;\n});\n\ncljs.core.max_key.cljs$core$IFn$_invoke$arity$3 \x3d (function (k,x,y){\nif(((k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(x) : k.call(null,x)) \x3e (k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(y) : k.call(null,y)))){\nreturn x;\n} else {\nreturn y;\n}\n});\n\ncljs.core.max_key.cljs$core$IFn$_invoke$arity$variadic \x3d (function (k,x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__11545_SHARP_,p2__11546_SHARP_){\nreturn cljs.core.max_key.cljs$core$IFn$_invoke$arity$3(k,p1__11545_SHARP_,p2__11546_SHARP_);\n}),cljs.core.max_key.cljs$core$IFn$_invoke$arity$3(k,x,y),more);\n});\n\n/** @this {Function} */\ncljs.core.max_key.cljs$lang$applyTo \x3d (function (seq11548){\nvar G__11549 \x3d cljs.core.first(seq11548);\nvar seq11548__$1 \x3d cljs.core.next(seq11548);\nvar G__11550 \x3d cljs.core.first(seq11548__$1);\nvar seq11548__$2 \x3d cljs.core.next(seq11548__$1);\nvar G__11551 \x3d cljs.core.first(seq11548__$2);\nvar seq11548__$3 \x3d cljs.core.next(seq11548__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11549,G__11550,G__11551,seq11548__$3);\n});\n\ncljs.core.max_key.cljs$lang$maxFixedArity \x3d (3);\n\n/**\n * Returns the x for which (k x), a number, is least.\n * \n *   If there are multiple such xs, the last one is returned.\n */\ncljs.core.min_key \x3d (function cljs$core$min_key(var_args){\nvar G__11564 \x3d arguments.length;\nswitch (G__11564) {\ncase 2:\nreturn cljs.core.min_key.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.min_key.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___11566 \x3d arguments.length;\nvar i__4731__auto___11567 \x3d (0);\nwhile(true){\nif((i__4731__auto___11567 \x3c len__4730__auto___11566)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___11567]));\n\nvar G__11568 \x3d (i__4731__auto___11567 + (1));\ni__4731__auto___11567 \x3d G__11568;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.min_key.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.min_key.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,x){\nreturn x;\n});\n\ncljs.core.min_key.cljs$core$IFn$_invoke$arity$3 \x3d (function (k,x,y){\nif(((k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(x) : k.call(null,x)) \x3c (k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(y) : k.call(null,y)))){\nreturn x;\n} else {\nreturn y;\n}\n});\n\ncljs.core.min_key.cljs$core$IFn$_invoke$arity$variadic \x3d (function (k,x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__11557_SHARP_,p2__11558_SHARP_){\nreturn cljs.core.min_key.cljs$core$IFn$_invoke$arity$3(k,p1__11557_SHARP_,p2__11558_SHARP_);\n}),cljs.core.min_key.cljs$core$IFn$_invoke$arity$3(k,x,y),more);\n});\n\n/** @this {Function} */\ncljs.core.min_key.cljs$lang$applyTo \x3d (function (seq11560){\nvar G__11561 \x3d cljs.core.first(seq11560);\nvar seq11560__$1 \x3d cljs.core.next(seq11560);\nvar G__11562 \x3d cljs.core.first(seq11560__$1);\nvar seq11560__$2 \x3d cljs.core.next(seq11560__$1);\nvar G__11563 \x3d cljs.core.first(seq11560__$2);\nvar seq11560__$3 \x3d cljs.core.next(seq11560__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11561,G__11562,G__11563,seq11560__$3);\n});\n\ncljs.core.min_key.cljs$lang$maxFixedArity \x3d (3);\n\n\n/**\n* @constructor\n*/\ncljs.core.ArrayList \x3d (function (arr){\nthis.arr \x3d arr;\n});\ncljs.core.ArrayList.prototype.add \x3d (function (x){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn self__.arr.push(x);\n});\n\ncljs.core.ArrayList.prototype.size \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn self__.arr.length;\n});\n\ncljs.core.ArrayList.prototype.clear \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn self__.arr \x3d [];\n});\n\ncljs.core.ArrayList.prototype.isEmpty \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn (self__.arr.length \x3d\x3d\x3d (0));\n});\n\ncljs.core.ArrayList.prototype.toArray \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn self__.arr;\n});\n\ncljs.core.ArrayList.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$arr,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.ArrayList.cljs$lang$type \x3d true;\n\ncljs.core.ArrayList.cljs$lang$ctorStr \x3d "cljs.core/ArrayList";\n\ncljs.core.ArrayList.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/ArrayList");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayList.\n */\ncljs.core.__GT_ArrayList \x3d (function cljs$core$__GT_ArrayList(arr){\nreturn (new cljs.core.ArrayList(arr));\n});\n\ncljs.core.array_list \x3d (function cljs$core$array_list(){\nreturn (new cljs.core.ArrayList([]));\n});\n/**\n * Returns a lazy sequence of lists like partition, but may include\n *   partitions with fewer than n items at the end.  Returns a stateful\n *   transducer when no collection is provided.\n */\ncljs.core.partition_all \x3d (function cljs$core$partition_all(var_args){\nvar G__11570 \x3d arguments.length;\nswitch (G__11570) {\ncase 1:\nreturn cljs.core.partition_all.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.partition_all.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.partition_all.cljs$core$IFn$_invoke$arity$1 \x3d (function (n){\nreturn (function (rf){\nvar a \x3d cljs.core.array_list();\nreturn ((function (a){\nreturn (function() {\nvar G__11572 \x3d null;\nvar G__11572__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__11572__1 \x3d (function (result){\nvar result__$1 \x3d (cljs.core.truth_(a.isEmpty())?result:(function (){var v \x3d cljs.core.vec(a.toArray());\na.clear();\n\nreturn cljs.core.unreduced((rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v)));\n})());\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result__$1) : rf.call(null,result__$1));\n});\nvar G__11572__2 \x3d (function (result,input){\na.add(input);\n\nif((n \x3d\x3d\x3d a.size())){\nvar v \x3d cljs.core.vec(a.toArray());\na.clear();\n\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v));\n} else {\nreturn result;\n}\n});\nG__11572 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__11572__0.call(this);\ncase 1:\nreturn G__11572__1.call(this,result);\ncase 2:\nreturn G__11572__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11572.cljs$core$IFn$_invoke$arity$0 \x3d G__11572__0;\nG__11572.cljs$core$IFn$_invoke$arity$1 \x3d G__11572__1;\nG__11572.cljs$core$IFn$_invoke$arity$2 \x3d G__11572__2;\nreturn G__11572;\n})()\n;})(a))\n});\n});\n\ncljs.core.partition_all.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,coll){\nreturn cljs.core.partition_all.cljs$core$IFn$_invoke$arity$3(n,n,coll);\n});\n\ncljs.core.partition_all.cljs$core$IFn$_invoke$arity$3 \x3d (function (n,step,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nreturn cljs.core.cons(cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,s),cljs.core.partition_all.cljs$core$IFn$_invoke$arity$3(n,step,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(step,s)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.partition_all.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Returns a lazy sequence of successive items from coll while\n *   (pred item) returns logical true. pred must be free of side-effects.\n *   Returns a transducer when no collection is provided.\n */\ncljs.core.take_while \x3d (function cljs$core$take_while(var_args){\nvar G__11574 \x3d arguments.length;\nswitch (G__11574) {\ncase 1:\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.take_while.cljs$core$IFn$_invoke$arity$1 \x3d (function (pred){\nreturn (function (rf){\nreturn (function() {\nvar G__11577 \x3d null;\nvar G__11577__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__11577__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__11577__2 \x3d (function (result,input){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(input) : pred.call(null,input)))){\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n} else {\nreturn cljs.core.reduced(result);\n}\n});\nG__11577 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__11577__0.call(this);\ncase 1:\nreturn G__11577__1.call(this,result);\ncase 2:\nreturn G__11577__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11577.cljs$core$IFn$_invoke$arity$0 \x3d G__11577__0;\nG__11577.cljs$core$IFn$_invoke$arity$1 \x3d G__11577__1;\nG__11577.cljs$core$IFn$_invoke$arity$2 \x3d G__11577__2;\nreturn G__11577;\n})()\n});\n});\n\ncljs.core.take_while.cljs$core$IFn$_invoke$arity$2 \x3d (function (pred,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nif(cljs.core.truth_((function (){var G__11575 \x3d cljs.core.first(s);\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(G__11575) : pred.call(null,G__11575));\n})())){\nreturn cljs.core.cons(cljs.core.first(s),cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(pred,cljs.core.rest(s)));\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.take_while.cljs$lang$maxFixedArity \x3d 2;\n\ncljs.core.mk_bound_fn \x3d (function cljs$core$mk_bound_fn(sc,test,key){\nreturn (function (e){\nvar comp \x3d cljs.core._comparator(sc);\nvar G__11578 \x3d (function (){var G__11580 \x3d cljs.core._entry_key(sc,e);\nvar G__11581 \x3d key;\nreturn (comp.cljs$core$IFn$_invoke$arity$2 ? comp.cljs$core$IFn$_invoke$arity$2(G__11580,G__11581) : comp.call(null,G__11580,G__11581));\n})();\nvar G__11579 \x3d (0);\nreturn (test.cljs$core$IFn$_invoke$arity$2 ? test.cljs$core$IFn$_invoke$arity$2(G__11578,G__11579) : test.call(null,G__11578,G__11579));\n});\n});\n/**\n * sc must be a sorted collection, test(s) one of \x3c, \x3c\x3d, \x3e or\n *   \x3e\x3d. Returns a seq of those entries with keys ek for\n *   which (test (.. sc comparator (compare ek key)) 0) is true\n */\ncljs.core.subseq \x3d (function cljs$core$subseq(var_args){\nvar G__11583 \x3d arguments.length;\nswitch (G__11583) {\ncase 3:\nreturn cljs.core.subseq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 5:\nreturn cljs.core.subseq.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.subseq.cljs$core$IFn$_invoke$arity$3 \x3d (function (sc,test,key){\nvar include \x3d cljs.core.mk_bound_fn(sc,test,key);\nif(cljs.core.truth_((function (){var fexpr__11584 \x3d cljs.core.PersistentHashSet.createAsIfByAssoc([cljs.core._GT_,cljs.core._GT__EQ_]);\nreturn (fexpr__11584.cljs$core$IFn$_invoke$arity$1 ? fexpr__11584.cljs$core$IFn$_invoke$arity$1(test) : fexpr__11584.call(null,test));\n})())){\nvar temp__5720__auto__ \x3d cljs.core._sorted_seq_from(sc,key,true);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar vec__11585 \x3d temp__5720__auto__;\nvar e \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11585,(0),null);\nvar s \x3d vec__11585;\nif(cljs.core.truth_((include.cljs$core$IFn$_invoke$arity$1 ? include.cljs$core$IFn$_invoke$arity$1(e) : include.call(null,e)))){\nreturn s;\n} else {\nreturn cljs.core.next(s);\n}\n} else {\nreturn null;\n}\n} else {\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(include,cljs.core._sorted_seq(sc,true));\n}\n});\n\ncljs.core.subseq.cljs$core$IFn$_invoke$arity$5 \x3d (function (sc,start_test,start_key,end_test,end_key){\nvar temp__5720__auto__ \x3d cljs.core._sorted_seq_from(sc,start_key,true);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar vec__11588 \x3d temp__5720__auto__;\nvar e \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11588,(0),null);\nvar s \x3d vec__11588;\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(cljs.core.mk_bound_fn(sc,end_test,end_key),(cljs.core.truth_((function (){var fexpr__11591 \x3d cljs.core.mk_bound_fn(sc,start_test,start_key);\nreturn (fexpr__11591.cljs$core$IFn$_invoke$arity$1 ? fexpr__11591.cljs$core$IFn$_invoke$arity$1(e) : fexpr__11591.call(null,e));\n})())?s:cljs.core.next(s)));\n} else {\nreturn null;\n}\n});\n\ncljs.core.subseq.cljs$lang$maxFixedArity \x3d 5;\n\n/**\n * sc must be a sorted collection, test(s) one of \x3c, \x3c\x3d, \x3e or\n *   \x3e\x3d. Returns a reverse seq of those entries with keys ek for\n *   which (test (.. sc comparator (compare ek key)) 0) is true\n */\ncljs.core.rsubseq \x3d (function cljs$core$rsubseq(var_args){\nvar G__11594 \x3d arguments.length;\nswitch (G__11594) {\ncase 3:\nreturn cljs.core.rsubseq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 5:\nreturn cljs.core.rsubseq.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.rsubseq.cljs$core$IFn$_invoke$arity$3 \x3d (function (sc,test,key){\nvar include \x3d cljs.core.mk_bound_fn(sc,test,key);\nif(cljs.core.truth_((function (){var fexpr__11595 \x3d cljs.core.PersistentHashSet.createAsIfByAssoc([cljs.core._LT_,cljs.core._LT__EQ_]);\nreturn (fexpr__11595.cljs$core$IFn$_invoke$arity$1 ? fexpr__11595.cljs$core$IFn$_invoke$arity$1(test) : fexpr__11595.call(null,test));\n})())){\nvar temp__5720__auto__ \x3d cljs.core._sorted_seq_from(sc,key,false);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar vec__11596 \x3d temp__5720__auto__;\nvar e \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11596,(0),null);\nvar s \x3d vec__11596;\nif(cljs.core.truth_((include.cljs$core$IFn$_invoke$arity$1 ? include.cljs$core$IFn$_invoke$arity$1(e) : include.call(null,e)))){\nreturn s;\n} else {\nreturn cljs.core.next(s);\n}\n} else {\nreturn null;\n}\n} else {\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(include,cljs.core._sorted_seq(sc,false));\n}\n});\n\ncljs.core.rsubseq.cljs$core$IFn$_invoke$arity$5 \x3d (function (sc,start_test,start_key,end_test,end_key){\nvar temp__5720__auto__ \x3d cljs.core._sorted_seq_from(sc,end_key,false);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar vec__11599 \x3d temp__5720__auto__;\nvar e \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11599,(0),null);\nvar s \x3d vec__11599;\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(cljs.core.mk_bound_fn(sc,start_test,start_key),(cljs.core.truth_((function (){var fexpr__11602 \x3d cljs.core.mk_bound_fn(sc,end_test,end_key);\nreturn (fexpr__11602.cljs$core$IFn$_invoke$arity$1 ? fexpr__11602.cljs$core$IFn$_invoke$arity$1(e) : fexpr__11602.call(null,e));\n})())?s:cljs.core.next(s)));\n} else {\nreturn null;\n}\n});\n\ncljs.core.rsubseq.cljs$lang$maxFixedArity \x3d 5;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.IChunk}\n*/\ncljs.core.RangeChunk \x3d (function (start,step,count){\nthis.start \x3d start;\nthis.step \x3d step;\nthis.count \x3d count;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 82;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.RangeChunk.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.count;\n});\n\ncljs.core.RangeChunk.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn self__.start;\n});\n\ncljs.core.RangeChunk.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (coll,i){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn (self__.start + (i * self__.step));\n});\n\ncljs.core.RangeChunk.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (coll,i,not_found){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((((i \x3e\x3d (0))) \x26\x26 ((i \x3c self__.count)))){\nreturn (self__.start + (i * self__.step));\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.RangeChunk.prototype.cljs$core$IChunk$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RangeChunk.prototype.cljs$core$IChunk$_drop_first$arity$1 \x3d (function (coll){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nif((self__.count \x3c\x3d (1))){\nthrow (new Error("-drop-first of empty chunk"));\n} else {\nreturn (new cljs.core.RangeChunk((self__.start + self__.step),self__.step,(self__.count - (1))));\n}\n});\n\ncljs.core.RangeChunk.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$start,cljs.core.cst$sym$step,cljs.core.cst$sym$count], null);\n});\n\ncljs.core.RangeChunk.cljs$lang$type \x3d true;\n\ncljs.core.RangeChunk.cljs$lang$ctorStr \x3d "cljs.core/RangeChunk";\n\ncljs.core.RangeChunk.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/RangeChunk");\n});\n\n/**\n * Positional factory function for cljs.core/RangeChunk.\n */\ncljs.core.__GT_RangeChunk \x3d (function cljs$core$__GT_RangeChunk(start,step,count){\nreturn (new cljs.core.RangeChunk(start,step,count));\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.RangeIterator \x3d (function (i,end,step){\nthis.i \x3d i;\nthis.end \x3d end;\nthis.step \x3d step;\n});\ncljs.core.RangeIterator.prototype.hasNext \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nif((self__.step \x3e (0))){\nreturn (self__.i \x3c self__.end);\n} else {\nreturn (self__.i \x3e self__.end);\n}\n});\n\ncljs.core.RangeIterator.prototype.next \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nvar ret \x3d self__.i;\nself__.i \x3d (self__.i + self__.step);\n\nreturn ret;\n});\n\ncljs.core.RangeIterator.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$i,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.cst$sym$end,cljs.core.cst$sym$step], null);\n});\n\ncljs.core.RangeIterator.cljs$lang$type \x3d true;\n\ncljs.core.RangeIterator.cljs$lang$ctorStr \x3d "cljs.core/RangeIterator";\n\ncljs.core.RangeIterator.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/RangeIterator");\n});\n\n/**\n * Positional factory function for cljs.core/RangeIterator.\n */\ncljs.core.__GT_RangeIterator \x3d (function cljs$core$__GT_RangeIterator(i,end,step){\nreturn (new cljs.core.RangeIterator(i,end,step));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IChunkedNext}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IChunkedSeq}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Range \x3d (function (meta,start,end,step,chunk,chunk_next,__hash){\nthis.meta \x3d meta;\nthis.start \x3d start;\nthis.end \x3d end;\nthis.step \x3d step;\nthis.chunk \x3d chunk;\nthis.chunk_next \x3d chunk_next;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 32375006;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 140800;\n});\ncljs.core.Range.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Range.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Range.prototype.indexOf \x3d (function() {\nvar G__11605 \x3d null;\nvar G__11605__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__11605__2 \x3d (function (x,start__$1){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start__$1);\n});\nG__11605 \x3d function(x,start__$1){\nswitch(arguments.length){\ncase 1:\nreturn G__11605__1.call(this,x);\ncase 2:\nreturn G__11605__2.call(this,x,start__$1);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11605.cljs$core$IFn$_invoke$arity$1 \x3d G__11605__1;\nG__11605.cljs$core$IFn$_invoke$arity$2 \x3d G__11605__2;\nreturn G__11605;\n})()\n;\n\ncljs.core.Range.prototype.lastIndexOf \x3d (function() {\nvar G__11606 \x3d null;\nvar G__11606__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__11606__2 \x3d (function (x,start__$1){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start__$1);\n});\nG__11606 \x3d function(x,start__$1){\nswitch(arguments.length){\ncase 1:\nreturn G__11606__1.call(this,x);\ncase 2:\nreturn G__11606__2.call(this,x,start__$1);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11606.cljs$core$IFn$_invoke$arity$1 \x3d G__11606__1;\nG__11606.cljs$core$IFn$_invoke$arity$2 \x3d G__11606__2;\nreturn G__11606;\n})()\n;\n\ncljs.core.Range.prototype.forceChunk \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nif((self__.chunk \x3d\x3d null)){\nvar count \x3d coll.cljs$core$ICounted$_count$arity$1(null);\nif((count \x3e (32))){\nself__.chunk_next \x3d (new cljs.core.Range(null,(self__.start + (self__.step * (32))),self__.end,self__.step,null,null,null));\n\nreturn self__.chunk \x3d (new cljs.core.RangeChunk(self__.start,self__.step,(32)));\n} else {\nreturn self__.chunk \x3d (new cljs.core.RangeChunk(self__.start,self__.step,count));\n}\n} else {\nreturn null;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IIndexed$_nth$arity$2 \x3d (function (rng,n){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nif(((((0) \x3c\x3d n)) \x26\x26 ((n \x3c rng__$1.cljs$core$ICounted$_count$arity$1(null))))){\nreturn (self__.start + (n * self__.step));\n} else {\nif(((((0) \x3c\x3d n)) \x26\x26 ((self__.start \x3e self__.end)) \x26\x26 ((self__.step \x3d\x3d\x3d (0))))){\nreturn self__.start;\n} else {\nthrow (new Error("Index out of bounds"));\n}\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IIndexed$_nth$arity$3 \x3d (function (rng,n,not_found){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nif(((((0) \x3c\x3d n)) \x26\x26 ((n \x3c rng__$1.cljs$core$ICounted$_count$arity$1(null))))){\nreturn (self__.start + (n * self__.step));\n} else {\nif(((((0) \x3c\x3d n)) \x26\x26 ((self__.start \x3e self__.end)) \x26\x26 ((self__.step \x3d\x3d\x3d (0))))){\nreturn self__.start;\n} else {\nreturn not_found;\n}\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.RangeIterator(self__.start,self__.end,self__.step));\n});\n\ncljs.core.Range.prototype.cljs$core$IMeta$_meta$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nreturn self__.meta;\n});\n\ncljs.core.Range.prototype.cljs$core$ICloneable$_clone$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (new cljs.core.Range(self__.meta,self__.start,self__.end,self__.step,self__.chunk,self__.chunk_next,self__.__hash));\n});\n\ncljs.core.Range.prototype.cljs$core$INext$_next$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nif((self__.step \x3e (0))){\nif(((self__.start + self__.step) \x3c self__.end)){\nreturn (new cljs.core.Range(null,(self__.start + self__.step),self__.end,self__.step,null,null,null));\n} else {\nreturn null;\n}\n} else {\nif(((self__.start + self__.step) \x3e self__.end)){\nreturn (new cljs.core.Range(null,(self__.start + self__.step),self__.end,self__.step,null,null,null));\n} else {\nreturn null;\n}\n}\n});\n\ncljs.core.Range.prototype.cljs$core$ICounted$_count$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nvar G__11604 \x3d ((self__.end - self__.start) / self__.step);\nreturn Math.ceil(G__11604);\n});\n\ncljs.core.Range.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nvar h__4243__auto__ \x3d self__.__hash;\nif((!((h__4243__auto__ \x3d\x3d null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 \x3d cljs.core.hash_ordered_coll(rng__$1);\nself__.__hash \x3d h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (rng,other){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nreturn cljs.core.equiv_sequential(rng__$1,other);\n});\n\ncljs.core.Range.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Range.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (rng,f){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(rng__$1,f);\n});\n\ncljs.core.Range.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (rng,f,init){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nvar i \x3d self__.start;\nvar ret \x3d init;\nwhile(true){\nif((((self__.step \x3e (0)))?(i \x3c self__.end):(i \x3e self__.end))){\nvar ret__$1 \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,i) : f.call(null,ret,i));\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__11607 \x3d (i + self__.step);\nvar G__11608 \x3d ret__$1;\ni \x3d G__11607;\nret \x3d G__11608;\ncontinue;\n}\n} else {\nreturn ret;\n}\nbreak;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$ISeq$_first$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nreturn self__.start;\n});\n\ncljs.core.Range.prototype.cljs$core$ISeq$_rest$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nvar s \x3d rng__$1.cljs$core$INext$_next$arity$1(null);\nif((s \x3d\x3d null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn s;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nreturn rng__$1;\n});\n\ncljs.core.Range.prototype.cljs$core$IChunkedSeq$_chunked_first$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nrng__$1.forceChunk();\n\nreturn self__.chunk;\n});\n\ncljs.core.Range.prototype.cljs$core$IChunkedSeq$_chunked_rest$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nrng__$1.forceChunk();\n\nif((self__.chunk_next \x3d\x3d null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.chunk_next;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IWithMeta$_with_meta$arity$2 \x3d (function (rng,new_meta){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nif((new_meta \x3d\x3d\x3d self__.meta)){\nreturn rng__$1;\n} else {\nreturn (new cljs.core.Range(new_meta,self__.start,self__.end,self__.step,self__.chunk,self__.chunk_next,self__.__hash));\n}\n});\n\ncljs.core.Range.prototype.cljs$core$ICollection$_conj$arity$2 \x3d (function (rng,o){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nreturn cljs.core.cons(o,rng__$1);\n});\n\ncljs.core.Range.prototype.cljs$core$IChunkedNext$_chunked_next$arity$1 \x3d (function (rng){\nvar self__ \x3d this;\nvar rng__$1 \x3d this;\nreturn cljs.core.seq(rng__$1.cljs$core$IChunkedSeq$_chunked_rest$arity$1(null));\n});\n\ncljs.core.Range.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$meta,cljs.core.cst$sym$start,cljs.core.cst$sym$end,cljs.core.cst$sym$step,cljs.core.with_meta(cljs.core.cst$sym$chunk,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$chunk_DASH_next,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Range.cljs$lang$type \x3d true;\n\ncljs.core.Range.cljs$lang$ctorStr \x3d "cljs.core/Range";\n\ncljs.core.Range.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Range");\n});\n\n/**\n * Positional factory function for cljs.core/Range.\n */\ncljs.core.__GT_Range \x3d (function cljs$core$__GT_Range(meta,start,end,step,chunk,chunk_next,__hash){\nreturn (new cljs.core.Range(meta,start,end,step,chunk,chunk_next,__hash));\n});\n\nvar G__11609_11612 \x3d cljs.core.Range.prototype;\nvar G__11610_11613 \x3d cljs.core.ITER_SYMBOL;\nvar G__11611_11614 \x3d ((function (G__11609_11612,G__11610_11613){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11609_11612,G__11610_11613))\n;\ngoog.object.set(G__11609_11612,G__11610_11613,G__11611_11614);\n/**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1,\n * and end to infinity.\n */\ncljs.core.range \x3d (function cljs$core$range(var_args){\nvar G__11616 \x3d arguments.length;\nswitch (G__11616) {\ncase 0:\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.range.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$3((0),Number.MAX_VALUE,(1));\n});\n\ncljs.core.range.cljs$core$IFn$_invoke$arity$1 \x3d (function (end){\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$3((0),end,(1));\n});\n\ncljs.core.range.cljs$core$IFn$_invoke$arity$2 \x3d (function (start,end){\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$3(start,end,(1));\n});\n\ncljs.core.range.cljs$core$IFn$_invoke$arity$3 \x3d (function (start,end,step){\nif((step \x3e (0))){\nif((end \x3c\x3d start)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn (new cljs.core.Range(null,start,end,step,null,null,null));\n}\n} else {\nif((step \x3c (0))){\nif((end \x3e\x3d start)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn (new cljs.core.Range(null,start,end,step,null,null,null));\n}\n} else {\nif((end \x3d\x3d\x3d start)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(start);\n}\n\n}\n}\n});\n\ncljs.core.range.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Returns a lazy seq of every nth item in coll.  Returns a stateful\n *   transducer when no collection is provided.\n */\ncljs.core.take_nth \x3d (function cljs$core$take_nth(var_args){\nvar G__11619 \x3d arguments.length;\nswitch (G__11619) {\ncase 1:\nreturn cljs.core.take_nth.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.take_nth.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.take_nth.cljs$core$IFn$_invoke$arity$1 \x3d (function (n){\nif(typeof n \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? n)"));\n}\n\nreturn (function (rf){\nvar ia \x3d cljs.core.volatile_BANG_((-1));\nreturn ((function (ia){\nreturn (function() {\nvar G__11621 \x3d null;\nvar G__11621__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__11621__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__11621__2 \x3d (function (result,input){\nvar i \x3d ia.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(ia.cljs$core$IDeref$_deref$arity$1(null) + (1)));\nif((cljs.core.rem(i,n) \x3d\x3d\x3d (0))){\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n} else {\nreturn result;\n}\n});\nG__11621 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__11621__0.call(this);\ncase 1:\nreturn G__11621__1.call(this,result);\ncase 2:\nreturn G__11621__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11621.cljs$core$IFn$_invoke$arity$0 \x3d G__11621__0;\nG__11621.cljs$core$IFn$_invoke$arity$1 \x3d G__11621__1;\nG__11621.cljs$core$IFn$_invoke$arity$2 \x3d G__11621__2;\nreturn G__11621;\n})()\n;})(ia))\n});\n});\n\ncljs.core.take_nth.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,coll){\nif(typeof n \x3d\x3d\x3d \'number\'){\n} else {\nthrow (new Error("Assert failed: (number? n)"));\n}\n\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nreturn cljs.core.cons(cljs.core.first(s),cljs.core.take_nth.cljs$core$IFn$_invoke$arity$2(n,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(n,s)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.take_nth.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a vector of [(take-while pred coll) (drop-while pred coll)]\n */\ncljs.core.split_with \x3d (function cljs$core$split_with(pred,coll){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(pred,coll),cljs.core.drop_while.cljs$core$IFn$_invoke$arity$2(pred,coll)], null);\n});\n/**\n * Applies f to each value in coll, splitting it each time f returns a\n * new value.  Returns a lazy seq of partitions.  Returns a stateful\n * transducer when no collection is provided.\n */\ncljs.core.partition_by \x3d (function cljs$core$partition_by(var_args){\nvar G__11624 \x3d arguments.length;\nswitch (G__11624) {\ncase 1:\nreturn cljs.core.partition_by.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.partition_by.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.partition_by.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn (function (rf){\nvar a \x3d cljs.core.array_list();\nvar pa \x3d cljs.core.volatile_BANG_(cljs.core.cst$kw$cljs$core_SLASH_none);\nreturn ((function (a,pa){\nreturn (function() {\nvar G__11626 \x3d null;\nvar G__11626__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__11626__1 \x3d (function (result){\nvar result__$1 \x3d (cljs.core.truth_(a.isEmpty())?result:(function (){var v \x3d cljs.core.vec(a.toArray());\na.clear();\n\nreturn cljs.core.unreduced((rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v)));\n})());\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result__$1) : rf.call(null,result__$1));\n});\nvar G__11626__2 \x3d (function (result,input){\nvar pval \x3d cljs.core.deref(pa);\nvar val \x3d (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(input) : f.call(null,input));\ncljs.core.vreset_BANG_(pa,val);\n\nif(((cljs.core.keyword_identical_QMARK_(pval,cljs.core.cst$kw$cljs$core_SLASH_none)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(val,pval)))){\na.add(input);\n\nreturn result;\n} else {\nvar v \x3d cljs.core.vec(a.toArray());\na.clear();\n\nvar ret \x3d (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v));\nif(cljs.core.reduced_QMARK_(ret)){\n} else {\na.add(input);\n}\n\nreturn ret;\n}\n});\nG__11626 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__11626__0.call(this);\ncase 1:\nreturn G__11626__1.call(this,result);\ncase 2:\nreturn G__11626__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11626.cljs$core$IFn$_invoke$arity$0 \x3d G__11626__0;\nG__11626.cljs$core$IFn$_invoke$arity$1 \x3d G__11626__1;\nG__11626.cljs$core$IFn$_invoke$arity$2 \x3d G__11626__2;\nreturn G__11626;\n})()\n;})(a,pa))\n});\n});\n\ncljs.core.partition_by.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nvar fst \x3d cljs.core.first(s);\nvar fv \x3d (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(fst) : f.call(null,fst));\nvar run \x3d cljs.core.cons(fst,cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(((function (fst,fv,s,temp__5720__auto__){\nreturn (function (p1__11622_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fv,(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(p1__11622_SHARP_) : f.call(null,p1__11622_SHARP_)));\n});})(fst,fv,s,temp__5720__auto__))\n,cljs.core.next(s)));\nreturn cljs.core.cons(run,cljs.core.partition_by.cljs$core$IFn$_invoke$arity$2(f,(new cljs.core.LazySeq(null,((function (fst,fv,run,s,temp__5720__auto__){\nreturn (function (){\nreturn cljs.core.drop.cljs$core$IFn$_invoke$arity$2(cljs.core.count(run),s);\n});})(fst,fv,run,s,temp__5720__auto__))\n,null,null))));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.partition_by.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a map from distinct items in coll to the number of times\n *   they appear.\n */\ncljs.core.frequencies \x3d (function cljs$core$frequencies(coll){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (counts,x){\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(counts,x,(cljs.core.get.cljs$core$IFn$_invoke$arity$3(counts,x,(0)) + (1)));\n}),cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY),coll));\n});\n/**\n * Returns a lazy seq of the intermediate values of the reduction (as\n *   per reduce) of coll by f, starting with init.\n */\ncljs.core.reductions \x3d (function cljs$core$reductions(var_args){\nvar G__11628 \x3d arguments.length;\nswitch (G__11628) {\ncase 2:\nreturn cljs.core.reductions.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.reductions.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.reductions.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5718__auto__ \x3d cljs.core.seq(coll);\nif(temp__5718__auto__){\nvar s \x3d temp__5718__auto__;\nreturn cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(f,cljs.core.first(s),cljs.core.rest(s));\n} else {\nreturn (new cljs.core.List(null,(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),null,(1),null));\n}\n}),null,null));\n});\n\ncljs.core.reductions.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,init,coll){\nif(cljs.core.reduced_QMARK_(init)){\nreturn (new cljs.core.List(null,cljs.core.deref(init),null,(1),null));\n} else {\nreturn cljs.core.cons(init,(new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nreturn cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(f,(function (){var G__11629 \x3d init;\nvar G__11630 \x3d cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__11629,G__11630) : f.call(null,G__11629,G__11630));\n})(),cljs.core.rest(s));\n} else {\nreturn null;\n}\n}),null,null)));\n}\n});\n\ncljs.core.reductions.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Takes a set of functions and returns a fn that is the juxtaposition\n *   of those fns.  The returned fn takes a variable number of args, and\n *   returns a vector containing the result of applying each fn to the\n *   args (left-to-right).\n *   ((juxt a b c) x) \x3d\x3e [(a x) (b x) (c x)]\n */\ncljs.core.juxt \x3d (function cljs$core$juxt(var_args){\nvar G__11647 \x3d arguments.length;\nswitch (G__11647) {\ncase 1:\nreturn cljs.core.juxt.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.juxt.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.juxt.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___11649 \x3d arguments.length;\nvar i__4731__auto___11650 \x3d (0);\nwhile(true){\nif((i__4731__auto___11650 \x3c len__4730__auto___11649)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___11650]));\n\nvar G__11651 \x3d (i__4731__auto___11650 + (1));\ni__4731__auto___11650 \x3d G__11651;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.juxt.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.juxt.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn (function() {\nvar G__11652 \x3d null;\nvar G__11652__0 \x3d (function (){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null))],null));\n});\nvar G__11652__1 \x3d (function (x){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x))],null));\n});\nvar G__11652__2 \x3d (function (x,y){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y))],null));\n});\nvar G__11652__3 \x3d (function (x,y,z){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(x,y,z) : f.call(null,x,y,z))],null));\n});\nvar G__11652__4 \x3d (function() { \nvar G__11653__delegate \x3d function (x,y,z,args){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,x,y,z,args)],null));\n};\nvar G__11653 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__11654__i \x3d 0, G__11654__a \x3d new Array(arguments.length -  3);\nwhile (G__11654__i \x3c G__11654__a.length) {G__11654__a[G__11654__i] \x3d arguments[G__11654__i + 3]; ++G__11654__i;}\n  args \x3d new cljs.core.IndexedSeq(G__11654__a,0,null);\n} \nreturn G__11653__delegate.call(this,x,y,z,args);};\nG__11653.cljs$lang$maxFixedArity \x3d 3;\nG__11653.cljs$lang$applyTo \x3d (function (arglist__11655){\nvar x \x3d cljs.core.first(arglist__11655);\narglist__11655 \x3d cljs.core.next(arglist__11655);\nvar y \x3d cljs.core.first(arglist__11655);\narglist__11655 \x3d cljs.core.next(arglist__11655);\nvar z \x3d cljs.core.first(arglist__11655);\nvar args \x3d cljs.core.rest(arglist__11655);\nreturn G__11653__delegate(x,y,z,args);\n});\nG__11653.cljs$core$IFn$_invoke$arity$variadic \x3d G__11653__delegate;\nreturn G__11653;\n})()\n;\nG__11652 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__11652__0.call(this);\ncase 1:\nreturn G__11652__1.call(this,x);\ncase 2:\nreturn G__11652__2.call(this,x,y);\ncase 3:\nreturn G__11652__3.call(this,x,y,z);\ndefault:\nvar G__11656 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__11657__i \x3d 0, G__11657__a \x3d new Array(arguments.length -  3);\nwhile (G__11657__i \x3c G__11657__a.length) {G__11657__a[G__11657__i] \x3d arguments[G__11657__i + 3]; ++G__11657__i;}\nG__11656 \x3d new cljs.core.IndexedSeq(G__11657__a,0,null);\n}\nreturn G__11652__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__11656);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11652.cljs$lang$maxFixedArity \x3d 3;\nG__11652.cljs$lang$applyTo \x3d G__11652__4.cljs$lang$applyTo;\nG__11652.cljs$core$IFn$_invoke$arity$0 \x3d G__11652__0;\nG__11652.cljs$core$IFn$_invoke$arity$1 \x3d G__11652__1;\nG__11652.cljs$core$IFn$_invoke$arity$2 \x3d G__11652__2;\nG__11652.cljs$core$IFn$_invoke$arity$3 \x3d G__11652__3;\nG__11652.cljs$core$IFn$_invoke$arity$variadic \x3d G__11652__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__11652;\n})()\n});\n\ncljs.core.juxt.cljs$core$IFn$_invoke$arity$2 \x3d (function (f,g){\nreturn (function() {\nvar G__11658 \x3d null;\nvar G__11658__0 \x3d (function (){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),(g.cljs$core$IFn$_invoke$arity$0 ? g.cljs$core$IFn$_invoke$arity$0() : g.call(null))],null));\n});\nvar G__11658__1 \x3d (function (x){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x)),(g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(x) : g.call(null,x))],null));\n});\nvar G__11658__2 \x3d (function (x,y){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y)),(g.cljs$core$IFn$_invoke$arity$2 ? g.cljs$core$IFn$_invoke$arity$2(x,y) : g.call(null,x,y))],null));\n});\nvar G__11658__3 \x3d (function (x,y,z){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(x,y,z) : f.call(null,x,y,z)),(g.cljs$core$IFn$_invoke$arity$3 ? g.cljs$core$IFn$_invoke$arity$3(x,y,z) : g.call(null,x,y,z))],null));\n});\nvar G__11658__4 \x3d (function() { \nvar G__11659__delegate \x3d function (x,y,z,args){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,x,y,z,args),cljs.core.apply.cljs$core$IFn$_invoke$arity$5(g,x,y,z,args)],null));\n};\nvar G__11659 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__11660__i \x3d 0, G__11660__a \x3d new Array(arguments.length -  3);\nwhile (G__11660__i \x3c G__11660__a.length) {G__11660__a[G__11660__i] \x3d arguments[G__11660__i + 3]; ++G__11660__i;}\n  args \x3d new cljs.core.IndexedSeq(G__11660__a,0,null);\n} \nreturn G__11659__delegate.call(this,x,y,z,args);};\nG__11659.cljs$lang$maxFixedArity \x3d 3;\nG__11659.cljs$lang$applyTo \x3d (function (arglist__11661){\nvar x \x3d cljs.core.first(arglist__11661);\narglist__11661 \x3d cljs.core.next(arglist__11661);\nvar y \x3d cljs.core.first(arglist__11661);\narglist__11661 \x3d cljs.core.next(arglist__11661);\nvar z \x3d cljs.core.first(arglist__11661);\nvar args \x3d cljs.core.rest(arglist__11661);\nreturn G__11659__delegate(x,y,z,args);\n});\nG__11659.cljs$core$IFn$_invoke$arity$variadic \x3d G__11659__delegate;\nreturn G__11659;\n})()\n;\nG__11658 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__11658__0.call(this);\ncase 1:\nreturn G__11658__1.call(this,x);\ncase 2:\nreturn G__11658__2.call(this,x,y);\ncase 3:\nreturn G__11658__3.call(this,x,y,z);\ndefault:\nvar G__11662 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__11663__i \x3d 0, G__11663__a \x3d new Array(arguments.length -  3);\nwhile (G__11663__i \x3c G__11663__a.length) {G__11663__a[G__11663__i] \x3d arguments[G__11663__i + 3]; ++G__11663__i;}\nG__11662 \x3d new cljs.core.IndexedSeq(G__11663__a,0,null);\n}\nreturn G__11658__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__11662);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11658.cljs$lang$maxFixedArity \x3d 3;\nG__11658.cljs$lang$applyTo \x3d G__11658__4.cljs$lang$applyTo;\nG__11658.cljs$core$IFn$_invoke$arity$0 \x3d G__11658__0;\nG__11658.cljs$core$IFn$_invoke$arity$1 \x3d G__11658__1;\nG__11658.cljs$core$IFn$_invoke$arity$2 \x3d G__11658__2;\nG__11658.cljs$core$IFn$_invoke$arity$3 \x3d G__11658__3;\nG__11658.cljs$core$IFn$_invoke$arity$variadic \x3d G__11658__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__11658;\n})()\n});\n\ncljs.core.juxt.cljs$core$IFn$_invoke$arity$3 \x3d (function (f,g,h){\nreturn (function() {\nvar G__11664 \x3d null;\nvar G__11664__0 \x3d (function (){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),(g.cljs$core$IFn$_invoke$arity$0 ? g.cljs$core$IFn$_invoke$arity$0() : g.call(null)),(h.cljs$core$IFn$_invoke$arity$0 ? h.cljs$core$IFn$_invoke$arity$0() : h.call(null))],null));\n});\nvar G__11664__1 \x3d (function (x){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x)),(g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(x) : g.call(null,x)),(h.cljs$core$IFn$_invoke$arity$1 ? h.cljs$core$IFn$_invoke$arity$1(x) : h.call(null,x))],null));\n});\nvar G__11664__2 \x3d (function (x,y){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y)),(g.cljs$core$IFn$_invoke$arity$2 ? g.cljs$core$IFn$_invoke$arity$2(x,y) : g.call(null,x,y)),(h.cljs$core$IFn$_invoke$arity$2 ? h.cljs$core$IFn$_invoke$arity$2(x,y) : h.call(null,x,y))],null));\n});\nvar G__11664__3 \x3d (function (x,y,z){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(x,y,z) : f.call(null,x,y,z)),(g.cljs$core$IFn$_invoke$arity$3 ? g.cljs$core$IFn$_invoke$arity$3(x,y,z) : g.call(null,x,y,z)),(h.cljs$core$IFn$_invoke$arity$3 ? h.cljs$core$IFn$_invoke$arity$3(x,y,z) : h.call(null,x,y,z))],null));\n});\nvar G__11664__4 \x3d (function() { \nvar G__11665__delegate \x3d function (x,y,z,args){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,x,y,z,args),cljs.core.apply.cljs$core$IFn$_invoke$arity$5(g,x,y,z,args),cljs.core.apply.cljs$core$IFn$_invoke$arity$5(h,x,y,z,args)],null));\n};\nvar G__11665 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__11666__i \x3d 0, G__11666__a \x3d new Array(arguments.length -  3);\nwhile (G__11666__i \x3c G__11666__a.length) {G__11666__a[G__11666__i] \x3d arguments[G__11666__i + 3]; ++G__11666__i;}\n  args \x3d new cljs.core.IndexedSeq(G__11666__a,0,null);\n} \nreturn G__11665__delegate.call(this,x,y,z,args);};\nG__11665.cljs$lang$maxFixedArity \x3d 3;\nG__11665.cljs$lang$applyTo \x3d (function (arglist__11667){\nvar x \x3d cljs.core.first(arglist__11667);\narglist__11667 \x3d cljs.core.next(arglist__11667);\nvar y \x3d cljs.core.first(arglist__11667);\narglist__11667 \x3d cljs.core.next(arglist__11667);\nvar z \x3d cljs.core.first(arglist__11667);\nvar args \x3d cljs.core.rest(arglist__11667);\nreturn G__11665__delegate(x,y,z,args);\n});\nG__11665.cljs$core$IFn$_invoke$arity$variadic \x3d G__11665__delegate;\nreturn G__11665;\n})()\n;\nG__11664 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__11664__0.call(this);\ncase 1:\nreturn G__11664__1.call(this,x);\ncase 2:\nreturn G__11664__2.call(this,x,y);\ncase 3:\nreturn G__11664__3.call(this,x,y,z);\ndefault:\nvar G__11668 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__11669__i \x3d 0, G__11669__a \x3d new Array(arguments.length -  3);\nwhile (G__11669__i \x3c G__11669__a.length) {G__11669__a[G__11669__i] \x3d arguments[G__11669__i + 3]; ++G__11669__i;}\nG__11668 \x3d new cljs.core.IndexedSeq(G__11669__a,0,null);\n}\nreturn G__11664__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__11668);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11664.cljs$lang$maxFixedArity \x3d 3;\nG__11664.cljs$lang$applyTo \x3d G__11664__4.cljs$lang$applyTo;\nG__11664.cljs$core$IFn$_invoke$arity$0 \x3d G__11664__0;\nG__11664.cljs$core$IFn$_invoke$arity$1 \x3d G__11664__1;\nG__11664.cljs$core$IFn$_invoke$arity$2 \x3d G__11664__2;\nG__11664.cljs$core$IFn$_invoke$arity$3 \x3d G__11664__3;\nG__11664.cljs$core$IFn$_invoke$arity$variadic \x3d G__11664__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__11664;\n})()\n});\n\ncljs.core.juxt.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,g,h,fs){\nvar fs__$1 \x3d cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(f,g,h,fs);\nreturn ((function (fs__$1){\nreturn (function() {\nvar G__11670 \x3d null;\nvar G__11670__0 \x3d (function (){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__11632_SHARP_,p2__11633_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__11632_SHARP_,(p2__11633_SHARP_.cljs$core$IFn$_invoke$arity$0 ? p2__11633_SHARP_.cljs$core$IFn$_invoke$arity$0() : p2__11633_SHARP_.call(null)));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n});\nvar G__11670__1 \x3d (function (x){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__11634_SHARP_,p2__11635_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__11634_SHARP_,(p2__11635_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p2__11635_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p2__11635_SHARP_.call(null,x)));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n});\nvar G__11670__2 \x3d (function (x,y){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__11636_SHARP_,p2__11637_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__11636_SHARP_,(p2__11637_SHARP_.cljs$core$IFn$_invoke$arity$2 ? p2__11637_SHARP_.cljs$core$IFn$_invoke$arity$2(x,y) : p2__11637_SHARP_.call(null,x,y)));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n});\nvar G__11670__3 \x3d (function (x,y,z){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__11638_SHARP_,p2__11639_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__11638_SHARP_,(p2__11639_SHARP_.cljs$core$IFn$_invoke$arity$3 ? p2__11639_SHARP_.cljs$core$IFn$_invoke$arity$3(x,y,z) : p2__11639_SHARP_.call(null,x,y,z)));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n});\nvar G__11670__4 \x3d (function() { \nvar G__11671__delegate \x3d function (x,y,z,args){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__11640_SHARP_,p2__11641_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__11640_SHARP_,cljs.core.apply.cljs$core$IFn$_invoke$arity$5(p2__11641_SHARP_,x,y,z,args));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n};\nvar G__11671 \x3d function (x,y,z,var_args){\nvar args \x3d null;\nif (arguments.length \x3e 3) {\nvar G__11672__i \x3d 0, G__11672__a \x3d new Array(arguments.length -  3);\nwhile (G__11672__i \x3c G__11672__a.length) {G__11672__a[G__11672__i] \x3d arguments[G__11672__i + 3]; ++G__11672__i;}\n  args \x3d new cljs.core.IndexedSeq(G__11672__a,0,null);\n} \nreturn G__11671__delegate.call(this,x,y,z,args);};\nG__11671.cljs$lang$maxFixedArity \x3d 3;\nG__11671.cljs$lang$applyTo \x3d (function (arglist__11673){\nvar x \x3d cljs.core.first(arglist__11673);\narglist__11673 \x3d cljs.core.next(arglist__11673);\nvar y \x3d cljs.core.first(arglist__11673);\narglist__11673 \x3d cljs.core.next(arglist__11673);\nvar z \x3d cljs.core.first(arglist__11673);\nvar args \x3d cljs.core.rest(arglist__11673);\nreturn G__11671__delegate(x,y,z,args);\n});\nG__11671.cljs$core$IFn$_invoke$arity$variadic \x3d G__11671__delegate;\nreturn G__11671;\n})()\n;\nG__11670 \x3d function(x,y,z,var_args){\nvar args \x3d var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__11670__0.call(this);\ncase 1:\nreturn G__11670__1.call(this,x);\ncase 2:\nreturn G__11670__2.call(this,x,y);\ncase 3:\nreturn G__11670__3.call(this,x,y,z);\ndefault:\nvar G__11674 \x3d null;\nif (arguments.length \x3e 3) {\nvar G__11675__i \x3d 0, G__11675__a \x3d new Array(arguments.length -  3);\nwhile (G__11675__i \x3c G__11675__a.length) {G__11675__a[G__11675__i] \x3d arguments[G__11675__i + 3]; ++G__11675__i;}\nG__11674 \x3d new cljs.core.IndexedSeq(G__11675__a,0,null);\n}\nreturn G__11670__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__11674);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11670.cljs$lang$maxFixedArity \x3d 3;\nG__11670.cljs$lang$applyTo \x3d G__11670__4.cljs$lang$applyTo;\nG__11670.cljs$core$IFn$_invoke$arity$0 \x3d G__11670__0;\nG__11670.cljs$core$IFn$_invoke$arity$1 \x3d G__11670__1;\nG__11670.cljs$core$IFn$_invoke$arity$2 \x3d G__11670__2;\nG__11670.cljs$core$IFn$_invoke$arity$3 \x3d G__11670__3;\nG__11670.cljs$core$IFn$_invoke$arity$variadic \x3d G__11670__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__11670;\n})()\n;})(fs__$1))\n});\n\n/** @this {Function} */\ncljs.core.juxt.cljs$lang$applyTo \x3d (function (seq11643){\nvar G__11644 \x3d cljs.core.first(seq11643);\nvar seq11643__$1 \x3d cljs.core.next(seq11643);\nvar G__11645 \x3d cljs.core.first(seq11643__$1);\nvar seq11643__$2 \x3d cljs.core.next(seq11643__$1);\nvar G__11646 \x3d cljs.core.first(seq11643__$2);\nvar seq11643__$3 \x3d cljs.core.next(seq11643__$2);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11644,G__11645,G__11646,seq11643__$3);\n});\n\ncljs.core.juxt.cljs$lang$maxFixedArity \x3d (3);\n\n/**\n * When lazy sequences are produced via functions that have side\n *   effects, any effects other than those needed to produce the first\n *   element in the seq do not occur until the seq is consumed. dorun can\n *   be used to force any effects. Walks through the successive nexts of\n *   the seq, does not retain the head and returns nil.\n */\ncljs.core.dorun \x3d (function cljs$core$dorun(var_args){\nvar G__11677 \x3d arguments.length;\nswitch (G__11677) {\ncase 1:\nreturn cljs.core.dorun.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.dorun.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.dorun.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nwhile(true){\nvar temp__5720__auto__ \x3d cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s \x3d temp__5720__auto__;\nvar G__11679 \x3d cljs.core.next(s);\ncoll \x3d G__11679;\ncontinue;\n} else {\nreturn null;\n}\nbreak;\n}\n});\n\ncljs.core.dorun.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,coll){\nwhile(true){\nif(((cljs.core.seq(coll)) \x26\x26 ((n \x3e (0))))){\nvar G__11680 \x3d (n - (1));\nvar G__11681 \x3d cljs.core.next(coll);\nn \x3d G__11680;\ncoll \x3d G__11681;\ncontinue;\n} else {\nreturn null;\n}\nbreak;\n}\n});\n\ncljs.core.dorun.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * When lazy sequences are produced via functions that have side\n *   effects, any effects other than those needed to produce the first\n *   element in the seq do not occur until the seq is consumed. doall can\n *   be used to force any effects. Walks through the successive nexts of\n *   the seq, retains the head and returns it, thus causing the entire\n *   seq to reside in memory at one time.\n */\ncljs.core.doall \x3d (function cljs$core$doall(var_args){\nvar G__11683 \x3d arguments.length;\nswitch (G__11683) {\ncase 1:\nreturn cljs.core.doall.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.doall.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.doall.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\ncljs.core.dorun.cljs$core$IFn$_invoke$arity$1(coll);\n\nreturn coll;\n});\n\ncljs.core.doall.cljs$core$IFn$_invoke$arity$2 \x3d (function (n,coll){\ncljs.core.dorun.cljs$core$IFn$_invoke$arity$2(n,coll);\n\nreturn coll;\n});\n\ncljs.core.doall.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns true if x is a JavaScript RegExp instance.\n */\ncljs.core.regexp_QMARK_ \x3d (function cljs$core$regexp_QMARK_(x){\nreturn (x instanceof RegExp);\n});\n/**\n * Returns the result of (re-find re s) if re fully matches s.\n */\ncljs.core.re_matches \x3d (function cljs$core$re_matches(re,s){\nif(typeof s \x3d\x3d\x3d \'string\'){\nvar matches \x3d re.exec(s);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(matches),s)){\nif((cljs.core.count(matches) \x3d\x3d\x3d (1))){\nreturn cljs.core.first(matches);\n} else {\nreturn cljs.core.vec(matches);\n}\n} else {\nreturn null;\n}\n} else {\nthrow (new TypeError("re-matches must match against a string."));\n}\n});\n/**\n * Returns the first regex match, if any, of s to re, using\n *   re.exec(s). Returns a vector, containing first the matching\n *   substring, then any capturing groups if the regular expression contains\n *   capturing groups.\n */\ncljs.core.re_find \x3d (function cljs$core$re_find(re,s){\nif(typeof s \x3d\x3d\x3d \'string\'){\nvar matches \x3d re.exec(s);\nif((matches \x3d\x3d null)){\nreturn null;\n} else {\nif((cljs.core.count(matches) \x3d\x3d\x3d (1))){\nreturn cljs.core.first(matches);\n} else {\nreturn cljs.core.vec(matches);\n}\n}\n} else {\nthrow (new TypeError("re-find must match against a string."));\n}\n});\ncljs.core.re_seq_STAR_ \x3d (function cljs$core$re_seq_STAR_(re,s){\nvar temp__5724__auto__ \x3d re.exec(s);\nif((temp__5724__auto__ \x3d\x3d null)){\nreturn null;\n} else {\nvar matches \x3d temp__5724__auto__;\nvar match_str \x3d (matches[(0)]);\nvar match_vals \x3d (((matches.length \x3d\x3d\x3d (1)))?match_str:cljs.core.vec(matches));\nreturn cljs.core.cons(match_vals,(new cljs.core.LazySeq(null,((function (match_str,match_vals,matches,temp__5724__auto__){\nreturn (function (){\nvar post_idx \x3d (matches.index + (function (){var x__4219__auto__ \x3d (1);\nvar y__4220__auto__ \x3d match_str.length;\nreturn ((x__4219__auto__ \x3e y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})());\nif((post_idx \x3c\x3d s.length)){\nvar G__11685 \x3d re;\nvar G__11686 \x3d cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,post_idx);\nreturn (cljs.core.re_seq_STAR_.cljs$core$IFn$_invoke$arity$2 ? cljs.core.re_seq_STAR_.cljs$core$IFn$_invoke$arity$2(G__11685,G__11686) : cljs.core.re_seq_STAR_.call(null,G__11685,G__11686));\n} else {\nreturn null;\n}\n});})(match_str,match_vals,matches,temp__5724__auto__))\n,null,null)));\n}\n});\n/**\n * Returns a lazy sequence of successive matches of re in s.\n */\ncljs.core.re_seq \x3d (function cljs$core$re_seq(re,s){\nif(typeof s \x3d\x3d\x3d \'string\'){\nreturn cljs.core.re_seq_STAR_(re,s);\n} else {\nthrow (new TypeError("re-seq must match against a string."));\n}\n});\n/**\n * Returns an instance of RegExp which has compiled the provided string.\n */\ncljs.core.re_pattern \x3d (function cljs$core$re_pattern(s){\nif((s instanceof RegExp)){\nreturn s;\n} else {\nvar vec__11687 \x3d cljs.core.re_find(/^\\(\\?([idmsux]*)\\)/,s);\nvar prefix \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11687,(0),null);\nvar flags \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11687,(1),null);\nvar pattern \x3d cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,cljs.core.count(prefix));\nreturn (new RegExp(pattern,(function (){var or__4131__auto__ \x3d flags;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn "";\n}\n})()));\n}\n});\ncljs.core.pr_sequential_writer \x3d (function cljs$core$pr_sequential_writer(writer,print_one,begin,sep,end,opts,coll){\nvar _STAR_print_level_STAR__orig_val__11690 \x3d cljs.core._STAR_print_level_STAR_;\nvar _STAR_print_level_STAR__temp_val__11691 \x3d (((cljs.core._STAR_print_level_STAR_ \x3d\x3d null))?null:(cljs.core._STAR_print_level_STAR_ - (1)));\ncljs.core._STAR_print_level_STAR_ \x3d _STAR_print_level_STAR__temp_val__11691;\n\ntry{if((((!((cljs.core._STAR_print_level_STAR_ \x3d\x3d null)))) \x26\x26 ((cljs.core._STAR_print_level_STAR_ \x3c (0))))){\nreturn cljs.core._write(writer,"#");\n} else {\ncljs.core._write(writer,begin);\n\nif((cljs.core.cst$kw$print_DASH_length.cljs$core$IFn$_invoke$arity$1(opts) \x3d\x3d\x3d (0))){\nif(cljs.core.seq(coll)){\ncljs.core._write(writer,(function (){var or__4131__auto__ \x3d cljs.core.cst$kw$more_DASH_marker.cljs$core$IFn$_invoke$arity$1(opts);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn "...";\n}\n})());\n} else {\n}\n} else {\nif(cljs.core.seq(coll)){\nvar G__11692_11698 \x3d cljs.core.first(coll);\nvar G__11693_11699 \x3d writer;\nvar G__11694_11700 \x3d opts;\n(print_one.cljs$core$IFn$_invoke$arity$3 ? print_one.cljs$core$IFn$_invoke$arity$3(G__11692_11698,G__11693_11699,G__11694_11700) : print_one.call(null,G__11692_11698,G__11693_11699,G__11694_11700));\n} else {\n}\n\nvar coll_11701__$1 \x3d cljs.core.next(coll);\nvar n_11702 \x3d (cljs.core.cst$kw$print_DASH_length.cljs$core$IFn$_invoke$arity$1(opts) - (1));\nwhile(true){\nif(((coll_11701__$1) \x26\x26 ((((n_11702 \x3d\x3d null)) || ((!((n_11702 \x3d\x3d\x3d (0))))))))){\ncljs.core._write(writer,sep);\n\nvar G__11695_11703 \x3d cljs.core.first(coll_11701__$1);\nvar G__11696_11704 \x3d writer;\nvar G__11697_11705 \x3d opts;\n(print_one.cljs$core$IFn$_invoke$arity$3 ? print_one.cljs$core$IFn$_invoke$arity$3(G__11695_11703,G__11696_11704,G__11697_11705) : print_one.call(null,G__11695_11703,G__11696_11704,G__11697_11705));\n\nvar G__11706 \x3d cljs.core.next(coll_11701__$1);\nvar G__11707 \x3d (n_11702 - (1));\ncoll_11701__$1 \x3d G__11706;\nn_11702 \x3d G__11707;\ncontinue;\n} else {\nif(((cljs.core.seq(coll_11701__$1)) \x26\x26 ((n_11702 \x3d\x3d\x3d (0))))){\ncljs.core._write(writer,sep);\n\ncljs.core._write(writer,(function (){var or__4131__auto__ \x3d cljs.core.cst$kw$more_DASH_marker.cljs$core$IFn$_invoke$arity$1(opts);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn "...";\n}\n})());\n} else {\n}\n}\nbreak;\n}\n}\n\nreturn cljs.core._write(writer,end);\n}\n}finally {cljs.core._STAR_print_level_STAR_ \x3d _STAR_print_level_STAR__orig_val__11690;\n}});\ncljs.core.write_all \x3d (function cljs$core$write_all(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11714 \x3d arguments.length;\nvar i__4731__auto___11715 \x3d (0);\nwhile(true){\nif((i__4731__auto___11715 \x3c len__4730__auto___11714)){\nargs__4736__auto__.push((arguments[i__4731__auto___11715]));\n\nvar G__11716 \x3d (i__4731__auto___11715 + (1));\ni__4731__auto___11715 \x3d G__11716;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((1) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic \x3d (function (writer,ss){\nvar seq__11710 \x3d cljs.core.seq(ss);\nvar chunk__11711 \x3d null;\nvar count__11712 \x3d (0);\nvar i__11713 \x3d (0);\nwhile(true){\nif((i__11713 \x3c count__11712)){\nvar s \x3d chunk__11711.cljs$core$IIndexed$_nth$arity$2(null,i__11713);\ncljs.core._write(writer,s);\n\n\nvar G__11717 \x3d seq__11710;\nvar G__11718 \x3d chunk__11711;\nvar G__11719 \x3d count__11712;\nvar G__11720 \x3d (i__11713 + (1));\nseq__11710 \x3d G__11717;\nchunk__11711 \x3d G__11718;\ncount__11712 \x3d G__11719;\ni__11713 \x3d G__11720;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__11710);\nif(temp__5720__auto__){\nvar seq__11710__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__11710__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__11710__$1);\nvar G__11721 \x3d cljs.core.chunk_rest(seq__11710__$1);\nvar G__11722 \x3d c__4550__auto__;\nvar G__11723 \x3d cljs.core.count(c__4550__auto__);\nvar G__11724 \x3d (0);\nseq__11710 \x3d G__11721;\nchunk__11711 \x3d G__11722;\ncount__11712 \x3d G__11723;\ni__11713 \x3d G__11724;\ncontinue;\n} else {\nvar s \x3d cljs.core.first(seq__11710__$1);\ncljs.core._write(writer,s);\n\n\nvar G__11725 \x3d cljs.core.next(seq__11710__$1);\nvar G__11726 \x3d null;\nvar G__11727 \x3d (0);\nvar G__11728 \x3d (0);\nseq__11710 \x3d G__11725;\nchunk__11711 \x3d G__11726;\ncount__11712 \x3d G__11727;\ni__11713 \x3d G__11728;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.write_all.cljs$lang$maxFixedArity \x3d (1);\n\n/** @this {Function} */\ncljs.core.write_all.cljs$lang$applyTo \x3d (function (seq11708){\nvar G__11709 \x3d cljs.core.first(seq11708);\nvar seq11708__$1 \x3d cljs.core.next(seq11708);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11709,seq11708__$1);\n});\n\ncljs.core.string_print \x3d (function cljs$core$string_print(x){\nif((cljs.core._STAR_print_fn_STAR_ \x3d\x3d null)){\nthrow (new Error("No *print-fn* fn set for evaluation environment"));\n} else {\n}\n\n(cljs.core._STAR_print_fn_STAR_.cljs$core$IFn$_invoke$arity$1 ? cljs.core._STAR_print_fn_STAR_.cljs$core$IFn$_invoke$arity$1(x) : cljs.core._STAR_print_fn_STAR_.call(null,x));\n\nreturn null;\n});\ncljs.core.flush \x3d (function cljs$core$flush(){\nreturn null;\n});\ncljs.core.char_escapes \x3d (function (){var obj11730 \x3d ({"\\"":"\\\\\\"","\\\\":"\\\\\\\\","\\b":"\\\\b","\\f":"\\\\f","\\n":"\\\\n","\\r":"\\\\r","\\t":"\\\\t"});\nreturn obj11730;\n})();\ncljs.core.quote_string \x3d (function cljs$core$quote_string(s){\nreturn ["\\"",cljs.core.str.cljs$core$IFn$_invoke$arity$1(s.replace(RegExp("[\\\\\\\\\\"\\b\\f\\n\\r\\t]","g"),(function (match){\nreturn (cljs.core.char_escapes[match]);\n}))),"\\""].join(\'\');\n});\ncljs.core.print_meta_QMARK_ \x3d (function cljs$core$print_meta_QMARK_(opts,obj){\nvar and__4120__auto__ \x3d cljs.core.boolean$(cljs.core.get.cljs$core$IFn$_invoke$arity$2(opts,cljs.core.cst$kw$meta));\nif(and__4120__auto__){\nvar and__4120__auto____$1 \x3d (((!((obj \x3d\x3d null))))?(((((obj.cljs$lang$protocol_mask$partition0$ \x26 (131072))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d obj.cljs$core$IMeta$))))?true:false):false);\nif(and__4120__auto____$1){\nreturn (!((cljs.core.meta(obj) \x3d\x3d null)));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});\ncljs.core.pr_writer_impl \x3d (function cljs$core$pr_writer_impl(obj,writer,opts){\nif((obj \x3d\x3d null)){\nreturn cljs.core._write(writer,"nil");\n} else {\nif(cljs.core.print_meta_QMARK_(opts,obj)){\ncljs.core._write(writer,"^");\n\ncljs.core.pr_writer(cljs.core.meta(obj),writer,opts);\n\ncljs.core._write(writer," ");\n} else {\n}\n\nif(obj.cljs$lang$type){\nreturn obj.cljs$lang$ctorPrWriter(obj,writer,opts);\n} else {\nif((((!((obj \x3d\x3d null))))?(((((obj.cljs$lang$protocol_mask$partition0$ \x26 (2147483648))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d obj.cljs$core$IPrintWithWriter$))))?true:(((!obj.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.IPrintWithWriter,obj):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IPrintWithWriter,obj))){\nreturn cljs.core._pr_writer(obj,writer,opts);\n} else {\nif(((obj \x3d\x3d\x3d true) || (obj \x3d\x3d\x3d false))){\nreturn cljs.core._write(writer,cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj));\n} else {\nif(typeof obj \x3d\x3d\x3d \'number\'){\nreturn cljs.core._write(writer,((isNaN(obj))?"##NaN":(((obj \x3d\x3d\x3d Number.POSITIVE_INFINITY))?"##Inf":(((obj \x3d\x3d\x3d Number.NEGATIVE_INFINITY))?"##-Inf":cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj)\n))));\n} else {\nif(cljs.core.object_QMARK_(obj)){\ncljs.core._write(writer,"#js ");\n\nreturn cljs.core.print_map(cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (k){\nreturn (new cljs.core.MapEntry((function (){var G__11735 \x3d k;\nif((!((cljs.core.re_matches(/[A-Za-z_\\*\\+\\?!\\-\'][\\w\\*\\+\\?!\\-\']*/,k) \x3d\x3d null)))){\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$1(G__11735);\n} else {\nreturn G__11735;\n}\n})(),(obj[k]),null));\n}),cljs.core.js_keys(obj)),cljs.core.pr_writer,writer,opts);\n} else {\nif(cljs.core.array_QMARK_(obj)){\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"#js ["," ","]",opts,obj);\n} else {\nif(goog.isString(obj)){\nif(cljs.core.truth_(cljs.core.cst$kw$readably.cljs$core$IFn$_invoke$arity$1(opts))){\nreturn cljs.core._write(writer,cljs.core.quote_string(obj));\n} else {\nreturn cljs.core._write(writer,obj);\n}\n} else {\nif(goog.isFunction(obj)){\nvar name \x3d obj.name;\nvar name__$1 \x3d (cljs.core.truth_((function (){var or__4131__auto__ \x3d (name \x3d\x3d null);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.string.isEmpty(name);\n}\n})())?"Function":name);\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(["#object[",name__$1,((cljs.core._STAR_print_fn_bodies_STAR_)?[" \\"",cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj),"\\""].join(\'\'):""),"]"], 0));\n} else {\nif((obj instanceof Date)){\nvar normalize \x3d (function (n,len){\nvar ns \x3d cljs.core.str.cljs$core$IFn$_invoke$arity$1(n);\nwhile(true){\nif((cljs.core.count(ns) \x3c len)){\nvar G__11738 \x3d ["0",ns].join(\'\');\nns \x3d G__11738;\ncontinue;\n} else {\nreturn ns;\n}\nbreak;\n}\n});\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(["#inst \\"",cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj.getUTCFullYear()),"-",normalize((obj.getUTCMonth() + (1)),(2)),"-",normalize(obj.getUTCDate(),(2)),"T",normalize(obj.getUTCHours(),(2)),":",normalize(obj.getUTCMinutes(),(2)),":",normalize(obj.getUTCSeconds(),(2)),".",normalize(obj.getUTCMilliseconds(),(3)),"-","00:00\\""], 0));\n} else {\nif(cljs.core.regexp_QMARK_(obj)){\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(["#\\"",obj.source,"\\""], 0));\n} else {\nif(cljs.core.truth_((function (){var G__11736 \x3d obj;\nvar G__11736__$1 \x3d (((G__11736 \x3d\x3d null))?null:G__11736.constructor);\nif((G__11736__$1 \x3d\x3d null)){\nreturn null;\n} else {\nreturn G__11736__$1.cljs$lang$ctorStr;\n}\n})())){\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(["#object[",obj.constructor.cljs$lang$ctorStr.replace((new RegExp("/","g")),"."),"]"], 0));\n} else {\nvar name \x3d (function (){var G__11737 \x3d obj;\nvar G__11737__$1 \x3d (((G__11737 \x3d\x3d null))?null:G__11737.constructor);\nif((G__11737__$1 \x3d\x3d null)){\nreturn null;\n} else {\nreturn G__11737__$1.name;\n}\n})();\nvar name__$1 \x3d (cljs.core.truth_((function (){var or__4131__auto__ \x3d (name \x3d\x3d null);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.string.isEmpty(name);\n}\n})())?"Object":name);\nif((obj.constructor \x3d\x3d null)){\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(["#object[",name__$1,"]"], 0));\n} else {\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(["#object[",name__$1," ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj),"]"], 0));\n}\n}\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n}\n});\n/**\n * Prefer this to pr-seq, because it makes the printing function\n * configurable, allowing efficient implementations such as appending\n * to a StringBuffer.\n */\ncljs.core.pr_writer \x3d (function cljs$core$pr_writer(obj,writer,opts){\nvar temp__5718__auto__ \x3d cljs.core.cst$kw$alt_DASH_impl.cljs$core$IFn$_invoke$arity$1(opts);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar alt_impl \x3d temp__5718__auto__;\nvar G__11739 \x3d obj;\nvar G__11740 \x3d writer;\nvar G__11741 \x3d cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(opts,cljs.core.cst$kw$fallback_DASH_impl,cljs.core.pr_writer_impl);\nreturn (alt_impl.cljs$core$IFn$_invoke$arity$3 ? alt_impl.cljs$core$IFn$_invoke$arity$3(G__11739,G__11740,G__11741) : alt_impl.call(null,G__11739,G__11740,G__11741));\n} else {\nreturn cljs.core.pr_writer_impl(obj,writer,opts);\n}\n});\ncljs.core.pr_seq_writer \x3d (function cljs$core$pr_seq_writer(objs,writer,opts){\ncljs.core.pr_writer(cljs.core.first(objs),writer,opts);\n\nvar seq__11742 \x3d cljs.core.seq(cljs.core.next(objs));\nvar chunk__11743 \x3d null;\nvar count__11744 \x3d (0);\nvar i__11745 \x3d (0);\nwhile(true){\nif((i__11745 \x3c count__11744)){\nvar obj \x3d chunk__11743.cljs$core$IIndexed$_nth$arity$2(null,i__11745);\ncljs.core._write(writer," ");\n\ncljs.core.pr_writer(obj,writer,opts);\n\n\nvar G__11746 \x3d seq__11742;\nvar G__11747 \x3d chunk__11743;\nvar G__11748 \x3d count__11744;\nvar G__11749 \x3d (i__11745 + (1));\nseq__11742 \x3d G__11746;\nchunk__11743 \x3d G__11747;\ncount__11744 \x3d G__11748;\ni__11745 \x3d G__11749;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__11742);\nif(temp__5720__auto__){\nvar seq__11742__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__11742__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__11742__$1);\nvar G__11750 \x3d cljs.core.chunk_rest(seq__11742__$1);\nvar G__11751 \x3d c__4550__auto__;\nvar G__11752 \x3d cljs.core.count(c__4550__auto__);\nvar G__11753 \x3d (0);\nseq__11742 \x3d G__11750;\nchunk__11743 \x3d G__11751;\ncount__11744 \x3d G__11752;\ni__11745 \x3d G__11753;\ncontinue;\n} else {\nvar obj \x3d cljs.core.first(seq__11742__$1);\ncljs.core._write(writer," ");\n\ncljs.core.pr_writer(obj,writer,opts);\n\n\nvar G__11754 \x3d cljs.core.next(seq__11742__$1);\nvar G__11755 \x3d null;\nvar G__11756 \x3d (0);\nvar G__11757 \x3d (0);\nseq__11742 \x3d G__11754;\nchunk__11743 \x3d G__11755;\ncount__11744 \x3d G__11756;\ni__11745 \x3d G__11757;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\ncljs.core.pr_sb_with_opts \x3d (function cljs$core$pr_sb_with_opts(objs,opts){\nvar sb \x3d (new goog.string.StringBuffer());\nvar writer \x3d (new cljs.core.StringBufferWriter(sb));\ncljs.core.pr_seq_writer(objs,writer,opts);\n\nwriter.cljs$core$IWriter$_flush$arity$1(null);\n\nreturn sb;\n});\n/**\n * Prints a sequence of objects to a string, observing all the\n *   options given in opts\n */\ncljs.core.pr_str_with_opts \x3d (function cljs$core$pr_str_with_opts(objs,opts){\nif(cljs.core.empty_QMARK_(objs)){\nreturn "";\n} else {\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.pr_sb_with_opts(objs,opts));\n}\n});\n/**\n * Same as pr-str-with-opts followed by (newline)\n */\ncljs.core.prn_str_with_opts \x3d (function cljs$core$prn_str_with_opts(objs,opts){\nif(cljs.core.empty_QMARK_(objs)){\nreturn "\\n";\n} else {\nvar sb \x3d cljs.core.pr_sb_with_opts(objs,opts);\nsb.append("\\n");\n\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(sb);\n}\n});\n/**\n * Prints a sequence of objects using string-print, observing all\n *   the options given in opts\n */\ncljs.core.pr_with_opts \x3d (function cljs$core$pr_with_opts(objs,opts){\nreturn cljs.core.string_print(cljs.core.pr_str_with_opts(objs,opts));\n});\n/**\n * Prints a newline using *print-fn*\n */\ncljs.core.newline \x3d (function cljs$core$newline(var_args){\nvar G__11759 \x3d arguments.length;\nswitch (G__11759) {\ncase 0:\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.newline.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$1(null);\n});\n\ncljs.core.newline.cljs$core$IFn$_invoke$arity$1 \x3d (function (opts){\ncljs.core.string_print("\\n");\n\nif(cljs.core.truth_(cljs.core.get.cljs$core$IFn$_invoke$arity$2(opts,cljs.core.cst$kw$flush_DASH_on_DASH_newline))){\nreturn cljs.core.flush();\n} else {\nreturn null;\n}\n});\n\ncljs.core.newline.cljs$lang$maxFixedArity \x3d 1;\n\n/**\n * pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.\n */\ncljs.core.pr_str \x3d (function cljs$core$pr_str(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11762 \x3d arguments.length;\nvar i__4731__auto___11763 \x3d (0);\nwhile(true){\nif((i__4731__auto___11763 \x3c len__4730__auto___11762)){\nargs__4736__auto__.push((arguments[i__4731__auto___11763]));\n\nvar G__11764 \x3d (i__4731__auto___11763 + (1));\ni__4731__auto___11763 \x3d G__11764;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic \x3d (function (objs){\nreturn cljs.core.pr_str_with_opts(objs,cljs.core.pr_opts());\n});\n\ncljs.core.pr_str.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.pr_str.cljs$lang$applyTo \x3d (function (seq11761){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11761));\n});\n\n/**\n * Same as pr-str followed by (newline)\n */\ncljs.core.prn_str \x3d (function cljs$core$prn_str(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11766 \x3d arguments.length;\nvar i__4731__auto___11767 \x3d (0);\nwhile(true){\nif((i__4731__auto___11767 \x3c len__4730__auto___11766)){\nargs__4736__auto__.push((arguments[i__4731__auto___11767]));\n\nvar G__11768 \x3d (i__4731__auto___11767 + (1));\ni__4731__auto___11767 \x3d G__11768;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.prn_str.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.prn_str.cljs$core$IFn$_invoke$arity$variadic \x3d (function (objs){\nreturn cljs.core.prn_str_with_opts(objs,cljs.core.pr_opts());\n});\n\ncljs.core.prn_str.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.prn_str.cljs$lang$applyTo \x3d (function (seq11765){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11765));\n});\n\n/**\n * Prints the object(s) using string-print.  Prints the\n *   object(s), separated by spaces if there is more than one.\n *   By default, pr and prn print in a way that objects can be\n *   read by the reader\n */\ncljs.core.pr \x3d (function cljs$core$pr(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11770 \x3d arguments.length;\nvar i__4731__auto___11771 \x3d (0);\nwhile(true){\nif((i__4731__auto___11771 \x3c len__4730__auto___11770)){\nargs__4736__auto__.push((arguments[i__4731__auto___11771]));\n\nvar G__11772 \x3d (i__4731__auto___11771 + (1));\ni__4731__auto___11771 \x3d G__11772;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.pr.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.pr.cljs$core$IFn$_invoke$arity$variadic \x3d (function (objs){\nreturn cljs.core.pr_with_opts(objs,cljs.core.pr_opts());\n});\n\ncljs.core.pr.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.pr.cljs$lang$applyTo \x3d (function (seq11769){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11769));\n});\n\n/**\n * Prints the object(s) using string-print.\n *   print and println produce output for human consumption.\n * @param {...*} var_args\n */\ncljs.core.print \x3d (function() { \nvar cljs$core$cljs_core_print__delegate \x3d function (objs){\nreturn cljs.core.pr_with_opts(objs,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.pr_opts(),cljs.core.cst$kw$readably,false));\n};\nvar cljs$core$cljs_core_print \x3d function (var_args){\nvar objs \x3d null;\nif (arguments.length \x3e 0) {\nvar G__11773__i \x3d 0, G__11773__a \x3d new Array(arguments.length -  0);\nwhile (G__11773__i \x3c G__11773__a.length) {G__11773__a[G__11773__i] \x3d arguments[G__11773__i + 0]; ++G__11773__i;}\n  objs \x3d new cljs.core.IndexedSeq(G__11773__a,0,null);\n} \nreturn cljs$core$cljs_core_print__delegate.call(this,objs);};\ncljs$core$cljs_core_print.cljs$lang$maxFixedArity \x3d 0;\ncljs$core$cljs_core_print.cljs$lang$applyTo \x3d (function (arglist__11774){\nvar objs \x3d cljs.core.seq(arglist__11774);\nreturn cljs$core$cljs_core_print__delegate(objs);\n});\ncljs$core$cljs_core_print.cljs$core$IFn$_invoke$arity$variadic \x3d cljs$core$cljs_core_print__delegate;\nreturn cljs$core$cljs_core_print;\n})()\n;\n/**\n * print to a string, returning it\n */\ncljs.core.print_str \x3d (function cljs$core$print_str(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11776 \x3d arguments.length;\nvar i__4731__auto___11777 \x3d (0);\nwhile(true){\nif((i__4731__auto___11777 \x3c len__4730__auto___11776)){\nargs__4736__auto__.push((arguments[i__4731__auto___11777]));\n\nvar G__11778 \x3d (i__4731__auto___11777 + (1));\ni__4731__auto___11777 \x3d G__11778;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.print_str.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.print_str.cljs$core$IFn$_invoke$arity$variadic \x3d (function (objs){\nreturn cljs.core.pr_str_with_opts(objs,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.pr_opts(),cljs.core.cst$kw$readably,false));\n});\n\ncljs.core.print_str.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.print_str.cljs$lang$applyTo \x3d (function (seq11775){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11775));\n});\n\n/**\n * Same as print followed by (newline)\n */\ncljs.core.println \x3d (function cljs$core$println(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11780 \x3d arguments.length;\nvar i__4731__auto___11781 \x3d (0);\nwhile(true){\nif((i__4731__auto___11781 \x3c len__4730__auto___11780)){\nargs__4736__auto__.push((arguments[i__4731__auto___11781]));\n\nvar G__11782 \x3d (i__4731__auto___11781 + (1));\ni__4731__auto___11781 \x3d G__11782;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic \x3d (function (objs){\ncljs.core.pr_with_opts(objs,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.pr_opts(),cljs.core.cst$kw$readably,false));\n\nif(cljs.core._STAR_print_newline_STAR_){\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$1(cljs.core.pr_opts());\n} else {\nreturn null;\n}\n});\n\ncljs.core.println.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.println.cljs$lang$applyTo \x3d (function (seq11779){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11779));\n});\n\n/**\n * println to a string, returning it\n */\ncljs.core.println_str \x3d (function cljs$core$println_str(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11784 \x3d arguments.length;\nvar i__4731__auto___11785 \x3d (0);\nwhile(true){\nif((i__4731__auto___11785 \x3c len__4730__auto___11784)){\nargs__4736__auto__.push((arguments[i__4731__auto___11785]));\n\nvar G__11786 \x3d (i__4731__auto___11785 + (1));\ni__4731__auto___11785 \x3d G__11786;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.println_str.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.println_str.cljs$core$IFn$_invoke$arity$variadic \x3d (function (objs){\nreturn cljs.core.prn_str_with_opts(objs,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.pr_opts(),cljs.core.cst$kw$readably,false));\n});\n\ncljs.core.println_str.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.println_str.cljs$lang$applyTo \x3d (function (seq11783){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11783));\n});\n\n/**\n * Same as pr followed by (newline).\n */\ncljs.core.prn \x3d (function cljs$core$prn(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11788 \x3d arguments.length;\nvar i__4731__auto___11789 \x3d (0);\nwhile(true){\nif((i__4731__auto___11789 \x3c len__4730__auto___11788)){\nargs__4736__auto__.push((arguments[i__4731__auto___11789]));\n\nvar G__11790 \x3d (i__4731__auto___11789 + (1));\ni__4731__auto___11789 \x3d G__11790;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic \x3d (function (objs){\ncljs.core.pr_with_opts(objs,cljs.core.pr_opts());\n\nif(cljs.core._STAR_print_newline_STAR_){\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$1(cljs.core.pr_opts());\n} else {\nreturn null;\n}\n});\n\ncljs.core.prn.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.prn.cljs$lang$applyTo \x3d (function (seq11787){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11787));\n});\n\ncljs.core.strip_ns \x3d (function cljs$core$strip_ns(named){\nif((named instanceof cljs.core.Symbol)){\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(null,cljs.core.name(named));\n} else {\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$2(null,cljs.core.name(named));\n}\n});\n/**\n * Returns [lifted-ns lifted-map] or nil if m can\'t be lifted.\n */\ncljs.core.lift_ns \x3d (function cljs$core$lift_ns(m){\nif(cljs.core._STAR_print_namespace_maps_STAR_){\nvar ns \x3d null;\nvar G__11797 \x3d cljs.core.seq(m);\nvar vec__11798 \x3d G__11797;\nvar seq__11799 \x3d cljs.core.seq(vec__11798);\nvar first__11800 \x3d cljs.core.first(seq__11799);\nvar seq__11799__$1 \x3d cljs.core.next(seq__11799);\nvar vec__11801 \x3d first__11800;\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11801,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11801,(1),null);\nvar entry \x3d vec__11801;\nvar entries \x3d seq__11799__$1;\nvar lm \x3d cljs.core.empty(m);\nvar ns__$1 \x3d ns;\nvar G__11797__$1 \x3d G__11797;\nvar lm__$1 \x3d lm;\nwhile(true){\nvar ns__$2 \x3d ns__$1;\nvar vec__11810 \x3d G__11797__$1;\nvar seq__11811 \x3d cljs.core.seq(vec__11810);\nvar first__11812 \x3d cljs.core.first(seq__11811);\nvar seq__11811__$1 \x3d cljs.core.next(seq__11811);\nvar vec__11813 \x3d first__11812;\nvar k__$1 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11813,(0),null);\nvar v__$1 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11813,(1),null);\nvar entry__$1 \x3d vec__11813;\nvar entries__$1 \x3d seq__11811__$1;\nvar lm__$2 \x3d lm__$1;\nif(cljs.core.truth_(entry__$1)){\nif((((k__$1 instanceof cljs.core.Keyword)) || ((k__$1 instanceof cljs.core.Symbol)))){\nif(cljs.core.truth_(ns__$2)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ns__$2,cljs.core.namespace(k__$1))){\nvar G__11816 \x3d ns__$2;\nvar G__11817 \x3d entries__$1;\nvar G__11818 \x3d cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(lm__$2,cljs.core.strip_ns(k__$1),v__$1);\nns__$1 \x3d G__11816;\nG__11797__$1 \x3d G__11817;\nlm__$1 \x3d G__11818;\ncontinue;\n} else {\nreturn null;\n}\n} else {\nvar temp__5720__auto__ \x3d cljs.core.namespace(k__$1);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar new_ns \x3d temp__5720__auto__;\nvar G__11819 \x3d new_ns;\nvar G__11820 \x3d entries__$1;\nvar G__11821 \x3d cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(lm__$2,cljs.core.strip_ns(k__$1),v__$1);\nns__$1 \x3d G__11819;\nG__11797__$1 \x3d G__11820;\nlm__$1 \x3d G__11821;\ncontinue;\n} else {\nreturn null;\n}\n}\n} else {\nreturn null;\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [ns__$2,lm__$2], null);\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\ncljs.core.print_prefix_map \x3d (function cljs$core$print_prefix_map(prefix,m,print_one,writer,opts){\nreturn cljs.core.pr_sequential_writer(writer,(function (e,w,opts__$1){\nvar G__11822_11828 \x3d cljs.core.key(e);\nvar G__11823_11829 \x3d w;\nvar G__11824_11830 \x3d opts__$1;\n(print_one.cljs$core$IFn$_invoke$arity$3 ? print_one.cljs$core$IFn$_invoke$arity$3(G__11822_11828,G__11823_11829,G__11824_11830) : print_one.call(null,G__11822_11828,G__11823_11829,G__11824_11830));\n\ncljs.core._write(w," ");\n\nvar G__11825 \x3d cljs.core.val(e);\nvar G__11826 \x3d w;\nvar G__11827 \x3d opts__$1;\nreturn (print_one.cljs$core$IFn$_invoke$arity$3 ? print_one.cljs$core$IFn$_invoke$arity$3(G__11825,G__11826,G__11827) : print_one.call(null,G__11825,G__11826,G__11827));\n}),[cljs.core.str.cljs$core$IFn$_invoke$arity$1(prefix),"{"].join(\'\'),", ","}",opts,cljs.core.seq(m));\n});\ncljs.core.print_map \x3d (function cljs$core$print_map(m,print_one,writer,opts){\nvar vec__11831 \x3d ((cljs.core.map_QMARK_(m))?cljs.core.lift_ns(m):null);\nvar ns \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11831,(0),null);\nvar lift_map \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11831,(1),null);\nif(cljs.core.truth_(ns)){\nreturn cljs.core.print_prefix_map(["#:",cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns)].join(\'\'),lift_map,print_one,writer,opts);\n} else {\nreturn cljs.core.print_prefix_map(null,m,print_one,writer,opts);\n}\n});\ncljs.core.Volatile.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Volatile.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (a,writer,opts){\nvar a__$1 \x3d this;\ncljs.core._write(writer,"#object[cljs.core.Volatile ");\n\ncljs.core.pr_writer(new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$val,a__$1.state], null),writer,opts);\n\nreturn cljs.core._write(writer,"]");\n});\n\ncljs.core.Var.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Var.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (a,writer,opts){\nvar a__$1 \x3d this;\ncljs.core._write(writer,"#\'");\n\nreturn cljs.core.pr_writer(a__$1.sym,writer,opts);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.IndexedSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.LazySeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.MapEntry.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"["," ","]",opts,coll__$1);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.NodeSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.BlackNode.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"["," ","]",opts,coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.ES6IteratorSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ES6IteratorSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"#{"," ","}",opts,coll__$1);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ObjMap.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.print_map(coll__$1,cljs.core.pr_writer,writer,opts);\n});\n\ncljs.core.Cons.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Cons.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.Iterate.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Iterate.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.RSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.print_map(coll__$1,cljs.core.pr_writer,writer,opts);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Subvec.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"["," ","]",opts,coll__$1);\n});\n\ncljs.core.Cycle.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Cycle.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.print_map(coll__$1,cljs.core.pr_writer,writer,opts);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"#{"," ","}",opts,coll__$1);\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ChunkedCons.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.Atom.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Atom.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (a,writer,opts){\nvar a__$1 \x3d this;\ncljs.core._write(writer,"#object[cljs.core.Atom ");\n\ncljs.core.pr_writer(new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$val,a__$1.state], null),writer,opts);\n\nreturn cljs.core._write(writer,"]");\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ValSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RedNode.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"["," ","]",opts,coll__$1);\n});\n\ncljs.core.Repeat.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Repeat.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentVector.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"["," ","]",opts,coll__$1);\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.EmptyList.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core._write(writer,"()");\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentQueue.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"#queue ["," ","]",opts,cljs.core.seq(coll__$1));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.print_map(coll__$1,cljs.core.pr_writer,writer,opts);\n});\n\ncljs.core.Range.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Range.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.TransformerIterator.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.TransformerIterator.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.KeySeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\n\ncljs.core.List.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.List.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll,writer,opts){\nvar coll__$1 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$1);\n});\ncljs.core.Symbol.prototype.cljs$core$IComparable$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Symbol.prototype.cljs$core$IComparable$_compare$arity$2 \x3d (function (x,y){\nvar x__$1 \x3d this;\nif((y instanceof cljs.core.Symbol)){\nreturn cljs.core.compare_symbols(x__$1,y);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join(\'\')));\n}\n});\n\ncljs.core.Keyword.prototype.cljs$core$IComparable$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Keyword.prototype.cljs$core$IComparable$_compare$arity$2 \x3d (function (x,y){\nvar x__$1 \x3d this;\nif((y instanceof cljs.core.Keyword)){\nreturn cljs.core.compare_keywords(x__$1,y);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join(\'\')));\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IComparable$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Subvec.prototype.cljs$core$IComparable$_compare$arity$2 \x3d (function (x,y){\nvar x__$1 \x3d this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join(\'\')));\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IComparable$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentVector.prototype.cljs$core$IComparable$_compare$arity$2 \x3d (function (x,y){\nvar x__$1 \x3d this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join(\'\')));\n}\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IComparable$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.MapEntry.prototype.cljs$core$IComparable$_compare$arity$2 \x3d (function (x,y){\nvar x__$1 \x3d this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join(\'\')));\n}\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IComparable$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.BlackNode.prototype.cljs$core$IComparable$_compare$arity$2 \x3d (function (x,y){\nvar x__$1 \x3d this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join(\'\')));\n}\n});\n\ncljs.core.RedNode.prototype.cljs$core$IComparable$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RedNode.prototype.cljs$core$IComparable$_compare$arity$2 \x3d (function (x,y){\nvar x__$1 \x3d this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error(["Cannot compare ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1)," to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join(\'\')));\n}\n});\n/**\n * Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n * \n *   (apply f its-current-meta args)\n * \n *   f must be free of side-effects\n */\ncljs.core.alter_meta_BANG_ \x3d (function cljs$core$alter_meta_BANG_(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11837 \x3d arguments.length;\nvar i__4731__auto___11838 \x3d (0);\nwhile(true){\nif((i__4731__auto___11838 \x3c len__4730__auto___11837)){\nargs__4736__auto__.push((arguments[i__4731__auto___11838]));\n\nvar G__11839 \x3d (i__4731__auto___11838 + (1));\ni__4731__auto___11838 \x3d G__11839;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((2) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((2)),(0),null)):null);\nreturn cljs.core.alter_meta_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4737__auto__);\n});\n\ncljs.core.alter_meta_BANG_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (iref,f,args){\nreturn iref.meta \x3d cljs.core.apply.cljs$core$IFn$_invoke$arity$3(f,iref.meta,args);\n});\n\ncljs.core.alter_meta_BANG_.cljs$lang$maxFixedArity \x3d (2);\n\n/** @this {Function} */\ncljs.core.alter_meta_BANG_.cljs$lang$applyTo \x3d (function (seq11834){\nvar G__11835 \x3d cljs.core.first(seq11834);\nvar seq11834__$1 \x3d cljs.core.next(seq11834);\nvar G__11836 \x3d cljs.core.first(seq11834__$1);\nvar seq11834__$2 \x3d cljs.core.next(seq11834__$1);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11835,G__11836,seq11834__$2);\n});\n\n/**\n * Atomically resets the metadata for an atom\n */\ncljs.core.reset_meta_BANG_ \x3d (function cljs$core$reset_meta_BANG_(iref,m){\nreturn iref.meta \x3d m;\n});\n/**\n * Adds a watch function to an atom reference. The watch fn must be a\n *   fn of 4 args: a key, the reference, its old-state, its\n *   new-state. Whenever the reference\'s state might have been changed,\n *   any registered watches will have their functions called. The watch\n *   fn will be called synchronously. Note that an atom\'s state\n *   may have changed again prior to the fn call, so use old/new-state\n *   rather than derefing the reference. Keys must be unique per\n *   reference, and can be used to remove the watch with remove-watch,\n *   but are otherwise considered opaque by the watch mechanism.  Bear in\n *   mind that regardless of the result or action of the watch fns the\n *   atom\'s value will change.  Example:\n * \n *    (def a (atom 0))\n *    (add-watch a :inc (fn [k r o n] (assert (\x3d\x3d 0 n))))\n *    (swap! a inc)\n *    ;; Assertion Error\n *    (deref a)\n *    ;\x3d\x3e 1\n */\ncljs.core.add_watch \x3d (function cljs$core$add_watch(iref,key,f){\ncljs.core._add_watch(iref,key,f);\n\nreturn iref;\n});\n/**\n * Removes a watch (set by add-watch) from a reference\n */\ncljs.core.remove_watch \x3d (function cljs$core$remove_watch(iref,key){\ncljs.core._remove_watch(iref,key);\n\nreturn iref;\n});\n/**\n * @type {*}\n */\ncljs.core.gensym_counter \x3d null;\n/**\n * Returns a new symbol with a unique name. If a prefix string is\n *   supplied, the name is prefix# where # is some unique number. If\n *   prefix is not supplied, the prefix is \'G__\'.\n */\ncljs.core.gensym \x3d (function cljs$core$gensym(var_args){\nvar G__11841 \x3d arguments.length;\nswitch (G__11841) {\ncase 0:\nreturn cljs.core.gensym.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.gensym.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.gensym.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.gensym.cljs$core$IFn$_invoke$arity$1("G__");\n});\n\ncljs.core.gensym.cljs$core$IFn$_invoke$arity$1 \x3d (function (prefix_string){\nif((cljs.core.gensym_counter \x3d\x3d null)){\ncljs.core.gensym_counter \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\n} else {\n}\n\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$1([cljs.core.str.cljs$core$IFn$_invoke$arity$1(prefix_string),cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(cljs.core.gensym_counter,cljs.core.inc))].join(\'\'));\n});\n\ncljs.core.gensym.cljs$lang$maxFixedArity \x3d 1;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IDeref}\n * @implements {cljs.core.IPrintWithWriter}\n*/\ncljs.core.Delay \x3d (function (f,value){\nthis.f \x3d f;\nthis.value \x3d value;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 2147516416;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 1;\n});\ncljs.core.Delay.prototype.cljs$core$IDeref$_deref$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nif(cljs.core.truth_(self__.f)){\nself__.value \x3d (self__.f.cljs$core$IFn$_invoke$arity$0 ? self__.f.cljs$core$IFn$_invoke$arity$0() : self__.f.call(null));\n\nself__.f \x3d null;\n} else {\n}\n\nreturn self__.value;\n});\n\ncljs.core.Delay.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 \x3d (function (x){\nvar self__ \x3d this;\nvar x__$1 \x3d this;\nreturn cljs.core.not(self__.f);\n});\n\ncljs.core.Delay.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (x,writer,opts){\nvar self__ \x3d this;\nvar x__$1 \x3d this;\ncljs.core._write(writer,"#object[cljs.core.Delay ");\n\ncljs.core.pr_writer(new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$status,(((self__.f \x3d\x3d null))?cljs.core.cst$kw$ready:cljs.core.cst$kw$pending),cljs.core.cst$kw$val,self__.value], null),writer,opts);\n\nreturn cljs.core._write(writer,"]");\n});\n\ncljs.core.Delay.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(cljs.core.cst$sym$f,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null)),cljs.core.with_meta(cljs.core.cst$sym$value,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.Delay.cljs$lang$type \x3d true;\n\ncljs.core.Delay.cljs$lang$ctorStr \x3d "cljs.core/Delay";\n\ncljs.core.Delay.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Delay");\n});\n\n/**\n * Positional factory function for cljs.core/Delay.\n */\ncljs.core.__GT_Delay \x3d (function cljs$core$__GT_Delay(f,value){\nreturn (new cljs.core.Delay(f,value));\n});\n\n/**\n * returns true if x is a Delay created with delay\n */\ncljs.core.delay_QMARK_ \x3d (function cljs$core$delay_QMARK_(x){\nreturn (x instanceof cljs.core.Delay);\n});\n/**\n * If x is a Delay, returns the (possibly cached) value of its expression, else returns x\n */\ncljs.core.force \x3d (function cljs$core$force(x){\nif(cljs.core.delay_QMARK_(x)){\nreturn cljs.core.deref(x);\n} else {\nreturn x;\n}\n});\n/**\n * Returns true if a value has been produced for a delay or lazy sequence.\n */\ncljs.core.realized_QMARK_ \x3d (function cljs$core$realized_QMARK_(x){\nreturn cljs.core._realized_QMARK_(x);\n});\ncljs.core.preserving_reduced \x3d (function cljs$core$preserving_reduced(rf){\nreturn (function (p1__11843_SHARP_,p2__11844_SHARP_){\nvar ret \x3d (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(p1__11843_SHARP_,p2__11844_SHARP_) : rf.call(null,p1__11843_SHARP_,p2__11844_SHARP_));\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.reduced(ret);\n} else {\nreturn ret;\n}\n});\n});\n/**\n * A transducer which concatenates the contents of each input, which must be a\n *   collection, into the reduction.\n */\ncljs.core.cat \x3d (function cljs$core$cat(rf){\nvar rf1 \x3d cljs.core.preserving_reduced(rf);\nreturn ((function (rf1){\nreturn (function() {\nvar G__11845 \x3d null;\nvar G__11845__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__11845__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__11845__2 \x3d (function (result,input){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(rf1,result,input);\n});\nG__11845 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__11845__0.call(this);\ncase 1:\nreturn G__11845__1.call(this,result);\ncase 2:\nreturn G__11845__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11845.cljs$core$IFn$_invoke$arity$0 \x3d G__11845__0;\nG__11845.cljs$core$IFn$_invoke$arity$1 \x3d G__11845__1;\nG__11845.cljs$core$IFn$_invoke$arity$2 \x3d G__11845__2;\nreturn G__11845;\n})()\n;})(rf1))\n});\n/**\n * Returns a transducer that ends transduction when pred returns true\n *   for an input. When retf is supplied it must be a fn of 2 arguments -\n *   it will be passed the (completed) result so far and the input that\n *   triggered the predicate, and its return value (if it does not throw\n *   an exception) will be the return value of the transducer. If retf\n *   is not supplied, the input that triggered the predicate will be\n *   returned. If the predicate never returns true the transduction is\n *   unaffected.\n */\ncljs.core.halt_when \x3d (function cljs$core$halt_when(var_args){\nvar G__11847 \x3d arguments.length;\nswitch (G__11847) {\ncase 1:\nreturn cljs.core.halt_when.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.halt_when.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.halt_when.cljs$core$IFn$_invoke$arity$1 \x3d (function (pred){\nreturn cljs.core.halt_when.cljs$core$IFn$_invoke$arity$2(pred,null);\n});\n\ncljs.core.halt_when.cljs$core$IFn$_invoke$arity$2 \x3d (function (pred,retf){\nreturn (function (rf){\nreturn (function() {\nvar G__11851 \x3d null;\nvar G__11851__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__11851__1 \x3d (function (result){\nif(((cljs.core.map_QMARK_(result)) \x26\x26 (cljs.core.contains_QMARK_(result,cljs.core.cst$kw$cljs$core_SLASH_halt)))){\nreturn cljs.core.cst$kw$cljs$core_SLASH_halt.cljs$core$IFn$_invoke$arity$1(result);\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n}\n});\nvar G__11851__2 \x3d (function (result,input){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(input) : pred.call(null,input)))){\nreturn cljs.core.reduced(new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$cljs$core_SLASH_halt,(cljs.core.truth_(retf)?(function (){var G__11848 \x3d (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\nvar G__11849 \x3d input;\nreturn (retf.cljs$core$IFn$_invoke$arity$2 ? retf.cljs$core$IFn$_invoke$arity$2(G__11848,G__11849) : retf.call(null,G__11848,G__11849));\n})():input)], null));\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__11851 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__11851__0.call(this);\ncase 1:\nreturn G__11851__1.call(this,result);\ncase 2:\nreturn G__11851__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11851.cljs$core$IFn$_invoke$arity$0 \x3d G__11851__0;\nG__11851.cljs$core$IFn$_invoke$arity$1 \x3d G__11851__1;\nG__11851.cljs$core$IFn$_invoke$arity$2 \x3d G__11851__2;\nreturn G__11851;\n})()\n});\n});\n\ncljs.core.halt_when.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns a lazy sequence removing consecutive duplicates in coll.\n *   Returns a transducer when no collection is provided.\n */\ncljs.core.dedupe \x3d (function cljs$core$dedupe(var_args){\nvar G__11853 \x3d arguments.length;\nswitch (G__11853) {\ncase 0:\nreturn cljs.core.dedupe.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.dedupe.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.dedupe.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn (function (rf){\nvar pa \x3d cljs.core.volatile_BANG_(cljs.core.cst$kw$cljs$core_SLASH_none);\nreturn ((function (pa){\nreturn (function() {\nvar G__11855 \x3d null;\nvar G__11855__0 \x3d (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__11855__1 \x3d (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__11855__2 \x3d (function (result,input){\nvar prior \x3d cljs.core.deref(pa);\ncljs.core.vreset_BANG_(pa,input);\n\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(prior,input)){\nreturn result;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__11855 \x3d function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__11855__0.call(this);\ncase 1:\nreturn G__11855__1.call(this,result);\ncase 2:\nreturn G__11855__2.call(this,result,input);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11855.cljs$core$IFn$_invoke$arity$0 \x3d G__11855__0;\nG__11855.cljs$core$IFn$_invoke$arity$1 \x3d G__11855__1;\nG__11855.cljs$core$IFn$_invoke$arity$2 \x3d G__11855__2;\nreturn G__11855;\n})()\n;})(pa))\n});\n});\n\ncljs.core.dedupe.cljs$core$IFn$_invoke$arity$1 \x3d (function (coll){\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$2(cljs.core.dedupe.cljs$core$IFn$_invoke$arity$0(),coll);\n});\n\ncljs.core.dedupe.cljs$lang$maxFixedArity \x3d 1;\n\n/**\n * Returns items from coll with random probability of prob (0.0 -\n *   1.0).  Returns a transducer when no collection is provided.\n */\ncljs.core.random_sample \x3d (function cljs$core$random_sample(var_args){\nvar G__11857 \x3d arguments.length;\nswitch (G__11857) {\ncase 1:\nreturn cljs.core.random_sample.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.random_sample.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.random_sample.cljs$core$IFn$_invoke$arity$1 \x3d (function (prob){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$1((function (_){\nreturn (cljs.core.rand.cljs$core$IFn$_invoke$arity$0() \x3c prob);\n}));\n});\n\ncljs.core.random_sample.cljs$core$IFn$_invoke$arity$2 \x3d (function (prob,coll){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2((function (_){\nreturn (cljs.core.rand.cljs$core$IFn$_invoke$arity$0() \x3c prob);\n}),coll);\n});\n\ncljs.core.random_sample.cljs$lang$maxFixedArity \x3d 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Eduction \x3d (function (xform,coll){\nthis.xform \x3d xform;\nthis.coll \x3d coll;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 2173173760;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 131072;\n});\ncljs.core.Eduction.prototype.indexOf \x3d (function() {\nvar G__11859 \x3d null;\nvar G__11859__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll__$1,x,(0));\n});\nvar G__11859__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll__$1,x,start);\n});\nG__11859 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11859__1.call(this,x);\ncase 2:\nreturn G__11859__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11859.cljs$core$IFn$_invoke$arity$1 \x3d G__11859__1;\nG__11859.cljs$core$IFn$_invoke$arity$2 \x3d G__11859__2;\nreturn G__11859;\n})()\n;\n\ncljs.core.Eduction.prototype.lastIndexOf \x3d (function() {\nvar G__11860 \x3d null;\nvar G__11860__1 \x3d (function (x){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll__$1,x,cljs.core.count(coll__$1));\n});\nvar G__11860__2 \x3d (function (x,start){\nvar self__ \x3d this;\nvar coll__$1 \x3d this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll__$1,x,start);\n});\nG__11860 \x3d function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__11860__1.call(this,x);\ncase 2:\nreturn G__11860__2.call(this,x,start);\n}\nthrow(new Error(\'Invalid arity: \' + arguments.length));\n};\nG__11860.cljs$core$IFn$_invoke$arity$1 \x3d G__11860__1;\nG__11860.cljs$core$IFn$_invoke$arity$2 \x3d G__11860__2;\nreturn G__11860;\n})()\n;\n\ncljs.core.Eduction.prototype.cljs$core$IIterable$_iterator$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn cljs.core.TransformerIterator.create(self__.xform,cljs.core.iter(self__.coll));\n});\n\ncljs.core.Eduction.prototype.cljs$core$ISeqable$_seq$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn cljs.core.seq(cljs.core.sequence.cljs$core$IFn$_invoke$arity$2(self__.xform,self__.coll));\n});\n\ncljs.core.Eduction.prototype.cljs$core$IReduce$_reduce$arity$2 \x3d (function (_,f){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$3(self__.xform,cljs.core.completing.cljs$core$IFn$_invoke$arity$1(f),self__.coll);\n});\n\ncljs.core.Eduction.prototype.cljs$core$IReduce$_reduce$arity$3 \x3d (function (_,f,init){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$4(self__.xform,cljs.core.completing.cljs$core$IFn$_invoke$arity$1(f),init,self__.coll);\n});\n\ncljs.core.Eduction.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (coll__$1,writer,opts){\nvar self__ \x3d this;\nvar coll__$2 \x3d this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,"("," ",")",opts,coll__$2);\n});\n\ncljs.core.Eduction.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xform,cljs.core.cst$sym$coll], null);\n});\n\ncljs.core.Eduction.cljs$lang$type \x3d true;\n\ncljs.core.Eduction.cljs$lang$ctorStr \x3d "cljs.core/Eduction";\n\ncljs.core.Eduction.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Eduction");\n});\n\n/**\n * Positional factory function for cljs.core/Eduction.\n */\ncljs.core.__GT_Eduction \x3d (function cljs$core$__GT_Eduction(xform,coll){\nreturn (new cljs.core.Eduction(xform,coll));\n});\n\nvar G__11861_11864 \x3d cljs.core.Eduction.prototype;\nvar G__11862_11865 \x3d cljs.core.ITER_SYMBOL;\nvar G__11863_11866 \x3d ((function (G__11861_11864,G__11862_11865){\nreturn (function (){\nvar this__4669__auto__ \x3d this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__11861_11864,G__11862_11865))\n;\ngoog.object.set(G__11861_11864,G__11862_11865,G__11863_11866);\n/**\n * Returns a reducible/iterable application of the transducers\n *   to the items in coll. Transducers are applied in order as if\n *   combined with comp. Note that these applications will be\n *   performed every time reduce/iterator is called.\n */\ncljs.core.eduction \x3d (function cljs$core$eduction(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11868 \x3d arguments.length;\nvar i__4731__auto___11869 \x3d (0);\nwhile(true){\nif((i__4731__auto___11869 \x3c len__4730__auto___11868)){\nargs__4736__auto__.push((arguments[i__4731__auto___11869]));\n\nvar G__11870 \x3d (i__4731__auto___11869 + (1));\ni__4731__auto___11869 \x3d G__11870;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((0) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.eduction.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.eduction.cljs$core$IFn$_invoke$arity$variadic \x3d (function (xforms){\nreturn (new cljs.core.Eduction(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.comp,cljs.core.butlast(xforms)),cljs.core.last(xforms)));\n});\n\ncljs.core.eduction.cljs$lang$maxFixedArity \x3d (0);\n\n/** @this {Function} */\ncljs.core.eduction.cljs$lang$applyTo \x3d (function (seq11867){\nvar self__4718__auto__ \x3d this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11867));\n});\n\n/**\n * Runs the supplied procedure (via reduce), for purposes of side\n *   effects, on successive items in the collection. Returns nil\n */\ncljs.core.run_BANG_ \x3d (function cljs$core$run_BANG_(proc,coll){\ncljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__11872_SHARP_,p2__11871_SHARP_){\nreturn (proc.cljs$core$IFn$_invoke$arity$1 ? proc.cljs$core$IFn$_invoke$arity$1(p2__11871_SHARP_) : proc.call(null,p2__11871_SHARP_));\n}),null,coll);\n\nreturn null;\n});\n\n/**\n * @interface\n */\ncljs.core.IEncodeJS \x3d function(){};\n\n/**\n * Recursively transforms clj values to JavaScript\n */\ncljs.core._clj__GT_js \x3d (function cljs$core$_clj__GT_js(x){\nif((((!((x \x3d\x3d null)))) \x26\x26 ((!((x.cljs$core$IEncodeJS$_clj__GT_js$arity$1 \x3d\x3d null)))))){\nreturn x.cljs$core$IEncodeJS$_clj__GT_js$arity$1(x);\n} else {\nvar x__4433__auto__ \x3d (((x \x3d\x3d null))?null:x);\nvar m__4434__auto__ \x3d (cljs.core._clj__GT_js[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._clj__GT_js["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol("IEncodeJS.-clj-\x3ejs",x);\n}\n}\n}\n});\n\n/**\n * Transforms map keys to valid JavaScript keys. Arbitrary keys are\n *   encoded to their string representation via (pr-str x)\n */\ncljs.core._key__GT_js \x3d (function cljs$core$_key__GT_js(x){\nif((((!((x \x3d\x3d null)))) \x26\x26 ((!((x.cljs$core$IEncodeJS$_key__GT_js$arity$1 \x3d\x3d null)))))){\nreturn x.cljs$core$IEncodeJS$_key__GT_js$arity$1(x);\n} else {\nvar x__4433__auto__ \x3d (((x \x3d\x3d null))?null:x);\nvar m__4434__auto__ \x3d (cljs.core._key__GT_js[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._key__GT_js["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol("IEncodeJS.-key-\x3ejs",x);\n}\n}\n}\n});\n\ncljs.core.key__GT_js \x3d (function cljs$core$key__GT_js(var_args){\nvar G__11874 \x3d arguments.length;\nswitch (G__11874) {\ncase 1:\nreturn cljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$1 \x3d (function (k){\nreturn cljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$2(k,cljs.core.clj__GT_js);\n});\n\ncljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$2 \x3d (function (k,primitive_fn){\nif((((!((k \x3d\x3d null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d k.cljs$core$IEncodeJS$))))?true:(((!k.cljs$lang$protocol_mask$partition$))?cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeJS,k):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeJS,k))){\nreturn cljs.core._clj__GT_js(k);\n} else {\nif(((typeof k \x3d\x3d\x3d \'string\') || (typeof k \x3d\x3d\x3d \'number\') || ((k instanceof cljs.core.Keyword)) || ((k instanceof cljs.core.Symbol)))){\nreturn (primitive_fn.cljs$core$IFn$_invoke$arity$1 ? primitive_fn.cljs$core$IFn$_invoke$arity$1(k) : primitive_fn.call(null,k));\n} else {\nreturn cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([k], 0));\n\n}\n}\n});\n\ncljs.core.key__GT_js.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Recursively transforms ClojureScript values to JavaScript.\n *   sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n *   Maps become Objects. Arbitrary keys are encoded to by `key-\x3ejs`.\n *   Options is a key-value pair, where the only valid key is\n *   :keyword-fn, which should point to a single-argument function to be\n *   called on keyword keys. Default to `name`.\n */\ncljs.core.clj__GT_js \x3d (function cljs$core$clj__GT_js(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___11952 \x3d arguments.length;\nvar i__4731__auto___11953 \x3d (0);\nwhile(true){\nif((i__4731__auto___11953 \x3c len__4730__auto___11952)){\nargs__4736__auto__.push((arguments[i__4731__auto___11953]));\n\nvar G__11954 \x3d (i__4731__auto___11953 + (1));\ni__4731__auto___11953 \x3d G__11954;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((1) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.clj__GT_js.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.clj__GT_js.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,p__11879){\nvar map__11880 \x3d p__11879;\nvar map__11880__$1 \x3d (((((!((map__11880 \x3d\x3d null))))?(((((map__11880.cljs$lang$protocol_mask$partition0$ \x26 (64))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d map__11880.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__11880):map__11880);\nvar options \x3d map__11880__$1;\nvar keyword_fn \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__11880__$1,cljs.core.cst$kw$keyword_DASH_fn,cljs.core.name);\nvar keyfn \x3d ((function (map__11880,map__11880__$1,options,keyword_fn){\nreturn (function cljs$core$keyfn(k){\nreturn cljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$2(k,thisfn);\n});})(map__11880,map__11880__$1,options,keyword_fn))\n;\nvar thisfn \x3d ((function (map__11880,map__11880__$1,options,keyword_fn){\nreturn (function cljs$core$thisfn(x__$1){\nif((x__$1 \x3d\x3d null)){\nreturn null;\n} else {\nif((((!((x__$1 \x3d\x3d null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x__$1.cljs$core$IEncodeJS$))))?true:(((!x__$1.cljs$lang$protocol_mask$partition$))?cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeJS,x__$1):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeJS,x__$1))){\nreturn cljs.core._clj__GT_js(x__$1);\n} else {\nif((x__$1 instanceof cljs.core.Keyword)){\nreturn (keyword_fn.cljs$core$IFn$_invoke$arity$1 ? keyword_fn.cljs$core$IFn$_invoke$arity$1(x__$1) : keyword_fn.call(null,x__$1));\n} else {\nif((x__$1 instanceof cljs.core.Symbol)){\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1);\n} else {\nif(cljs.core.map_QMARK_(x__$1)){\nvar m \x3d ({});\nvar seq__11920_11955 \x3d cljs.core.seq(x__$1);\nvar chunk__11921_11956 \x3d null;\nvar count__11922_11957 \x3d (0);\nvar i__11923_11958 \x3d (0);\nwhile(true){\nif((i__11923_11958 \x3c count__11922_11957)){\nvar vec__11936_11959 \x3d chunk__11921_11956.cljs$core$IIndexed$_nth$arity$2(null,i__11923_11958);\nvar k_11960 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11936_11959,(0),null);\nvar v_11961 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11936_11959,(1),null);\nvar G__11939_11962 \x3d m;\nvar G__11940_11963 \x3d keyfn(k_11960);\nvar G__11941_11964 \x3d cljs$core$thisfn(v_11961);\ngoog.object.set(G__11939_11962,G__11940_11963,G__11941_11964);\n\n\nvar G__11965 \x3d seq__11920_11955;\nvar G__11966 \x3d chunk__11921_11956;\nvar G__11967 \x3d count__11922_11957;\nvar G__11968 \x3d (i__11923_11958 + (1));\nseq__11920_11955 \x3d G__11965;\nchunk__11921_11956 \x3d G__11966;\ncount__11922_11957 \x3d G__11967;\ni__11923_11958 \x3d G__11968;\ncontinue;\n} else {\nvar temp__5720__auto___11969 \x3d cljs.core.seq(seq__11920_11955);\nif(temp__5720__auto___11969){\nvar seq__11920_11970__$1 \x3d temp__5720__auto___11969;\nif(cljs.core.chunked_seq_QMARK_(seq__11920_11970__$1)){\nvar c__4550__auto___11971 \x3d cljs.core.chunk_first(seq__11920_11970__$1);\nvar G__11972 \x3d cljs.core.chunk_rest(seq__11920_11970__$1);\nvar G__11973 \x3d c__4550__auto___11971;\nvar G__11974 \x3d cljs.core.count(c__4550__auto___11971);\nvar G__11975 \x3d (0);\nseq__11920_11955 \x3d G__11972;\nchunk__11921_11956 \x3d G__11973;\ncount__11922_11957 \x3d G__11974;\ni__11923_11958 \x3d G__11975;\ncontinue;\n} else {\nvar vec__11942_11976 \x3d cljs.core.first(seq__11920_11970__$1);\nvar k_11977 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11942_11976,(0),null);\nvar v_11978 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11942_11976,(1),null);\nvar G__11945_11979 \x3d m;\nvar G__11946_11980 \x3d keyfn(k_11977);\nvar G__11947_11981 \x3d cljs$core$thisfn(v_11978);\ngoog.object.set(G__11945_11979,G__11946_11980,G__11947_11981);\n\n\nvar G__11982 \x3d cljs.core.next(seq__11920_11970__$1);\nvar G__11983 \x3d null;\nvar G__11984 \x3d (0);\nvar G__11985 \x3d (0);\nseq__11920_11955 \x3d G__11982;\nchunk__11921_11956 \x3d G__11983;\ncount__11922_11957 \x3d G__11984;\ni__11923_11958 \x3d G__11985;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn m;\n} else {\nif(cljs.core.coll_QMARK_(x__$1)){\nvar arr \x3d [];\nvar seq__11948_11986 \x3d cljs.core.seq(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs$core$thisfn,x__$1));\nvar chunk__11949_11987 \x3d null;\nvar count__11950_11988 \x3d (0);\nvar i__11951_11989 \x3d (0);\nwhile(true){\nif((i__11951_11989 \x3c count__11950_11988)){\nvar x_11990__$2 \x3d chunk__11949_11987.cljs$core$IIndexed$_nth$arity$2(null,i__11951_11989);\narr.push(x_11990__$2);\n\n\nvar G__11991 \x3d seq__11948_11986;\nvar G__11992 \x3d chunk__11949_11987;\nvar G__11993 \x3d count__11950_11988;\nvar G__11994 \x3d (i__11951_11989 + (1));\nseq__11948_11986 \x3d G__11991;\nchunk__11949_11987 \x3d G__11992;\ncount__11950_11988 \x3d G__11993;\ni__11951_11989 \x3d G__11994;\ncontinue;\n} else {\nvar temp__5720__auto___11995 \x3d cljs.core.seq(seq__11948_11986);\nif(temp__5720__auto___11995){\nvar seq__11948_11996__$1 \x3d temp__5720__auto___11995;\nif(cljs.core.chunked_seq_QMARK_(seq__11948_11996__$1)){\nvar c__4550__auto___11997 \x3d cljs.core.chunk_first(seq__11948_11996__$1);\nvar G__11998 \x3d cljs.core.chunk_rest(seq__11948_11996__$1);\nvar G__11999 \x3d c__4550__auto___11997;\nvar G__12000 \x3d cljs.core.count(c__4550__auto___11997);\nvar G__12001 \x3d (0);\nseq__11948_11986 \x3d G__11998;\nchunk__11949_11987 \x3d G__11999;\ncount__11950_11988 \x3d G__12000;\ni__11951_11989 \x3d G__12001;\ncontinue;\n} else {\nvar x_12002__$2 \x3d cljs.core.first(seq__11948_11996__$1);\narr.push(x_12002__$2);\n\n\nvar G__12003 \x3d cljs.core.next(seq__11948_11996__$1);\nvar G__12004 \x3d null;\nvar G__12005 \x3d (0);\nvar G__12006 \x3d (0);\nseq__11948_11986 \x3d G__12003;\nchunk__11949_11987 \x3d G__12004;\ncount__11950_11988 \x3d G__12005;\ni__11951_11989 \x3d G__12006;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn arr;\n} else {\nreturn x__$1;\n\n}\n}\n}\n}\n}\n}\n});})(map__11880,map__11880__$1,options,keyword_fn))\n;\nreturn thisfn(x);\n});\n\ncljs.core.clj__GT_js.cljs$lang$maxFixedArity \x3d (1);\n\n/** @this {Function} */\ncljs.core.clj__GT_js.cljs$lang$applyTo \x3d (function (seq11877){\nvar G__11878 \x3d cljs.core.first(seq11877);\nvar seq11877__$1 \x3d cljs.core.next(seq11877);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11878,seq11877__$1);\n});\n\n\n/**\n * @interface\n */\ncljs.core.IEncodeClojure \x3d function(){};\n\n/**\n * Transforms JavaScript values to Clojure\n */\ncljs.core._js__GT_clj \x3d (function cljs$core$_js__GT_clj(x,options){\nif((((!((x \x3d\x3d null)))) \x26\x26 ((!((x.cljs$core$IEncodeClojure$_js__GT_clj$arity$2 \x3d\x3d null)))))){\nreturn x.cljs$core$IEncodeClojure$_js__GT_clj$arity$2(x,options);\n} else {\nvar x__4433__auto__ \x3d (((x \x3d\x3d null))?null:x);\nvar m__4434__auto__ \x3d (cljs.core._js__GT_clj[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(x,options) : m__4434__auto__.call(null,x,options));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._js__GT_clj["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(x,options) : m__4431__auto__.call(null,x,options));\n} else {\nthrow cljs.core.missing_protocol("IEncodeClojure.-js-\x3eclj",x);\n}\n}\n}\n});\n\n/**\n * Recursively transforms JavaScript arrays into ClojureScript\n *   vectors, and JavaScript objects into ClojureScript maps.  With\n *   option \':keywordize-keys true\' will convert object fields from\n *   strings to keywords.\n */\ncljs.core.js__GT_clj \x3d (function cljs$core$js__GT_clj(var_args){\nvar G__12012 \x3d arguments.length;\nswitch (G__12012) {\ncase 1:\nreturn cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___12017 \x3d arguments.length;\nvar i__4731__auto___12018 \x3d (0);\nwhile(true){\nif((i__4731__auto___12018 \x3c len__4730__auto___12017)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___12018]));\n\nvar G__12019 \x3d (i__4731__auto___12018 + (1));\ni__4731__auto___12018 \x3d G__12019;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$1 \x3d (function (x){\nreturn cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$variadic(x,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.cst$kw$keywordize_DASH_keys,false], 0));\n});\n\ncljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$variadic \x3d (function (x,opts){\nvar map__12013 \x3d opts;\nvar map__12013__$1 \x3d (((((!((map__12013 \x3d\x3d null))))?(((((map__12013.cljs$lang$protocol_mask$partition0$ \x26 (64))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d map__12013.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__12013):map__12013);\nvar keywordize_keys \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__12013__$1,cljs.core.cst$kw$keywordize_DASH_keys);\nvar keyfn \x3d (cljs.core.truth_(keywordize_keys)?cljs.core.keyword:cljs.core.str);\nvar f \x3d ((function (map__12013,map__12013__$1,keywordize_keys,keyfn){\nreturn (function cljs$core$thisfn(x__$1){\nif((((!((x__$1 \x3d\x3d null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x__$1.cljs$core$IEncodeClojure$))))?true:(((!x__$1.cljs$lang$protocol_mask$partition$))?cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeClojure,x__$1):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeClojure,x__$1))){\nreturn cljs.core._js__GT_clj(x__$1,cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.array_map,opts));\n} else {\nif(cljs.core.seq_QMARK_(x__$1)){\nreturn cljs.core.doall.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs$core$thisfn,x__$1));\n} else {\nif(cljs.core.map_entry_QMARK_(x__$1)){\nreturn (new cljs.core.MapEntry(cljs$core$thisfn(cljs.core.key(x__$1)),cljs$core$thisfn(cljs.core.val(x__$1)),null));\n} else {\nif(cljs.core.coll_QMARK_(x__$1)){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.empty(x__$1),cljs.core.map.cljs$core$IFn$_invoke$arity$1(cljs$core$thisfn),x__$1);\n} else {\nif(cljs.core.array_QMARK_(x__$1)){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (map__12013,map__12013__$1,keywordize_keys,keyfn){\nreturn (function (p1__12007_SHARP_,p2__12008_SHARP_){\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(p1__12007_SHARP_,cljs$core$thisfn(p2__12008_SHARP_));\n});})(map__12013,map__12013__$1,keywordize_keys,keyfn))\n,cljs.core.transient$(cljs.core.PersistentVector.EMPTY),x__$1));\n} else {\nif((cljs.core.type(x__$1) \x3d\x3d\x3d Object)){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (map__12013,map__12013__$1,keywordize_keys,keyfn){\nreturn (function (r,k){\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(r,(keyfn.cljs$core$IFn$_invoke$arity$1 ? keyfn.cljs$core$IFn$_invoke$arity$1(k) : keyfn.call(null,k)),cljs$core$thisfn(goog.object.get(x__$1,k)));\n});})(map__12013,map__12013__$1,keywordize_keys,keyfn))\n,cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY),cljs.core.js_keys(x__$1)));\n} else {\nreturn x__$1;\n\n}\n}\n}\n}\n}\n}\n});})(map__12013,map__12013__$1,keywordize_keys,keyfn))\n;\nreturn f(x);\n});\n\n/** @this {Function} */\ncljs.core.js__GT_clj.cljs$lang$applyTo \x3d (function (seq12010){\nvar G__12011 \x3d cljs.core.first(seq12010);\nvar seq12010__$1 \x3d cljs.core.next(seq12010);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__12011,seq12010__$1);\n});\n\ncljs.core.js__GT_clj.cljs$lang$maxFixedArity \x3d (1);\n\n/**\n * Returns a memoized version of a referentially transparent function. The\n *   memoized version of the function keeps a cache of the mapping from arguments\n *   to results and, when calls with the same arguments are repeated often, has\n *   higher performance at the expense of higher memory use.\n */\ncljs.core.memoize \x3d (function cljs$core$memoize(f){\nvar mem \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nreturn ((function (mem){\nreturn (function() { \nvar G__12020__delegate \x3d function (args){\nvar v \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$3(cljs.core.deref(mem),args,cljs.core.lookup_sentinel);\nif((v \x3d\x3d\x3d cljs.core.lookup_sentinel)){\nvar ret \x3d cljs.core.apply.cljs$core$IFn$_invoke$arity$2(f,args);\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(mem,cljs.core.assoc,args,ret);\n\nreturn ret;\n} else {\nreturn v;\n}\n};\nvar G__12020 \x3d function (var_args){\nvar args \x3d null;\nif (arguments.length \x3e 0) {\nvar G__12021__i \x3d 0, G__12021__a \x3d new Array(arguments.length -  0);\nwhile (G__12021__i \x3c G__12021__a.length) {G__12021__a[G__12021__i] \x3d arguments[G__12021__i + 0]; ++G__12021__i;}\n  args \x3d new cljs.core.IndexedSeq(G__12021__a,0,null);\n} \nreturn G__12020__delegate.call(this,args);};\nG__12020.cljs$lang$maxFixedArity \x3d 0;\nG__12020.cljs$lang$applyTo \x3d (function (arglist__12022){\nvar args \x3d cljs.core.seq(arglist__12022);\nreturn G__12020__delegate(args);\n});\nG__12020.cljs$core$IFn$_invoke$arity$variadic \x3d G__12020__delegate;\nreturn G__12020;\n})()\n;\n;})(mem))\n});\n/**\n * trampoline can be used to convert algorithms requiring mutual\n *   recursion without stack consumption. Calls f with supplied args, if\n *   any. If f returns a fn, calls that fn with no arguments, and\n *   continues to repeat, until the return value is not a fn, then\n *   returns that non-fn value. Note that if you want to return a fn as a\n *   final value, you must wrap it in some data structure and unpack it\n *   after trampoline returns.\n */\ncljs.core.trampoline \x3d (function cljs$core$trampoline(var_args){\nvar G__12026 \x3d arguments.length;\nswitch (G__12026) {\ncase 1:\nreturn cljs.core.trampoline.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ \x3d [];\nvar len__4730__auto___12028 \x3d arguments.length;\nvar i__4731__auto___12029 \x3d (0);\nwhile(true){\nif((i__4731__auto___12029 \x3c len__4730__auto___12028)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___12029]));\n\nvar G__12030 \x3d (i__4731__auto___12029 + (1));\ni__4731__auto___12029 \x3d G__12030;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ \x3d (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.trampoline.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.trampoline.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nwhile(true){\nvar ret \x3d (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\nif(cljs.core.fn_QMARK_(ret)){\nvar G__12031 \x3d ret;\nf \x3d G__12031;\ncontinue;\n} else {\nreturn ret;\n}\nbreak;\n}\n});\n\ncljs.core.trampoline.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,args){\nreturn cljs.core.trampoline.cljs$core$IFn$_invoke$arity$1((function (){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(f,args);\n}));\n});\n\n/** @this {Function} */\ncljs.core.trampoline.cljs$lang$applyTo \x3d (function (seq12024){\nvar G__12025 \x3d cljs.core.first(seq12024);\nvar seq12024__$1 \x3d cljs.core.next(seq12024);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__12025,seq12024__$1);\n});\n\ncljs.core.trampoline.cljs$lang$maxFixedArity \x3d (1);\n\n/**\n * Returns a random floating point number between 0 (inclusive) and\n *   n (default 1) (exclusive).\n */\ncljs.core.rand \x3d (function cljs$core$rand(var_args){\nvar G__12033 \x3d arguments.length;\nswitch (G__12033) {\ncase 0:\nreturn cljs.core.rand.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.rand.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.rand.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.rand.cljs$core$IFn$_invoke$arity$1((1));\n});\n\ncljs.core.rand.cljs$core$IFn$_invoke$arity$1 \x3d (function (n){\nreturn (Math.random() * n);\n});\n\ncljs.core.rand.cljs$lang$maxFixedArity \x3d 1;\n\n/**\n * Returns a random integer between 0 (inclusive) and n (exclusive).\n */\ncljs.core.rand_int \x3d (function cljs$core$rand_int(n){\nvar G__12035 \x3d (Math.random() * n);\nreturn Math.floor(G__12035);\n});\n/**\n * Return a random element of the (sequential) collection. Will have\n *   the same performance characteristics as nth for the given\n *   collection.\n */\ncljs.core.rand_nth \x3d (function cljs$core$rand_nth(coll){\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2(coll,cljs.core.rand_int(cljs.core.count(coll)));\n});\n/**\n * Returns a map of the elements of coll keyed by the result of\n *   f on each element. The value at each key will be a vector of the\n *   corresponding elements, in the order they appeared in coll.\n */\ncljs.core.group_by \x3d (function cljs$core$group_by(f,coll){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (ret,x){\nvar k \x3d (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x));\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(ret,k,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(ret,k,cljs.core.PersistentVector.EMPTY),x));\n}),cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY),coll));\n});\n/**\n * Creates a hierarchy object for use with derive, isa? etc.\n */\ncljs.core.make_hierarchy \x3d (function cljs$core$make_hierarchy(){\nreturn new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$parents,cljs.core.PersistentArrayMap.EMPTY,cljs.core.cst$kw$descendants,cljs.core.PersistentArrayMap.EMPTY,cljs.core.cst$kw$ancestors,cljs.core.PersistentArrayMap.EMPTY], null);\n});\n/**\n * @type {*}\n */\ncljs.core._global_hierarchy \x3d null;\ncljs.core.get_global_hierarchy \x3d (function cljs$core$get_global_hierarchy(){\nif((cljs.core._global_hierarchy \x3d\x3d null)){\ncljs.core._global_hierarchy \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.make_hierarchy());\n} else {\n}\n\nreturn cljs.core._global_hierarchy;\n});\ncljs.core.swap_global_hierarchy_BANG_ \x3d (function cljs$core$swap_global_hierarchy_BANG_(var_args){\nvar args__4736__auto__ \x3d [];\nvar len__4730__auto___12038 \x3d arguments.length;\nvar i__4731__auto___12039 \x3d (0);\nwhile(true){\nif((i__4731__auto___12039 \x3c len__4730__auto___12038)){\nargs__4736__auto__.push((arguments[i__4731__auto___12039]));\n\nvar G__12040 \x3d (i__4731__auto___12039 + (1));\ni__4731__auto___12039 \x3d G__12040;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ \x3d ((((1) \x3c args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.swap_global_hierarchy_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.swap_global_hierarchy_BANG_.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core.swap_BANG_,cljs.core.get_global_hierarchy(),f,args);\n});\n\ncljs.core.swap_global_hierarchy_BANG_.cljs$lang$maxFixedArity \x3d (1);\n\n/** @this {Function} */\ncljs.core.swap_global_hierarchy_BANG_.cljs$lang$applyTo \x3d (function (seq12036){\nvar G__12037 \x3d cljs.core.first(seq12036);\nvar seq12036__$1 \x3d cljs.core.next(seq12036);\nvar self__4717__auto__ \x3d this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__12037,seq12036__$1);\n});\n\n/**\n * Returns true if (\x3d child parent), or child is directly or indirectly derived from\n *   parent, either via a JavaScript type inheritance relationship or a\n *   relationship established via derive. h must be a hierarchy obtained\n *   from make-hierarchy, if not supplied defaults to the global\n *   hierarchy\n */\ncljs.core.isa_QMARK_ \x3d (function cljs$core$isa_QMARK_(var_args){\nvar G__12042 \x3d arguments.length;\nswitch (G__12042) {\ncase 2:\nreturn cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$2 \x3d (function (child,parent){\nreturn cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3(cljs.core.deref(cljs.core.get_global_hierarchy()),child,parent);\n});\n\ncljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3 \x3d (function (h,child,parent){\nvar or__4131__auto__ \x3d cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(child,parent);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d cljs.core.contains_QMARK_((function (){var fexpr__12045 \x3d cljs.core.cst$kw$ancestors.cljs$core$IFn$_invoke$arity$1(h);\nreturn (fexpr__12045.cljs$core$IFn$_invoke$arity$1 ? fexpr__12045.cljs$core$IFn$_invoke$arity$1(child) : fexpr__12045.call(null,child));\n})(),parent);\nif(or__4131__auto____$1){\nreturn or__4131__auto____$1;\n} else {\nvar and__4120__auto__ \x3d cljs.core.vector_QMARK_(parent);\nif(and__4120__auto__){\nvar and__4120__auto____$1 \x3d cljs.core.vector_QMARK_(child);\nif(and__4120__auto____$1){\nvar and__4120__auto____$2 \x3d (cljs.core.count(parent) \x3d\x3d\x3d cljs.core.count(child));\nif(and__4120__auto____$2){\nvar ret \x3d true;\nvar i \x3d (0);\nwhile(true){\nif((((!(ret))) || ((i \x3d\x3d\x3d cljs.core.count(parent))))){\nreturn ret;\n} else {\nvar G__12047 \x3d cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3(h,(child.cljs$core$IFn$_invoke$arity$1 ? child.cljs$core$IFn$_invoke$arity$1(i) : child.call(null,i)),(parent.cljs$core$IFn$_invoke$arity$1 ? parent.cljs$core$IFn$_invoke$arity$1(i) : parent.call(null,i)));\nvar G__12048 \x3d (i + (1));\nret \x3d G__12047;\ni \x3d G__12048;\ncontinue;\n}\nbreak;\n}\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n}\n}\n});\n\ncljs.core.isa_QMARK_.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Returns the immediate parents of tag, either via a JavaScript type\n *   inheritance relationship or a relationship established via derive. h\n *   must be a hierarchy obtained from make-hierarchy, if not supplied\n *   defaults to the global hierarchy\n */\ncljs.core.parents \x3d (function cljs$core$parents(var_args){\nvar G__12050 \x3d arguments.length;\nswitch (G__12050) {\ncase 1:\nreturn cljs.core.parents.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.parents.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.parents.cljs$core$IFn$_invoke$arity$1 \x3d (function (tag){\nreturn cljs.core.parents.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.get_global_hierarchy()),tag);\n});\n\ncljs.core.parents.cljs$core$IFn$_invoke$arity$2 \x3d (function (h,tag){\nreturn cljs.core.not_empty(cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.cst$kw$parents.cljs$core$IFn$_invoke$arity$1(h),tag));\n});\n\ncljs.core.parents.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns the immediate and indirect parents of tag, either via a JavaScript type\n *   inheritance relationship or a relationship established via derive. h\n *   must be a hierarchy obtained from make-hierarchy, if not supplied\n *   defaults to the global hierarchy\n */\ncljs.core.ancestors \x3d (function cljs$core$ancestors(var_args){\nvar G__12053 \x3d arguments.length;\nswitch (G__12053) {\ncase 1:\nreturn cljs.core.ancestors.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.ancestors.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.ancestors.cljs$core$IFn$_invoke$arity$1 \x3d (function (tag){\nreturn cljs.core.ancestors.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.get_global_hierarchy()),tag);\n});\n\ncljs.core.ancestors.cljs$core$IFn$_invoke$arity$2 \x3d (function (h,tag){\nreturn cljs.core.not_empty(cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.cst$kw$ancestors.cljs$core$IFn$_invoke$arity$1(h),tag));\n});\n\ncljs.core.ancestors.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns the immediate and indirect children of tag, through a\n *   relationship established via derive. h must be a hierarchy obtained\n *   from make-hierarchy, if not supplied defaults to the global\n *   hierarchy. Note: does not work on JavaScript type inheritance\n *   relationships.\n */\ncljs.core.descendants \x3d (function cljs$core$descendants(var_args){\nvar G__12056 \x3d arguments.length;\nswitch (G__12056) {\ncase 1:\nreturn cljs.core.descendants.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.descendants.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.descendants.cljs$core$IFn$_invoke$arity$1 \x3d (function (tag){\nreturn cljs.core.descendants.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.get_global_hierarchy()),tag);\n});\n\ncljs.core.descendants.cljs$core$IFn$_invoke$arity$2 \x3d (function (h,tag){\nreturn cljs.core.not_empty(cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.cst$kw$descendants.cljs$core$IFn$_invoke$arity$1(h),tag));\n});\n\ncljs.core.descendants.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Establishes a parent/child relationship between parent and\n *   tag. Parent must be a namespace-qualified symbol or keyword and\n *   child can be either a namespace-qualified symbol or keyword or a\n *   class. h must be a hierarchy obtained from make-hierarchy, if not\n *   supplied defaults to, and modifies, the global hierarchy.\n */\ncljs.core.derive \x3d (function cljs$core$derive(var_args){\nvar G__12059 \x3d arguments.length;\nswitch (G__12059) {\ncase 2:\nreturn cljs.core.derive.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.derive.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.derive.cljs$core$IFn$_invoke$arity$2 \x3d (function (tag,parent){\nif(cljs.core.truth_(cljs.core.namespace(parent))){\n} else {\nthrow (new Error("Assert failed: (namespace parent)"));\n}\n\ncljs.core.swap_global_hierarchy_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.derive,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([tag,parent], 0));\n\nreturn null;\n});\n\ncljs.core.derive.cljs$core$IFn$_invoke$arity$3 \x3d (function (h,tag,parent){\nif(cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(tag,parent)){\n} else {\nthrow (new Error("Assert failed: (not\x3d tag parent)"));\n}\n\nvar tp \x3d cljs.core.cst$kw$parents.cljs$core$IFn$_invoke$arity$1(h);\nvar td \x3d cljs.core.cst$kw$descendants.cljs$core$IFn$_invoke$arity$1(h);\nvar ta \x3d cljs.core.cst$kw$ancestors.cljs$core$IFn$_invoke$arity$1(h);\nvar tf \x3d ((function (tp,td,ta){\nreturn (function (m,source,sources,target,targets){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (tp,td,ta){\nreturn (function (ret,k){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(ret,k,cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,cljs.core.get.cljs$core$IFn$_invoke$arity$3(targets,k,cljs.core.PersistentHashSet.EMPTY),cljs.core.cons(target,(targets.cljs$core$IFn$_invoke$arity$1 ? targets.cljs$core$IFn$_invoke$arity$1(target) : targets.call(null,target)))));\n});})(tp,td,ta))\n,m,cljs.core.cons(source,(sources.cljs$core$IFn$_invoke$arity$1 ? sources.cljs$core$IFn$_invoke$arity$1(source) : sources.call(null,source))));\n});})(tp,td,ta))\n;\nvar or__4131__auto__ \x3d ((cljs.core.contains_QMARK_((tp.cljs$core$IFn$_invoke$arity$1 ? tp.cljs$core$IFn$_invoke$arity$1(tag) : tp.call(null,tag)),parent))?null:(function (){\nif(cljs.core.contains_QMARK_((ta.cljs$core$IFn$_invoke$arity$1 ? ta.cljs$core$IFn$_invoke$arity$1(tag) : ta.call(null,tag)),parent)){\nthrow (new Error([cljs.core.str.cljs$core$IFn$_invoke$arity$1(tag),"already has",cljs.core.str.cljs$core$IFn$_invoke$arity$1(parent),"as ancestor"].join(\'\')));\n} else {\n}\n\nif(cljs.core.contains_QMARK_((ta.cljs$core$IFn$_invoke$arity$1 ? ta.cljs$core$IFn$_invoke$arity$1(parent) : ta.call(null,parent)),tag)){\nthrow (new Error(["Cyclic derivation:",cljs.core.str.cljs$core$IFn$_invoke$arity$1(parent),"has",cljs.core.str.cljs$core$IFn$_invoke$arity$1(tag),"as ancestor"].join(\'\')));\n} else {\n}\n\nreturn new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$parents,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.cst$kw$parents.cljs$core$IFn$_invoke$arity$1(h),tag,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(tp,tag,cljs.core.PersistentHashSet.EMPTY),parent)),cljs.core.cst$kw$ancestors,tf(cljs.core.cst$kw$ancestors.cljs$core$IFn$_invoke$arity$1(h),tag,td,parent,ta),cljs.core.cst$kw$descendants,tf(cljs.core.cst$kw$descendants.cljs$core$IFn$_invoke$arity$1(h),parent,ta,tag,td)], null);\n})()\n);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn h;\n}\n});\n\ncljs.core.derive.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Removes a parent/child relationship between parent and\n *   tag. h must be a hierarchy obtained from make-hierarchy, if not\n *   supplied defaults to, and modifies, the global hierarchy.\n */\ncljs.core.underive \x3d (function cljs$core$underive(var_args){\nvar G__12065 \x3d arguments.length;\nswitch (G__12065) {\ncase 2:\nreturn cljs.core.underive.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.underive.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.underive.cljs$core$IFn$_invoke$arity$2 \x3d (function (tag,parent){\ncljs.core.swap_global_hierarchy_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.underive,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([tag,parent], 0));\n\nreturn null;\n});\n\ncljs.core.underive.cljs$core$IFn$_invoke$arity$3 \x3d (function (h,tag,parent){\nvar parentMap \x3d cljs.core.cst$kw$parents.cljs$core$IFn$_invoke$arity$1(h);\nvar childsParents \x3d (cljs.core.truth_((parentMap.cljs$core$IFn$_invoke$arity$1 ? parentMap.cljs$core$IFn$_invoke$arity$1(tag) : parentMap.call(null,tag)))?cljs.core.disj.cljs$core$IFn$_invoke$arity$2((parentMap.cljs$core$IFn$_invoke$arity$1 ? parentMap.cljs$core$IFn$_invoke$arity$1(tag) : parentMap.call(null,tag)),parent):cljs.core.PersistentHashSet.EMPTY);\nvar newParents \x3d (cljs.core.truth_(cljs.core.not_empty(childsParents))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(parentMap,tag,childsParents):cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(parentMap,tag));\nvar deriv_seq \x3d cljs.core.flatten(cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (parentMap,childsParents,newParents){\nreturn (function (p1__12061_SHARP_){\nreturn cljs.core.cons(cljs.core.first(p1__12061_SHARP_),cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p1__12061_SHARP_),cljs.core.second(p1__12061_SHARP_)));\n});})(parentMap,childsParents,newParents))\n,cljs.core.seq(newParents)));\nif(cljs.core.contains_QMARK_((parentMap.cljs$core$IFn$_invoke$arity$1 ? parentMap.cljs$core$IFn$_invoke$arity$1(tag) : parentMap.call(null,tag)),parent)){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (parentMap,childsParents,newParents,deriv_seq){\nreturn (function (p1__12062_SHARP_,p2__12063_SHARP_){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.derive,p1__12062_SHARP_,p2__12063_SHARP_);\n});})(parentMap,childsParents,newParents,deriv_seq))\n,cljs.core.make_hierarchy(),cljs.core.partition.cljs$core$IFn$_invoke$arity$2((2),deriv_seq));\n} else {\nreturn h;\n}\n});\n\ncljs.core.underive.cljs$lang$maxFixedArity \x3d 3;\n\ncljs.core.reset_cache \x3d (function cljs$core$reset_cache(method_cache,method_table,cached_hierarchy,hierarchy){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(method_cache,(function (_){\nreturn cljs.core.deref(method_table);\n}));\n\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(cached_hierarchy,(function (_){\nreturn cljs.core.deref(hierarchy);\n}));\n});\ncljs.core.prefers_STAR_ \x3d (function cljs$core$prefers_STAR_(x,y,prefer_table){\nvar xprefs \x3d (function (){var fexpr__12067 \x3d cljs.core.deref(prefer_table);\nreturn (fexpr__12067.cljs$core$IFn$_invoke$arity$1 ? fexpr__12067.cljs$core$IFn$_invoke$arity$1(x) : fexpr__12067.call(null,x));\n})();\nvar or__4131__auto__ \x3d (cljs.core.truth_((function (){var and__4120__auto__ \x3d xprefs;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (xprefs.cljs$core$IFn$_invoke$arity$1 ? xprefs.cljs$core$IFn$_invoke$arity$1(y) : xprefs.call(null,y));\n} else {\nreturn and__4120__auto__;\n}\n})())?true:null);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 \x3d (function (){var ps \x3d cljs.core.parents.cljs$core$IFn$_invoke$arity$1(y);\nwhile(true){\nif((cljs.core.count(ps) \x3e (0))){\nif(cljs.core.truth_((function (){var G__12071 \x3d x;\nvar G__12072 \x3d cljs.core.first(ps);\nvar G__12073 \x3d prefer_table;\nreturn (cljs.core.prefers_STAR_.cljs$core$IFn$_invoke$arity$3 ? cljs.core.prefers_STAR_.cljs$core$IFn$_invoke$arity$3(G__12071,G__12072,G__12073) : cljs.core.prefers_STAR_.call(null,G__12071,G__12072,G__12073));\n})())){\n} else {\n}\n\nvar G__12080 \x3d cljs.core.rest(ps);\nps \x3d G__12080;\ncontinue;\n} else {\nreturn null;\n}\nbreak;\n}\n})();\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 \x3d (function (){var ps \x3d cljs.core.parents.cljs$core$IFn$_invoke$arity$1(x);\nwhile(true){\nif((cljs.core.count(ps) \x3e (0))){\nif(cljs.core.truth_((function (){var G__12077 \x3d cljs.core.first(ps);\nvar G__12078 \x3d y;\nvar G__12079 \x3d prefer_table;\nreturn (cljs.core.prefers_STAR_.cljs$core$IFn$_invoke$arity$3 ? cljs.core.prefers_STAR_.cljs$core$IFn$_invoke$arity$3(G__12077,G__12078,G__12079) : cljs.core.prefers_STAR_.call(null,G__12077,G__12078,G__12079));\n})())){\n} else {\n}\n\nvar G__12081 \x3d cljs.core.rest(ps);\nps \x3d G__12081;\ncontinue;\n} else {\nreturn null;\n}\nbreak;\n}\n})();\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nreturn false;\n}\n}\n}\n});\ncljs.core.dominates \x3d (function cljs$core$dominates(x,y,prefer_table,hierarchy){\nvar or__4131__auto__ \x3d cljs.core.prefers_STAR_(x,y,prefer_table);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3(hierarchy,x,y);\n}\n});\ncljs.core.find_and_cache_best_method \x3d (function cljs$core$find_and_cache_best_method(name,dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy,default_dispatch_val){\nvar best_entry \x3d cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (be,p__12082){\nvar vec__12083 \x3d p__12082;\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__12083,(0),null);\nvar _ \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__12083,(1),null);\nvar e \x3d vec__12083;\nif(cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3(cljs.core.deref(hierarchy),dispatch_val,k)){\nvar be2 \x3d (((((be \x3d\x3d null)) || (cljs.core.dominates(k,cljs.core.first(be),prefer_table,cljs.core.deref(hierarchy)))))?e:be);\nif(cljs.core.dominates(cljs.core.first(be2),k,prefer_table,cljs.core.deref(hierarchy))){\n} else {\nthrow (new Error(["Multiple methods in multimethod \'",cljs.core.str.cljs$core$IFn$_invoke$arity$1(name),"\' match dispatch value: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(dispatch_val)," -\x3e ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(k)," and ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(be2)),", and neither is preferred"].join(\'\')));\n}\n\nreturn be2;\n} else {\nreturn be;\n}\n}),null,cljs.core.deref(method_table));\nvar best_entry__$1 \x3d (function (){var temp__5718__auto__ \x3d (function (){var and__4120__auto__ \x3d (best_entry \x3d\x3d null);\nif(and__4120__auto__){\nvar fexpr__12087 \x3d cljs.core.deref(method_table);\nreturn (fexpr__12087.cljs$core$IFn$_invoke$arity$1 ? fexpr__12087.cljs$core$IFn$_invoke$arity$1(default_dispatch_val) : fexpr__12087.call(null,default_dispatch_val));\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_(temp__5718__auto__)){\nvar entry \x3d temp__5718__auto__;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [default_dispatch_val,entry], null);\n} else {\nreturn best_entry;\n}\n})();\nif(cljs.core.truth_(best_entry__$1)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cached_hierarchy),cljs.core.deref(hierarchy))){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(method_cache,cljs.core.assoc,dispatch_val,cljs.core.second(best_entry__$1));\n\nreturn cljs.core.second(best_entry__$1);\n} else {\ncljs.core.reset_cache(method_cache,method_table,cached_hierarchy,hierarchy);\n\nreturn (cljs.core.find_and_cache_best_method.cljs$core$IFn$_invoke$arity$8 ? cljs.core.find_and_cache_best_method.cljs$core$IFn$_invoke$arity$8(name,dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy,default_dispatch_val) : cljs.core.find_and_cache_best_method.call(null,name,dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy,default_dispatch_val));\n}\n} else {\nreturn null;\n}\n});\n\n/**\n * @interface\n */\ncljs.core.IMultiFn \x3d function(){};\n\ncljs.core._reset \x3d (function cljs$core$_reset(mf){\nif((((!((mf \x3d\x3d null)))) \x26\x26 ((!((mf.cljs$core$IMultiFn$_reset$arity$1 \x3d\x3d null)))))){\nreturn mf.cljs$core$IMultiFn$_reset$arity$1(mf);\n} else {\nvar x__4433__auto__ \x3d (((mf \x3d\x3d null))?null:mf);\nvar m__4434__auto__ \x3d (cljs.core._reset[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._reset["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol("IMultiFn.-reset",mf);\n}\n}\n}\n});\n\ncljs.core._add_method \x3d (function cljs$core$_add_method(mf,dispatch_val,method){\nif((((!((mf \x3d\x3d null)))) \x26\x26 ((!((mf.cljs$core$IMultiFn$_add_method$arity$3 \x3d\x3d null)))))){\nreturn mf.cljs$core$IMultiFn$_add_method$arity$3(mf,dispatch_val,method);\n} else {\nvar x__4433__auto__ \x3d (((mf \x3d\x3d null))?null:mf);\nvar m__4434__auto__ \x3d (cljs.core._add_method[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(mf,dispatch_val,method) : m__4434__auto__.call(null,mf,dispatch_val,method));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._add_method["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(mf,dispatch_val,method) : m__4431__auto__.call(null,mf,dispatch_val,method));\n} else {\nthrow cljs.core.missing_protocol("IMultiFn.-add-method",mf);\n}\n}\n}\n});\n\ncljs.core._remove_method \x3d (function cljs$core$_remove_method(mf,dispatch_val){\nif((((!((mf \x3d\x3d null)))) \x26\x26 ((!((mf.cljs$core$IMultiFn$_remove_method$arity$2 \x3d\x3d null)))))){\nreturn mf.cljs$core$IMultiFn$_remove_method$arity$2(mf,dispatch_val);\n} else {\nvar x__4433__auto__ \x3d (((mf \x3d\x3d null))?null:mf);\nvar m__4434__auto__ \x3d (cljs.core._remove_method[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(mf,dispatch_val) : m__4434__auto__.call(null,mf,dispatch_val));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._remove_method["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(mf,dispatch_val) : m__4431__auto__.call(null,mf,dispatch_val));\n} else {\nthrow cljs.core.missing_protocol("IMultiFn.-remove-method",mf);\n}\n}\n}\n});\n\ncljs.core._prefer_method \x3d (function cljs$core$_prefer_method(mf,dispatch_val,dispatch_val_y){\nif((((!((mf \x3d\x3d null)))) \x26\x26 ((!((mf.cljs$core$IMultiFn$_prefer_method$arity$3 \x3d\x3d null)))))){\nreturn mf.cljs$core$IMultiFn$_prefer_method$arity$3(mf,dispatch_val,dispatch_val_y);\n} else {\nvar x__4433__auto__ \x3d (((mf \x3d\x3d null))?null:mf);\nvar m__4434__auto__ \x3d (cljs.core._prefer_method[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(mf,dispatch_val,dispatch_val_y) : m__4434__auto__.call(null,mf,dispatch_val,dispatch_val_y));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._prefer_method["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(mf,dispatch_val,dispatch_val_y) : m__4431__auto__.call(null,mf,dispatch_val,dispatch_val_y));\n} else {\nthrow cljs.core.missing_protocol("IMultiFn.-prefer-method",mf);\n}\n}\n}\n});\n\ncljs.core._get_method \x3d (function cljs$core$_get_method(mf,dispatch_val){\nif((((!((mf \x3d\x3d null)))) \x26\x26 ((!((mf.cljs$core$IMultiFn$_get_method$arity$2 \x3d\x3d null)))))){\nreturn mf.cljs$core$IMultiFn$_get_method$arity$2(mf,dispatch_val);\n} else {\nvar x__4433__auto__ \x3d (((mf \x3d\x3d null))?null:mf);\nvar m__4434__auto__ \x3d (cljs.core._get_method[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(mf,dispatch_val) : m__4434__auto__.call(null,mf,dispatch_val));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._get_method["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(mf,dispatch_val) : m__4431__auto__.call(null,mf,dispatch_val));\n} else {\nthrow cljs.core.missing_protocol("IMultiFn.-get-method",mf);\n}\n}\n}\n});\n\ncljs.core._methods \x3d (function cljs$core$_methods(mf){\nif((((!((mf \x3d\x3d null)))) \x26\x26 ((!((mf.cljs$core$IMultiFn$_methods$arity$1 \x3d\x3d null)))))){\nreturn mf.cljs$core$IMultiFn$_methods$arity$1(mf);\n} else {\nvar x__4433__auto__ \x3d (((mf \x3d\x3d null))?null:mf);\nvar m__4434__auto__ \x3d (cljs.core._methods[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._methods["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol("IMultiFn.-methods",mf);\n}\n}\n}\n});\n\ncljs.core._prefers \x3d (function cljs$core$_prefers(mf){\nif((((!((mf \x3d\x3d null)))) \x26\x26 ((!((mf.cljs$core$IMultiFn$_prefers$arity$1 \x3d\x3d null)))))){\nreturn mf.cljs$core$IMultiFn$_prefers$arity$1(mf);\n} else {\nvar x__4433__auto__ \x3d (((mf \x3d\x3d null))?null:mf);\nvar m__4434__auto__ \x3d (cljs.core._prefers[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._prefers["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol("IMultiFn.-prefers",mf);\n}\n}\n}\n});\n\ncljs.core._default_dispatch_val \x3d (function cljs$core$_default_dispatch_val(mf){\nif((((!((mf \x3d\x3d null)))) \x26\x26 ((!((mf.cljs$core$IMultiFn$_default_dispatch_val$arity$1 \x3d\x3d null)))))){\nreturn mf.cljs$core$IMultiFn$_default_dispatch_val$arity$1(mf);\n} else {\nvar x__4433__auto__ \x3d (((mf \x3d\x3d null))?null:mf);\nvar m__4434__auto__ \x3d (cljs.core._default_dispatch_val[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._default_dispatch_val["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol("IMultiFn.-default-dispatch-val",mf);\n}\n}\n}\n});\n\ncljs.core._dispatch_fn \x3d (function cljs$core$_dispatch_fn(mf){\nif((((!((mf \x3d\x3d null)))) \x26\x26 ((!((mf.cljs$core$IMultiFn$_dispatch_fn$arity$1 \x3d\x3d null)))))){\nreturn mf.cljs$core$IMultiFn$_dispatch_fn$arity$1(mf);\n} else {\nvar x__4433__auto__ \x3d (((mf \x3d\x3d null))?null:mf);\nvar m__4434__auto__ \x3d (cljs.core._dispatch_fn[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ \x3d\x3d null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ \x3d (cljs.core._dispatch_fn["_"]);\nif((!((m__4431__auto__ \x3d\x3d null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol("IMultiFn.-dispatch-fn",mf);\n}\n}\n}\n});\n\ncljs.core.throw_no_method_error \x3d (function cljs$core$throw_no_method_error(name,dispatch_val){\nthrow (new Error(["No method in multimethod \'",cljs.core.str.cljs$core$IFn$_invoke$arity$1(name),"\' for dispatch value: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(dispatch_val)].join(\'\')));\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.IMultiFn}\n * @implements {cljs.core.INamed}\n*/\ncljs.core.MultiFn \x3d (function (name,dispatch_fn,default_dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy){\nthis.name \x3d name;\nthis.dispatch_fn \x3d dispatch_fn;\nthis.default_dispatch_val \x3d default_dispatch_val;\nthis.hierarchy \x3d hierarchy;\nthis.method_table \x3d method_table;\nthis.prefer_table \x3d prefer_table;\nthis.method_cache \x3d method_cache;\nthis.cached_hierarchy \x3d cached_hierarchy;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 4194305;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 4352;\n});\ncljs.core.MultiFn.prototype.call \x3d (function() {\nvar G__12090 \x3d null;\nvar G__12090__1 \x3d (function (self__){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$0 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$0() : self__.dispatch_fn.call(null));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$0 ? target_fn.cljs$core$IFn$_invoke$arity$0() : target_fn.call(null));\n});\nvar G__12090__2 \x3d (function (self__,a){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$1 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$1(a) : self__.dispatch_fn.call(null,a));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$1 ? target_fn.cljs$core$IFn$_invoke$arity$1(a) : target_fn.call(null,a));\n});\nvar G__12090__3 \x3d (function (self__,a,b){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$2 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$2(a,b) : self__.dispatch_fn.call(null,a,b));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$2 ? target_fn.cljs$core$IFn$_invoke$arity$2(a,b) : target_fn.call(null,a,b));\n});\nvar G__12090__4 \x3d (function (self__,a,b,c){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$3 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$3(a,b,c) : self__.dispatch_fn.call(null,a,b,c));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$3 ? target_fn.cljs$core$IFn$_invoke$arity$3(a,b,c) : target_fn.call(null,a,b,c));\n});\nvar G__12090__5 \x3d (function (self__,a,b,c,d){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$4 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : self__.dispatch_fn.call(null,a,b,c,d));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$4 ? target_fn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : target_fn.call(null,a,b,c,d));\n});\nvar G__12090__6 \x3d (function (self__,a,b,c,d,e){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$5 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : self__.dispatch_fn.call(null,a,b,c,d,e));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$5 ? target_fn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : target_fn.call(null,a,b,c,d,e));\n});\nvar G__12090__7 \x3d (function (self__,a,b,c,d,e,f){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$6 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : self__.dispatch_fn.call(null,a,b,c,d,e,f));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$6 ? target_fn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : target_fn.call(null,a,b,c,d,e,f));\n});\nvar G__12090__8 \x3d (function (self__,a,b,c,d,e,f,g){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$7 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$7 ? target_fn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : target_fn.call(null,a,b,c,d,e,f,g));\n});\nvar G__12090__9 \x3d (function (self__,a,b,c,d,e,f,g,h){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$8 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$8 ? target_fn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : target_fn.call(null,a,b,c,d,e,f,g,h));\n});\nvar G__12090__10 \x3d (function (self__,a,b,c,d,e,f,g,h,i){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$9 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$9 ? target_fn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : target_fn.call(null,a,b,c,d,e,f,g,h,i));\n});\nvar G__12090__11 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$10 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$10 ? target_fn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j));\n});\nvar G__12090__12 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$11 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$11 ? target_fn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\nvar G__12090__13 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$12 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$12 ? target_fn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\nvar G__12090__14 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$13 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$13 ? target_fn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\nvar G__12090__15 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$14 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$14 ? target_fn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\nvar G__12090__16 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$15 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$15 ? target_fn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\nvar G__12090__17 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$16 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$16 ? target_fn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\nvar G__12090__18 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$17 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$17 ? target_fn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\nvar G__12090__19 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$18 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$18 ? target_fn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\nvar G__12090__20 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$19 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$19 ? target_fn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\nvar G__12090__21 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$20 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$20 ? target_fn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\nvar G__12090__22 \x3d (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nvar mf \x3d self____$1;\nvar dispatch_val \x3d cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(self__.dispatch_fn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(target_fn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\nG__12090 \x3d function(self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nswitch(arguments.length){\ncase 1:\nreturn G__12090__1.call(this,self__);\ncase 2:\nreturn G__12090__2.call(this,self__,a);\ncase 3:\nreturn G__12090__3.call(this,self__,a,b);\ncase 4:\nreturn G__12090__4.call(this,self__,a,b,c);\ncase 5:\nreturn G__12090__5.call(this,self__,a,b,c,d);\ncase 6:\nreturn G__12090__6.call(this,self__,a,b,c,d,e);\ncase 7:\nreturn G__12090__7.call(this,self__,a,b,c,d,e,f);\ncase 8:\nreturn G__12090__8.call(this,self__,a,b,c,d,e,f,g);\ncase 9:\nreturn G__12090__9.call(this,self__,a,b,c,d,e,f,g,h);\ncase 10:\nreturn G__12090__10.call(this,self__,a,b,c,d,e,f,g,h,i);\ncase 11:\nreturn G__12090__11.call(this,self__,a,b,c,d,e,f,g,h,i,j);\ncase 12:\nreturn G__12090__12.call(this,self__,a,b,c,d,e,f,g,h,i,j,k);\ncase 13:\nreturn G__12090__13.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l);\ncase 14:\nreturn G__12090__14.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m);\ncase 15:\nreturn G__12090__15.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n);\ncase 16:\nreturn G__12090__16.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);\ncase 17:\nreturn G__12090__17.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);\ncase 18:\nreturn G__12090__18.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);\ncase 19:\nreturn G__12090__19.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r);\ncase 20:\nreturn G__12090__20.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s);\ncase 21:\nreturn G__12090__21.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t);\ncase 22:\nreturn G__12090__22.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest);\n}\nthrow(new Error(\'Invalid arity: \' + (arguments.length - 1)));\n};\nG__12090.cljs$core$IFn$_invoke$arity$1 \x3d G__12090__1;\nG__12090.cljs$core$IFn$_invoke$arity$2 \x3d G__12090__2;\nG__12090.cljs$core$IFn$_invoke$arity$3 \x3d G__12090__3;\nG__12090.cljs$core$IFn$_invoke$arity$4 \x3d G__12090__4;\nG__12090.cljs$core$IFn$_invoke$arity$5 \x3d G__12090__5;\nG__12090.cljs$core$IFn$_invoke$arity$6 \x3d G__12090__6;\nG__12090.cljs$core$IFn$_invoke$arity$7 \x3d G__12090__7;\nG__12090.cljs$core$IFn$_invoke$arity$8 \x3d G__12090__8;\nG__12090.cljs$core$IFn$_invoke$arity$9 \x3d G__12090__9;\nG__12090.cljs$core$IFn$_invoke$arity$10 \x3d G__12090__10;\nG__12090.cljs$core$IFn$_invoke$arity$11 \x3d G__12090__11;\nG__12090.cljs$core$IFn$_invoke$arity$12 \x3d G__12090__12;\nG__12090.cljs$core$IFn$_invoke$arity$13 \x3d G__12090__13;\nG__12090.cljs$core$IFn$_invoke$arity$14 \x3d G__12090__14;\nG__12090.cljs$core$IFn$_invoke$arity$15 \x3d G__12090__15;\nG__12090.cljs$core$IFn$_invoke$arity$16 \x3d G__12090__16;\nG__12090.cljs$core$IFn$_invoke$arity$17 \x3d G__12090__17;\nG__12090.cljs$core$IFn$_invoke$arity$18 \x3d G__12090__18;\nG__12090.cljs$core$IFn$_invoke$arity$19 \x3d G__12090__19;\nG__12090.cljs$core$IFn$_invoke$arity$20 \x3d G__12090__20;\nG__12090.cljs$core$IFn$_invoke$arity$21 \x3d G__12090__21;\nG__12090.cljs$core$IFn$_invoke$arity$22 \x3d G__12090__22;\nreturn G__12090;\n})()\n;\n\ncljs.core.MultiFn.prototype.apply \x3d (function (self__,args12088){\nvar self__ \x3d this;\nvar self____$1 \x3d this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args12088)));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$0 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$0() : self__.dispatch_fn.call(null));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$0 ? target_fn.cljs$core$IFn$_invoke$arity$0() : target_fn.call(null));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$1 \x3d (function (a){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$1 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$1(a) : self__.dispatch_fn.call(null,a));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$1 ? target_fn.cljs$core$IFn$_invoke$arity$1(a) : target_fn.call(null,a));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$2 \x3d (function (a,b){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$2 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$2(a,b) : self__.dispatch_fn.call(null,a,b));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$2 ? target_fn.cljs$core$IFn$_invoke$arity$2(a,b) : target_fn.call(null,a,b));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$3 \x3d (function (a,b,c){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$3 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$3(a,b,c) : self__.dispatch_fn.call(null,a,b,c));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$3 ? target_fn.cljs$core$IFn$_invoke$arity$3(a,b,c) : target_fn.call(null,a,b,c));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$4 \x3d (function (a,b,c,d){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$4 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : self__.dispatch_fn.call(null,a,b,c,d));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$4 ? target_fn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : target_fn.call(null,a,b,c,d));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$5 \x3d (function (a,b,c,d,e){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$5 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : self__.dispatch_fn.call(null,a,b,c,d,e));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$5 ? target_fn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : target_fn.call(null,a,b,c,d,e));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$6 \x3d (function (a,b,c,d,e,f){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$6 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : self__.dispatch_fn.call(null,a,b,c,d,e,f));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$6 ? target_fn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : target_fn.call(null,a,b,c,d,e,f));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$7 \x3d (function (a,b,c,d,e,f,g){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$7 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$7 ? target_fn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : target_fn.call(null,a,b,c,d,e,f,g));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$8 \x3d (function (a,b,c,d,e,f,g,h){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$8 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$8 ? target_fn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : target_fn.call(null,a,b,c,d,e,f,g,h));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$9 \x3d (function (a,b,c,d,e,f,g,h,i){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$9 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$9 ? target_fn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : target_fn.call(null,a,b,c,d,e,f,g,h,i));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$10 \x3d (function (a,b,c,d,e,f,g,h,i,j){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$10 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$10 ? target_fn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$11 \x3d (function (a,b,c,d,e,f,g,h,i,j,k){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$11 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$11 ? target_fn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$12 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$12 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$12 ? target_fn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$13 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$13 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$13 ? target_fn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$14 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$14 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$14 ? target_fn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$15 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$15 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$15 ? target_fn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$16 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$16 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$16 ? target_fn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$17 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$17 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$17 ? target_fn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$18 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$18 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$18 ? target_fn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$19 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$19 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$19 ? target_fn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$20 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$20 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$20 ? target_fn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$21 \x3d (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ \x3d this;\nvar mf \x3d this;\nvar dispatch_val \x3d cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(self__.dispatch_fn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\nvar target_fn \x3d mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(target_fn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_prefer_method$arity$3 \x3d (function (mf,dispatch_val_x,dispatch_val_y){\nvar self__ \x3d this;\nvar mf__$1 \x3d this;\nif(cljs.core.truth_(cljs.core.prefers_STAR_(dispatch_val_x,dispatch_val_y,self__.prefer_table))){\nthrow (new Error(["Preference conflict in multimethod \'",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.name),"\': ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(dispatch_val_y)," is already preferred to ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(dispatch_val_x)].join(\'\')));\n} else {\n}\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.prefer_table,((function (mf__$1){\nreturn (function (old){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(old,dispatch_val_x,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(old,dispatch_val_x,cljs.core.PersistentHashSet.EMPTY),dispatch_val_y));\n});})(mf__$1))\n);\n\nreturn cljs.core.reset_cache(self__.method_cache,self__.method_table,self__.cached_hierarchy,self__.hierarchy);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_default_dispatch_val$arity$1 \x3d (function (mf){\nvar self__ \x3d this;\nvar mf__$1 \x3d this;\nreturn self__.default_dispatch_val;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_remove_method$arity$2 \x3d (function (mf,dispatch_val){\nvar self__ \x3d this;\nvar mf__$1 \x3d this;\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(self__.method_table,cljs.core.dissoc,dispatch_val);\n\ncljs.core.reset_cache(self__.method_cache,self__.method_table,self__.cached_hierarchy,self__.hierarchy);\n\nreturn mf__$1;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_methods$arity$1 \x3d (function (mf){\nvar self__ \x3d this;\nvar mf__$1 \x3d this;\nreturn cljs.core.deref(self__.method_table);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_prefers$arity$1 \x3d (function (mf){\nvar self__ \x3d this;\nvar mf__$1 \x3d this;\nreturn cljs.core.deref(self__.prefer_table);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_dispatch_fn$arity$1 \x3d (function (mf){\nvar self__ \x3d this;\nvar mf__$1 \x3d this;\nreturn self__.dispatch_fn;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_add_method$arity$3 \x3d (function (mf,dispatch_val,method){\nvar self__ \x3d this;\nvar mf__$1 \x3d this;\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(self__.method_table,cljs.core.assoc,dispatch_val,method);\n\ncljs.core.reset_cache(self__.method_cache,self__.method_table,self__.cached_hierarchy,self__.hierarchy);\n\nreturn mf__$1;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_reset$arity$1 \x3d (function (mf){\nvar self__ \x3d this;\nvar mf__$1 \x3d this;\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.method_table,((function (mf__$1){\nreturn (function (mf__$2){\nreturn cljs.core.PersistentArrayMap.EMPTY;\n});})(mf__$1))\n);\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.method_cache,((function (mf__$1){\nreturn (function (mf__$2){\nreturn cljs.core.PersistentArrayMap.EMPTY;\n});})(mf__$1))\n);\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.prefer_table,((function (mf__$1){\nreturn (function (mf__$2){\nreturn cljs.core.PersistentArrayMap.EMPTY;\n});})(mf__$1))\n);\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.cached_hierarchy,((function (mf__$1){\nreturn (function (mf__$2){\nreturn null;\n});})(mf__$1))\n);\n\nreturn mf__$1;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_get_method$arity$2 \x3d (function (mf,dispatch_val){\nvar self__ \x3d this;\nvar mf__$1 \x3d this;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(self__.cached_hierarchy),cljs.core.deref(self__.hierarchy))){\n} else {\ncljs.core.reset_cache(self__.method_cache,self__.method_table,self__.cached_hierarchy,self__.hierarchy);\n}\n\nvar temp__5718__auto__ \x3d (function (){var fexpr__12089 \x3d cljs.core.deref(self__.method_cache);\nreturn (fexpr__12089.cljs$core$IFn$_invoke$arity$1 ? fexpr__12089.cljs$core$IFn$_invoke$arity$1(dispatch_val) : fexpr__12089.call(null,dispatch_val));\n})();\nif(cljs.core.truth_(temp__5718__auto__)){\nvar target_fn \x3d temp__5718__auto__;\nreturn target_fn;\n} else {\nreturn cljs.core.find_and_cache_best_method(self__.name,dispatch_val,self__.hierarchy,self__.method_table,self__.prefer_table,self__.method_cache,self__.cached_hierarchy,self__.default_dispatch_val);\n}\n});\n\ncljs.core.MultiFn.prototype.cljs$core$INamed$_name$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn cljs.core._name(self__.name);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$INamed$_namespace$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn cljs.core._namespace(self__.name);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn goog.getUid(this$__$1);\n});\n\ncljs.core.MultiFn.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 8, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$name,cljs.core.cst$sym$dispatch_DASH_fn,cljs.core.cst$sym$default_DASH_dispatch_DASH_val,cljs.core.cst$sym$hierarchy,cljs.core.cst$sym$method_DASH_table,cljs.core.cst$sym$prefer_DASH_table,cljs.core.cst$sym$method_DASH_cache,cljs.core.cst$sym$cached_DASH_hierarchy], null);\n});\n\ncljs.core.MultiFn.cljs$lang$type \x3d true;\n\ncljs.core.MultiFn.cljs$lang$ctorStr \x3d "cljs.core/MultiFn";\n\ncljs.core.MultiFn.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/MultiFn");\n});\n\n/**\n * Positional factory function for cljs.core/MultiFn.\n */\ncljs.core.__GT_MultiFn \x3d (function cljs$core$__GT_MultiFn(name,dispatch_fn,default_dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy){\nreturn (new cljs.core.MultiFn(name,dispatch_fn,default_dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy));\n});\n\n/**\n * Removes all of the methods of multimethod.\n */\ncljs.core.remove_all_methods \x3d (function cljs$core$remove_all_methods(multifn){\nreturn cljs.core._reset(multifn);\n});\n/**\n * Removes the method of multimethod associated with dispatch-value.\n */\ncljs.core.remove_method \x3d (function cljs$core$remove_method(multifn,dispatch_val){\nreturn cljs.core._remove_method(multifn,dispatch_val);\n});\n/**\n * Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n * when there is a conflict\n */\ncljs.core.prefer_method \x3d (function cljs$core$prefer_method(multifn,dispatch_val_x,dispatch_val_y){\nreturn cljs.core._prefer_method(multifn,dispatch_val_x,dispatch_val_y);\n});\n/**\n * Given a multimethod, returns a map of dispatch values -\x3e dispatch fns\n */\ncljs.core.methods$ \x3d (function cljs$core$methods(multifn){\nreturn cljs.core._methods(multifn);\n});\n/**\n * Given a multimethod and a dispatch value, returns the dispatch fn\n *   that would apply to that value, or nil if none apply and no default\n */\ncljs.core.get_method \x3d (function cljs$core$get_method(multifn,dispatch_val){\nreturn cljs.core._get_method(multifn,dispatch_val);\n});\n/**\n * Given a multimethod, returns a map of preferred value -\x3e set of other values\n */\ncljs.core.prefers \x3d (function cljs$core$prefers(multifn){\nreturn cljs.core._prefers(multifn);\n});\n/**\n * Given a multimethod, return it\'s default-dispatch-val.\n */\ncljs.core.default_dispatch_val \x3d (function cljs$core$default_dispatch_val(multifn){\nreturn cljs.core._default_dispatch_val(multifn);\n});\n/**\n * Given a multimethod, return it\'s dispatch-fn.\n */\ncljs.core.dispatch_fn \x3d (function cljs$core$dispatch_fn(multifn){\nreturn cljs.core._dispatch_fn(multifn);\n});\n\n/**\n * A marker protocol for UUIDs\n * @interface\n */\ncljs.core.IUUID \x3d function(){};\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IComparable}\n * @implements {cljs.core.IUUID}\n*/\ncljs.core.UUID \x3d (function (uuid,__hash){\nthis.uuid \x3d uuid;\nthis.__hash \x3d __hash;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 2153775104;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 2048;\n});\ncljs.core.UUID.prototype.cljs$core$IUUID$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.UUID.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn self__.uuid;\n});\n\ncljs.core.UUID.prototype.equiv \x3d (function (other){\nvar self__ \x3d this;\nvar this$ \x3d this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.UUID.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (_,other){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (((other instanceof cljs.core.UUID)) \x26\x26 ((self__.uuid \x3d\x3d\x3d other.uuid)));\n});\n\ncljs.core.UUID.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (_,writer,___$1){\nvar self__ \x3d this;\nvar ___$2 \x3d this;\nreturn cljs.core._write(writer,["#uuid \\"",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.uuid),"\\""].join(\'\'));\n});\n\ncljs.core.UUID.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nif((self__.__hash \x3d\x3d null)){\nself__.__hash \x3d cljs.core.hash(self__.uuid);\n} else {\n}\n\nreturn self__.__hash;\n});\n\ncljs.core.UUID.prototype.cljs$core$IComparable$_compare$arity$2 \x3d (function (_,other){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nvar G__12091 \x3d self__.uuid;\nvar G__12092 \x3d other.uuid;\nreturn goog.array.defaultCompare(G__12091,G__12092);\n});\n\ncljs.core.UUID.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$uuid,cljs.core.with_meta(cljs.core.cst$sym$__hash,new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$mutable,true], null))], null);\n});\n\ncljs.core.UUID.cljs$lang$type \x3d true;\n\ncljs.core.UUID.cljs$lang$ctorStr \x3d "cljs.core/UUID";\n\ncljs.core.UUID.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/UUID");\n});\n\n/**\n * Positional factory function for cljs.core/UUID.\n */\ncljs.core.__GT_UUID \x3d (function cljs$core$__GT_UUID(uuid,__hash){\nreturn (new cljs.core.UUID(uuid,__hash));\n});\n\ncljs.core.uuid \x3d (function cljs$core$uuid(s){\nif(typeof s \x3d\x3d\x3d \'string\'){\n} else {\nthrow (new Error("Assert failed: (string? s)"));\n}\n\nreturn (new cljs.core.UUID(s.toLowerCase(),null));\n});\ncljs.core.random_uuid \x3d (function cljs$core$random_uuid(){\nvar hex \x3d (function cljs$core$random_uuid_$_hex(){\nreturn cljs.core.rand_int((16)).toString((16));\n});\nvar rhex \x3d ((8) | ((3) \x26 cljs.core.rand_int((16)))).toString((16));\nreturn cljs.core.uuid([cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),"-",cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),"-","4",cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),"-",cljs.core.str.cljs$core$IFn$_invoke$arity$1(rhex),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),"-",cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex())].join(\'\'));\n});\ncljs.core.uuid_QMARK_ \x3d (function cljs$core$uuid_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IUUID$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n});\ncljs.core.pr_writer_ex_info \x3d (function cljs$core$pr_writer_ex_info(obj,writer,opts){\ncljs.core._write(writer,"#error {:message ");\n\ncljs.core.pr_writer(obj.message,writer,opts);\n\nif(cljs.core.truth_(obj.data)){\ncljs.core._write(writer,", :data ");\n\ncljs.core.pr_writer(obj.data,writer,opts);\n} else {\n}\n\nif(cljs.core.truth_(obj.cause)){\ncljs.core._write(writer,", :cause ");\n\ncljs.core.pr_writer(obj.cause,writer,opts);\n} else {\n}\n\nreturn cljs.core._write(writer,"}");\n});\n/**\n * @constructor\n */\ncljs.core.ExceptionInfo \x3d (function cljs$core$ExceptionInfo(message,data,cause){\nvar e \x3d (new Error(message));\nvar this$ \x3d this;\nthis$.message \x3d message;\n\nthis$.data \x3d data;\n\nthis$.cause \x3d cause;\n\nthis$.name \x3d e.name;\n\nthis$.description \x3d e.description;\n\nthis$.number \x3d e.number;\n\nthis$.fileName \x3d e.fileName;\n\nthis$.lineNumber \x3d e.lineNumber;\n\nthis$.columnNumber \x3d e.columnNumber;\n\nthis$.stack \x3d e.stack;\n\nreturn this$;\n});\ncljs.core.ExceptionInfo.prototype.__proto__ \x3d Error.prototype;\ncljs.core.ExceptionInfo.prototype.cljs$core$IPrintWithWriter$ \x3d cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ExceptionInfo.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (obj,writer,opts){\nvar obj__$1 \x3d this;\nreturn cljs.core.pr_writer_ex_info(obj__$1,writer,opts);\n});\ncljs.core.ExceptionInfo.prototype.toString \x3d (function (){\nvar this$ \x3d this;\nreturn cljs.core.pr_str_STAR_(this$);\n});\n/**\n * Create an instance of ExceptionInfo, an Error type that carries a\n *   map of additional data.\n */\ncljs.core.ex_info \x3d (function cljs$core$ex_info(var_args){\nvar G__12095 \x3d arguments.length;\nswitch (G__12095) {\ncase 2:\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.ex_info.cljs$core$IFn$_invoke$arity$2 \x3d (function (msg,data){\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3(msg,data,null);\n});\n\ncljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 \x3d (function (msg,data,cause){\nreturn (new cljs.core.ExceptionInfo(msg,data,cause));\n});\n\ncljs.core.ex_info.cljs$lang$maxFixedArity \x3d 3;\n\n/**\n * Returns exception data (a map) if ex is an ExceptionInfo.\n *   Otherwise returns nil.\n */\ncljs.core.ex_data \x3d (function cljs$core$ex_data(ex){\nif((ex instanceof cljs.core.ExceptionInfo)){\nreturn ex.data;\n} else {\nreturn null;\n}\n});\n/**\n * Returns the message attached to the given Error / ExceptionInfo object.\n *   For non-Errors returns nil.\n */\ncljs.core.ex_message \x3d (function cljs$core$ex_message(ex){\nif((ex instanceof Error)){\nreturn ex.message;\n} else {\nreturn null;\n}\n});\n/**\n * Returns exception cause (an Error / ExceptionInfo) if ex is an\n *   ExceptionInfo.\n *   Otherwise returns nil.\n */\ncljs.core.ex_cause \x3d (function cljs$core$ex_cause(ex){\nif((ex instanceof cljs.core.ExceptionInfo)){\nreturn ex.cause;\n} else {\nreturn null;\n}\n});\n/**\n * Returns an JavaScript compatible comparator based upon pred.\n */\ncljs.core.comparator \x3d (function cljs$core$comparator(pred){\nreturn (function (x,y){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$2 ? pred.cljs$core$IFn$_invoke$arity$2(x,y) : pred.call(null,x,y)))){\nreturn (-1);\n} else {\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$2 ? pred.cljs$core$IFn$_invoke$arity$2(y,x) : pred.call(null,y,x)))){\nreturn (1);\n} else {\nreturn (0);\n\n}\n}\n});\n});\n/**\n * Returns true if x names a special form\n */\ncljs.core.special_symbol_QMARK_ \x3d (function cljs$core$special_symbol_QMARK_(x){\nreturn cljs.core.contains_QMARK_(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 24, [cljs.core.cst$sym$_AMPERSAND_,"null",cljs.core.cst$sym$case_STAR_,"null",cljs.core.cst$sym$defrecord_STAR_,"null",cljs.core.cst$sym$try,"null",cljs.core.cst$sym$ns_STAR_,"null",cljs.core.cst$sym$finally,"null",cljs.core.cst$sym$loop_STAR_,"null",cljs.core.cst$sym$do,"null",cljs.core.cst$sym$letfn_STAR_,"null",cljs.core.cst$sym$if,"null",cljs.core.cst$sym$new,"null",cljs.core.cst$sym$ns,"null",cljs.core.cst$sym$deftype_STAR_,"null",cljs.core.cst$sym$let_STAR_,"null",cljs.core.cst$sym$js_STAR_,"null",cljs.core.cst$sym$fn_STAR_,"null",cljs.core.cst$sym$recur,"null",cljs.core.cst$sym$set_BANG_,"null",cljs.core.cst$sym$_DOT_,"null",cljs.core.cst$sym$var,"null",cljs.core.cst$sym$quote,"null",cljs.core.cst$sym$catch,"null",cljs.core.cst$sym$throw,"null",cljs.core.cst$sym$def,"null"], null), null),x);\n});\n/**\n * test [v] finds fn at key :test in var metadata and calls it,\n *   presuming failure will throw exception\n */\ncljs.core.test \x3d (function cljs$core$test(v){\nvar f \x3d v.cljs$lang$test;\nif(cljs.core.truth_(f)){\n(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n\nreturn cljs.core.cst$kw$ok;\n} else {\nreturn cljs.core.cst$kw$no_DASH_test;\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TaggedLiteral \x3d (function (tag,form){\nthis.tag \x3d tag;\nthis.form \x3d form;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 2153775360;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.TaggedLiteral.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar coll \x3d this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (this$,other){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn (((other instanceof cljs.core.TaggedLiteral)) \x26\x26 (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(self__.tag,other.tag)) \x26\x26 (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(self__.form,other.form)));\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn (((31) * cljs.core.hash(self__.tag)) + cljs.core.hash(self__.form));\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$ILookup$_lookup$arity$2 \x3d (function (this$,v){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn this$__$1.cljs$core$ILookup$_lookup$arity$3(null,v,null);\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$ILookup$_lookup$arity$3 \x3d (function (this$,v,not_found){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nvar G__12097 \x3d v;\nvar G__12097__$1 \x3d (((G__12097 instanceof cljs.core.Keyword))?G__12097.fqn:null);\nswitch (G__12097__$1) {\ncase "tag":\nreturn self__.tag;\n\nbreak;\ncase "form":\nreturn self__.form;\n\nbreak;\ndefault:\nreturn not_found;\n\n}\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 \x3d (function (o,writer,opts){\nvar self__ \x3d this;\nvar o__$1 \x3d this;\ncljs.core._write(writer,["#",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.tag)," "].join(\'\'));\n\nreturn cljs.core.pr_writer(self__.form,writer,opts);\n});\n\ncljs.core.TaggedLiteral.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$tag,cljs.core.cst$sym$form], null);\n});\n\ncljs.core.TaggedLiteral.cljs$lang$type \x3d true;\n\ncljs.core.TaggedLiteral.cljs$lang$ctorStr \x3d "cljs.core/TaggedLiteral";\n\ncljs.core.TaggedLiteral.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/TaggedLiteral");\n});\n\n/**\n * Positional factory function for cljs.core/TaggedLiteral.\n */\ncljs.core.__GT_TaggedLiteral \x3d (function cljs$core$__GT_TaggedLiteral(tag,form){\nreturn (new cljs.core.TaggedLiteral(tag,form));\n});\n\n/**\n * Return true if the value is the data representation of a tagged literal\n */\ncljs.core.tagged_literal_QMARK_ \x3d (function cljs$core$tagged_literal_QMARK_(value){\nreturn (value instanceof cljs.core.TaggedLiteral);\n});\n/**\n * Construct a data representation of a tagged literal from a\n *   tag symbol and a form.\n */\ncljs.core.tagged_literal \x3d (function cljs$core$tagged_literal(tag,form){\nif((tag instanceof cljs.core.Symbol)){\n} else {\nthrow (new Error("Assert failed: (symbol? tag)"));\n}\n\nreturn (new cljs.core.TaggedLiteral(tag,form));\n});\n/**\n * @type {*}\n */\ncljs.core.js_reserved_arr \x3d ["arguments","abstract","await","boolean","break","byte","case","catch","char","class","const","continue","debugger","default","delete","do","double","else","enum","export","extends","final","finally","float","for","function","goto","if","implements","import","in","instanceof","int","interface","let","long","native","new","package","private","protected","public","return","short","static","super","switch","synchronized","this","throw","throws","transient","try","typeof","var","void","volatile","while","with","yield","methods","null","constructor"];\n/**\n * @type {null|Object}\n */\ncljs.core.js_reserved \x3d null;\ncljs.core.js_reserved_QMARK_ \x3d (function cljs$core$js_reserved_QMARK_(x){\nif((cljs.core.js_reserved \x3d\x3d null)){\ncljs.core.js_reserved \x3d cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__12099_SHARP_,p2__12100_SHARP_){\ngoog.object.set(p1__12099_SHARP_,p2__12100_SHARP_,true);\n\nreturn p1__12099_SHARP_;\n}),({}),cljs.core.js_reserved_arr);\n} else {\n}\n\nreturn cljs.core.js_reserved.hasOwnProperty(x);\n});\ncljs.core.demunge_pattern \x3d (function cljs$core$demunge_pattern(){\nif(cljs.core.truth_(cljs.core.DEMUNGE_PATTERN)){\n} else {\ncljs.core.DEMUNGE_PATTERN \x3d (function (){var ks \x3d cljs.core.sort.cljs$core$IFn$_invoke$arity$2((function (a,b){\nreturn (b.length - a.length);\n}),cljs.core.js_keys(cljs.core.DEMUNGE_MAP));\nvar ks__$1 \x3d ks;\nvar ret \x3d "";\nwhile(true){\nif(cljs.core.seq(ks__$1)){\nvar G__12103 \x3d cljs.core.next(ks__$1);\nvar G__12104 \x3d [(function (){var G__12102 \x3d ret;\nif((!((ret \x3d\x3d\x3d "")))){\nreturn [G__12102,"|"].join(\'\');\n} else {\nreturn G__12102;\n}\n})(),cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(ks__$1))].join(\'\');\nks__$1 \x3d G__12103;\nret \x3d G__12104;\ncontinue;\n} else {\nreturn [ret,"|\\\\$"].join(\'\');\n}\nbreak;\n}\n})();\n}\n\nreturn cljs.core.DEMUNGE_PATTERN;\n});\ncljs.core.munge_str \x3d (function cljs$core$munge_str(name){\nvar sb \x3d (new goog.string.StringBuffer());\nvar i_12105 \x3d (0);\nwhile(true){\nif((i_12105 \x3c name.length)){\nvar c_12106 \x3d name.charAt(i_12105);\nvar sub_12107 \x3d goog.object.get(cljs.core.CHAR_MAP,c_12106);\nif((!((sub_12107 \x3d\x3d null)))){\nsb.append(sub_12107);\n} else {\nsb.append(c_12106);\n}\n\nvar G__12108 \x3d (i_12105 + (1));\ni_12105 \x3d G__12108;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn sb.toString();\n});\ncljs.core.munge \x3d (function cljs$core$munge(name){\nvar name_SINGLEQUOTE_ \x3d cljs.core.munge_str(cljs.core.str.cljs$core$IFn$_invoke$arity$1(name));\nvar name_SINGLEQUOTE___$1 \x3d (((name_SINGLEQUOTE_ \x3d\x3d\x3d ".."))?"_DOT__DOT_":(cljs.core.truth_(cljs.core.js_reserved_QMARK_(name_SINGLEQUOTE_))?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(name_SINGLEQUOTE_),"$"].join(\'\'):name_SINGLEQUOTE_\n));\nif((name instanceof cljs.core.Symbol)){\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$1(name_SINGLEQUOTE___$1);\n} else {\nreturn name_SINGLEQUOTE___$1;\n}\n});\ncljs.core.demunge_str \x3d (function cljs$core$demunge_str(munged_name){\nvar r \x3d (new RegExp(cljs.core.demunge_pattern(),"g"));\nvar munged_name__$1 \x3d (cljs.core.truth_(goog.string.endsWith(munged_name,"$"))?munged_name.substring((0),(munged_name.length - (1))):munged_name);\nvar ret \x3d "";\nvar last_match_end \x3d (0);\nwhile(true){\nvar temp__5718__auto__ \x3d r.exec(munged_name__$1);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar match \x3d temp__5718__auto__;\nvar vec__12112 \x3d match;\nvar x \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__12112,(0),null);\nvar G__12115 \x3d [ret,cljs.core.str.cljs$core$IFn$_invoke$arity$1(munged_name__$1.substring(last_match_end,(r.lastIndex - x.length))),cljs.core.str.cljs$core$IFn$_invoke$arity$1((((x \x3d\x3d\x3d "$"))?"/":goog.object.get(cljs.core.DEMUNGE_MAP,x)))].join(\'\');\nvar G__12116 \x3d r.lastIndex;\nret \x3d G__12115;\nlast_match_end \x3d G__12116;\ncontinue;\n} else {\nreturn [ret,cljs.core.str.cljs$core$IFn$_invoke$arity$1(munged_name__$1.substring(last_match_end,munged_name__$1.length))].join(\'\');\n}\nbreak;\n}\n});\ncljs.core.demunge \x3d (function cljs$core$demunge(name){\nvar G__12118 \x3d (function (){var name_SINGLEQUOTE_ \x3d cljs.core.str.cljs$core$IFn$_invoke$arity$1(name);\nif((name_SINGLEQUOTE_ \x3d\x3d\x3d "_DOT__DOT_")){\nreturn "..";\n} else {\nreturn cljs.core.demunge_str(name_SINGLEQUOTE_);\n}\n})();\nvar fexpr__12117 \x3d (((name instanceof cljs.core.Symbol))?cljs.core.symbol:cljs.core.str);\nreturn (fexpr__12117.cljs$core$IFn$_invoke$arity$1 ? fexpr__12117.cljs$core$IFn$_invoke$arity$1(G__12118) : fexpr__12117.call(null,G__12118));\n});\nif((typeof cljs !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core.tapset !\x3d\x3d \'undefined\')){\n} else {\n/**\n * @type {*}\n */\ncljs.core.tapset \x3d null;\n}\ncljs.core.maybe_init_tapset \x3d (function cljs$core$maybe_init_tapset(){\nif((cljs.core.tapset \x3d\x3d null)){\nreturn cljs.core.tapset \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentHashSet.EMPTY);\n} else {\nreturn null;\n}\n});\n/**\n * Adds f, a fn of one argument, to the tap set. This function will be called with\n *   anything sent via tap\x3e. Remember f in order to remove-tap\n */\ncljs.core.add_tap \x3d (function cljs$core$add_tap(f){\ncljs.core.maybe_init_tapset();\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(cljs.core.tapset,cljs.core.conj,f);\n\nreturn null;\n});\n/**\n * Remove f from the tap set.\n */\ncljs.core.remove_tap \x3d (function cljs$core$remove_tap(f){\ncljs.core.maybe_init_tapset();\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(cljs.core.tapset,cljs.core.disj,f);\n\nreturn null;\n});\n/**\n * Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value.\n */\ncljs.core.tap_GT_ \x3d (function cljs$core$tap_GT_(x){\ncljs.core.maybe_init_tapset();\n\nreturn (cljs.core._STAR_exec_tap_fn_STAR_.cljs$core$IFn$_invoke$arity$1 ? cljs.core._STAR_exec_tap_fn_STAR_.cljs$core$IFn$_invoke$arity$1((function (){\nvar seq__12119 \x3d cljs.core.seq(cljs.core.deref(cljs.core.tapset));\nvar chunk__12120 \x3d null;\nvar count__12121 \x3d (0);\nvar i__12122 \x3d (0);\nwhile(true){\nif((i__12122 \x3c count__12121)){\nvar tap \x3d chunk__12120.cljs$core$IIndexed$_nth$arity$2(null,i__12122);\ntry{(tap.cljs$core$IFn$_invoke$arity$1 ? tap.cljs$core$IFn$_invoke$arity$1(x) : tap.call(null,x));\n}catch (e12125){if((e12125 instanceof Error)){\nvar ex_12127 \x3d e12125;\n} else {\nthrow e12125;\n\n}\n}\n\nvar G__12128 \x3d seq__12119;\nvar G__12129 \x3d chunk__12120;\nvar G__12130 \x3d count__12121;\nvar G__12131 \x3d (i__12122 + (1));\nseq__12119 \x3d G__12128;\nchunk__12120 \x3d G__12129;\ncount__12121 \x3d G__12130;\ni__12122 \x3d G__12131;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__12119);\nif(temp__5720__auto__){\nvar seq__12119__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__12119__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__12119__$1);\nvar G__12132 \x3d cljs.core.chunk_rest(seq__12119__$1);\nvar G__12133 \x3d c__4550__auto__;\nvar G__12134 \x3d cljs.core.count(c__4550__auto__);\nvar G__12135 \x3d (0);\nseq__12119 \x3d G__12132;\nchunk__12120 \x3d G__12133;\ncount__12121 \x3d G__12134;\ni__12122 \x3d G__12135;\ncontinue;\n} else {\nvar tap \x3d cljs.core.first(seq__12119__$1);\ntry{(tap.cljs$core$IFn$_invoke$arity$1 ? tap.cljs$core$IFn$_invoke$arity$1(x) : tap.call(null,x));\n}catch (e12126){if((e12126 instanceof Error)){\nvar ex_12136 \x3d e12126;\n} else {\nthrow e12126;\n\n}\n}\n\nvar G__12137 \x3d cljs.core.next(seq__12119__$1);\nvar G__12138 \x3d null;\nvar G__12139 \x3d (0);\nvar G__12140 \x3d (0);\nseq__12119 \x3d G__12137;\nchunk__12120 \x3d G__12138;\ncount__12121 \x3d G__12139;\ni__12122 \x3d G__12140;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n})) : cljs.core._STAR_exec_tap_fn_STAR_.call(null,(function (){\nvar seq__12119 \x3d cljs.core.seq(cljs.core.deref(cljs.core.tapset));\nvar chunk__12120 \x3d null;\nvar count__12121 \x3d (0);\nvar i__12122 \x3d (0);\nwhile(true){\nif((i__12122 \x3c count__12121)){\nvar tap \x3d chunk__12120.cljs$core$IIndexed$_nth$arity$2(null,i__12122);\ntry{(tap.cljs$core$IFn$_invoke$arity$1 ? tap.cljs$core$IFn$_invoke$arity$1(x) : tap.call(null,x));\n}catch (e12125){if((e12125 instanceof Error)){\nvar ex_12141 \x3d e12125;\n} else {\nthrow e12125;\n\n}\n}\n\nvar G__12142 \x3d seq__12119;\nvar G__12143 \x3d chunk__12120;\nvar G__12144 \x3d count__12121;\nvar G__12145 \x3d (i__12122 + (1));\nseq__12119 \x3d G__12142;\nchunk__12120 \x3d G__12143;\ncount__12121 \x3d G__12144;\ni__12122 \x3d G__12145;\ncontinue;\n} else {\nvar temp__5720__auto__ \x3d cljs.core.seq(seq__12119);\nif(temp__5720__auto__){\nvar seq__12119__$1 \x3d temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__12119__$1)){\nvar c__4550__auto__ \x3d cljs.core.chunk_first(seq__12119__$1);\nvar G__12146 \x3d cljs.core.chunk_rest(seq__12119__$1);\nvar G__12147 \x3d c__4550__auto__;\nvar G__12148 \x3d cljs.core.count(c__4550__auto__);\nvar G__12149 \x3d (0);\nseq__12119 \x3d G__12146;\nchunk__12120 \x3d G__12147;\ncount__12121 \x3d G__12148;\ni__12122 \x3d G__12149;\ncontinue;\n} else {\nvar tap \x3d cljs.core.first(seq__12119__$1);\ntry{(tap.cljs$core$IFn$_invoke$arity$1 ? tap.cljs$core$IFn$_invoke$arity$1(x) : tap.call(null,x));\n}catch (e12126){if((e12126 instanceof Error)){\nvar ex_12150 \x3d e12126;\n} else {\nthrow e12126;\n\n}\n}\n\nvar G__12151 \x3d cljs.core.next(seq__12119__$1);\nvar G__12152 \x3d null;\nvar G__12153 \x3d (0);\nvar G__12154 \x3d (0);\nseq__12119 \x3d G__12151;\nchunk__12120 \x3d G__12152;\ncount__12121 \x3d G__12153;\ni__12122 \x3d G__12154;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n})));\n});\n/**\n * Bootstrap only.\n */\ncljs.core.ns_lookup \x3d (function cljs$core$ns_lookup(ns_obj,k){\nreturn (function (){\nreturn goog.object.get(ns_obj,k);\n});\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n*/\ncljs.core.Namespace \x3d (function (obj,name){\nthis.obj \x3d obj;\nthis.name \x3d name;\nthis.cljs$lang$protocol_mask$partition0$ \x3d 6291456;\nthis.cljs$lang$protocol_mask$partition1$ \x3d 0;\n});\ncljs.core.Namespace.prototype.findInternedVar \x3d (function (sym){\nvar self__ \x3d this;\nvar this$ \x3d this;\nvar k \x3d cljs.core.munge(cljs.core.str.cljs$core$IFn$_invoke$arity$1(sym));\nif(goog.object.containsKey(self__.obj,k)){\nvar var_sym \x3d cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.name),cljs.core.str.cljs$core$IFn$_invoke$arity$1(sym));\nvar var_meta \x3d new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$ns,this$], null);\nreturn (new cljs.core.Var(cljs.core.ns_lookup(self__.obj,k),var_sym,var_meta));\n} else {\nreturn null;\n}\n});\n\ncljs.core.Namespace.prototype.getName \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn self__.name;\n});\n\ncljs.core.Namespace.prototype.toString \x3d (function (){\nvar self__ \x3d this;\nvar _ \x3d this;\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.name);\n});\n\ncljs.core.Namespace.prototype.cljs$core$IEquiv$_equiv$arity$2 \x3d (function (_,other){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nif((other instanceof cljs.core.Namespace)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(self__.name,other.name);\n} else {\nreturn false;\n}\n});\n\ncljs.core.Namespace.prototype.cljs$core$IHash$_hash$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn cljs.core.hash(self__.name);\n});\n\ncljs.core.Namespace.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$obj,cljs.core.cst$sym$name], null);\n});\n\ncljs.core.Namespace.cljs$lang$type \x3d true;\n\ncljs.core.Namespace.cljs$lang$ctorStr \x3d "cljs.core/Namespace";\n\ncljs.core.Namespace.cljs$lang$ctorPrWriter \x3d (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,"cljs.core/Namespace");\n});\n\n/**\n * Positional factory function for cljs.core/Namespace.\n */\ncljs.core.__GT_Namespace \x3d (function cljs$core$__GT_Namespace(obj,name){\nreturn (new cljs.core.Namespace(obj,name));\n});\n\n/**\n * Bootstrap only.\n * @type {*}\n */\ncljs.core.NS_CACHE \x3d null;\n/**\n * Bootstrap only.\n */\ncljs.core.find_ns_obj_STAR_ \x3d (function cljs$core$find_ns_obj_STAR_(ctxt,xs){\nwhile(true){\nif((ctxt \x3d\x3d null)){\nreturn null;\n} else {\nif((xs \x3d\x3d null)){\nreturn ctxt;\n} else {\nvar G__12157 \x3d (function (){var G__12155 \x3d ctxt;\nvar G__12156 \x3d cljs.core.first(xs);\nreturn goog.object.get(G__12155,G__12156);\n})();\nvar G__12158 \x3d cljs.core.next(xs);\nctxt \x3d G__12157;\nxs \x3d G__12158;\ncontinue;\n\n}\n}\nbreak;\n}\n});\n/**\n * Bootstrap only.\n */\ncljs.core.find_ns_obj \x3d (function cljs$core$find_ns_obj(ns){\nvar munged_ns \x3d cljs.core.munge(cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns));\nvar segs \x3d munged_ns.split(".");\nvar G__12159 \x3d cljs.core._STAR_target_STAR_;\nswitch (G__12159) {\ncase "nodejs":\nif(COMPILED){\nreturn cljs.core.find_ns_obj_STAR_((function (){try{var ctxt \x3d eval(cljs.core.first(segs));\nif(cljs.core.truth_((function (){var and__4120__auto__ \x3d ctxt;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.object_QMARK_(ctxt);\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn ctxt;\n} else {\nreturn null;\n}\n}catch (e12160){if((e12160 instanceof ReferenceError)){\nvar e \x3d e12160;\nreturn null;\n} else {\nthrow e12160;\n\n}\n}})(),cljs.core.next(segs));\n} else {\nreturn cljs.core.find_ns_obj_STAR_(goog.global,segs);\n}\n\nbreak;\ncase "default":\ncase "webworker":\nreturn cljs.core.find_ns_obj_STAR_(goog.global,segs);\n\nbreak;\ndefault:\nthrow (new Error(["find-ns-obj not supported for target ",cljs.core._STAR_target_STAR_].join(\'\')));\n\n}\n});\n/**\n * Returns a map of the intern mappings for the namespace.\n *   Bootstrap only.\n */\ncljs.core.ns_interns_STAR_ \x3d (function cljs$core$ns_interns_STAR_(sym){\nvar ns_obj \x3d cljs.core.find_ns_obj(sym);\nvar ns \x3d (new cljs.core.Namespace(ns_obj,sym));\nvar step \x3d ((function (ns_obj,ns){\nreturn (function cljs$core$ns_interns_STAR__$_step(ret,k){\nvar var_sym \x3d cljs.core.symbol.cljs$core$IFn$_invoke$arity$1(cljs.core.demunge(k));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(ret,var_sym,(new cljs.core.Var(((function (var_sym,ns_obj,ns){\nreturn (function (){\nreturn goog.object.get(ns_obj,k);\n});})(var_sym,ns_obj,ns))\n,cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(cljs.core.str.cljs$core$IFn$_invoke$arity$1(sym),cljs.core.str.cljs$core$IFn$_invoke$arity$1(var_sym)),new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$ns,ns], null))));\n});})(ns_obj,ns))\n;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(step,cljs.core.PersistentArrayMap.EMPTY,cljs.core.js_keys(ns_obj));\n});\n/**\n * Create a new namespace named by the symbol. Bootstrap only.\n */\ncljs.core.create_ns \x3d (function cljs$core$create_ns(var_args){\nvar G__12163 \x3d arguments.length;\nswitch (G__12163) {\ncase 1:\nreturn cljs.core.create_ns.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.create_ns.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\'\')));\n\n}\n});\n\ncljs.core.create_ns.cljs$core$IFn$_invoke$arity$1 \x3d (function (sym){\nreturn cljs.core.create_ns.cljs$core$IFn$_invoke$arity$2(sym,cljs.core.find_ns_obj(sym));\n});\n\ncljs.core.create_ns.cljs$core$IFn$_invoke$arity$2 \x3d (function (sym,ns_obj){\nreturn (new cljs.core.Namespace(ns_obj,sym));\n});\n\ncljs.core.create_ns.cljs$lang$maxFixedArity \x3d 2;\n\n/**\n * Returns the namespace named by the symbol or nil if it doesn\'t exist.\n *   Bootstrap only.\n */\ncljs.core.find_ns \x3d (function cljs$core$find_ns(ns){\nif((cljs.core.NS_CACHE \x3d\x3d null)){\ncljs.core.NS_CACHE \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\n} else {\n}\n\nvar the_ns \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.NS_CACHE),ns);\nif((!((the_ns \x3d\x3d null)))){\nreturn the_ns;\n} else {\nvar ns_obj \x3d cljs.core.find_ns_obj(ns);\nif((ns_obj \x3d\x3d null)){\nreturn null;\n} else {\nvar new_ns \x3d cljs.core.create_ns.cljs$core$IFn$_invoke$arity$2(ns,ns_obj);\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(cljs.core.NS_CACHE,cljs.core.assoc,ns,new_ns);\n\nreturn new_ns;\n}\n}\n});\n/**\n * Returns the macros namespace named by the symbol or nil if it doesn\'t exist.\n *   Bootstrap only.\n */\ncljs.core.find_macros_ns \x3d (function cljs$core$find_macros_ns(ns){\nif((cljs.core.NS_CACHE \x3d\x3d null)){\ncljs.core.NS_CACHE \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\n} else {\n}\n\nvar ns_str \x3d cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns);\nvar ns__$1 \x3d (((!(goog.string.contains(ns_str,"$macros"))))?cljs.core.symbol.cljs$core$IFn$_invoke$arity$1([ns_str,"$macros"].join(\'\')):ns);\nvar the_ns \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.NS_CACHE),ns__$1);\nif((!((the_ns \x3d\x3d null)))){\nreturn the_ns;\n} else {\nvar ns_obj \x3d cljs.core.find_ns_obj(ns__$1);\nif((ns_obj \x3d\x3d null)){\nreturn null;\n} else {\nvar new_ns \x3d cljs.core.create_ns.cljs$core$IFn$_invoke$arity$2(ns__$1,ns_obj);\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(cljs.core.NS_CACHE,cljs.core.assoc,ns__$1,new_ns);\n\nreturn new_ns;\n}\n}\n});\n/**\n * Returns the name of the namespace, a Namespace object.\n *   Bootstrap only.\n */\ncljs.core.ns_name \x3d (function cljs$core$ns_name(ns_obj){\nreturn ns_obj.name;\n});\n/**\n * Returns true x is a goog.Uri instance.\n */\ncljs.core.uri_QMARK_ \x3d (function cljs$core$uri_QMARK_(x){\nreturn (x instanceof goog.Uri);\n});\ncljs.core.maybe_enable_print_BANG_ \x3d (function cljs$core$maybe_enable_print_BANG_(){\nif((typeof console !\x3d\x3d \'undefined\')){\nreturn cljs.core.enable_console_print_BANG_();\n} else {\nif((((cljs.core._STAR_target_STAR_ \x3d\x3d\x3d "nashorn")) || ((cljs.core._STAR_target_STAR_ \x3d\x3d\x3d "graaljs")))){\nvar system \x3d Java.type("java.lang.System");\ncljs.core._STAR_print_newline_STAR_ \x3d false;\n\ncljs.core.set_print_fn_BANG_(((function (system){\nreturn (function (){\nvar xs \x3d arguments;\nvar s \x3d goog.array.clone(xs).join("");\nreturn system.out.println(s);\n});})(system))\n);\n\nreturn cljs.core.set_print_err_fn_BANG_(((function (system){\nreturn (function (){\nvar xs \x3d arguments;\nvar s \x3d goog.array.clone(xs).join("");\nreturn system.error.println(s);\n});})(system))\n);\n} else {\nreturn null;\n}\n}\n});\ncljs.core.maybe_enable_print_BANG_();\nif((typeof cljs !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core !\x3d\x3d \'undefined\') \x26\x26 (typeof cljs.core._STAR_eval_STAR_ !\x3d\x3d \'undefined\')){\n} else {\n/**\n * Runtime environments may provide a way to evaluate ClojureScript\n *   forms. Whatever function *eval* is bound to will be passed any forms which\n *   should be evaluated.\n */\ncljs.core._STAR_eval_STAR_ \x3d (function cljs$core$_STAR_eval_STAR_(_){\nthrow (new Error("cljs.core/*eval* not bound"));\n});\n}\n/**\n * Evaluates the form data structure (not text!) and returns the result.\n *   Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\n *   which sets up an implementation of cljs.core/*eval* for that environment.\n */\ncljs.core.eval \x3d (function cljs$core$eval(form){\nreturn (cljs.core._STAR_eval_STAR_.cljs$core$IFn$_invoke$arity$1 ? cljs.core._STAR_eval_STAR_.cljs$core$IFn$_invoke$arity$1(form) : cljs.core._STAR_eval_STAR_.call(null,form));\n});\n'],
null),new p(null,3,[Cl,"cljs/spec/test/alpha.cljs",Xn,"cljs.spec.test.alpha",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.test.alpha\n  (:require-macros [cljs.spec.test.alpha :as m :refer [with-instrument-disabled setup-static-dispatches]])\n  (:require\n    [goog.object :as gobj]\n    [goog.userAgent.product :as product]\n    [clojure.string :as string]\n    [cljs.stacktrace :as st]\n    [cljs.pprint :as pp]\n    [cljs.spec.alpha :as s]\n    [cljs.spec.gen.alpha :as gen]))\n\n(defn distinct-by\n  ([f coll]\n   (let [step (fn step [xs seen]\n                (lazy-seq\n                  ((fn [[x :as xs] seen]\n                     (when-let [s (seq xs)]\n                       (let [v (f x)]\n                         (if (contains? seen v)\n                           (recur (rest s) seen)\n                           (cons x (step (rest s) (conj seen v)))))))\n                    xs seen)))]\n     (step coll #{}))))\n\n(defn -\x3esym\n  [x]\n  (@#\'s/-\x3esym x))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; instrument ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^:private ^:dynamic *instrument-enabled*\n  "if false, instrumented fns call straight through"\n  true)\n\n(defn get-host-port []\n  (if (not\x3d "browser" *target*)\n    {}\n    {:host (.. js/window -location -host)\n     :port (.. js/window -location -port)}))\n\n(defn get-ua-product []\n  (if (not\x3d "browser" *target*)\n    (keyword *target*)\n    (cond\n      product/SAFARI :safari\n      product/CHROME :chrome\n      product/FIREFOX :firefox\n      product/IE :ie)))\n\n(defn get-env []\n  {:ua-product (get-ua-product)})\n\n(defn- fn-spec?\n  "Fn-spec must include at least :args or :ret specs."\n  [m]\n  (or (:args m) (:ret m)))\n\n;; wrap spec/explain-data until specs always return nil for ok data\n(defn- explain-data*\n  [spec v]\n  (when-not (s/valid? spec v nil)\n    (s/explain-data spec v)))\n\n(defn- find-caller [st]\n  (letfn [(search-spec-fn [frame]\n            (when frame\n              (let [s (:function frame)]\n                (and (string? s) (not (string/blank? s))\n                     (re-find #"cljs\\.spec\\.test\\.spec_checking_fn" s)))))]\n    (-\x3e\x3e st\n         (drop-while #(not (search-spec-fn %)))\n         (drop-while search-spec-fn)\n         first)))\n\n;; TODO: check ::caller result in other browsers - David\n\n(defn- spec-checking-fn\n  [v f fn-spec]\n  (let [fn-spec (@#\'s/maybe-spec fn-spec)\n        args-spec (:args fn-spec)\n        conform! (fn [v role spec data args]\n                   (let [conformed (s/conform spec data)]\n                     (if (\x3d ::s/invalid conformed)\n                       (let [caller (find-caller\n                                      (st/parse-stacktrace\n                                        (get-host-port)\n                                        (.-stack (js/Error.))\n                                        (get-env) nil))\n                             ed (merge (assoc (s/explain-data* spec [] [] [] data)\n                                         ::s/fn (-\x3esym v)\n                                         ::s/args args\n                                         ::s/failure :instrument)\n                                  (when caller\n                                    {::caller caller}))]\n                         (throw (ex-info\n                                  (str "Call to " v " did not conform to spec." )\n                                  ed)))\n                       conformed)))\n        pure-variadic? (and (-\x3e (meta v) :top-fn :variadic?)\n                            (zero? (-\x3e (meta v) :top-fn :max-fixed-arity)))\n        apply\' (fn [f args]\n                 (if (and (nil? args)\n                          pure-variadic?)\n                   (.cljs$core$IFn$_invoke$arity$variadic f)\n                   (apply f args)))\n        conform!* #(conform! v :args args-spec % %)\n        ret (if args-spec\n              (fn [\x26 args]\n                (if *instrument-enabled*\n                  (with-instrument-disabled\n                    (conform!* args)\n                    (binding [*instrument-enabled* true]\n                      (apply\' f args)))\n                  (apply\' f args)))\n              f)]\n    (when (and (not pure-variadic?) args-spec)\n      (setup-static-dispatches f ret conform!* 20)\n      (when-some [variadic (.-cljs$core$IFn$_invoke$arity$variadic f)]\n        (set! (.-cljs$core$IFn$_invoke$arity$variadic ret)\n          (fn [\x26 args]\n            (if *instrument-enabled*\n              (with-instrument-disabled\n                (conform!* (apply list* args))\n                (binding [*instrument-enabled* true]\n                  (apply\' variadic args)))\n              (apply\' variadic args))))))\n    ret))\n\n(defn- no-fspec\n  [v spec]\n  (ex-info (str "Fn at " v " is not spec\'ed.")\n    {:var v :spec spec ::s/failure :no-fspec}))\n\n(defonce ^:private instrumented-vars (atom {}))\n\n(defn- instrument-choose-fn\n  "Helper for instrument."\n  [f spec sym {over :gen :keys [stub replace]}]\n  (if (some #{sym} stub)\n    (-\x3e spec (s/gen over) gen/generate)\n    (get replace sym f)))\n\n(defn- instrument-choose-spec\n  "Helper for instrument"\n  [spec sym {overrides :spec}]\n  (get overrides sym spec))\n\n(defn- instrument-1*\n  [s v opts]\n  (let [spec (s/get-spec v)\n        {:keys [raw wrapped]} (get @instrumented-vars v)\n        current @v\n        to-wrap (if (\x3d wrapped current) raw current)\n        ospec (or (instrument-choose-spec spec s opts)\n                (throw (no-fspec v spec)))\n        ofn (instrument-choose-fn to-wrap ospec s opts)\n        checked (spec-checking-fn v ofn ospec)]\n    (swap! instrumented-vars assoc v {:raw to-wrap :wrapped checked})\n    checked))\n\n(defn- unstrument-1*\n  [s v]\n  (when v\n    (when-let [{:keys [raw wrapped]} (get @instrumented-vars v)]\n      (swap! instrumented-vars dissoc v)\n      (let [current @v]\n        (when (\x3d wrapped current)\n          raw)))))\n\n(defn- fn-spec-name?\n  [s]\n  (symbol? s))\n\n(defn- collectionize\n  [x]\n  (if (symbol? x)\n    (list x)\n    x))\n\n(defn instrumentable-syms\n  "Given an opts map as per instrument, returns the set of syms\nthat can be instrumented."\n  ([] (instrumentable-syms nil))\n  ([opts]\n   (assert (every? ident? (keys (:gen opts))) "instrument :gen expects ident keys")\n   (reduce into #{} [(filter fn-spec-name? (keys (s/registry)))\n                     (keys (:spec opts))\n                     (:stub opts)\n                     (keys (:replace opts))])))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; testing  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- explain-check\n  [args spec v role]\n  (ex-info\n    "Specification-based check failed"\n    (when-not (s/valid? spec v nil)\n      (assoc (s/explain-data* spec [role] [] [] v)\n        ::args args\n        ::val v\n        ::s/failure :check-failed))))\n\n(defn- check-call\n  "Returns true if call passes specs, otherwise *returns* an exception\nwith explain-data + ::s/failure."\n  [f specs args]\n  (let [cargs (when (:args specs) (s/conform (:args specs) args))]\n    (if (\x3d cargs ::s/invalid)\n      (explain-check args (:args specs) args :args)\n      (let [ret (apply f args)\n            cret (when (:ret specs) (s/conform (:ret specs) ret))]\n        (if (\x3d cret ::s/invalid)\n          (explain-check args (:ret specs) ret :ret)\n          (if (and (:args specs) (:ret specs) (:fn specs))\n            (if (s/valid? (:fn specs) {:args cargs :ret cret})\n              true\n              (explain-check args (:fn specs) {:args cargs :ret cret} :fn))\n            true))))))\n\n(defn- quick-check\n  [f specs {gen :gen opts :clojure.spec.test.check/opts}]\n  (let [{:keys [num-tests] :or {num-tests 1000}} opts\n        g (try (s/gen (:args specs) gen) (catch js/Error t t))]\n    (if (instance? js/Error g)\n      {:result g}\n      (let [prop (gen/for-all* [g] #(check-call f specs %))]\n        (apply gen/quick-check num-tests prop (mapcat identity opts))))))\n\n(defn- make-check-result\n  "Builds spec result map."\n  [check-sym spec test-check-ret tc-ret-key]\n  (merge {:spec spec\n          tc-ret-key test-check-ret}\n    (when check-sym\n      {:sym check-sym})\n    (when-let [result (-\x3e test-check-ret :result)]\n      (when-not (true? result) {:failure result}))\n    (when-let [shrunk (-\x3e test-check-ret :shrunk)]\n      {:failure (:result shrunk)})))\n\n(defn validate-check-opts\n  [opts]\n  (assert (every? ident? (keys (:gen opts))) "check :gen expects ident keys"))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; check reporting  ;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- failure-type\n  [x]\n  (::s/failure (ex-data x)))\n\n(defn- unwrap-failure\n  [x]\n  (if (failure-type x)\n    (ex-data x)\n    x))\n\n(defn- result-type\n  "Returns the type of the check result. This can be any of the\n::s/failure keywords documented in \'check\', or:\n\n  :check-passed   all checked fn returns conformed\n  :check-threw    checked fn threw an exception"\n  [ret]\n  (let [failure (:failure ret)]\n    (cond\n      (nil? failure) :check-passed\n      (failure-type failure) (failure-type failure)\n      :default :check-threw)))\n\n(defn abbrev-result\n  "Given a check result, returns an abbreviated version\nsuitable for summary use."\n  [x]\n  (if (:failure x)\n    (-\x3e (dissoc x :clojure.spec.test.check/ret)\n      (update :spec s/describe)\n      (update :failure unwrap-failure))\n    (dissoc x :spec :clojure.spec.test.check/opts)))\n\n(defn summarize-results\n  "Given a collection of check-results, e.g. from \'check\', pretty\nprints the summary-result (default abbrev-result) of each.\n\nReturns a map with :total, the total number of results, plus a\nkey with a count for each different :type of result."\n  ([check-results] (summarize-results check-results abbrev-result))\n  ([check-results summary-result]\n   (reduce\n     (fn [summary result]\n       (pp/pprint (summary-result result))\n       (-\x3e summary\n         (update :total inc)\n         (update (result-type result) (fnil inc 0))))\n     {:total 0}\n     check-results)))\n\n(comment\n  (require\n    \'[cljs.pprint :as pp]\n    \'[cljs.spec :as s]\n    \'[cljs.spec.gen :as gen]\n    \'[cljs.test :as ctest])\n\n  (require :reload \'[cljs.spec.test :as test])\n\n  ;; discover speced vars for your own test runner\n  (s/speced-vars)\n\n  ;; check a single var\n  (test/check-var #\'-)\n  (test/check-var #\'+)\n  (test/check-var #\'clojure.spec.broken-specs/throwing-fn)\n\n  ;; old style example tests\n  (ctest/run-all-tests)\n\n  (s/speced-vars \'clojure.spec.correct-specs)\n  ;; new style spec tests return same kind of map\n  (test/check-var #\'subs)\n  (cljs.spec.test/run-tests \'clojure.core)\n  (test/run-all-tests)\n\n  ;; example evaluation\n  (defn ranged-rand\n    "Returns random int in range start \x3c\x3d rand \x3c end"\n    [start end]\n    (+ start (long (rand (- end start)))))\n\n  (s/fdef ranged-rand\n    :args (s/and (s/cat :start int? :end int?)\n                 #(\x3c (:start %) (:end %)))\n    :ret  int?\n    :fn   (s/and #(\x3e\x3d (:ret %) (-\x3e % :args :start))\n                 #(\x3c (:ret %) (-\x3e % :args :end))))\n\n  (instrumentable-syms)\n\n  (m/instrument-1 `ranged-rand {})\n  (m/unstrument-1 `ranged-rand)\n\n  (m/instrument)\n  (m/instrument `ranged-rand)\n  (m/instrument `[ranged-rand])\n\n  (m/unstrument)\n  (m/unstrument `ranged-rand)\n  (m/unstrument `[ranged-rand])\n\n  (ranged-rand 8 5)\n  (defn foo\n    ([a])\n    ([a b]\n     (ranged-rand 8 5)))\n  (foo 1 2)\n  (m/unstrument-1 `ranged-rand)\n\n  (m/check-1 `ranged-rand nil nil {})\n\n  (m/check-fn inc\n    (s/fspec\n      :args (s/cat :x int?)\n      :ret  int?))\n\n  (m/checkable-syms)\n\n  (m/check `ranged-rand)\n  )\n\n\n\n\n\n'],
null),new p(null,3,[Cl,"clojure/zip.cljs",Xn,"clojure.zip",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;functional hierarchical zipper, with navigation, editing and enumeration\n;see Huet\n\n(ns ^{:doc "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet"\n       :author "Rich Hickey"}\n  clojure.zip\n  (:refer-clojure :exclude (replace remove next)))\n\n(defn zipper\n  "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn\'t.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])\n\n(defn seq-zip\n  "Returns a zipper for nested sequences, given a root sequence"\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))\n\n(defn vector-zip\n  "Returns a zipper for nested vectors, given a root vector"\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))\n\n(defn xml-zip\n  "Returns a zipper for xml elements (as from xml/parse),\n  given a root element"\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))\n\n(defn node\n  "Returns the node at loc"\n  [loc] (loc 0))\n\n(defn branch?\n  "Returns true if the node at loc is a branch"\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))\n\n(defn children\n  "Returns a seq of the children of node at loc, which must be a branch"\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw "called children on a leaf node")))\n\n(defn make-node\n  "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))\n\n(defn path\n  "Returns a seq of nodes leading to this loc"\n  [loc]\n    (:pnodes (loc 1)))\n\n(defn lefts\n  "Returns a seq of the left siblings of this loc"\n  [loc]\n    (seq (:l (loc 1))))\n\n(defn rights\n  "Returns a seq of the right siblings of this loc"\n  [loc]\n    (:r (loc 1)))\n\n\n(defn down\n  "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c \x26 cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))\n\n(defn up\n  "Returns the loc of the parent of the node at this loc, or nil if at\n  the top"\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))\n\n(defn root\n  "zips all the way up and returns the root node, reflecting any\n changes."\n  [loc]\n    (if (\x3d :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))\n\n(defn right\n  "Returns the loc of the right sibling of the node at this loc, or nil"\n  [loc]\n    (let [[node {l :l  [r \x26 rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))\n\n(defn rightmost\n  "Returns the loc of the rightmost sibling of the node at this loc, or self"\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))\n\n(defn left\n  "Returns the loc of the left sibling of the node at this loc, or nil"\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))\n\n(defn leftmost\n  "Returns the loc of the leftmost sibling of the node at this loc, or self"\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))\n\n(defn insert-left\n  "Inserts the item as the left sibling of the node at this loc,\n without moving"\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw "Insert at top")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))\n\n(defn insert-right\n  "Inserts the item as the right sibling of the node at this loc,\n  without moving"\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw "Insert at top")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))\n\n(defn replace\n  "Replaces the node at this loc, without moving"\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))\n\n(defn edit\n  "Replaces the node at this loc with the value of (f node args)"\n  [loc f \x26 args]\n    (replace loc (apply f (node loc) args)))\n\n(defn insert-child\n  "Inserts the item as the leftmost child of the node at this loc,\n  without moving"\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))\n\n(defn append-child\n  "Inserts the item as the rightmost child of the node at this loc,\n  without moving"\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))\n\n(defn next\n  "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."\n  [loc]\n    (if (\x3d :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))\n\n(defn prev\n  "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))\n\n(defn end?\n  "Returns true if loc represents the end of a depth-first walk"\n  [loc]\n    (\x3d :end (loc 1)))\n\n(defn remove\n  "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw "Remove at top")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))\n  \n(comment\n\n(load-file "/Users/rich/dev/clojure/src/zip.clj")\n(refer \'zip)\n(def data \'[[a * b] + [c * d]])\n(def dz (vector-zip data))\n\n(right (down dz))\n(right (down (right (right (down dz)))))\n(lefts (right (down (right (right (down dz))))))\n(rights (right (down (right (right (down dz))))))\n(up (up (right (down (right (right (down dz)))))))\n(path (right (down (right (right (down dz))))))\n\n(-\x3e dz down right right down right)\n(-\x3e dz down right right down right (replace \'/) root)\n(-\x3e dz next next (edit str) next next next (replace \'/) root)\n(-\x3e dz next next next next next next next next next remove root)\n(-\x3e dz next next next next next next next next next remove (insert-right \'e) root)\n(-\x3e dz next next next next next next next next next remove up (append-child \'e) root)\n\n(end? (-\x3e dz next next next next next next next next next remove next))\n\n(-\x3e dz next remove next remove root)\n\n(loop [loc dz]\n  (if (end? loc)\n    (root loc)\n    (recur (next (if (\x3d \'* (node loc)) \n                   (replace loc \'/)\n                   loc)))))\n\n(loop [loc dz]\n  (if (end? loc)\n    (root loc)\n    (recur (next (if (\x3d \'* (node loc)) \n                   (remove loc)\n                   loc)))))\n)\n'],
null),new p(null,3,[Cl,"cljs/tools/reader/impl/utils.cljs",Xn,"cljs.tools.reader.impl.utils",nr,';;   Copyright (c) Nicola Mometto, Rich Hickey \x26 contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.tools.reader.impl.utils\n  (:refer-clojure :exclude [char])\n  (:require\n   [clojure.string :as string]\n   [goog.string :as gstring]))\n\n(defn char [x]\n  (when-not (nil? x)\n    (cljs.core/char x)))\n\n(defn ^boolean ex-info? [ex]\n  (instance? cljs.core.ExceptionInfo ex))\n\n(defrecord ReaderConditional [splicing? form])\n\n(defn ^boolean reader-conditional?\n  "Return true if the value is the data representation of a reader conditional"\n  [value]\n  (instance? ReaderConditional value))\n\n(defn reader-conditional\n  "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing."\n  [form splicing?]\n  (ReaderConditional. splicing? form))\n\n(extend-protocol IPrintWithWriter\n  ReaderConditional\n  (-pr-writer [coll writer opts]\n    (-write writer (str "#?" (when (:splicing? coll) "@")))\n    (pr-writer (:form coll) writer opts)))\n\n(def ws-rx #"[\\s]")\n\n(defn ^boolean whitespace?\n  "Checks whether a given character is whitespace"\n  [ch]\n  (when-not (nil? ch)\n    (if (identical? ch \\,)\n      true\n      (.test ws-rx ch))))\n\n(defn ^boolean numeric?\n  "Checks whether a given character is numeric"\n  [ch]\n  (when-not (nil? ch)\n    (gstring/isNumeric ch)))\n\n(defn ^boolean newline?\n  "Checks whether the character is a newline"\n  [c]\n  (or (identical? \\newline c)\n      (identical? "\\n" c)\n      (nil? c)))\n\n(defn desugar-meta\n  "Resolves syntactical sugar in metadata" ;; could be combined with some other desugar?\n  [f]\n  (cond\n    (keyword? f) {f true}\n    (symbol? f)  {:tag f}\n    (string? f)  {:tag f}\n    :else        f))\n\n(def last-id (atom 0))\n\n(defn next-id\n  []\n  (swap! last-id inc))\n\n(defn namespace-keys [ns keys]\n  (for [key keys]\n    (if (or (symbol? key)\n            (keyword? key))\n      (let [[key-ns key-name] ((juxt namespace name) key)\n            -\x3ekey (if (symbol? key) symbol keyword)]\n        (cond\n          (nil? key-ns)\n          (-\x3ekey ns key-name)\n\n          (\x3d "_" key-ns)\n          (-\x3ekey key-name)\n\n          :else\n          key))\n      key)))\n\n(defn second\' [[a b]]\n  (when-not a b))\n\n(defn char-code [ch base]\n  (let [code (js/parseInt ch base)]\n    (if (js/isNaN code)\n      -1\n      code)))\n'],
null),new p(null,3,[Cl,"clojure/test/check/properties.cljc",Xn,"clojure.test.check.properties",nr,';   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check.properties\n  (:require [clojure.test.check.generators :as gen]\n            [clojure.test.check.results :as results])\n  #?(:cljs (:require-macros [clojure.test.check.properties :refer [for-all]])))\n\n(defrecord ErrorResult [error]\n  results/Result\n  (pass? [_] false)\n  (result-data [_]\n    ;; spelling out the whole keyword here since `::error` is\n    ;; different in self-hosted cljs.\n    {:clojure.test.check.properties/error error}))\n\n(defn ^:private exception?\n  [x]\n  (instance? #?(:clj Throwable :cljs js/Error) x))\n\n(defn ^:private apply-gen\n  [function]\n  (fn [args]\n    (let [result (try\n                   (let [ret (apply function args)]\n                     ;; TCHECK-131: for backwards compatibility (mainly\n                     ;; for spec), treat returned exceptions like thrown\n                     ;; exceptions\n                     (if (exception? ret)\n                       (throw ret)\n                       ret))\n                   #?(:clj (catch java.lang.ThreadDeath t (throw t)))\n                   (catch #?(:clj Throwable :cljs :default) ex\n                     (-\x3eErrorResult ex)))]\n      {:result result\n       :function function\n       :args args})))\n\n(defn for-all*\n  "A function version of `for-all`. Takes a sequence of N generators\n  and a function of N args, and returns a property that calls the\n  function with generated values and tests the return value for\n  truthiness, like with `for-all`.\n\n  Example:\n\n  (for-all* [gen/large-integer gen/large-integer]\n            (fn [a b] (\x3e\x3d (+ a b) a)))"\n  [args function]\n  (gen/fmap\n   (apply-gen function)\n   (apply gen/tuple args)))\n\n(defn- binding-vars\n  [bindings]\n  (map first (partition 2 bindings)))\n\n(defn- binding-gens\n  [bindings]\n  (map second (partition 2 bindings)))\n\n(defmacro for-all\n  "Returns a property, which is the combination of some generators and\n  an assertion that should be true for all generated values. Properties\n  can be used with `quick-check` or `defspec`.\n\n  `for-all` takes a `let`-style bindings vector, where the right-hand\n  side of each binding is a generator.\n\n  The body should be an expression of the generated values that will\n  be tested for truthiness. Exceptions in the body will be caught and\n  treated as failures.\n\n  When there are multiple binding pairs, the earlier pairs are not\n  visible to the later pairs.\n\n  If there are multiple body expressions, all but the last one are\n  executed for side effects, as with `do`.\n\n  Example:\n\n  (for-all [a gen/large-integer\n            b gen/large-integer]\n    (\x3e\x3d (+ a b) a))"\n  [bindings \x26 body]\n  `(for-all* ~(vec (binding-gens bindings))\n             (fn [~@(binding-vars bindings)]\n               ~@body)))\n'],
null),new p(null,3,[Cl,"clojure/reflect.clj",Xn,"clojure.reflect",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:author "Stuart Halloway"\n      :added "1.3"\n      :doc "Reflection on Host Types\nAlpha - subject to change.\n\nTwo main entry points: \n\n* type-reflect reflects on something that implements TypeReference.\n* reflect (for REPL use) reflects on the class of an instance, or\n  on a class if passed a class\n\nKey features:\n\n* Exposes the read side of reflection as pure data. Reflecting\n  on a type returns a map with keys :bases, :flags, and :members.\n\n* Canonicalizes class names as Clojure symbols. Types can extend\n  to the TypeReference protocol to indicate that they can be\n  unambiguously resolved as a type name. The canonical format\n  requires one non-Java-ish convention: array brackets are \x3c\x3e\n  instead of [] so they can be part of a Clojure symbol.\n\n* Pluggable Reflectors for different implementations. The default\n  JavaReflector is good when you have a class in hand, or use\n  the AsmReflector for \\"hands off\\" reflection without forcing\n  classes to load.\n\nPlatform implementers must:\n\n* Create an implementation of Reflector.\n* Create one or more implementations of TypeReference.\n* def default-reflector to be an instance that satisfies Reflector."}\n  clojure.reflect\n  (:require [clojure.set :as set]))\n\n(defprotocol Reflector\n  "Protocol for reflection implementers."\n  (do-reflect [reflector typeref]))\n\n(defprotocol TypeReference\n  "A TypeReference can be unambiguously converted to a type name on\n   the host platform.\n\n   All typerefs are normalized into symbols. If you need to\n   normalize a typeref yourself, call typesym."\n  (typename [o] "Returns Java name as returned by ASM getClassName, e.g. byte[], java.lang.String[]"))\n\n(declare default-reflector)\n\n(defn type-reflect\n  "Alpha - subject to change.\n   Reflect on a typeref, returning a map with :bases, :flags, and\n  :members. In the discussion below, names are always Clojure symbols.\n\n   :bases            a set of names of the type\'s bases\n   :flags            a set of keywords naming the boolean attributes\n                     of the type.\n   :members          a set of the type\'s members. Each member is a map\n                     and can be a constructor, method, or field.\n\n   Keys common to all members:\n   :name             name of the type \n   :declaring-class  name of the declarer\n   :flags            keyword naming boolean attributes of the member\n\n   Keys specific to constructors:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n\n   Key specific to methods:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n   :return-type      return type name\n\n   Keys specific to fields:\n   :type             type name\n\n   Options:\n\n     :ancestors     in addition to the keys described above, also\n                    include an :ancestors key with the entire set of\n                    ancestors, and add all ancestor members to\n                    :members.\n     :reflector     implementation to use. Defaults to JavaReflector,\n                    AsmReflector is also an option."\n  {:added "1.3"}\n  [typeref \x26 options]\n  (let [{:keys [ancestors reflector]}\n        (merge {:reflector default-reflector}\n               (apply hash-map options))\n        refl (partial do-reflect reflector)\n        result (refl typeref)]\n    ;; could make simpler loop of two args: names an\n    (if ancestors\n      (let [make-ancestor-map (fn [names]\n                            (zipmap names (map refl names)))]\n        (loop [reflections (make-ancestor-map (:bases result))]\n          (let [ancestors-visited (set (keys reflections))\n                ancestors-to-visit (set/difference (set (mapcat :bases (vals reflections)))\n                                               ancestors-visited)]\n            (if (seq ancestors-to-visit)\n              (recur (merge reflections (make-ancestor-map ancestors-to-visit)))\n              (apply merge-with into result {:ancestors ancestors-visited}\n                     (map #(select-keys % [:members]) (vals reflections)))))))\n      result)))\n\n(defn reflect\n  "Alpha - subject to change.\n   Reflect on the type of obj (or obj itself if obj is a class).\n   Return value and options are the same as for type-reflect. "\n  {:added "1.3"}\n  [obj \x26 options]\n  (apply type-reflect (if (class? obj) obj (class obj)) options))\n\n(load "reflect/java")\n'],
null),new p(null,3,[Cl,"cljs/test.cljs",Xn,"cljs.test",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns\n^{:author "Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, David Nolen, and\n  Leon Grapenthin",\n     :doc "A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \\"is\\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (\x3d 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \\"abcde\\" \\"ab\\"))\n\n   You can type an \\"is\\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user\x3e (is (\x3d 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (\x3d 5 (+ 2 2))\n         actual: (not (\x3d 5 4))\n       false\n\n   The \\"expected:\\" line shows you the original expression, and the\n   \\"actual:\\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not \x3d to 5.  Finally, the\n   \\"false\\" on the last line is the value returned from the\n   expression.  The \\"is\\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \\"(is (thrown? c ...))\\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \\"(is (thrown-with-msg? c re ...))\\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\\"Divide by zero\\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \\"is\\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (\x3d 5 (+ 2 2)) \\"Crazy arithmetic\\")\n\n   In addition, you can document groups of assertions with the\n   \\"testing\\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \\"testing\\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec \x3chttp://rspec.info/\x3e\n\n   (testing \\"Arithmetic\\"\n     (testing \\"with positive integers\\"\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4))))\n     (testing \\"with negative integers\\"\n       (is (\x3d -4 (+ -2 -2)))\n       (is (\x3d -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \\"testing\\" macro may only be used\n   INSIDE a \\"deftest\\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (\x3d 4 (+ 2 2)))\n     (is (\x3d 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (\x3d 1 (- 4 3)))\n     (is (\x3d 3 (- 7 4))))\n\n   This creates functions named \\"addition\\" and \\"subtraction\\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel\'s \\"Practical Common Lisp\\"\n   \x3chttp://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html\x3e\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \\"(arithmetic addition)\\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n   DEFINING ASYNC TESTS\n\n   (deftest addition\n     (async done\n       (is (\x3d 4 (+ 2 2)))\n       (is (\x3d 7 (+ 3 4)))\n       (done)))\n\n   Async tests are constructed with the async macro. The first argument to\n   the macro is the test completion callback. The body of the async macro may\n   be any series of expressions. The completion callback must be invoked when\n   all assertions have run. There is no support for asynchronous coordination -\n   core.async is recommended for this. Note the body of the async test must be\n   truly asynchronous to avoid stack overflow.\n\n   RUNNING TESTS\n\n   Run tests with the function \\"(run-tests namespaces...)\\":\n\n   (run-tests \'your.namespace \'some.other.namespace)\n\n   If you don\'t specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \\"(run-all-tests)\\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \\"arithmetic\\" example above, you\n   probably do not want the \\"addition\\" and \\"subtraction\\" tests run\n   separately.  In that case, you must define a special function\n   named \\"test-ns-hook\\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \\"run-tests\\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \\"empty-env\\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \\"test-ns\\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \\"run-tests\\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \\":load-tests\\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \\"deftest\\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is a map of one or two functions that run code before and\n   after tests.  It looks like this:\n\n   {:before (fn []\n              Perform setup, establish bindings, whatever.\n              )\n    :after (fn []\n             Tear-down / clean-up code here.\n             )}\n\n   Both are optional and can be left out.\n\n   Fixtures are attached to namespaces in one of two ways.  \\"each\\"\n   fixtures are run repeatedly, once for each test function created\n   with \\"deftest\\".  \\"each\\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \\"each\\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just maps like the example above.\n   They can also be passed directly, like this:\n   (use-fixtures :each\n     {:before (fn [] setup...), :after (fn [] cleanup...)})\n\n   The other kind of fixture, a \\"once\\" fixture, is only run once,\n   around ALL the tests in the namespace.  \\"once\\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \\"once\\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   WRAPPING FIXTURES\n\n   Instead of a map, a fixture can be specified like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   This style is incompatible with async tests. If an async test is\n   encountered, testing will be aborted. It can\'t be mixed with\n   fixtures specified as maps.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \\"is\\" macro by defining new\n   methods for the \\"assert-expr\\" multimethod.  These methods are\n   called during expansion of the \\"is\\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \\"report\\" multimethod.\n\n   The \'event\' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to \'is\'\n\n   The \\"testing\\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n"}\n  cljs.test\n  (:require-macros [clojure.template :as temp]\n                   [cljs.test :as test])\n  (:require [clojure.string :as string]\n            [cljs.pprint :as pprint]))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Default Reporting\n\n(defn empty-env\n  "Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report"\n  ([] (empty-env ::default))\n  ([reporter]\n   (cond-\x3e {:report-counters {:test 0 :pass 0 :fail 0 :error 0}\n            :testing-vars ()\n            :testing-contexts ()\n            :formatter pr-str\n            :reporter reporter}\n     (\x3d ::pprint reporter) (assoc :reporter ::default\n                             :formatter pprint/pprint))))\n\n(def ^:dynamic *current-env* nil)\n\n(defn get-current-env []\n  (or *current-env* (empty-env)))\n\n(defn update-current-env! [ks f \x26 args]\n  (set! *current-env* (apply update-in (get-current-env) ks f args)))\n\n(defn set-env! [new-env]\n  (set! *current-env* new-env))\n\n(defn clear-env! []\n  (set! *current-env* nil))\n\n(defn get-and-clear-env! []\n  "Like get-current-env, but cleans env before returning."\n  (let [env (cljs.test/get-current-env)]\n    (clear-env!)\n    env))\n\n(defn testing-vars-str\n  "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion."\n  [m]\n  (let [{:keys [file line column]} m]\n    (str\n      (reverse (map #(:name (meta %)) (:testing-vars (get-current-env))))\n      " (" file ":" line (when column (str ":" column)) ")")))\n\n(defn testing-contexts-str\n  "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces."\n  []\n  (apply str (interpose " " (reverse (:testing-contexts (get-current-env))))))\n\n(defn inc-report-counter!\n  "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil."\n  [name]\n  (if (:report-counters (get-current-env))\n    (update-current-env! [:report-counters name] (fnil inc 0))))\n\n(defmulti\n  ^{:doc "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   \'is\' call \'report\' to indicate results.  The argument given to\n   \'report\' will be a map with a :type key."\n     :dynamic true}\n  report (fn [m] [(:reporter (get-current-env)) (:type m)]))\n\n(defmethod report :default [m])\n\n(defmethod report [::default :pass] [m]\n  (inc-report-counter! :pass))\n\n(defn- print-comparison [m]\n  (let [formatter-fn (or (:formatter (get-current-env)) pr-str)]\n    (println "expected:" (formatter-fn (:expected m)))\n    (println "  actual:" (formatter-fn (:actual m)))))\n\n(defmethod report [::default :fail] [m]\n  (inc-report-counter! :fail)\n  (println "\\nFAIL in" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))\n\n(defmethod report [::default :error] [m]\n  (inc-report-counter! :error)\n  (println "\\nERROR in" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))\n\n(defmethod report [::default :summary] [m]\n  (println "\\nRan" (:test m) "tests containing"\n    (+ (:pass m) (:fail m) (:error m)) "assertions.")\n  (println (:fail m) "failures," (:error m) "errors."))\n\n(defmethod report [::default :begin-test-ns] [m]\n  (println "\\nTesting" (name (:ns m))))\n\n;; Ignore these message types:\n(defmethod report [::default :end-test-ns] [m])\n(defmethod report [::default :begin-test-var] [m]\n  #_(println ":begin-test-var" (testing-vars-str m)))\n(defmethod report [::default :end-test-var] [m])\n(defmethod report [::default :end-run-tests] [m])\n(defmethod report [::default :end-test-all-vars] [m])\n(defmethod report [::default :end-test-vars] [m])\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; File, Line, and Column Helpers\n\n(defn js-line-and-column [stack-element]\n  "Returns a 2-element vector containing the line and\n  column encoded at the end of a stack element string.\n  A line or column will be represented as NaN if not\n  parsesable."\n  (let [parts (.split stack-element ":")\n        cnt   (count parts)]\n    (if (\x3e cnt 1)\n      [(js/parseInt (nth parts (- cnt 2)) 10)\n       (js/parseInt (nth parts (dec cnt)) 10)]\n      [##NaN ##NaN])))\n\n(defn js-filename [stack-element]\n  (let [output-dir (cljs.test/cljs-output-dir)\n        output-dir (cond-\x3e output-dir\n                     (not (string/ends-with? output-dir "/"))\n                     (str "/"))]\n    (-\x3e (.split stack-element output-dir)\n      last\n      (.split ":")\n      first)))\n\n(defn mapped-line-and-column [filename line column]\n  (let [default [filename line column]]\n    (if-let [source-map (:source-map (get-current-env))]\n      ;; source maps are 0 indexed for lines\n      (if-let [columns (get-in source-map [filename (dec line)])]\n        (vec\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; just take first\n            (first\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:source :line :col]))\n        default)\n      default)))\n\n(defn file-and-line [exception depth]\n  ;; TODO: flesh out\n  (if-let [stack-element (and (string? (.-stack exception))\n                              (some-\x3e (.-stack exception)\n                                      string/split-lines\n                                      (get depth)\n                                      string/trim))]\n    (let [fname (js-filename stack-element)\n          [line column] (js-line-and-column stack-element)\n          [fname line column] (mapped-line-and-column fname line column)]\n      {:file fname :line line :column column})\n    {:file (.-fileName exception)\n     :line (.-lineNumber exception)}))\n\n(defn do-report [m]\n  (let [m (case (:type m)\n            :fail (merge (file-and-line (js/Error.) 4) m)\n            :error (merge (file-and-line (:actual m) 0) m)\n            m)]\n    (report m)))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Async\n\n(defprotocol IAsyncTest\n  "Marker protocol denoting CPS function to begin asynchronous\n  testing.")\n\n(defn async?\n  "Returns whether x implements IAsyncTest."\n  [x]\n  (satisfies? IAsyncTest x))\n\n(defn run-block\n  "Invoke all functions in fns with no arguments. A fn can optionally\n  return\n\n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn"\n  [fns]\n  (when-first [f fns]\n    (let [obj (f)]\n      (if (async? obj)\n        (obj (let [d (delay (run-block (rest fns)))]\n               (fn []\n                 (if (realized? d)\n                   (println "WARNING: Async test called done more than one time.")\n                   @d))))\n        (recur (cond-\x3e\x3e (rest fns)\n                 (::block? (meta obj)) (concat obj)))))))\n\n(defn block\n  "Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block."\n  [fns]\n  (some-\x3e fns\n          (vary-meta assoc ::block? true)))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Low-level functions\n\n(defn- test-var-block*\n  [v t]\n  {:pre [(instance? Var v)]}\n  [(fn []\n     (update-current-env! [:testing-vars] conj v)\n     (update-current-env! [:report-counters :test] inc)\n     (do-report {:type :begin-test-var :var v})\n     (try\n       (t)\n       (catch :default e\n         (case e\n           ::async-disabled (throw "Async tests require fixtures to be specified as maps.  Testing aborted.")\n           (do-report\n            {:type :error\n             :message "Uncaught exception, not in assertion."\n             :expected nil\n             :actual e})))))\n   (fn []\n     (do-report {:type :end-test-var :var v})\n     (update-current-env! [:testing-vars] rest))])\n\n(defn test-var-block\n  "Like test-var, but returns a block for further composition and\n  later execution."\n  [v]\n  (if-let [t (:test (meta v))]\n    (test-var-block* v t)))\n\n(defn test-var\n  "If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env."\n  [v]\n  (run-block (test-var-block v)))\n\n(defn- default-fixture\n  "The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures."\n  [f]\n  (f))\n\n(defn compose-fixtures\n  "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures."\n  [f1 f2]\n  (fn [g] (f1 (fn [] (f2 g)))))\n\n(defn join-fixtures\n  "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures."\n  [fixtures]\n  (reduce compose-fixtures default-fixture fixtures))\n\n(defn- wrap-map-fixtures\n  "Wraps block in map-fixtures."\n  [map-fixtures block]\n  (concat (keep :before map-fixtures)\n          block\n          (reverse (keep :after map-fixtures))))\n\n(defn- execution-strategy [once each]\n  (letfn [(fixtures-type [coll]\n            (cond\n              (empty? coll) :none\n              (every? map? coll) :map\n              (every? fn? coll) :fn))\n          (fixtures-types []\n            (-\x3e\x3e (map fixtures-type [once each])\n              (remove #{:none})\n              (distinct)))]\n    (let [[type :as types] (fixtures-types)]\n      (assert (not-any? nil? types)\n        "Fixtures may not be of mixed types")\n      (assert (\x3e 2 (count types))\n        "fixtures specified in :once and :each must be of the same type")\n      ({:map :async :fn :sync} type :async))))\n\n(defn- disable-async [f]\n  (fn []\n    (let [obj (f)]\n      (when (async? obj)\n        (throw ::async-disabled))\n      obj)))\n\n(defn test-vars-block\n  "Like test-vars, but returns a block for further composition and\n  later execution."\n  [vars]\n  (map\n   (fn [[ns vars]]\n     (fn []\n       (block\n        (let [env (get-current-env)\n              once-fixtures (get-in env [:once-fixtures ns])\n              each-fixtures (get-in env [:each-fixtures ns])]\n          (case (execution-strategy once-fixtures each-fixtures)\n            :async\n            (-\x3e\x3e vars\n                 (filter (comp :test meta))\n                 (mapcat (comp (partial wrap-map-fixtures each-fixtures)\n                               test-var-block))\n                 (wrap-map-fixtures once-fixtures))\n            :sync\n            (let [each-fixture-fn (join-fixtures each-fixtures)]\n              [(fn []\n                 ((join-fixtures once-fixtures)\n                  (fn []\n                    (doseq [v vars]\n                      (when-let [t (:test (meta v))]\n                        ;; (alter-meta! v update :test disable-async)\n                        (each-fixture-fn\n                         (fn []\n                           ;; (test-var v)\n                           (run-block\n                            (test-var-block* v (disable-async t))))))))))]))))))\n   (group-by (comp :ns meta) vars)))\n\n(defn test-vars\n  "Groups vars by their namespace and runs test-vars on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment."\n  [vars]\n  (run-block (concat (test-vars-block vars)\n                     [(fn []\n                        (report {:type :end-test-vars :vars vars}))])))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Running Tests, high level functions\n\n(defn successful?\n  "Returns true if the given test summary indicates all tests\n  were successful, false otherwise."\n  [summary]\n  (and (zero? (:fail summary 0))\n       (zero? (:error summary 0))))\n'],
null),new p(null,3,[Cl,"cljs/spec/gen/alpha.cljs",Xn,"cljs.spec.gen.alpha",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.gen.alpha\n  (:refer-clojure :exclude [boolean cat hash-map list map not-empty set vector\n                            char double int keyword symbol string uuid delay shuffle])\n  (:require-macros [cljs.core :as c]\n                   [cljs.spec.gen.alpha :as gen :refer [dynaload lazy-combinators lazy-prims]])\n  (:require [cljs.core :as c])\n  (:import (goog Uri)))\n\n(deftype LazyVar [f ^:mutable cached]\n  IDeref\n  (-deref [this]\n    (if-not (nil? cached)\n      cached\n      (let [x (f)]\n        (when-not (nil? x)\n          (set! cached x))\n        x))))\n\n(def ^:private quick-check-ref\n  (dynaload \'clojure.test.check/quick-check))\n\n(defn quick-check\n  [\x26 args]\n  (apply @quick-check-ref args))\n\n(def ^:private for-all*-ref\n  (dynaload \'clojure.test.check.properties/for-all*))\n\n(defn for-all*\n  "Dynamically loaded clojure.test.check.properties/for-all*."\n  [\x26 args]\n  (apply @for-all*-ref args))\n\n(let [g? (dynaload \'clojure.test.check.generators/generator?)\n      g (dynaload \'clojure.test.check.generators/generate)\n      mkg (dynaload \'clojure.test.check.generators/-\x3eGenerator)]\n  (defn- generator?\n    [x]\n    (@g? x))\n  (defn- generator\n    [gfn]\n    (@mkg gfn))\n  (defn generate\n    "Generate a single value using generator."\n    [generator]\n    (@g generator)))\n\n(defn ^:skip-wiki delay-impl\n  [gfnd]\n  ;;N.B. depends on test.check impl details\n  (generator (fn [rnd size]\n               ((:gen @gfnd) rnd size))))\n\n;(defn gen-for-name\n;  "Dynamically loads test.check generator named s."\n;  [s]\n;  (let [g (dynaload s)]\n;    (if (generator? g)\n;      g\n;      (throw (js/Error. (str "Var " s " is not a generator"))))))\n\n(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)\n\n(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)\n\n(defn cat\n  "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential."\n  [\x26 gens]\n  (fmap #(apply concat %)\n    (apply tuple gens)))\n\n(defn- ^boolean qualified? [ident] (not (nil? (namespace ident))))\n\n(def ^:private\ngen-builtins\n  (c/delay\n    (let [simple (simple-type-printable)]\n      {any? (one-of [(return nil) (any-printable)])\n       some? (such-that some? (any-printable))\n       number? (one-of [(large-integer) (double)])\n       integer? (large-integer)\n       int? (large-integer)\n       pos-int? (large-integer* {:min 1})\n       neg-int? (large-integer* {:max -1})\n       nat-int? (large-integer* {:min 0})\n       float? (double)\n       double? (double)\n       string? (string-alphanumeric)\n       ident? (one-of [(keyword-ns) (symbol-ns)])\n       simple-ident? (one-of [(keyword) (symbol)])\n       qualified-ident? (such-that qualified? (one-of [(keyword-ns) (symbol-ns)]))\n       keyword? (keyword-ns)\n       simple-keyword? (keyword)\n       qualified-keyword? (such-that qualified? (keyword-ns))\n       symbol? (symbol-ns)\n       simple-symbol? (symbol)\n       qualified-symbol? (such-that qualified? (symbol-ns))\n       uuid? (uuid)\n       uri? (fmap #(Uri. (str "http://" % ".com")) (uuid))\n       inst? (fmap #(js/Date. %)\n                    (large-integer))\n       seqable? (one-of [(return nil)\n                         (list simple)\n                         (vector simple)\n                         (map simple simple)\n                         (set simple)\n                         (string-alphanumeric)])\n       indexed? (vector simple)\n       map? (map simple simple)\n       vector? (vector simple)\n       list? (list simple)\n       seq? (list simple)\n       char? (char)\n       set? (set simple)\n       nil? (return nil)\n       false? (return false)\n       true? (return true)\n       boolean? (boolean)\n       zero? (return 0)\n       ;rational? (one-of [(large-integer) (ratio)])\n       coll? (one-of [(map simple simple)\n                      (list simple)\n                      (vector simple)\n                      (set simple)])\n       empty? (elements [nil \'() [] {} #{}])\n       associative? (one-of [(map simple simple) (vector simple)])\n       sequential? (one-of [(list simple) (vector simple)])\n       ;ratio? (such-that ratio? (ratio))\n       })))\n\n(defn gen-for-pred\n  "Given a predicate, returns a built-in generator if one exists."\n  [pred]\n  (if (set? pred)\n    (elements pred)\n    (get @gen-builtins pred)))\n\n(comment\n  (require \'clojure.test.check)\n  (require \'clojure.test.check.properties)\n  (require \'cljs.spec.gen)\n  (in-ns \'cljs.spec.gen)\n\n  ;; combinators, see call to lazy-combinators above for complete list\n  (generate (one-of [(gen-for-pred integer?) (gen-for-pred string?)]))\n  (generate (such-that #(\x3c 10000 %) (gen-for-pred integer?)))\n  (let [reqs {:a (gen-for-pred number?)\n              :b (gen-for-pred keyword?)}\n        opts {:c (gen-for-pred string?)}]\n    (generate (bind (choose 0 (count opts))\n                #(let [args (concat (seq reqs) (c/shuffle (seq opts)))]\n                  (-\x3e\x3e args\n                    (take (+ % (count reqs)))\n                    (mapcat identity)\n                    (apply hash-map))))))\n  (generate (cat (list (gen-for-pred string?))\n              (list (gen-for-pred integer?))))\n\n  ;; load your own generator\n  ;(gen-for-name \'clojure.test.check.generators/int)\n\n  ;; failure modes\n  ;(gen-for-name \'unqualified)\n  ;(gen-for-name \'clojure.core/+)\n  ;(gen-for-name \'clojure.core/name-does-not-exist)\n  ;(gen-for-name \'ns.does.not.exist/f)\n\n  )\n\n\n'],
null),new p(null,3,[Cl,"cljs/core.cljc",Xn,"cljs.core",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.core\n  (:refer-clojure :exclude [-\x3e -\x3e\x3e .. amap and areduce alength aclone assert assert-args binding bound-fn case comment\n                            cond condp declare definline definterface defmethod defmulti defn defn- defonce\n                            defprotocol defrecord defstruct deftype delay destructure doseq dosync dotimes doto\n                            extend-protocol extend-type fn for future gen-class gen-interface\n                            if-let if-not import io! lazy-cat lazy-seq let letfn locking loop\n                            memfn ns or proxy proxy-super pvalues refer-clojure reify sync time\n                            when when-first when-let when-not while with-bindings with-in-str\n                            with-loading-context with-local-vars with-open with-out-str with-precision with-redefs\n                            satisfies? identical? true? false? number? nil? instance? symbol? keyword? string? str get\n                            make-array vector list hash-map array-map hash-set\n\n                            aget aset\n                            + - * / \x3c \x3c\x3d \x3e \x3e\x3d \x3d\x3d zero? pos? neg? inc dec max min mod\n                            byte char short int long float double\n                            unchecked-byte unchecked-char unchecked-short unchecked-int\n                            unchecked-long unchecked-float unchecked-double\n                            unchecked-add unchecked-add-int unchecked-dec unchecked-dec-int\n                            unchecked-divide unchecked-divide-int unchecked-inc unchecked-inc-int\n                            unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int\n                            unchecked-subtract unchecked-subtract-int unchecked-remainder-int\n                            unsigned-bit-shift-right\n\n                            bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set\n                            bit-test bit-shift-left bit-shift-right bit-xor defmacro\n\n                            cond-\x3e cond-\x3e\x3e as-\x3e some-\x3e some-\x3e\x3e\n\n                            require use refer-clojure\n\n                            if-some when-some test ns-publics ns-imports ns-interns\n                            ns-unmap var vswap! macroexpand-1 macroexpand\n                            some? resolve\n                            #?@(:cljs [alias coercive-not coercive-not\x3d coercive-\x3d coercive-boolean\n                                       truth_ js-arguments js-delete js-in js-debugger exists? divide js-mod\n                                       unsafe-bit-and bit-shift-right-zero-fill mask bitpos caching-hash\n                                       defcurried rfn specify! js-this this-as implements? array js-obj\n                                       simple-benchmark gen-apply-to js-str es6-iterable load-file* undefined?\n                                       specify copy-arguments goog-define js-comment js-inline-comment\n                                       unsafe-cast require-macros use-macros gen-apply-to-simple unchecked-get unchecked-set])])\n  #?(:cljs (:require-macros [cljs.core :as core]\n                            [cljs.support :refer [assert-args]]))\n  (:require clojure.walk\n            clojure.set\n            [clojure.string :as string]\n            [cljs.compiler :as comp]\n            [cljs.env :as env]\n            #?(:clj [cljs.support :refer [assert-args]])\n            #?(:cljs [cljs.core :as core])\n            #?(:cljs [cljs.analyzer :as ana])))\n\n#?(:clj (alias \'core \'clojure.core))\n#?(:clj (alias \'ana \'cljs.analyzer))\n\n#?(:clj\n   (core/defmacro import-macros [ns [\x26 vars]]\n     (core/let [ns (find-ns ns)\n                vars (map #(ns-resolve ns %) vars)\n                syms (map\n                       (core/fn [^clojure.lang.Var v]\n                         (core/-\x3e v .sym\n                           (with-meta\n                             (merge\n                               {:macro true}\n                               (update-in (select-keys (meta v) [:arglists :doc :file :line])\n                                 [:arglists] (core/fn [arglists] `(quote ~arglists)))))))\n                       vars)\n                defs (map\n                       (core/fn [sym var]\n                         (core/let [{:keys [arglists doc file line]} (meta sym)]\n                           `(do\n                              (def ~sym (deref ~var))\n                              ;for AOT compilation\n                              (alter-meta! (var ~sym) assoc\n                                :macro true\n                                :arglists ~arglists\n                                :doc ~doc\n                                :file ~file\n                                :line ~line))))\n                       syms vars)]\n       `(do ~@defs\n            :imported))))\n\n#?(:clj\n   (import-macros clojure.core\n     [-\x3e -\x3e\x3e .. assert comment cond\n      declare defn-\n      extend-protocol fn for\n      if-let if-not letfn\n      memfn\n      when when-first when-let when-not while\n      cond-\x3e cond-\x3e\x3e as-\x3e some-\x3e some-\x3e\x3e\n      if-some when-some]))\n\n#?(:cljs\n   (core/defmacro -\x3e\n     "Threads the expr through the forms. Inserts x as the\n     second item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     second item in second form, etc."\n     [x \x26 forms]\n     (core/loop [x x, forms forms]\n       (if forms\n         (core/let [form (first forms)\n                    threaded (if (seq? form)\n                               (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n                               (core/list form x))]\n           (recur threaded (next forms)))\n         x))))\n\n#?(:cljs\n   (core/defmacro -\x3e\x3e\n     "Threads the expr through the forms. Inserts x as the\n     last item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     last item in second form, etc."\n     [x \x26 forms]\n     (core/loop [x x, forms forms]\n       (if forms\n         (core/let [form (first forms)\n                    threaded (if (seq? form)\n                               (with-meta `(~(first form) ~@(next form) ~x) (meta form))\n                               (core/list form x))]\n           (recur threaded (next forms)))\n         x))))\n\n#?(:cljs\n   (core/defmacro ..\n     "form \x3d\x3e fieldName-symbol or (instanceMethodName-symbol args*)\n\n     Expands into a member access (.) of the first member on the first\n     argument, followed by the next member on the result, etc. For\n     instance:\n\n     (.. System (getProperties) (get \\"os.name\\"))\n\n     expands to:\n\n     (. (. System (getProperties)) (get \\"os.name\\"))\n\n     but is easier to write, read, and understand."\n     ([x form] `(. ~x ~form))\n     ([x form \x26 more] `(.. (. ~x ~form) ~@more))))\n\n#?(:cljs\n   (core/defmacro comment\n     "Ignores body, yields nil"\n     [\x26 body]))\n\n#?(:cljs\n   (core/defmacro cond\n     "Takes a set of test/expr pairs. It evaluates each test one at a\n     time.  If a test returns logical true, cond evaluates and returns\n     the value of the corresponding expr and doesn\'t evaluate any of the\n     other tests or exprs. (cond) returns nil."\n     {:added "1.0"}\n     [\x26 clauses]\n     (core/when clauses\n       (core/list \'if (first clauses)\n         (if (next clauses)\n           (second clauses)\n           (throw (js/Error. "cond requires an even number of forms")))\n         (cons \'cljs.core/cond (next (next clauses)))))))\n\n#?(:cljs\n   (core/defmacro declare\n     "defs the supplied var names with no bindings, useful for making forward declarations."\n     [\x26 names] `(do ~@(map #(core/list \'def (vary-meta % assoc :declared true)) names))))\n\n(core/defmacro doto\n  "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new js/Map) (.set \\"a\\" 1) (.set \\"b\\" 2))"\n  [x \x26 forms]\n  (core/let [gx (gensym)]\n    `(let [~gx ~x]\n       ~@(map (core/fn [f]\n                (if (seq? f)\n                  `(~(first f) ~gx ~@(next f))\n                  `(~f ~gx)))\n           forms)\n       ~gx)))\n\n#?(:cljs\n   (core/defn- parse-impls [specs]\n     (core/loop [ret {} s specs]\n       (if (seq s)\n         (recur (assoc ret (first s) (take-while seq? (next s)))\n           (drop-while seq? (next s)))\n         ret))))\n\n#?(:cljs\n   (core/defn- emit-extend-protocol [p specs]\n     (core/let [impls (parse-impls specs)]\n       `(do\n          ~@(map (core/fn [[t fs]]\n                   `(extend-type ~t ~p ~@fs))\n              impls)))))\n\n#?(:cljs\n   (core/defmacro extend-protocol\n     "Useful when you want to provide several implementations of the same\n     protocol all at once. Takes a single protocol and the implementation\n     of that protocol for one or more types. Expands into calls to\n     extend-type:\n\n     (extend-protocol Protocol\n       AType\n         (foo [x] ...)\n         (bar [x y] ...)\n       BType\n         (foo [x] ...)\n         (bar [x y] ...)\n       AClass\n         (foo [x] ...)\n         (bar [x y] ...)\n       nil\n         (foo [x] ...)\n         (bar [x y] ...))\n\n     expands into:\n\n     (do\n      (clojure.core/extend-type AType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type BType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type AClass Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type nil Protocol\n        (foo [x] ...)\n        (bar [x y] ...)))"\n     [p \x26 specs]\n     (emit-extend-protocol p specs)))\n\n#?(:cljs\n   (core/defn ^{:private true}\n   maybe-destructured\n     [params body]\n     (if (every? core/symbol? params)\n       (cons params body)\n       (core/loop [params params\n                   new-params (with-meta [] (meta params))\n                   lets []]\n         (if params\n           (if (core/symbol? (first params))\n             (recur (next params) (conj new-params (first params)) lets)\n             (core/let [gparam (gensym "p__")]\n               (recur (next params) (conj new-params gparam)\n                 (core/-\x3e lets (conj (first params)) (conj gparam)))))\n           `(~new-params\n              (let ~lets\n                ~@body)))))))\n\n#?(:cljs\n   (core/defmacro fn\n     "params \x3d\x3e positional-params* , or positional-params* \x26 next-param\n     positional-param \x3d\x3e binding-form\n     next-param \x3d\x3e binding-form\n     name \x3d\x3e symbol\n\n     Defines a function"\n     {:forms \'[(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)]}\n     [\x26 sigs]\n     (core/let [name (if (core/symbol? (first sigs)) (first sigs) nil)\n                sigs (if name (next sigs) sigs)\n                sigs (if (vector? (first sigs))\n                       (core/list sigs)\n                       (if (seq? (first sigs))\n                         sigs\n                         ;; Assume single arity syntax\n                         (throw (js/Error.\n                                  (if (seq sigs)\n                                    (core/str "Parameter declaration "\n                                      (core/first sigs)\n                                      " should be a vector")\n                                    (core/str "Parameter declaration missing"))))))\n                psig (fn* [sig]\n                       ;; Ensure correct type before destructuring sig\n                       (core/when (not (seq? sig))\n                         (throw (js/Error.\n                                  (core/str "Invalid signature " sig\n                                    " should be a list"))))\n                       (core/let [[params \x26 body] sig\n                                  _ (core/when (not (vector? params))\n                                      (throw (js/Error.\n                                               (if (seq? (first sigs))\n                                                 (core/str "Parameter declaration " params\n                                                   " should be a vector")\n                                                 (core/str "Invalid signature " sig\n                                                   " should be a list")))))\n                                  conds (core/when (core/and (next body) (map? (first body)))\n                                          (first body))\n                                  body (if conds (next body) body)\n                                  conds (core/or conds (meta params))\n                                  pre (:pre conds)\n                                  post (:post conds)\n                                  body (if post\n                                         `((let [~\'% ~(if (core/\x3c 1 (count body))\n                                                        `(do ~@body)\n                                                        (first body))]\n                                             ~@(map (fn* [c] `(assert ~c)) post)\n                                             ~\'%))\n                                         body)\n                                  body (if pre\n                                         (concat (map (fn* [c] `(assert ~c)) pre)\n                                           body)\n                                         body)]\n                         (maybe-destructured params body)))\n                new-sigs (map psig sigs)]\n       (with-meta\n         (if name\n           (list* \'fn* name new-sigs)\n           (cons \'fn* new-sigs))\n         (meta \x26form)))))\n\n#?(:cljs\n   (core/defmacro defn-\n     "same as defn, yielding non-public def"\n     [name \x26 decls]\n     (list* `defn (with-meta name (assoc (meta name) :private true)) decls)))\n\n#?(:cljs\n   (core/defmacro if-let\n     "bindings \x3d\x3e binding-form test\n\n     If test is true, evaluates then with binding-form bound to the value of\n     test, if not, yields else"\n     ([bindings then]\n      `(if-let ~bindings ~then nil))\n     ([bindings then else \x26 oldform]\n      (assert-args if-let\n        (vector? bindings) "a vector for its binding"\n        (empty? oldform) "1 or 2 forms after binding vector"\n        (\x3d 2 (count bindings)) "exactly 2 forms in binding vector")\n      (core/let [form (bindings 0) tst (bindings 1)]\n        `(let [temp# ~tst]\n           (if temp#\n             (let [~form temp#]\n               ~then)\n             ~else))))))\n\n#?(:cljs\n   (core/defmacro if-not\n     "Evaluates test. If logical false, evaluates and returns then expr,\n     otherwise else expr, if supplied, else nil."\n     ([test then] `(if-not ~test ~then nil))\n     ([test then else]\n      `(if (not ~test) ~then ~else))))\n\n#?(:cljs\n   (core/defmacro letfn\n     "fnspec \x3d\x3d\x3e (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n     Takes a vector of function specs and a body, and generates a set of\n     bindings of functions to their names. All of the names are available\n     in all of the definitions of the functions, as well as the body."\n     {:forms \'[(letfn [fnspecs*] exprs*)],\n      :special-form true, :url nil}\n     [fnspecs \x26 body]\n     `(letfn* ~(vec (interleave (map first fnspecs)\n                      (map #(cons `fn %) fnspecs)))\n        ~@body)))\n\n(core/defmacro memfn\n  "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn."\n  [name \x26 args]\n  (core/let [t (with-meta (gensym "target")\n                 (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))\n\n#?(:cljs\n   (core/defmacro when\n     "Evaluates test. If logical true, evaluates body in an implicit do."\n     [test \x26 body]\n     (core/list \'if test (cons \'do body))))\n\n#?(:cljs\n   (core/defmacro when-first\n     "bindings \x3d\x3e x xs\n\n     Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"\n     [bindings \x26 body]\n     (assert-args when-first\n       (vector? bindings) "a vector for its binding"\n       (\x3d 2 (count bindings)) "exactly 2 forms in binding vector")\n     (core/let [[x xs] bindings]\n       `(when-let [xs# (seq ~xs)]\n          (let [~x (first xs#)]\n            ~@body)))))\n\n#?(:cljs\n   (core/defmacro when-let\n     "bindings \x3d\x3e binding-form test\n\n     When test is true, evaluates body with binding-form bound to the value of test"\n     [bindings \x26 body]\n     (assert-args when-let\n       (vector? bindings) "a vector for its binding"\n       (\x3d 2 (count bindings)) "exactly 2 forms in binding vector")\n     (core/let [form (bindings 0) tst (bindings 1)]\n       `(let [temp# ~tst]\n          (when temp#\n            (let [~form temp#]\n              ~@body))))))\n\n#?(:cljs\n   (core/defmacro when-not\n     "Evaluates test. If logical false, evaluates body in an implicit do."\n     [test \x26 body]\n     (core/list \'if test nil (cons \'do body))))\n\n#?(:cljs\n   (core/defmacro while\n     "Repeatedly executes body while test expression is true. Presumes\n     some side-effect will cause test to become false/nil. Returns nil"\n     [test \x26 body]\n     `(loop []\n        (when ~test\n          ~@body\n          (recur)))))\n\n#?(:cljs\n   (core/defmacro cond-\x3e\n     "Takes an expression and a set of test/form pairs. Threads expr (via -\x3e)\n     through each form for which the corresponding test\n     expression is true. Note that, unlike cond branching, cond-\x3e threading does\n     not short circuit after the first true test expression."\n     [expr \x26 clauses]\n     (core/assert (even? (count clauses)))\n     (core/let [g (gensym)\n                steps (map (core/fn [[test step]] `(if ~test (-\x3e ~g ~step) ~g))\n                        (partition 2 clauses))]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro cond-\x3e\x3e\n     "Takes an expression and a set of test/form pairs. Threads expr (via -\x3e\x3e)\n     through each form for which the corresponding test expression\n     is true.  Note that, unlike cond branching, cond-\x3e\x3e threading does not short circuit\n     after the first true test expression."\n     [expr \x26 clauses]\n     (core/assert (even? (count clauses)))\n     (core/let [g (gensym)\n                steps (map (core/fn [[test step]] `(if ~test (-\x3e\x3e ~g ~step) ~g))\n                        (partition 2 clauses))]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro as-\x3e\n     "Binds name to expr, evaluates the first form in the lexical context\n     of that binding, then binds name to that result, repeating for each\n     successive form, returning the result of the last form."\n     [expr name \x26 forms]\n     `(let [~name ~expr\n            ~@(interleave (repeat name) (butlast forms))]\n        ~(if (empty? forms)\n           name\n           (last forms)))))\n\n#?(:cljs\n   (core/defmacro some-\x3e\n     "When expr is not nil, threads it into the first form (via -\x3e),\n     and when that result is not nil, through the next etc"\n     [expr \x26 forms]\n     (core/let [g (gensym)\n                steps (map (core/fn [step] `(if (nil? ~g) nil (-\x3e ~g ~step)))\n                        forms)]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro some-\x3e\x3e\n     "When expr is not nil, threads it into the first form (via -\x3e\x3e),\n     and when that result is not nil, through the next etc"\n     [expr \x26 forms]\n     (core/let [g (gensym)\n                steps (map (core/fn [step] `(if (nil? ~g) nil (-\x3e\x3e ~g ~step)))\n                        forms)]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro if-some\n     "bindings \x3d\x3e binding-form test\n\n      If test is not nil, evaluates then with binding-form bound to the\n      value of test, if not, yields else"\n     ([bindings then]\n      `(if-some ~bindings ~then nil))\n     ([bindings then else \x26 oldform]\n      (assert-args if-some\n        (vector? bindings) "a vector for its binding"\n        (empty? oldform) "1 or 2 forms after binding vector"\n        (\x3d 2 (count bindings)) "exactly 2 forms in binding vector")\n      (core/let [form (bindings 0) tst (bindings 1)]\n        `(let [temp# ~tst]\n           (if (nil? temp#)\n             ~else\n             (let [~form temp#]\n               ~then)))))))\n\n#?(:cljs\n   (core/defmacro when-some\n     "bindings \x3d\x3e binding-form test\n\n      When test is not nil, evaluates body with binding-form bound to the\n      value of test"\n     [bindings \x26 body]\n     (assert-args when-some\n       (vector? bindings) "a vector for its binding"\n       (\x3d 2 (count bindings)) "exactly 2 forms in binding vector")\n     (core/let [form (bindings 0) tst (bindings 1)]\n       `(let [temp# ~tst]\n          (if (nil? temp#)\n            nil\n            (let [~form temp#]\n              ~@body))))))\n\n(core/defn- ^{:dynamic true} assert-valid-fdecl\n  "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn."\n  [fdecl]\n  (core/when (empty? fdecl)\n    (throw\n      #?(:clj  (IllegalArgumentException. "Parameter declaration missing")\n         :cljs (js/Error. "Parameter declaration missing"))))\n  (core/let [argdecls\n             (map\n               #(if (seq? %)\n                 (first %)\n                 (throw\n                   #?(:clj (IllegalArgumentException.\n                             (if (seq? (first fdecl))\n                               (core/str "Invalid signature \\""\n                                 %\n                                 "\\" should be a list")\n                               (core/str "Parameter declaration \\""\n                                 %\n                                 "\\" should be a vector")))\n                      :cljs (js/Error.\n                              (if (seq? (first fdecl))\n                                (core/str "Invalid signature \\""\n                                  %\n                                  "\\" should be a list")\n                                (core/str "Parameter declaration \\""\n                                  %\n                                  "\\" should be a vector"))))))\n               fdecl)\n             bad-args (seq (remove #(vector? %) argdecls))]\n    (core/when bad-args\n      (throw\n        #?(:clj (IllegalArgumentException.\n                  (core/str "Parameter declaration \\"" (first bad-args)\n                    "\\" should be a vector"))\n           :cljs (js/Error.\n                   (core/str "Parameter declaration \\"" (first bad-args)\n                     "\\" should be a vector")))))))\n\n(def\n  ^{:private true}\n  sigs\n  (core/fn [fdecl]\n    (assert-valid-fdecl fdecl)\n    (core/let [asig\n               (core/fn [fdecl]\n                 (core/let [arglist (first fdecl)\n                            ;elide implicit macro args\n                            arglist (if #?(:clj (clojure.lang.Util/equals \'\x26form (first arglist))\n                                           :cljs (\x3d \'\x26form (first arglist)))\n                                      #?(:clj (clojure.lang.RT/subvec arglist 2 (clojure.lang.RT/count arglist))\n                                         :cljs (subvec arglist 2 (count arglist)))\n                                      arglist)\n                            body (next fdecl)]\n                   (if (map? (first body))\n                     (if (next body)\n                       (with-meta arglist (conj (if (meta arglist) (meta arglist) {}) (first body)))\n                       arglist)\n                     arglist)))]\n      (if (seq? (first fdecl))\n        (core/loop [ret [] fdecls fdecl]\n          (if fdecls\n            (recur (conj ret (asig (first fdecls))) (next fdecls))\n            (seq ret)))\n        (core/list (asig fdecl))))))\n\n(core/defmacro defonce\n  "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated"\n  [x init]\n  `(when-not (exists? ~x)\n     (def ~x ~init)))\n\n(core/defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n             pb (core/fn pb [bvec b v]\n                  (core/let [pvec\n                             (core/fn [bvec b val]\n                               (core/let [gvec (gensym "vec__")\n                                          gseq (gensym "seq__")\n                                          gfirst (gensym "first__")\n                                          has-rest (some #{\'\x26} b)]\n                                 (core/loop [ret (core/let [ret (conj bvec gvec val)]\n                                                   (if has-rest\n                                                     (conj ret gseq (core/list `seq gvec))\n                                                     ret))\n                                             n 0\n                                             bs b\n                                             seen-rest? false]\n                                   (if (seq bs)\n                                     (core/let [firstb (first bs)]\n                                       (core/cond\n                                         (\x3d firstb \'\x26) (recur (pb ret (second bs) gseq)\n                                                              n\n                                                              (nnext bs)\n                                                              true)\n                                         (\x3d firstb :as) (pb ret (second bs) gvec)\n                                         :else (if seen-rest?\n                                                 (throw #?(:clj (new Exception "Unsupported binding form, only :as can follow \x26 parameter")\n                                                           :cljs (new js/Error "Unsupported binding form, only :as can follow \x26 parameter")))\n                                                 (recur (pb (if has-rest\n                                                              (conj ret\n                                                                    gfirst `(first ~gseq)\n                                                                    gseq `(next ~gseq))\n                                                              ret)\n                                                            firstb\n                                                            (if has-rest\n                                                              gfirst\n                                                              (core/list `nth gvec n nil)))\n                                                        (core/inc n)\n                                                        (next bs)\n                                                        seen-rest?))))\n                                     ret))))\n                             pmap\n                             (core/fn [bvec b v]\n                               (core/let [gmap (gensym "map__")\n                                          defaults (:or b)]\n                                 (core/loop [ret (core/-\x3e bvec (conj gmap) (conj v)\n                                                          (conj gmap) (conj `(if (implements? ISeq ~gmap) (apply cljs.core/hash-map ~gmap) ~gmap))\n                                                     ((core/fn [ret]\n                                                        (if (:as b)\n                                                          (conj ret (:as b) gmap)\n                                                          ret))))\n                                             bes (core/let [transforms\n                                                            (reduce\n                                                              (core/fn [transforms mk]\n                                                                (if (core/keyword? mk)\n                                                                  (core/let [mkns (namespace mk)\n                                                                        mkn (name mk)]\n                                                                    (core/cond (\x3d mkn "keys") (assoc transforms mk #(keyword (core/or mkns (namespace %)) (name %)))\n                                                                               (\x3d mkn "syms") (assoc transforms mk #(core/list `quote (symbol (core/or mkns (namespace %)) (name %))))\n                                                                               (\x3d mkn "strs") (assoc transforms mk core/str)\n                                                                               :else transforms))\n                                                                  transforms))\n                                                              {}\n                                                              (keys b))]\n                                                   (reduce\n                                                     (core/fn [bes entry]\n                                                       (reduce #(assoc %1 %2 ((val entry) %2))\n                                                         (dissoc bes (key entry))\n                                                         ((key entry) bes)))\n                                                     (dissoc b :as :or)\n                                                     transforms))]\n                                   (if (seq bes)\n                                     (core/let [bb (key (first bes))\n                                                bk (val (first bes))\n                                                local (if #?(:clj  (core/instance? clojure.lang.Named bb)\n                                                             :cljs (cljs.core/implements? INamed bb))\n                                                          (with-meta (symbol nil (name bb)) (meta bb))\n                                                        bb)\n                                                bv (if (contains? defaults local)\n                                                     (core/list \'cljs.core/get gmap bk (defaults local))\n                                                     (core/list \'cljs.core/get gmap bk))]\n                                       (recur\n                                         (if (core/or (core/keyword? bb) (core/symbol? bb)) ;(ident? bb)\n                                           (core/-\x3e ret (conj local bv))\n                                           (pb ret bb bv))\n                                              (next bes)))\n                                     ret))))]\n                    (core/cond\n                      (core/symbol? b) (core/-\x3e bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (core/-\x3e bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw\n                             #?(:clj (new Exception (core/str "Unsupported binding form: " b))\n                                :cljs (new js/Error (core/str "Unsupported binding form: " b)))))))\n             process-entry (core/fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? core/symbol? (map first bents))\n      bindings\n      (core/if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n        (throw\n          #?(:clj (new Exception (core/str "Unsupported binding key: " (ffirst kwbs)))\n             :cljs (new js/Error (core/str "Unsupported binding key: " (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))\n\n(core/defmacro ^:private return-first\n  [\x26 body]\n  `(let [ret# ~(first body)]\n     ~@(rest body)\n     ret#))\n\n(core/defmacro goog-define\n  "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\\"your_app.core.DEBUG_BANG_\\" true}\n    or\n    :closure-defines {\'your-app.core/DEBUG! true}"\n  [sym default]\n  (assert-args goog-define\n   (core/or (core/string? default)\n            (core/number? default)\n            (core/true? default)\n            (core/false? default)) "a string, number or boolean as default value")\n  (core/let [defname (comp/munge (core/str *ns* "/" sym))\n             type    (core/cond\n                       (core/string? default) "string"\n                       (core/number? default) "number"\n                       (core/or (core/true? default) (core/false? default)) "boolean")]\n    `(~(if (:def-emits-var \x26env) `return-first `do)\n       (declare ~(core/vary-meta sym\n                   (core/fn [m]\n                     (core/cond-\x3e m\n                       (core/not (core/contains? m :tag))\n                       (core/assoc :tag (core/symbol type))\n                       ))))\n       (~\'js* ~(core/str "/** @define {" type "} */"))\n       (goog/define ~defname ~default))))\n\n(core/defmacro let\n  "binding \x3d\x3e binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein."\n  [bindings \x26 body]\n  (assert-args let\n     (vector? bindings) "a vector for its binding"\n     (even? (count bindings)) "an even number of forms in binding vector")\n  `(let* ~(destructure bindings) ~@body))\n\n(core/defmacro loop\n  "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target."\n  [bindings \x26 body]\n  (assert-args loop\n    (vector? bindings) "a vector for its binding"\n    (even? (count bindings)) "an even number of forms in binding vector")\n  (core/let [db (destructure bindings)]\n    (if (\x3d db bindings)\n      `(loop* ~bindings ~@body)\n      (core/let [vs (take-nth 2 (drop 1 bindings))\n                 bs (take-nth 2 bindings)\n                 gs (map (core/fn [b] (if (core/symbol? b) b (gensym))) bs)\n                 bfs (reduce (core/fn [ret [b v g]]\n                               (if (core/symbol? b)\n                                 (conj ret g v)\n                                 (conj ret g v b g)))\n                       [] (map core/vector bs vs gs))]\n        `(let ~bfs\n           (loop* ~(vec (interleave gs gs))\n             (let ~(vec (interleave bs gs))\n               ~@body)))))))\n\n(def fast-path-protocols\n  "protocol fqn -\x3e [partition number, bit]"\n  (zipmap (map #(symbol "cljs.core" (core/str %))\n               \'[IFn ICounted IEmptyableCollection ICollection IIndexed ASeq ISeq INext\n                 ILookup IAssociative IMap IMapEntry ISet IStack IVector IDeref\n                 IDerefWithTimeout IMeta IWithMeta IReduce IKVReduce IEquiv IHash\n                 ISeqable ISequential IList IRecord IReversible ISorted IPrintWithWriter IWriter\n                 IPrintWithWriter IPending IWatchable IEditableCollection ITransientCollection\n                 ITransientAssociative ITransientMap ITransientVector ITransientSet\n                 IMultiFn IChunkedSeq IChunkedNext IComparable INamed ICloneable IAtom\n                 IReset ISwap IIterable])\n          (iterate (core/fn [[p b]]\n                     (if (core/\x3d\x3d 2147483648 b)\n                       [(core/inc p) 1]\n                       [p #?(:clj  (core/bit-shift-left b 1)\n                             :cljs (core/* 2 b))]))\n                   [0 1])))\n\n(def fast-path-protocol-partitions-count\n  "total number of partitions"\n  (core/let [c (count fast-path-protocols)\n             m (core/mod c 32)]\n    (if (core/zero? m)\n      (core/quot c 32)\n      (core/inc (core/quot c 32)))))\n\n(core/defn- compatible? [inferred-tag allowed-tags]\n  (if (set? inferred-tag)\n    (clojure.set/subset? inferred-tag allowed-tags)\n    (contains? allowed-tags inferred-tag)))\n\n(core/defn- typed-expr? [env form allowed-tags]\n  (compatible? (cljs.analyzer/infer-tag env\n                 (cljs.analyzer/no-warn (cljs.analyzer/analyze env form)))\n    allowed-tags))\n\n(core/defn- string-expr [e]\n  (vary-meta e assoc :tag \'string))\n\n(core/defmacro str\n  ([] "")\n  ([x]\n   (if (typed-expr? \x26env x \'#{string})\n     x\n     (string-expr (core/list \'js* "cljs.core.str.cljs$core$IFn$_invoke$arity$1(~{})" x))))\n  ([x \x26 ys]\n   (core/let [interpolate (core/fn [x]\n                            (if (typed-expr? \x26env x \'#{string clj-nil})\n                              "~{}"\n                              "cljs.core.str.cljs$core$IFn$_invoke$arity$1(~{})"))\n              strs        (core/-\x3e\x3e (core/list* x ys)\n                            (map interpolate)\n                            (interpose ",")\n                            (apply core/str))]\n     (string-expr (list* \'js* (core/str "[" strs "].join(\'\')") x ys)))))\n\n(core/defn- bool-expr [e]\n  (vary-meta e assoc :tag \'boolean))\n\n(core/defn- simple-test-expr? [env ast]\n  (core/and\n    (#{:var :js-var :local :invoke :const :host-field :host-call :js :quote} (:op ast))\n    (\'#{boolean seq} (cljs.analyzer/infer-tag env ast))))\n\n(core/defmacro and\n  "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn\'t evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true."\n  ([] true)\n  ([x] x)\n  ([x \x26 next]\n   (core/let [forms (concat [x] next)]\n     (if (every? #(simple-test-expr? \x26env %)\n           (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze \x26env %)) forms))\n       (core/let [and-str (core/-\x3e\x3e (repeat (count forms) "(~{})")\n                            (interpose " \x26\x26 ")\n                            (#(concat ["("] % [")"]))\n                            (apply core/str))]\n         (bool-expr `(~\'js* ~and-str ~@forms)))\n       `(let [and# ~x]\n          (if and# (and ~@next) and#))))))\n\n(core/defmacro or\n  "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn\'t\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil."\n  ([] nil)\n  ([x] x)\n  ([x \x26 next]\n   (core/let [forms (concat [x] next)]\n     (if (every? #(simple-test-expr? \x26env %)\n           (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze \x26env %)) forms))\n       (core/let [or-str (core/-\x3e\x3e (repeat (count forms) "(~{})")\n                           (interpose " || ")\n                           (#(concat ["("] % [")"]))\n                           (apply core/str))]\n         (bool-expr `(~\'js* ~or-str ~@forms)))\n       `(let [or# ~x]\n          (if or# or# (or ~@next)))))))\n\n(core/defmacro nil? [x]\n  `(coercive-\x3d ~x nil))\n\n(core/defmacro some? [x]\n  `(not (nil? ~x)))\n\n(core/defmacro coercive-not [x]\n  (bool-expr (core/list \'js* "(!~{})" x)))\n\n(core/defmacro coercive-not\x3d [x y]\n  (bool-expr (core/list \'js* "(~{} !\x3d ~{})" x y)))\n\n(core/defmacro coercive-\x3d [x y]\n  (bool-expr (core/list \'js* "(~{} \x3d\x3d ~{})" x y)))\n\n(core/defmacro coercive-boolean [x]\n  (with-meta (core/list \'js* "~{}" x)\n    {:tag \'boolean}))\n\n;; internal - do not use.\n(core/defmacro truth_ [x]\n  (core/assert (core/symbol? x) "x is substituted twice")\n  (core/list \'js* "(~{} !\x3d null \x26\x26 ~{} !\x3d\x3d false)" x x))\n\n(core/defmacro js-arguments []\n  (core/list \'js* "arguments"))\n\n(core/defmacro js-delete [obj key]\n  (core/list \'js* "delete ~{}[~{}]" obj key))\n\n(core/defmacro js-in [key obj]\n  (core/list \'js* "~{} in ~{}" key obj))\n\n(core/defmacro js-debugger\n  "Emit JavaScript \\"debugger;\\" statement"\n  []\n  (core/list \'do\n             (core/list \'js* "debugger")\n             nil))\n\n(core/defmacro js-comment\n  "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline"\n  [comment]\n  (core/let [[x \x26 ys] (string/split comment #"\\n")]\n    (core/list \'js*\n      (core/str\n        "\\n/**\\n"\n        (core/str " * " x "\\n")\n        (core/-\x3e\x3e ys\n          (map #(core/str " * " (string/replace % #"^   " "") "\\n"))\n          (reduce core/str ""))\n        " */\\n"))))\n\n(core/defmacro unsafe-cast\n  "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type."\n  [t x]\n  (core/let [cast-expr (core/str "~{} \x3d /** @type {" t "} */ (~{})")]\n    (core/list \'js* cast-expr x x)))\n\n(core/defmacro js-inline-comment\n  "Emit an inline JavaScript comment."\n  [comment]\n  (core/list \'js* (core/str "/**" comment "*/")))\n\n(core/defmacro true? [x]\n  (bool-expr (core/list \'js* "~{} \x3d\x3d\x3d true" x)))\n\n(core/defmacro false? [x]\n  (bool-expr (core/list \'js* "~{} \x3d\x3d\x3d false" x)))\n\n(core/defmacro string? [x]\n  (bool-expr (core/list \'js* "typeof ~{} \x3d\x3d\x3d \'string\'" x)))\n\n(core/defmacro exists?\n  "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript."\n  [x]\n  (if (core/symbol? x)\n    (core/let [x     (core/cond-\x3e (:name (cljs.analyzer/resolve-var \x26env x))\n                       (\x3d "js" (namespace x)) name)\n               segs  (string/split (core/str (string/replace (core/str x) "/" ".")) #"\\.")\n               n     (count segs)\n               syms  (map\n                       #(vary-meta (symbol "js" (string/join "." %))\n                          assoc :cljs.analyzer/no-resolve true)\n                       (reverse (take n (iterate butlast segs))))\n               js    (string/join " \x26\x26 " (repeat n "(typeof ~{} !\x3d\x3d \'undefined\')"))]\n      (bool-expr (concat (core/list \'js* js) syms)))\n    `(some? ~x)))\n\n(core/defmacro undefined?\n  "Return true if argument is identical to the JavaScript undefined value."\n  [x]\n  (bool-expr (core/list \'js* "(void 0 \x3d\x3d\x3d ~{})" x)))\n\n(core/defmacro identical? [a b]\n  (bool-expr (core/list \'js* "(~{} \x3d\x3d\x3d ~{})" a b)))\n\n(core/defmacro instance? [c x]\n  ;; Google Closure warns about some references to RegExp, so\n  ;; (instance? RegExp ...) needs to be inlined, but the expansion\n  ;; should preserve the order of argument evaluation.\n  (bool-expr (if (clojure.core/symbol? c)\n               (core/list \'js* "(~{} instanceof ~{})" x c)\n               `(let [c# ~c x# ~x]\n                  (~\'js* "(~{} instanceof ~{})" x# c#)))))\n\n(core/defmacro number? [x]\n  (bool-expr (core/list \'js* "typeof ~{} \x3d\x3d\x3d \'number\'" x)))\n\n(core/defmacro symbol? [x]\n  (bool-expr `(instance? Symbol ~x)))\n\n(core/defmacro keyword? [x]\n  (bool-expr `(instance? Keyword ~x)))\n\n(core/defmacro aget\n  ([array idx]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aget ~array ~idx)\n     :error `(checked-aget\' ~array ~idx)\n     (core/list \'js* "(~{}[~{}])" array idx)))\n  ([array idx \x26 idxs]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aget ~array ~idx ~@idxs)\n     :error `(checked-aget\' ~array ~idx ~@idxs)\n     (core/let [astr (apply core/str (repeat (count idxs) "[~{}]"))]\n       `(~\'js* ~(core/str "(~{}[~{}]" astr ")") ~array ~idx ~@idxs)))))\n\n(core/defmacro aset\n  ([array idx val]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aset ~array ~idx ~val)\n     :error `(checked-aset\' ~array ~idx ~val)\n     (core/list \'js* "(~{}[~{}] \x3d ~{})" array idx val)))\n  ([array idx idx2 \x26 idxv]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aset ~array ~idx ~idx2 ~@idxv)\n     :error `(checked-aset\' ~array ~idx ~idx2 ~@idxv)\n     (core/let [n    (core/dec (count idxv))\n                astr (apply core/str (repeat n "[~{}]"))]\n       `(~\'js* ~(core/str "(~{}[~{}][~{}]" astr " \x3d ~{})") ~array ~idx ~idx2 ~@idxv)))))\n\n(core/defmacro unchecked-get\n  "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis."\n  [obj key]\n  (core/list \'js* "(~{}[~{}])" obj key))\n\n(core/defmacro unchecked-set\n  "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis."\n  [obj key val]\n  (core/list \'js* "(~{}[~{}] \x3d ~{})" obj key val))\n\n(core/defmacro ^::ana/numeric +\n  ([] 0)\n  ([x] x)\n  ([x y] (core/list \'js* "(~{} + ~{})" x y))\n  ([x y \x26 more] `(+ (+ ~x ~y) ~@more)))\n\n(core/defmacro byte [x] x)\n(core/defmacro short [x] x)\n(core/defmacro float [x] x)\n(core/defmacro double [x] x)\n\n(core/defmacro unchecked-byte [x] x)\n(core/defmacro unchecked-char [x] x)\n(core/defmacro unchecked-short [x] x)\n(core/defmacro unchecked-float [x] x)\n(core/defmacro unchecked-double [x] x)\n\n(core/defmacro ^::ana/numeric unchecked-add\n  ([\x26 xs] `(+ ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-add-int\n  ([\x26 xs] `(+ ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-dec\n  ([x] `(dec ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-dec-int\n  ([x] `(dec ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-divide-int\n  ([\x26 xs] `(/ ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-inc\n  ([x] `(inc ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-inc-int\n  ([x] `(inc ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-multiply\n  ([\x26 xs] `(* ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-multiply-int\n  ([\x26 xs] `(* ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-negate\n  ([x] `(- ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-negate-int\n  ([x] `(- ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-remainder-int\n  ([x n] `(core/mod ~x ~n)))\n\n(core/defmacro ^::ana/numeric unchecked-subtract\n  ([\x26 xs] `(- ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-subtract-int\n  ([\x26 xs] `(- ~@xs)))\n\n(core/defmacro ^::ana/numeric -\n  ([x] (core/list \'js* "(- ~{})" x))\n  ([x y] (core/list \'js* "(~{} - ~{})" x y))\n  ([x y \x26 more] `(- (- ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric *\n  ([] 1)\n  ([x] x)\n  ([x y] (core/list \'js* "(~{} * ~{})" x y))\n  ([x y \x26 more] `(* (* ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric /\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list \'js* "(~{} / ~{})" x y))\n  ([x y \x26 more] `(/ (/ ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric divide\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list \'js* "(~{} / ~{})" x y))\n  ([x y \x26 more] `(/ (/ ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric \x3c\n  ([x] true)\n  ([x y] (bool-expr (core/list \'js* "(~{} \x3c ~{})" x y)))\n  ([x y \x26 more] `(and (\x3c ~x ~y) (\x3c ~y ~@more))))\n\n(core/defmacro ^::ana/numeric \x3c\x3d\n  ([x] true)\n  ([x y] (bool-expr (core/list \'js* "(~{} \x3c\x3d ~{})" x y)))\n  ([x y \x26 more] `(and (\x3c\x3d ~x ~y) (\x3c\x3d ~y ~@more))))\n\n(core/defmacro ^::ana/numeric \x3e\n  ([x] true)\n  ([x y] (bool-expr (core/list \'js* "(~{} \x3e ~{})" x y)))\n  ([x y \x26 more] `(and (\x3e ~x ~y) (\x3e ~y ~@more))))\n\n(core/defmacro ^::ana/numeric \x3e\x3d\n  ([x] true)\n  ([x y] (bool-expr (core/list \'js* "(~{} \x3e\x3d ~{})" x y)))\n  ([x y \x26 more] `(and (\x3e\x3d ~x ~y) (\x3e\x3d ~y ~@more))))\n\n(core/defmacro ^::ana/numeric \x3d\x3d\n  ([x] true)\n  ([x y] (bool-expr (core/list \'js* "(~{} \x3d\x3d\x3d ~{})" x y)))\n  ([x y \x26 more] `(and (\x3d\x3d ~x ~y) (\x3d\x3d ~y ~@more))))\n\n(core/defmacro ^::ana/numeric dec [x]\n  `(- ~x 1))\n\n(core/defmacro ^::ana/numeric inc [x]\n  `(+ ~x 1))\n\n(core/defmacro ^::ana/numeric zero? [x]\n  `(\x3d\x3d ~x 0))\n\n(core/defmacro ^::ana/numeric pos? [x]\n  `(\x3e ~x 0))\n\n(core/defmacro ^::ana/numeric neg? [x]\n  `(\x3c ~x 0))\n\n(core/defmacro ^::ana/numeric max\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~\'js* "((~{} \x3e ~{}) ? ~{} : ~{})" x# y# x# y#)))\n  ([x y \x26 more] `(max (max ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric min\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~\'js* "((~{} \x3c ~{}) ? ~{} : ~{})" x# y# x# y#)))\n  ([x y \x26 more] `(min (min ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric js-mod [num div]\n  (core/list \'js* "(~{} % ~{})" num div))\n\n(core/defmacro ^::ana/numeric bit-not [x]\n  (core/list \'js* "(~ ~{})" x))\n\n(core/defmacro ^::ana/numeric bit-and\n  ([x y] (core/list \'js* "(~{} \x26 ~{})" x y))\n  ([x y \x26 more] `(bit-and (bit-and ~x ~y) ~@more)))\n\n;; internal do not use\n(core/defmacro ^::ana/numeric unsafe-bit-and\n  ([x y] (bool-expr (core/list \'js* "(~{} \x26 ~{})" x y)))\n  ([x y \x26 more] `(unsafe-bit-and (unsafe-bit-and ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric bit-or\n  ([x y] (core/list \'js* "(~{} | ~{})" x y))\n  ([x y \x26 more] `(bit-or (bit-or ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric int [x]\n  `(bit-or ~x 0))\n\n(core/defmacro ^::ana/numeric bit-xor\n  ([x y] (core/list \'js* "(~{} ^ ~{})" x y))\n  ([x y \x26 more] `(bit-xor (bit-xor ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric bit-and-not\n  ([x y] (core/list \'js* "(~{} \x26 ~~{})" x y))\n  ([x y \x26 more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric bit-clear [x n]\n  (core/list \'js* "(~{} \x26 ~(1 \x3c\x3c ~{}))" x n))\n\n(core/defmacro ^::ana/numeric bit-flip [x n]\n  (core/list \'js* "(~{} ^ (1 \x3c\x3c ~{}))" x n))\n\n(core/defmacro bit-test [x n]\n  (bool-expr (core/list \'js* "((~{} \x26 (1 \x3c\x3c ~{})) !\x3d 0)" x n)))\n\n(core/defmacro ^::ana/numeric bit-shift-left [x n]\n  (core/list \'js* "(~{} \x3c\x3c ~{})" x n))\n\n(core/defmacro ^::ana/numeric bit-shift-right [x n]\n  (core/list \'js* "(~{} \x3e\x3e ~{})" x n))\n\n(core/defmacro ^::ana/numeric bit-shift-right-zero-fill [x n]\n  (core/list \'js* "(~{} \x3e\x3e\x3e ~{})" x n))\n\n(core/defmacro ^::ana/numeric unsigned-bit-shift-right [x n]\n  (core/list \'js* "(~{} \x3e\x3e\x3e ~{})" x n))\n\n(core/defmacro ^::ana/numeric bit-set [x n]\n  (core/list \'js* "(~{} | (1 \x3c\x3c ~{}))" x n))\n\n;; internal\n(core/defmacro mask [hash shift]\n  (core/list \'js* "((~{} \x3e\x3e\x3e ~{}) \x26 0x01f)" hash shift))\n\n;; internal\n(core/defmacro bitpos [hash shift]\n  (core/list \'js* "(1 \x3c\x3c ~{})" `(mask ~hash ~shift)))\n\n;; internal\n(core/defmacro caching-hash [coll hash-fn hash-key]\n  (core/assert (clojure.core/symbol? hash-key) "hash-key is substituted twice")\n  `(let [h# ~hash-key]\n     (if-not (nil? h#)\n       h#\n       (let [h# (~hash-fn ~coll)]\n         (set! ~hash-key h#)\n         h#))))\n\n;;; internal -- reducers-related macros\n\n(core/defn- do-curried\n  [name doc meta args body]\n  (core/let [cargs (vec (butlast args))]\n    `(defn ~name ~doc ~meta\n       (~cargs (fn [x#] (~name ~@cargs x#)))\n       (~args ~@body))))\n\n(core/defmacro ^:private defcurried\n  "Builds another arity of the fn that returns a fn awaiting the last\n  param"\n  [name doc meta args \x26 body]\n  (do-curried name doc meta args body))\n\n(core/defn- do-rfn [f1 k fkv]\n  `(fn\n     ([] (~f1))\n     ~(clojure.walk/postwalk\n       #(if (sequential? %)\n          ((if (vector? %) vec identity)\n           (core/remove #{k} %))\n          %)\n       fkv)\n     ~fkv))\n\n(core/defmacro ^:private rfn\n  "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl."\n  [[f1 k] fkv]\n  (do-rfn f1 k fkv))\n\n;;; end of reducers macros\n\n(core/defn- protocol-prefix [psym]\n  (core/str (core/-\x3e (core/str psym)\n              (.replace #?(:clj \\. :cljs (js/RegExp. "\\\\." "g")) \\$)\n              (.replace \\/ \\$))\n    "$"))\n\n(def ^:private base-type\n     {nil "null"\n      \'object "object"\n      \'string "string"\n      \'number "number"\n      \'array "array"\n      \'function "function"\n      \'boolean "boolean"\n      \'default "_"})\n\n(def ^:private js-base-type\n     {\'js/Boolean "boolean"\n      \'js/String "string"\n      \'js/Array "array"\n      \'js/Object "object"\n      \'js/Number "number"\n      \'js/Function "function"})\n\n(core/defmacro reify\n  "reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  (\'this\' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \\"foo\\"]\n       (reify Object\n         (toString [this] f))))\n  \x3d\x3d \\"foo\\"\n\n  (seq (let [f \\"foo\\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  \x3d\x3d (\\"f\\" \\"o\\" \\"o\\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \\"foo\\")))\n  \x3d\x3d {:k :v}"\n  [\x26 impls]\n  (core/let [t        (with-meta\n                        (gensym\n                          (core/str "t_"\n                            (string/replace (core/str (munge ana/*cljs-ns*)) "." "$")))\n                        {:anonymous true})\n             meta-sym (gensym "meta")\n             this-sym (gensym "_")\n             locals   (keys (:locals \x26env))\n             ns       (core/-\x3e \x26env :ns :name)\n             munge    comp/munge]\n    `(do\n       (when-not (exists? ~(symbol (core/str ns) (core/str t)))\n         (deftype ~t [~@locals ~meta-sym]\n           IWithMeta\n           (~\'-with-meta [~this-sym ~meta-sym]\n             (new ~t ~@locals ~meta-sym))\n           IMeta\n           (~\'-meta [~this-sym] ~meta-sym)\n           ~@impls))\n       (new ~t ~@locals ~(ana/elide-reader-meta (meta \x26form))))))\n\n(core/defmacro specify!\n  "Identical to reify but mutates its first argument."\n  [expr \x26 impls]\n  (core/let [x (with-meta (gensym "x") {:extend :instance})]\n    `(let [~x ~expr]\n       (extend-type ~x ~@impls)\n       ~x)))\n\n(core/defmacro specify\n  "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance."\n  [expr \x26 impls]\n  `(cljs.core/specify! (cljs.core/clone ~expr)\n     ~@impls))\n\n(core/defmacro ^:private js-this []\n  (core/list \'js* "this"))\n\n(core/defmacro this-as\n  "Defines a scope where JavaScript\'s implicit \\"this\\" is bound to the name provided."\n  [name \x26 body]\n  `(let [~name (js-this)]\n     ~@body))\n\n(core/defn- to-property [sym]\n  (symbol (core/str "-" sym)))\n\n(core/defn- warn-and-update-protocol [p type env]\n  (core/when-not (\x3d \'Object p)\n    (core/if-let [var (cljs.analyzer/resolve-existing-var (dissoc env :locals) p)]\n      (do\n        (core/when-not (:protocol-symbol var)\n          (cljs.analyzer/warning :invalid-protocol-symbol env {:protocol p}))\n        (core/when (core/and (:protocol-deprecated cljs.analyzer/*cljs-warnings*)\n                (core/-\x3e var :deprecated)\n                (not (core/-\x3e p meta :deprecation-nowarn)))\n          (cljs.analyzer/warning :protocol-deprecated env {:protocol p}))\n        (core/when (:protocol-symbol var)\n          (swap! env/*compiler* update-in [:cljs.analyzer/namespaces]\n            (core/fn [ns]\n              (update-in ns [(:ns var) :defs (symbol (name p)) :impls]\n                conj type)))))\n      (core/when (:undeclared cljs.analyzer/*cljs-warnings*)\n        (cljs.analyzer/warning :undeclared-protocol-symbol env {:protocol p})))))\n\n(core/defn- resolve-var [env sym]\n  (core/let [ret (:name (cljs.analyzer/resolve-var env sym))]\n    (core/assert ret (core/str "Can\'t resolve: " sym))\n    ret))\n\n(core/defn- -\x3eimpl-map [impls]\n  (core/loop [ret {} s impls]\n    (if (seq s)\n      (recur (assoc ret (first s) (take-while seq? (next s)))\n        (drop-while seq? (next s)))\n      ret)))\n\n(core/defn- base-assign-impls [env resolve tsym type [p sigs]]\n  (warn-and-update-protocol p tsym env)\n  (core/let [psym       (resolve p)\n             pfn-prefix (subs (core/str psym) 0\n                          (clojure.core/inc (.indexOf (core/str psym) "/")))]\n    (cons `(goog.object/set ~psym ~type true)\n      (map (core/fn [[f \x26 meths :as form]]\n             `(goog.object/set ~(symbol (core/str pfn-prefix f))\n                ~type ~(with-meta `(fn ~@meths) (meta form))))\n        sigs))))\n\n(core/defmulti ^:private extend-prefix (core/fn [tsym sym] (core/-\x3e tsym meta :extend)))\n\n(core/defmethod extend-prefix :instance\n  [tsym sym] `(.. ~tsym ~(to-property sym)))\n\n(core/defmethod extend-prefix :default\n  [tsym sym] `(.. ~tsym ~\'-prototype ~(to-property sym)))\n\n(core/defn- adapt-obj-params [type [[this \x26 args :as sig] \x26 body]]\n  (core/list (vec args)\n    (list* \'this-as (vary-meta this assoc :tag type) body)))\n\n(core/defn- adapt-ifn-params [type [[this \x26 args :as sig] \x26 body]]\n  (core/let [self-sym (with-meta \'self__ {:tag type})]\n    `(~(vec (cons self-sym args))\n       (this-as ~self-sym\n         (let [~this ~self-sym]\n           ~@body)))))\n\n;; for IFn invoke implementations, we need to drop first arg\n(core/defn- adapt-ifn-invoke-params [type [[this \x26 args :as sig] \x26 body]]\n  `(~(vec args)\n     (this-as ~(vary-meta this assoc :tag type)\n       ~@body)))\n\n(core/defn- adapt-proto-params [type [[this \x26 args :as sig] \x26 body]]\n  (core/let [this\' (vary-meta this assoc :tag type)]\n    `(~(vec (cons this\' args))\n      (this-as ~this\'\n        ~@body))))\n\n(core/defn- add-obj-methods [type type-sym sigs]\n  (map (core/fn [[f \x26 meths :as form]]\n         (core/let [[f meths] (if (vector? (first meths))\n                                [f [(rest form)]]\n                                [f meths])]\n           `(set! ~(extend-prefix type-sym f)\n              ~(with-meta `(fn ~@(map #(adapt-obj-params type %) meths)) (meta form)))))\n    sigs))\n\n(core/defn- ifn-invoke-methods [type type-sym [f \x26 meths :as form]]\n  (map\n    (core/fn [meth]\n      (core/let [arity (count (first meth))]\n        `(set! ~(extend-prefix type-sym (symbol (core/str "cljs$core$IFn$_invoke$arity$" arity)))\n           ~(with-meta `(fn ~meth) (meta form)))))\n    (map #(adapt-ifn-invoke-params type %) meths)))\n\n(core/defn- add-ifn-methods [type type-sym [f \x26 meths :as form]]\n  (core/let [meths    (map #(adapt-ifn-params type %) meths)\n             this-sym (with-meta \'self__ {:tag type})\n             argsym   (gensym "args")]\n    (concat\n      [`(set! ~(extend-prefix type-sym \'call) ~(with-meta `(fn ~@meths) (meta form)))\n       `(set! ~(extend-prefix type-sym \'apply)\n          ~(with-meta\n             `(fn ~[this-sym argsym]\n                (this-as ~this-sym\n                  (.apply (.-call ~this-sym) ~this-sym\n                    (.concat (array ~this-sym) (cljs.core/aclone ~argsym)))))\n             (meta form)))]\n      (ifn-invoke-methods type type-sym form))))\n\n(core/defn- add-proto-methods* [pprefix type type-sym [f \x26 meths :as form]]\n  (core/let [pf (core/str pprefix (munge (name f)))]\n    (if (vector? (first meths))\n      ;; single method case\n      (core/let [meth meths]\n        [`(set! ~(extend-prefix type-sym (core/str pf "$arity$" (count (first meth))))\n            ~(with-meta `(fn ~@(adapt-proto-params type meth)) (meta form)))])\n      (map (core/fn [[sig \x26 body :as meth]]\n             `(set! ~(extend-prefix type-sym (core/str pf "$arity$" (count sig)))\n                ~(with-meta `(fn ~(adapt-proto-params type meth)) (meta form))))\n        meths))))\n\n(core/defn- proto-assign-impls [env resolve type-sym type [p sigs]]\n  (warn-and-update-protocol p type env)\n  (core/let [psym      (resolve p)\n             pprefix   (protocol-prefix psym)\n             skip-flag (set (core/-\x3e type-sym meta :skip-protocol-flag))]\n    (if (\x3d p \'Object)\n      (add-obj-methods type type-sym sigs)\n      (concat\n        (core/when-not (skip-flag psym)\n          [`(set! ~(extend-prefix type-sym pprefix) cljs.core/PROTOCOL_SENTINEL)])\n        (mapcat\n          (core/fn [sig]\n            (if (\x3d psym \'cljs.core/IFn)\n              (add-ifn-methods type type-sym sig)\n              (add-proto-methods* pprefix type type-sym sig)))\n          sigs)))))\n\n(core/defn- validate-impl-sigs [env p method]\n  (core/when-not (\x3d p \'Object)\n    (core/let [var (ana/resolve-var (dissoc env :locals) p)\n               minfo (core/-\x3e var :protocol-info :methods)\n               method-name (first method)\n               -\x3ename (comp symbol name)\n               [fname sigs] (if (core/vector? (second method))\n                              [(-\x3ename method-name) [(second method)]]\n                              [(-\x3ename method-name) (map first (rest method))])\n               decmeths (core/get minfo fname ::not-found)]\n      (core/when (\x3d decmeths ::not-found)\n        (ana/warning :protocol-invalid-method env {:protocol p :fname fname :no-such-method true}))\n      (core/when (namespace method-name)\n        (core/let [method-var (ana/resolve-var (dissoc env :locals) method-name\n                                ana/confirm-var-exist-warning)]\n          (core/when-not (\x3d (:name var) (:protocol method-var))\n            (ana/warning :protocol-invalid-method env\n              {:protocol p :fname method-name :no-such-method true}))))\n      (core/loop [sigs sigs seen #{}]\n        (core/when (seq sigs)\n          (core/let [sig (first sigs)\n                     c   (count sig)]\n            (core/when (contains? seen c)\n              (ana/warning :protocol-duped-method env {:protocol p :fname fname}))\n            (core/when (some \'#{\x26} sig)\n              (ana/warning :protocol-impl-with-variadic-method env {:protocol p :name fname}))\n            (core/when (core/and (not\x3d decmeths ::not-found) (not (some #{c} (map count decmeths))))\n              (ana/warning :protocol-invalid-method env {:protocol p :fname fname :invalid-arity c}))\n            (recur (next sigs) (conj seen c))))))))\n\n(core/defn- validate-impls [env impls]\n  (core/loop [protos #{} impls impls]\n    (core/when (seq impls)\n      (core/let [proto   (first impls)\n                 methods (take-while seq? (next impls))\n                 impls   (drop-while seq? (next impls))]\n        (core/when (contains? protos proto)\n          (ana/warning :protocol-multiple-impls env {:protocol proto}))\n        (core/loop [seen #{} methods methods]\n          (core/when (seq methods)\n            (core/let [[fname :as method] (first methods)]\n              (core/when (contains? seen fname)\n                (ana/warning :extend-type-invalid-method-shape env\n                  {:protocol proto :method fname}))\n              (validate-impl-sigs env proto method)\n              (recur (conj seen fname) (next methods)))))\n        (recur (conj protos proto) impls)))))\n\n(core/defn- type-hint-first-arg\n  [type-sym argv]\n  (assoc argv 0 (vary-meta (argv 0) assoc :tag type-sym)))\n\n(core/defn- type-hint-single-arity-sig\n  [type-sym sig]\n  (list* (first sig) (type-hint-first-arg type-sym (second sig)) (nnext sig)))\n\n(core/defn- type-hint-multi-arity-sig\n  [type-sym sig]\n  (list* (type-hint-first-arg type-sym (first sig)) (next sig)))\n\n(core/defn- type-hint-multi-arity-sigs\n  [type-sym sigs]\n  (list* (first sigs) (map (partial type-hint-multi-arity-sig type-sym) (rest sigs))))\n\n(core/defn- type-hint-sigs\n  [type-sym sig]\n  (if (vector? (second sig))\n    (type-hint-single-arity-sig type-sym sig)\n    (type-hint-multi-arity-sigs type-sym sig)))\n\n(core/defn- type-hint-impl-map\n  [type-sym impl-map]\n  (reduce-kv (core/fn [m proto sigs]\n               (assoc m proto (map (partial type-hint-sigs type-sym) sigs)))\n    {} impl-map))\n\n(core/defmacro extend-type\n  "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)"\n  [type-sym \x26 impls]\n  (core/let [env \x26env\n             _ (validate-impls env impls)\n             resolve (partial resolve-var env)\n             impl-map (-\x3eimpl-map impls)\n             impl-map (if (\'#{boolean number} type-sym)\n                        (type-hint-impl-map type-sym impl-map)\n                        impl-map)\n             [type assign-impls] (core/if-let [type (base-type type-sym)]\n                                   [type base-assign-impls]\n                                   [(resolve type-sym) proto-assign-impls])]\n    (core/when (core/and (:extending-base-js-type cljs.analyzer/*cljs-warnings*)\n            (js-base-type type-sym))\n      (cljs.analyzer/warning :extending-base-js-type env\n        {:current-symbol type-sym :suggested-symbol (js-base-type type-sym)}))\n    `(do ~@(mapcat #(assign-impls env resolve type-sym type %) impl-map))))\n\n(core/defn- prepare-protocol-masks [env impls]\n  (core/let [resolve  (partial resolve-var env)\n             impl-map (-\x3eimpl-map impls)\n             fpp-pbs  (seq\n                        (keep fast-path-protocols\n                          (map resolve\n                            (keys impl-map))))]\n    (if fpp-pbs\n      (core/let [fpps  (into #{}\n                         (filter (partial contains? fast-path-protocols)\n                           (map resolve (keys impl-map))))\n                 parts (core/as-\x3e (group-by first fpp-pbs) parts\n                         (into {}\n                           (map (juxt key (comp (partial map peek) val))\n                             parts))\n                         (into {}\n                           (map (juxt key (comp (partial reduce core/bit-or) val))\n                             parts)))]\n        [fpps (reduce (core/fn [ps p] (update-in ps [p] (core/fnil identity 0)))\n                parts\n                (range fast-path-protocol-partitions-count))]))))\n\n(core/defn- annotate-specs [annots v [f sigs]]\n  (conj v\n    (vary-meta (cons f (map #(cons (second %) (nnext %)) sigs))\n      merge annots)))\n\n(core/defn dt-\x3eet\n  ([type specs fields]\n   (dt-\x3eet type specs fields false))\n  ([type specs fields inline]\n   (core/let [annots {:cljs.analyzer/type type\n                      :cljs.analyzer/protocol-impl true\n                      :cljs.analyzer/protocol-inline inline}]\n     (core/loop [ret [] specs specs]\n       (if (seq specs)\n         (core/let [p     (first specs)\n                    ret   (core/-\x3e (conj ret p)\n                            (into (reduce (partial annotate-specs annots) []\n                                    (group-by first (take-while seq? (next specs))))))\n                    specs (drop-while seq? (next specs))]\n           (recur ret specs))\n         ret)))))\n\n(core/defn- collect-protocols [impls env]\n  (core/-\x3e\x3e impls\n      (filter core/symbol?)\n      (map #(:name (cljs.analyzer/resolve-var (dissoc env :locals) %)))\n      (into #{})))\n\n(core/defn- build-positional-factory\n  [rsym rname fields]\n  (core/let [fn-name (with-meta (symbol (core/str \'-\x3e rsym))\n                       (assoc (meta rsym) :factory :positional))\n             docstring (core/str "Positional factory function for " rname ".")\n        field-values (if (core/-\x3e rsym meta :internal-ctor) (conj fields nil nil nil) fields)]\n    `(defn ~fn-name\n       ~docstring\n       [~@fields]\n       (new ~rname ~@field-values))))\n\n(core/defn- validate-fields\n  [case name fields]\n  (core/when-not (vector? fields)\n    (throw\n      #?(:clj (AssertionError. (core/str case " " name ", no fields vector given."))\n         :cljs (js/Error. (core/str case " " name ", no fields vector given."))))))\n\n(core/defmacro deftype\n  "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript\'s reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  (\'this\' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called -\x3eTypeName\n  will be defined, taking positional parameters for the fields"\n  [t fields \x26 impls]\n  (validate-fields "deftype" t fields)\n  (core/let [env \x26env\n             r (:name (cljs.analyzer/resolve-var (dissoc env :locals) t))\n             [fpps pmasks] (prepare-protocol-masks env impls)\n             protocols (collect-protocols impls env)\n             t (vary-meta t assoc\n                 :protocols protocols\n                 :skip-protocol-flag fpps) ]\n    `(do\n       (deftype* ~t ~fields ~pmasks\n         ~(if (seq impls)\n            `(extend-type ~t ~@(dt-\x3eet t impls fields))))\n       (set! (.-getBasis ~t) (fn [] \'[~@fields]))\n       (set! (.-cljs$lang$type ~t) true)\n       (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n       (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opt#] (-write writer# ~(core/str r))))\n\n       ~(build-positional-factory t r fields)\n       ~t)))\n\n(core/defn- emit-defrecord\n  "Do not use this directly - use defrecord"\n  [env tagname rname fields impls]\n  (core/let [hinted-fields fields\n             fields (vec (map #(with-meta % nil) fields))\n             base-fields fields\n             pr-open (core/str "#" #?(:clj  (.getNamespace rname)\n                                      :cljs (namespace rname))\n                               "." #?(:clj  (.getName rname)\n                                      :cljs (name rname))\n                               "{")\n             fields (conj fields \'__meta \'__extmap (with-meta \'__hash {:mutable true}))]\n    (core/let [gs (gensym)\n               ksym (gensym "k")\n               impls (concat\n                       impls\n                       [\'IRecord\n                        \'ICloneable\n                        `(~\'-clone [this#] (new ~tagname ~@fields))\n                        \'IHash\n                        `(~\'-hash [this#]\n                           (caching-hash this#\n                             (fn [coll#]\n                               (bit-xor\n                                 ~(hash (core/-\x3e rname comp/munge core/str))\n                                 (hash-unordered-coll coll#)))\n                             ~\'__hash))\n                        \'IEquiv\n                        (core/let [this (gensym \'this) other (gensym \'other)]\n                          `(~\'-equiv [~this ~other]\n                             (and (some? ~other)\n                                  (identical? (.-constructor ~this)\n                                              (.-constructor ~other))\n                                  ~@(map (core/fn [field]\n                                           `(\x3d (.. ~this ~(to-property field))\n                                               (.. ~(with-meta other {:tag tagname}) ~(to-property field))))\n                                         base-fields)\n                                  (\x3d (.-__extmap ~this)\n                                     (.-__extmap ~(with-meta other {:tag tagname}))))))\n                        \'IMeta\n                        `(~\'-meta [this#] ~\'__meta)\n                        \'IWithMeta\n                        `(~\'-with-meta [this# ~gs] (new ~tagname ~@(replace {\'__meta gs} fields)))\n                        \'ILookup\n                        `(~\'-lookup [this# k#] (-lookup this# k# nil))\n                        `(~\'-lookup [this# ~ksym else#]\n                           (case ~ksym\n                             ~@(mapcat (core/fn [f] [(keyword f) f]) base-fields)\n                             (cljs.core/get ~\'__extmap ~ksym else#)))\n                        \'ICounted\n                        `(~\'-count [this#] (+ ~(count base-fields) (count ~\'__extmap)))\n                        \'ICollection\n                        `(~\'-conj [this# entry#]\n                           (if (vector? entry#)\n                             (-assoc this# (-nth entry# 0) (-nth entry# 1))\n                             (reduce -conj\n                               this#\n                               entry#)))\n                        \'IAssociative\n                        `(~\'-assoc [this# k# ~gs]\n                           (condp keyword-identical? k#\n                             ~@(mapcat (core/fn [fld]\n                                         [(keyword fld) (list* `new tagname (replace {fld gs \'__hash nil} fields))])\n                                 base-fields)\n                             (new ~tagname ~@(remove #{\'__extmap \'__hash} fields) (assoc ~\'__extmap k# ~gs) nil)))\n                        \'IMap\n                        `(~\'-dissoc [this# k#] (if (contains? #{~@(map keyword base-fields)} k#)\n                                                 (dissoc (-with-meta (into {} this#) ~\'__meta) k#)\n                                                 (new ~tagname ~@(remove #{\'__extmap \'__hash} fields)\n                                                   (not-empty (dissoc ~\'__extmap k#))\n                                                   nil)))\n                        \'ISeqable\n                        `(~\'-seq [this#] (seq (concat [~@(map #(core/list \'cljs.core/MapEntry. (keyword %) % nil) base-fields)]\n                                                ~\'__extmap)))\n\n                        \'IIterable\n                        `(~\'-iterator [~gs]\n                          (RecordIter. 0 ~gs ~(count base-fields) [~@(map keyword base-fields)] (if ~\'__extmap\n                                                                                                  (-iterator ~\'__extmap)\n                                                                                                  (core/nil-iter))))\n\n                        \'IPrintWithWriter\n                        `(~\'-pr-writer [this# writer# opts#]\n                           (let [pr-pair# (fn [keyval#] (pr-sequential-writer writer# (~\'js* "cljs.core.pr_writer") "" " " "" opts# keyval#))]\n                             (pr-sequential-writer\n                               writer# pr-pair# ~pr-open ", " "}" opts#\n                               (concat [~@(map #(core/list `vector (keyword %) %) base-fields)]\n                                 ~\'__extmap))))\n                        \'IKVReduce\n                        `(~\'-kv-reduce [this# f# init#]\n                           (reduce (fn [ret# [k# v#]] (f# ret# k# v#)) init# this#))\n                        ])\n               [fpps pmasks] (prepare-protocol-masks env impls)\n               protocols (collect-protocols impls env)\n               tagname (vary-meta tagname assoc\n                         :protocols protocols\n                         :skip-protocol-flag fpps)]\n      `(do\n         (~\'defrecord* ~tagname ~hinted-fields ~pmasks\n           (extend-type ~tagname ~@(dt-\x3eet tagname impls fields true)))))))\n\n(core/defn- build-map-factory [rsym rname fields]\n  (core/let [fn-name (with-meta (symbol (core/str \'map-\x3e rsym))\n                       (assoc (meta rsym) :factory :map))\n             docstring (core/str "Factory function for " rname ", taking a map of keywords to field values.")\n             ms (gensym)\n             ks (map keyword fields)\n             getters (map (core/fn [k] `(~k ~ms)) ks)]\n    `(defn ~fn-name ~docstring [~ms]\n       (let [extmap# (cond-\x3e\x3e (dissoc ~ms ~@ks)\n                        (record? ~ms) (into {}))]\n         (new ~rname ~@getters nil (not-empty extmap#) nil)))))\n\n(core/defmacro defrecord\n  "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object (\'this\' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based \x3d,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: -\x3eTypeName, taking positional parameters for the fields,\n  and map-\x3eTypeName, taking a map of keywords to field values."\n  [rsym fields \x26 impls]\n  (validate-fields "defrecord" rsym fields)\n  (core/let [rsym (vary-meta rsym assoc :internal-ctor true)\n             r    (vary-meta\n                    (:name (cljs.analyzer/resolve-var (dissoc \x26env :locals) rsym))\n                    assoc :internal-ctor true)]\n    `(let []\n       ~(emit-defrecord \x26env rsym r fields impls)\n       (set! (.-getBasis ~r) (fn [] \'[~@fields]))\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (cljs.core/list ~(core/str r))))\n       (set! (.-cljs$lang$ctorPrWriter ~r) (fn [this# writer#] (-write writer# ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))\n\n(core/defmacro defprotocol\n  "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \\"A doc string for AProtocol abstraction\\"\n\n  ;method signatures\n    (bar [this a b] \\"bar docs\\")\n    (baz [this a] [this a b] [this a b c] \\"baz docs\\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object (\'this\' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  \x3d\x3e 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  \x3d\x3e 17"\n  [psym \x26 doc+methods]\n  (core/let [p (:name (cljs.analyzer/resolve-var (dissoc \x26env :locals) psym))\n             [opts methods]\n             (core/loop [opts {:protocol-symbol true}\n                         methods []\n                         sigs doc+methods]\n               (core/if-not (seq sigs)\n                 [opts methods]\n                 (core/let [[head \x26 tail] sigs]\n                   (core/cond\n                     (core/string? head)\n                     (recur (assoc opts :doc head) methods tail)\n                     (core/keyword? head)\n                     (recur (assoc opts head (first tail)) methods (rest tail))\n                     (core/list? head)\n                     (recur opts (conj methods head) tail)\n                     :else\n                     (throw #?(:clj  (Exception.\n                                       (core/str "Invalid protocol, " psym " received unexpected argument"))\n                               :cljs (js/Error.\n                                       (core/str "Invalid protocol, " psym " received unexpected argument"))))\n                     ))))\n             psym (vary-meta psym merge opts)\n             ns-name (core/-\x3e \x26env :ns :name)\n             fqn (core/fn [n] (symbol (core/str ns-name) (core/str n)))\n             prefix (protocol-prefix p)\n             _ (core/doseq [[mname \x26 arities] methods]\n                 (core/when (some #{0} (map count (filter vector? arities)))\n                   (throw\n                     #?(:clj (Exception.\n                               (core/str "Invalid protocol, " psym\n                                 " defines method " mname " with arity 0"))\n                        :cljs (js/Error.\n                                (core/str "Invalid protocol, " psym\n                                  " defines method " mname " with arity 0"))))))\n             expand-sig (core/fn [fname slot sig]\n                          (core/let [sig (core/if-not (every? core/symbol? sig)\n                                           (mapv (core/fn [arg]\n                                                   (core/cond\n                                                     (core/symbol? arg) arg\n                                                     (core/and (map? arg) (core/some? (:as arg))) (:as arg)\n                                                     :else (gensym))) sig)\n                                           sig)\n\n                                     fqn-fname (fqn fname)\n                                     fsig (first sig)\n\n                                     ;; construct protocol checks in reverse order\n                                     ;; check the.protocol/fn["_"] for default impl last\n                                     check\n                                     `(let [m# (unchecked-get ~fqn-fname "_")]\n                                        (if-not (nil? m#)\n                                          (m# ~@sig)\n                                          (throw\n                                            (missing-protocol\n                                              ~(core/str psym "." fname) ~fsig))))\n\n                                     ;; then check protocol fn in metadata (only when protocol is marked with :extend-via-metadata true)\n                                     check\n                                     (core/if-not (:extend-via-metadata opts)\n                                       check\n                                       `(if-let [meta-impl# (-\x3e ~fsig (core/meta) (core/get \'~fqn-fname))]\n                                          (meta-impl# ~@sig)\n                                          ~check))\n\n                                     ;; then check protocol on js string,function,array,object\n                                     check\n                                     `(let [x# (if (nil? ~fsig) nil ~fsig)\n                                            m# (unchecked-get ~fqn-fname (goog/typeOf x#))]\n                                        (if-not (nil? m#)\n                                          (m# ~@sig)\n                                          ~check))\n\n                                     ;; then check protocol property on object (first check actually executed)\n                                     check\n                                     `(if (and (not (nil? ~fsig))\n                                               (not (nil? (. ~fsig ~(symbol (core/str "-" slot)))))) ;; Property access needed here.\n                                        (. ~fsig ~slot ~@sig)\n                                        ~check)]\n                            `(~sig ~check)))\n             psym (core/-\x3e psym\n                    (vary-meta update-in [:jsdoc] conj\n                      "@interface")\n                    (vary-meta assoc-in [:protocol-info :methods]\n                      (into {}\n                        (map\n                          (core/fn [[fname \x26 sigs]]\n                            (core/let [doc (core/as-\x3e (last sigs) doc\n                                             (core/when (core/string? doc) doc))\n                                       sigs (take-while vector? sigs)]\n                              [(vary-meta fname assoc :doc doc)\n                               (vec sigs)]))\n                          methods))))\n             method (core/fn [[fname \x26 sigs]]\n                      (core/let [doc (core/as-\x3e (last sigs) doc\n                                       (core/when (core/string? doc) doc))\n                                 sigs (take-while vector? sigs)\n                                 amp (core/when (some #{\'\x26} (apply concat sigs))\n                                       (cljs.analyzer/warning\n                                        :protocol-with-variadic-method\n                                        \x26env {:protocol psym :name fname}))\n                                 slot (symbol (core/str prefix (munge (name fname))))\n                                 fname (vary-meta fname assoc\n                                         :protocol p\n                                         :doc doc)]\n                        `(defn ~fname\n                           ~@(map (core/fn [sig]\n                                    (expand-sig fname\n                                      (symbol (core/str slot "$arity$" (count sig)))\n                                      sig))\n                               sigs))))]\n    `(do\n       (set! ~\'*unchecked-if* true)\n       (def ~psym (~\'js* "function(){}"))\n       ~@(map method methods)\n       (set! ~\'*unchecked-if* false))))\n\n(core/defmacro implements?\n  "EXPERIMENTAL"\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc \x26env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str "-cljs$lang$protocol_mask$partition" part "$"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if ~xsym\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                    (identical? cljs.core/PROTOCOL_SENTINEL (. ~xsym ~(symbol (core/str "-" prefix)))))\n             true\n             false)\n           false))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                  (identical? cljs.core/PROTOCOL_SENTINEL (. ~x ~(symbol (core/str "-" prefix)))))\n           true\n           false)\n         false))))\n\n(core/defmacro satisfies?\n  "Returns true if x satisfies the protocol"\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc \x26env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str "-cljs$lang$protocol_mask$partition" part "$"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if-not (nil? ~xsym)\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                    (identical? cljs.core/PROTOCOL_SENTINEL (. ~xsym ~(symbol (core/str "-" prefix)))))\n             true\n             (if (coercive-not (. ~xsym ~msym))\n               (cljs.core/native-satisfies? ~psym ~xsym)\n               false))\n           (cljs.core/native-satisfies? ~psym ~xsym)))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                  (identical? cljs.core/PROTOCOL_SENTINEL (. ~x ~(symbol (core/str "-" prefix)))))\n           true\n           (if (coercive-not (. ~x ~msym))\n             (cljs.core/native-satisfies? ~psym ~x)\n             false))\n         (cljs.core/native-satisfies? ~psym ~x)))))\n\n(core/defmacro lazy-seq\n  "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls."\n  [\x26 body]\n  `(new cljs.core/LazySeq nil (fn [] ~@body) nil nil))\n\n(core/defmacro delay\n  "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls."\n  [\x26 body]\n  `(new cljs.core/Delay (fn [] ~@body) nil))\n\n(core/defmacro with-redefs\n  "binding \x3d\x3e var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing."\n  [bindings \x26 body]\n  (core/let [names (take-nth 2 bindings)\n             vals (take-nth 2 (drop 1 bindings))\n             orig-val-syms (map (comp gensym #(core/str % "-orig-val__") name) names)\n             temp-val-syms (map (comp gensym #(core/str % "-temp-val__") name) names)\n             binds (map core/vector names temp-val-syms)\n             resets (reverse (map core/vector names orig-val-syms))\n             bind-value (core/fn [[k v]] (core/list \'set! k v))]\n    `(let [~@(interleave orig-val-syms names)\n           ~@(interleave temp-val-syms vals)]\n       ~@(map bind-value binds)\n       (try\n         ~@body\n         (finally\n           ~@(map bind-value resets))))))\n\n(core/defmacro binding\n  "binding \x3d\x3e var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values."\n  [bindings \x26 body]\n  (core/let [names (take-nth 2 bindings)]\n    (cljs.analyzer/confirm-bindings \x26env names)\n    `(with-redefs ~bindings ~@body)))\n\n(core/defmacro condp\n  "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :\x3e\x3e result-fn\n\n  Note :\x3e\x3e is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an Error is thrown."\n  {:added "1.0"}\n\n  [pred expr \x26 clauses]\n  (core/let [gpred (gensym "pred__")\n             gexpr (gensym "expr__")\n             emit (core/fn emit [pred expr args]\n                    (core/let [[[a b c :as clause] more]\n                               (split-at (if (\x3d :\x3e\x3e (second args)) 3 2) args)\n                               n (count clause)]\n                      (core/cond\n                        (\x3d 0 n) `(throw (js/Error. (cljs.core/str "No matching clause: " ~expr)))\n                        (\x3d 1 n) a\n                        (\x3d 2 n) `(if (~pred ~a ~expr)\n                                   ~b\n                                   ~(emit pred expr more))\n                        :else `(if-let [p# (~pred ~a ~expr)]\n                                 (~c p#)\n                                 ~(emit pred expr more)))))\n             gres (gensym "res__")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))\n\n(core/defn- assoc-test [m test expr env]\n  (if (contains? m test)\n    (throw\n      #?(:clj (clojure.core/IllegalArgumentException.\n                (core/str "Duplicate case test constant \'"\n                  test "\'"\n                  (core/when (:line env)\n                    (core/str " on line " (:line env) " "\n                      cljs.analyzer/*cljs-file*))))\n         :cljs (js/Error.\n                 (core/str "Duplicate case test constant \'"\n                   test "\'"\n                   (core/when (:line env)\n                     (core/str " on line " (:line env) " "\n                       cljs.analyzer/*cljs-file*))))))\n    (assoc m test expr)))\n\n(core/defn- const? [env x]\n  (core/let [m (core/and (core/list? x)\n                         (ana/resolve-var env (last x)))]\n    (core/when m (core/get m :const))))\n\n(core/defmacro case\n  "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type."\n  [e \x26 clauses]\n  (core/let [esym    (gensym)\n             default (if (odd? (count clauses))\n                       (last clauses)\n                       `(throw\n                          (js/Error.\n                            (cljs.core/str "No matching clause: " ~esym))))\n             env     \x26env\n             pairs   (reduce\n                       (core/fn [m [test expr]]\n                         (core/cond\n                           (seq? test)\n                           (reduce\n                             (core/fn [m test]\n                               (core/let [test (if (core/symbol? test)\n                                                 (core/list \'quote test)\n                                                 test)]\n                                 (assoc-test m test expr env)))\n                             m test)\n                           (core/symbol? test)\n                           (assoc-test m (core/list \'quote test) expr env)\n                           :else\n                           (assoc-test m test expr env)))\n                     {} (partition 2 clauses))\n             tests   (keys pairs)]\n    (core/cond\n      (every? (some-fn core/number? core/string? #?(:clj core/char? :cljs (core/fnil core/char? :nonchar)) #(const? env %)) tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 tests      (mapv #(if (seq? %) (vec %) [%]) (take-nth 2 no-default))\n                 thens      (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e] (case* ~esym ~tests ~thens ~default)))\n\n      (every? core/keyword? tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 kw-str #(.substring (core/str %) 1)\n                 tests (mapv #(if (seq? %) (mapv kw-str %) [(kw-str %)]) (take-nth 2 no-default))\n                 thens (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e\n               ~esym (if (keyword? ~esym) (.-fqn ~(vary-meta esym assoc :tag \'cljs.core/Keyword)) nil)]\n           (case* ~esym ~tests ~thens ~default)))\n\n      ;; equality\n      :else\n      `(let [~esym ~e]\n         (cond\n           ~@(mapcat (core/fn [[m c]] `((cljs.core/\x3d ~m ~esym) ~c)) pairs)\n           :else ~default)))))\n\n(core/defmacro ^:private when-assert [x]\n  (core/when *assert* x))\n\n(core/defmacro assert\n  "Evaluates expr and throws an exception if it does not evaluate to\n  logical true."\n  ([x]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error. ~(core/str "Assert failed: " (core/pr-str x)))))))\n  ([x message]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str "Assert failed: " ~message "\\n" ~(core/pr-str x))))))))\n\n(core/defmacro for\n  "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (\x3c y x)]  [x y]))"\n  [seq-exprs body-expr]\n  (assert-args for\n    (vector? seq-exprs) "a vector for its binding"\n    (even? (count seq-exprs)) "an even number of forms in binding vector")\n  (core/let [to-groups (core/fn [seq-exprs]\n                         (reduce (core/fn [groups [k v]]\n                                   (if (core/keyword? k)\n                                     (conj (pop groups) (conj (peek groups) [k v]))\n                                     (conj groups [k v])))\n                           [] (partition 2 seq-exprs)))\n             err (core/fn [\x26 msg] (throw (ex-info (apply core/str msg) {})))\n             emit-bind (core/fn emit-bind [[[bind expr \x26 mod-pairs]\n                                       \x26 [[_ next-expr] :as next-groups]]]\n                         (core/let [giter (gensym "iter__")\n                                    gxs (gensym "s__")\n                                    do-mod (core/fn do-mod [[[k v :as pair] \x26 etc]]\n                                             (core/cond\n                                               (\x3d k :let) `(let ~v ~(do-mod etc))\n                                               (\x3d k :while) `(when ~v ~(do-mod etc))\n                                               (\x3d k :when) `(if ~v\n                                                              ~(do-mod etc)\n                                                              (recur (rest ~gxs)))\n                                               (core/keyword? k) (err "Invalid \'for\' keyword " k)\n                                               next-groups\n                                               `(let [iterys# ~(emit-bind next-groups)\n                                                      fs# (seq (iterys# ~next-expr))]\n                                                  (if fs#\n                                                    (concat fs# (~giter (rest ~gxs)))\n                                                    (recur (rest ~gxs))))\n                                               :else `(cons ~body-expr\n                                                        (~giter (rest ~gxs)))))]\n                           (if next-groups\n                             #_ "not the inner-most loop"\n                             `(fn ~giter [~gxs]\n                                (lazy-seq\n                                  (loop [~gxs ~gxs]\n                                    (when-first [~bind ~gxs]\n                                      ~(do-mod mod-pairs)))))\n                             #_"inner-most loop"\n                             (core/let [gi (gensym "i__")\n                                        gb (gensym "b__")\n                                        do-cmod (core/fn do-cmod [[[k v :as pair] \x26 etc]]\n                                                  (core/cond\n                                                    (\x3d k :let) `(let ~v ~(do-cmod etc))\n                                                    (\x3d k :while) `(when ~v ~(do-cmod etc))\n                                                    (\x3d k :when) `(if ~v\n                                                                   ~(do-cmod etc)\n                                                                   (recur\n                                                                     (unchecked-inc ~gi)))\n                                                    (core/keyword? k)\n                                                    (err "Invalid \'for\' keyword " k)\n                                                    :else\n                                                    `(do (chunk-append ~gb ~body-expr)\n                                                         (recur (unchecked-inc ~gi)))))]\n                               `(fn ~giter [~gxs]\n                                  (lazy-seq\n                                    (loop [~gxs ~gxs]\n                                      (when-let [~gxs (seq ~gxs)]\n                                        (if (chunked-seq? ~gxs)\n                                          (let [c# ^not-native (chunk-first ~gxs)\n                                                size# (count c#)\n                                                ~gb (chunk-buffer size#)]\n                                            (if (coercive-boolean\n                                                  (loop [~gi 0]\n                                                    (if (\x3c ~gi size#)\n                                                      (let [~bind (-nth c# ~gi)]\n                                                        ~(do-cmod mod-pairs))\n                                                      true)))\n                                              (chunk-cons\n                                                (chunk ~gb)\n                                                (~giter (chunk-rest ~gxs)))\n                                              (chunk-cons (chunk ~gb) nil)))\n                                          (let [~bind (first ~gxs)]\n                                            ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))\n\n(core/defmacro doseq\n  "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \\"for\\".  Does not retain\n  the head of the sequence. Returns nil."\n  [seq-exprs \x26 body]\n  (assert-args doseq\n    (vector? seq-exprs) "a vector for its binding"\n    (even? (count seq-exprs)) "an even number of forms in binding vector")\n  (core/let [err (core/fn [\x26 msg] (throw (ex-info (apply core/str msg) {})))\n             step (core/fn step [recform exprs]\n                    (core/if-not exprs\n                      [true `(do ~@body nil)]\n                      (core/let [k (first exprs)\n                                 v (second exprs)\n\n                                 seqsym (gensym "seq__")\n                                 recform (if (core/keyword? k) recform `(recur (next ~seqsym) nil 0 0))\n                                 steppair (step recform (nnext exprs))\n                                 needrec (steppair 0)\n                                 subform (steppair 1)]\n                        (core/cond\n                          (\x3d k :let) [needrec `(let ~v ~subform)]\n                          (\x3d k :while) [false `(when ~v\n                                                 ~subform\n                                                 ~@(core/when needrec [recform]))]\n                          (\x3d k :when) [false `(if ~v\n                                                (do\n                                                  ~subform\n                                                  ~@(core/when needrec [recform]))\n                                                ~recform)]\n                          (core/keyword? k) (err "Invalid \'doseq\' keyword" k)\n                          :else (core/let [chunksym (with-meta (gensym "chunk__")\n                                                      {:tag \'not-native})\n                                           countsym (gensym "count__")\n                                           isym     (gensym "i__")\n                                           recform-chunk  `(recur ~seqsym ~chunksym ~countsym (unchecked-inc ~isym))\n                                           steppair-chunk (step recform-chunk (nnext exprs))\n                                           subform-chunk  (steppair-chunk 1)]\n                                  [true `(loop [~seqsym   (seq ~v)\n                                                ~chunksym nil\n                                                ~countsym 0\n                                                ~isym     0]\n                                           (if (coercive-boolean (\x3c ~isym ~countsym))\n                                             (let [~k (-nth ~chunksym ~isym)]\n                                               ~subform-chunk\n                                               ~@(core/when needrec [recform-chunk]))\n                                             (when-let [~seqsym (seq ~seqsym)]\n                                               (if (chunked-seq? ~seqsym)\n                                                 (let [c# (chunk-first ~seqsym)]\n                                                   (recur (chunk-rest ~seqsym) c#\n                                                     (count c#) 0))\n                                                 (let [~k (first ~seqsym)]\n                                                   ~subform\n                                                   ~@(core/when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))\n\n(core/defmacro array [\x26 rest]\n  (core/let [xs-str (core/-\x3e\x3e (repeat "~{}")\n                      (take (count rest))\n                      (interpose ",")\n                      (apply core/str))]\n    (vary-meta\n      (list* \'js* (core/str "[" xs-str "]") rest)\n      assoc :tag \'array)))\n\n(core/defmacro make-array\n  ([size]\n   (vary-meta\n     (if (core/number? size)\n       `(array ~@(take size (repeat nil)))\n       `(js/Array. ~size))\n     assoc :tag \'array))\n  ([type size]\n   `(cljs.core/make-array ~size))\n  ([type size \x26 more-sizes]\n   (vary-meta\n     `(let [dims#     (list ~@more-sizes)\n            dimarray# (cljs.core/make-array ~size)]\n        (dotimes [i# (alength dimarray#)]\n          (aset dimarray# i# (apply cljs.core/make-array nil dims#)))\n        dimarray#)\n     assoc :tag \'array)))\n\n(core/defmacro list\n  ([]\n   \'(.-EMPTY cljs.core/List))\n  ([x]\n   `(cljs.core/List. nil ~x nil 1 nil))\n  ([x \x26 xs]\n   (core/let [cnt (core/inc (count xs))]\n     `(cljs.core/List. nil ~x (list ~@xs) ~cnt nil))))\n\n(core/defmacro vector\n  ([] \'(.-EMPTY cljs.core/PersistentVector))\n  ([\x26 xs]\n   (core/let [cnt (count xs)]\n     (if (core/\x3c cnt 32)\n       `(cljs.core/PersistentVector. nil ~cnt 5\n          (.-EMPTY-NODE cljs.core/PersistentVector) (array ~@xs) nil)\n       (vary-meta\n         `(.fromArray cljs.core/PersistentVector (array ~@xs) true)\n         assoc :tag \'cljs.core/PersistentVector)))))\n\n(core/defmacro array-map\n  ([] \'(.-EMPTY cljs.core/PersistentArrayMap))\n  ([\x26 kvs]\n   (core/let [keys (map first (partition 2 kvs))]\n     (if (core/and (every? #(\x3d (:op (cljs.analyzer/unwrap-quote %)) :const)\n                     (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze \x26env %)) keys))\n           (\x3d (count (into #{} keys)) (count keys)))\n       `(cljs.core/PersistentArrayMap. nil ~(clojure.core// (count kvs) 2) (array ~@kvs) nil)\n       `(.createAsIfByAssoc cljs.core/PersistentArrayMap (array ~@kvs))))))\n\n(core/defmacro hash-map\n  ([] `(.-EMPTY cljs.core/PersistentHashMap))\n  ([\x26 kvs]\n   (core/let [pairs (partition 2 kvs)\n              ks    (map first pairs)\n              vs    (map second pairs)]\n     (vary-meta\n       `(.fromArrays cljs.core/PersistentHashMap (array ~@ks) (array ~@vs))\n       assoc :tag \'cljs.core/PersistentHashMap))))\n\n(core/defmacro hash-set\n  ([] `(.-EMPTY cljs.core/PersistentHashSet))\n  ([\x26 xs]\n    (if (core/and (core/\x3c\x3d (count xs) 8)\n                  (every? #(\x3d (:op (cljs.analyzer/unwrap-quote %)) :const)\n                    (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze \x26env %)) xs))\n                  (\x3d (count (into #{} xs)) (count xs)))\n      `(cljs.core/PersistentHashSet. nil\n         (cljs.core/PersistentArrayMap. nil ~(count xs) (array ~@(interleave xs (repeat nil))) nil)\n         nil)\n      (vary-meta\n        `(.createAsIfByAssoc cljs.core/PersistentHashSet (array ~@xs))\n        assoc :tag \'cljs.core/PersistentHashSet))))\n\n(core/defn- js-obj* [kvs]\n  (core/let [kvs-str (core/-\x3e\x3e (repeat "~{}:~{}")\n                       (take (count kvs))\n                       (interpose ",")\n                       (apply core/str))]\n    (vary-meta\n      (list* \'js* (core/str "({" kvs-str "})") (apply concat kvs))\n      assoc :tag \'object)))\n\n(core/defmacro js-obj [\x26 rest]\n  (core/let [sym-or-str? (core/fn [x] (core/or (core/symbol? x) (core/string? x)))\n             filter-on-keys (core/fn [f coll]\n                              (core/-\x3e\x3e coll\n                                (filter (core/fn [[k _]] (f k)))\n                                (into {})))\n             kvs (into {} (map vec (partition 2 rest)))\n             sym-pairs (filter-on-keys core/symbol? kvs)\n             expr-\x3elocal (zipmap\n                           (filter (complement sym-or-str?) (keys kvs))\n                           (repeatedly gensym))\n             obj (gensym "obj")]\n    (if (empty? rest)\n      (js-obj* \'())\n      `(let [~@(apply concat (clojure.set/map-invert expr-\x3elocal))\n            ~obj ~(js-obj* (filter-on-keys core/string? kvs))]\n        ~@(map (core/fn [[k v]] `(goog.object/set ~obj ~k ~v)) sym-pairs)\n        ~@(map (core/fn [[k v]] `(goog.object/set ~obj ~v ~(core/get kvs k))) expr-\x3elocal)\n        ~obj))))\n\n(core/defmacro alength [a]\n  (vary-meta\n    (core/list \'js* "~{}.length" a)\n    assoc :tag \'number))\n\n(core/defmacro amap\n  "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret."\n  [a idx ret expr]\n  `(let [a# ~a\n         l# (alength a#)\n         ~ret (cljs.core/aclone a#)]\n     (loop  [~idx 0]\n       (if (\x3c ~idx l#)\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))\n\n(core/defmacro areduce\n  "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret."\n  [a idx ret init expr]\n  `(let [a# ~a\n         l# (alength a#)]\n     (loop  [~idx 0 ~ret ~init]\n       (if (\x3c ~idx l#)\n         (recur (inc ~idx) ~expr)\n         ~ret))))\n\n(core/defmacro dotimes\n  "bindings \x3d\x3e name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1."\n  [bindings \x26 body]\n  (core/let [i (first bindings)\n             n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (\x3c ~i n#)\n           ~@body\n           (recur (inc ~i)))))))\n\n(core/defn- check-valid-options\n  "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil."\n  [options \x26 valid-keys]\n  (core/when (seq (apply disj (apply core/hash-set (keys options)) valid-keys))\n    (throw\n      (apply core/str "Only these options are valid: "\n        (first valid-keys)\n        (map #(core/str ", " %) (rest valid-keys))))))\n\n(core/defmacro defmulti\n  "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy"\n  {:arglists \'([name docstring? attr-map? dispatch-fn \x26 options])}\n  [mm-name \x26 options]\n  (core/let [docstring   (if (core/string? (first options))\n                           (first options)\n                           nil)\n             options     (if (core/string? (first options))\n                           (next options)\n                           options)\n             m           (if (map? (first options))\n                           (first options)\n                           {})\n             options     (if (map? (first options))\n                           (next options)\n                           options)\n             dispatch-fn (first options)\n             options     (next options)\n             m           (if docstring\n                           (assoc m :doc docstring)\n                           m)\n             m           (if (meta mm-name)\n                           (conj (meta mm-name) m)\n                           m)\n             mm-ns (core/-\x3e \x26env :ns :name core/str)]\n    (core/when (\x3d (count options) 1)\n      (throw\n        #?(:clj (Exception. "The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)")\n           :cljs (js/Error. "The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)"))))\n    (core/let [options (apply core/hash-map options)\n               default (core/get options :default :default)]\n      (check-valid-options options :default :hierarchy)\n      `(defonce ~(with-meta mm-name m)\n         (let [method-table# (atom {})\n               prefer-table# (atom {})\n               method-cache# (atom {})\n               cached-hierarchy# (atom {})\n               hierarchy# (cljs.core/get ~options :hierarchy ((~\'js* "cljs.core.get_global_hierarchy")))]\n           (cljs.core/MultiFn. (cljs.core/symbol ~mm-ns ~(name mm-name)) ~dispatch-fn ~default hierarchy#\n             method-table# prefer-table# method-cache# cached-hierarchy#))))))\n\n(core/defmacro defmethod\n  "Creates and installs a new method of multimethod associated with dispatch-value. "\n  [multifn dispatch-val \x26 fn-tail]\n  `(-add-method ~(with-meta multifn {:tag \'cljs.core/MultiFn}) ~dispatch-val (fn ~@fn-tail)))\n\n(core/defmacro time\n  "Evaluates expr and prints the time it took. Returns the value of expr."\n  [expr]\n  `(let [start# (system-time)\n         ret# ~expr]\n     (prn (cljs.core/str "Elapsed time: "\n            (.toFixed (- (system-time) start#) 6)\n            " msecs"))\n     ret#))\n\n(core/defmacro simple-benchmark\n  "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr\'s string representation will be produced\n  using pr-str in any case."\n  [bindings expr iterations \x26 {:keys [print-fn] :or {print-fn \'println}}]\n  (core/let [bs-str   (pr-str bindings)\n             expr-str (pr-str expr)]\n    `(let ~bindings\n       (let [start#   (.getTime (js/Date.))\n             ret#     (dotimes [_# ~iterations] ~expr)\n             end#     (.getTime (js/Date.))\n             elapsed# (- end# start#)]\n         (~print-fn (str ~bs-str ", " ~expr-str ", "\n                      ~iterations " runs, " elapsed# " msecs"))))))\n\n(def ^:private cs (into [] (map (comp gensym core/str core/char) (range 97 118))))\n\n(core/defn- gen-apply-to-helper\n  ([] (gen-apply-to-helper 1))\n  ([n]\n   (if (core/\x3c\x3d n 20)\n     `(let [~(cs (core/dec n)) (-first ~\'args)\n            ~\'args (-rest ~\'args)]\n        (if (\x3d\x3d ~\'argc ~n)\n          (~\'f ~@(take n cs))\n          ~(gen-apply-to-helper (core/inc n))))\n     `(throw (js/Error. "Only up to 20 arguments supported on functions")))))\n\n(core/defmacro gen-apply-to []\n  `(do\n     (set! ~\'*unchecked-if* true)\n     (defn ~\'apply-to [~\'f ~\'argc ~\'args]\n       (let [~\'args (seq ~\'args)]\n         (if (zero? ~\'argc)\n           (~\'f)\n           ~(gen-apply-to-helper))))\n     (set! ~\'*unchecked-if* false)))\n\n(core/defn- gen-apply-to-simple-helper\n  [f num-args args]\n  (core/let [new-arg-sym (symbol (core/str "a" num-args))\n             proto-name (core/str "cljs$core$IFn$_invoke$arity$" (core/inc num-args))\n             proto-prop (symbol (core/str ".-" proto-name))\n             proto-inv (symbol (core/str "." proto-name))\n             next-sym (symbol (core/str "next_" num-args))\n             all-args (mapv #(symbol (core/str "a" %)) (range (core/inc num-args)))]\n    `(let [~new-arg-sym (cljs.core/-first ~args)\n           ~next-sym (cljs.core/next ~args)]\n       (if (nil? ~next-sym)\n         (if (~proto-prop ~f)\n           (~proto-inv ~f ~@all-args)\n           (.call ~f ~f ~@all-args))\n         ~(if (core/\x3c\x3d 19 num-args)\n            ;; We\'ve exhausted all protocols, fallback to .apply:\n            `(let [arr# (cljs.core/array ~@all-args)]\n               (loop [s# ~next-sym]\n                 (when s#\n                   (do (.push arr# (cljs.core/-first s#))\n                       (recur (cljs.core/next s#)))))\n               (.apply ~f ~f arr#))\n            (gen-apply-to-simple-helper f (core/inc num-args) next-sym))))))\n\n(core/defmacro gen-apply-to-simple\n  [f num-args args]\n  (gen-apply-to-simple-helper f num-args args))\n\n(core/defmacro with-out-str\n  "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls."\n  [\x26 body]\n  `(let [sb# (goog.string/StringBuffer.)]\n     (binding [cljs.core/*print-newline* true\n               cljs.core/*print-fn* (fn [x#] (.append sb# x#))]\n       ~@body)\n     (cljs.core/str sb#)))\n\n(core/defmacro lazy-cat\n  "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) \x3d\x3d\x3d (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"\n  [\x26 colls]\n  `(concat ~@(map #(core/list `lazy-seq %) colls)))\n\n(core/defmacro js-str [s]\n  (core/list \'js* "\'\'+~{}" s))\n\n(core/defmacro es6-iterable [ty]\n  `(goog.object/set (.-prototype ~ty) cljs.core/ITER_SYMBOL\n     (fn []\n       (this-as this#\n         (cljs.core/es6-iterator this#)))))\n\n(core/defmacro ns-publics\n  "Returns a map of the public intern mappings for the namespace."\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                         (\x3d (first quoted-ns) \'quote)\n                         (core/symbol? (second quoted-ns)))\n    "Argument to ns-publics must be a quoted symbol")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[sym _]]\n              `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n            (filter (core/fn [[_ info]]\n                      (not (core/-\x3e info :meta :private)))\n              (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs])))])))\n\n(core/defmacro ns-imports\n  "Returns a map of the import mappings for the namespace."\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                         (\x3d (first quoted-ns) \'quote)\n                         (core/symbol? (second quoted-ns)))\n    "Argument to ns-imports must be a quoted symbol")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[ctor qualified-ctor]]\n              `[(symbol ~(name ctor)) ~(symbol qualified-ctor)])\n            (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :imports]))])))\n\n(core/defmacro ns-interns\n  "Returns a map of the intern mappings for the namespace."\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                 (\x3d (first quoted-ns) \'quote)\n                 (core/symbol? (second quoted-ns)))\n    "Argument to ns-interns must be a quoted symbol")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[sym _]]\n              `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n            (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs]))])))\n\n(core/defmacro ns-unmap\n  "Removes the mappings for the symbol from the namespace."\n  [quoted-ns quoted-sym]\n  (core/assert\n    (core/and (seq? quoted-ns) (\x3d (first quoted-ns) \'quote) (core/symbol? (second quoted-ns))\n              (seq? quoted-sym) (\x3d (first quoted-sym) \'quote) (core/symbol? (second quoted-sym)))\n    "Arguments to ns-unmap must be quoted symbols")\n  (core/let [ns (second quoted-ns)\n             sym (second quoted-sym)]\n    (swap! env/*compiler* update-in [::ana/namespaces ns :defs] dissoc sym)\n    `(js-delete ~(comp/munge ns) ~(comp/munge (core/str sym)))))\n\n(core/defmacro vswap!\n  "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in."\n  [vol f \x26 args]\n  `(-vreset! ~vol (~f (-deref ~vol) ~@args)))\n\n(core/defmacro locking\n  [x \x26 forms]\n  `(do ~@forms))\n\n;; An internal-use Var for defining specs on the ns special form\n(core/defmacro ^:private ns-special-form [])\n\n(core/defmacro require\n  "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A \'lib\' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib\'s name also locates its root directory\n  within classpath using Java\'s package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  \'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol \'x.y.z; it has the root directory\n  \x3cclasspath\x3e/x/y/, and its root resource is \x3cclasspath\x3e/x/y/z.clj. The root\n  resource should contain code to create the lib\'s namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib\'s namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require \'[clojure.string :as string])"\n  [\x26 args]\n  `(~\'ns* ~(cons :require args)))\n\n(core/defmacro require-macros\n  "Similar to require but only for macros."\n  [\x26 args]\n  `(~\'ns* ~(cons :require-macros args)))\n\n(core/defmacro use\n  "Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use \'[clojure.set :only [intersection]])"\n  [\x26 args]\n  `(~\'ns* ~(cons :use args)))\n\n(core/defmacro use-macros\n  "Similar to use but only for macros."\n  [\x26 args]\n  `(~\'ns* ~(cons :use-macros args)))\n\n(core/defmacro import\n  "import-list \x3d\x3e (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly."\n  [\x26 import-symbols-or-lists]\n  `(~\'ns* ~(cons :import import-symbols-or-lists)))\n\n(core/defmacro refer-clojure\n  "Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var\'s name, in order to prevent clashes."\n  [\x26 args]\n  `(~\'ns* ~(cons :refer-clojure args)))\n\n;; INTERNAL - do not use, only for Node.js\n(core/defmacro load-file* [f]\n  `(goog/nodeGlobalRequire ~f))\n\n(core/defmacro macroexpand-1\n  "If form represents a macro form, returns its expansion,\n  else returns form."\n  [quoted]\n  (core/assert (core/\x3d (core/first quoted) \'quote)\n    "Argument to macroexpand-1 must be quoted")\n  (core/let [form (second quoted)]\n    (if (seq? form)\n      `(quote ~(ana/macroexpand-1 \x26env form))\n      form)))\n\n(core/defmacro macroexpand\n  "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms."\n  [quoted]\n  (core/assert (core/\x3d (core/first quoted) \'quote)\n    "Argument to macroexpand must be quoted")\n  (core/let [form (second quoted)\n             env \x26env]\n    (if (seq? form)\n      (core/loop [form form form\' (ana/macroexpand-1 env form)]\n        (core/if-not (core/identical? form form\')\n          (recur form\' (ana/macroexpand-1 env form\'))\n          `(quote ~form\')))\n      form)))\n\n(core/defn- multi-arity-fn? [fdecl]\n  (core/\x3c 1 (count fdecl)))\n\n(core/defn- variadic-fn? [fdecl]\n  (core/and (\x3d 1 (count fdecl))\n            (some \'#{\x26} (ffirst fdecl))))\n\n(core/defn- variadic-fn*\n  ([sym method]\n   (variadic-fn* sym method true))\n  ([sym [arglist \x26 body :as method] solo]\n   (core/let [sig (remove \'#{\x26} arglist)\n              restarg (gensym "seq")]\n     (core/letfn [(get-delegate []\n                    \'cljs$core$IFn$_invoke$arity$variadic)\n                  (get-delegate-prop []\n                    (symbol (core/str "-" (get-delegate))))\n                  (param-bind [param]\n                    `[~param (^::ana/no-resolve first ~restarg)\n                      ~restarg (^::ana/no-resolve next ~restarg)])\n                  (apply-to []\n                    (if (core/\x3c 1 (count sig))\n                      (core/let [params (repeatedly (core/dec (count sig)) gensym)]\n                        `(fn\n                           ([~restarg]\n                            (let [~@(mapcat param-bind params)]\n                              (this-as self#\n                                (. self# (~(get-delegate) ~@params ~restarg)))))))\n                      `(fn\n                         ([~restarg]\n                          (this-as self#\n                            (. self# (~(get-delegate) (seq ~restarg))))))))]\n       `(do\n          (set! (. ~sym ~(get-delegate-prop))\n            (fn (~(vec sig) ~@body)))\n          ~@(core/when solo\n              `[(set! (. ~sym ~\'-cljs$lang$maxFixedArity)\n                  ~(core/dec (count sig)))])\n          (js-inline-comment " @this {Function} ")\n          ;; dissoc :top-fn so this helper gets ignored in cljs.analyzer/parse \'set!\n          (set! (. ~(vary-meta sym dissoc :top-fn) ~\'-cljs$lang$applyTo)\n            ~(apply-to)))))))\n\n(core/defmacro copy-arguments [dest]\n  `(let [len# (alength (js-arguments))]\n     (loop [i# 0]\n       (when (\x3c i# len#)\n         (.push ~dest (unchecked-get (js-arguments) i#))\n         (recur (inc i#))))))\n\n(core/defn- elide-implicit-macro-args [arglists]\n  (core/map (core/fn [arglist]\n              (if (core/vector? arglist)\n                (core/subvec arglist 2)\n                (core/drop 2 arglist)))\n    arglists))\n\n(core/defn- variadic-fn [name meta [[arglist \x26 body :as method] :as fdecl] emit-var?]\n  (core/letfn [(dest-args [c]\n                 (map (core/fn [n] `(unchecked-get (js-arguments) ~n))\n                   (range c)))]\n    (core/let [rname (symbol (core/str ana/*cljs-ns*) (core/str name))\n               sig   (remove \'#{\x26} arglist)\n               c-1   (core/dec (count sig))\n               macro? (:macro meta)\n               mfa   (core/cond-\x3e c-1 macro? (core/- 2))\n               meta  (assoc meta\n                       :top-fn\n                       {:variadic? true\n                        :fixed-arity mfa\n                        :max-fixed-arity mfa\n                        :method-params (core/cond-\x3e [sig] macro? elide-implicit-macro-args)\n                        :arglists (core/cond-\x3e (core/list arglist) macro? elide-implicit-macro-args)\n                        :arglists-meta (doall (map meta [arglist]))})\n               name  (with-meta name meta)]\n      `(do\n         (def ~name\n           (fn [~\'var_args]\n             (let [args# (array)]\n               (copy-arguments args#)\n               (let [argseq# (when (\x3c ~c-1 (alength args#))\n                               (new ^::ana/no-resolve cljs.core/IndexedSeq\n                                 (.slice args# ~c-1) 0 nil))]\n                 (. ~rname (~\'cljs$core$IFn$_invoke$arity$variadic ~@(dest-args c-1) argseq#))))))\n         ~(variadic-fn* name method)\n         ~(core/when emit-var? `(var ~name))))))\n\n(core/comment\n  (require \'[clojure.pprint :as pp])\n  (pp/pprint (variadic-fn \'foo {} \'(([\x26 xs]))))\n  (pp/pprint (variadic-fn \'foo {} \'(([a \x26 xs] xs))))\n  (pp/pprint (variadic-fn \'foo {} \'(([a b \x26 xs] xs))))\n  (pp/pprint (variadic-fn \'foo {} \'(([a [b \x26 cs] \x26 xs] xs))))\n  )\n\n(core/defn- multi-arity-fn [name meta fdecl emit-var?]\n  (core/letfn [(dest-args [c]\n                 (map (core/fn [n] `(unchecked-get (js-arguments) ~n))\n                   (range c)))\n               (fixed-arity [rname sig]\n                 (core/let [c (count sig)]\n                   [c `(. ~rname\n                         (~(symbol\n                             (core/str "cljs$core$IFn$_invoke$arity$" c))\n                           ~@(dest-args c)))]))\n               (fn-method [name [sig \x26 body :as method]]\n                 (if (some \'#{\x26} sig)\n                   (variadic-fn* name method false)\n                   ;; fix up individual :fn-method meta for\n                   ;; cljs.analyzer/parse \'set! :top-fn handling\n                   `(set!\n                      (. ~(vary-meta name update :top-fn merge\n                            {:variadic? false :fixed-arity (count sig)})\n                        ~(symbol (core/str "-cljs$core$IFn$_invoke$arity$"\n                                   (count sig))))\n                      (fn ~method))))]\n    (core/let [rname    (symbol (core/str ana/*cljs-ns*) (core/str name))\n               arglists (map first fdecl)\n               varsig?  #(some \'#{\x26} %)\n               variadic (boolean (some varsig? arglists))\n               sigs     (remove varsig? arglists)\n               maxfa    (apply core/max\n                          (concat\n                            (map count sigs)\n                            [(core/- (count (first (filter varsig? arglists))) 2)]))\n               macro?   (:macro meta)\n               mfa      (core/cond-\x3e maxfa macro? (core/- 2))\n               meta     (assoc meta\n                          :top-fn\n                          {:variadic? variadic\n                           :fixed-arity mfa\n                           :max-fixed-arity mfa\n                           :method-params (core/cond-\x3e sigs macro? elide-implicit-macro-args)\n                           :arglists (core/cond-\x3e arglists macro? elide-implicit-macro-args)\n                           :arglists-meta (doall (map meta arglists))})\n               args-sym (gensym "args")\n               param-counts (map count arglists)\n               name     (with-meta name meta)]\n      (core/when (not\x3d (distinct param-counts) param-counts)\n        (ana/warning :overload-arity {} {:name name}))\n      `(do\n         (def ~name\n           (fn [~\'var_args]\n             (case (alength (js-arguments))\n               ~@(mapcat #(fixed-arity rname %) sigs)\n               ~(if variadic\n                  `(let [args-arr# (array)]\n                     (copy-arguments args-arr#)\n                     (let [argseq# (new ^::ana/no-resolve cljs.core/IndexedSeq\n                                        (.slice args-arr# ~maxfa) 0 nil)]\n                       (. ~rname\n                          (~\'cljs$core$IFn$_invoke$arity$variadic\n                           ~@(dest-args maxfa)\n                           argseq#))))\n                  (if (:macro meta)\n                    `(throw (js/Error.\n                             (str "Invalid arity: " (- (alength (js-arguments)) 2))))\n                    `(throw (js/Error.\n                             (str "Invalid arity: " (alength (js-arguments))))))))))\n         ~@(map #(fn-method name %) fdecl)\n         ;; optimization properties\n         (set! (. ~name ~\'-cljs$lang$maxFixedArity) ~maxfa)\n         ~(core/when emit-var? `(var ~name))))))\n\n(core/comment\n  (require \'[clojure.pprint :as pp])\n  (pp/pprint (multi-arity-fn \'foo {} \'(([a]) ([a b]))))\n  (pp/pprint (multi-arity-fn \'foo {} \'(([a]) ([a \x26 xs]))))\n  (pp/pprint (multi-arity-fn \'foo {} \'(([a]) ([a [b \x26 cs] \x26 xs]))))\n  ;; CLJS-1216\n  (pp/pprint (multi-arity-fn \'foo {} \'(([a]) ([a b \x26 xs]))))\n  )\n\n(def\n  ^{:doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions."\n    :arglists \'([name doc-string? attr-map? [params*] prepost-map? body]\n                 [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n    :macro true}\n  defn (core/fn defn [\x26form \x26env name \x26 fdecl]\n         ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n         (if (core/instance? #?(:clj clojure.lang.Symbol :cljs Symbol) name)\n           nil\n           (throw\n             #?(:clj (IllegalArgumentException. "First argument to defn must be a symbol")\n                :cljs (js/Error. "First argument to defn must be a symbol"))))\n         (core/let [m (if (core/string? (first fdecl))\n                        {:doc (first fdecl)}\n                        {})\n                    fdecl (if (core/string? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    m (if (map? (first fdecl))\n                        (conj m (first fdecl))\n                        m)\n                    fdecl (if (map? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    fdecl (if (vector? (first fdecl))\n                            (core/list fdecl)\n                            fdecl)\n                    m (if (map? (last fdecl))\n                        (conj m (last fdecl))\n                        m)\n                    fdecl (if (map? (last fdecl))\n                            (butlast fdecl)\n                            fdecl)\n                    m (conj {:arglists (core/list \'quote (sigs fdecl))} m)\n                    ;; no support for :inline\n                    ;m (core/let [inline (:inline m)\n                    ;             ifn (first inline)\n                    ;             iname (second inline)]\n                    ;    ;; same as: (if (and (\x3d \'fn ifn) (not (symbol? iname))) ...)\n                    ;    (if (if #?(:clj (clojure.lang.Util/equiv \'fn ifn)\n                    ;               :cljs (\x3d \'fn ifn))\n                    ;          (if #?(:clj (core/instance? clojure.lang.Symbol iname)\n                    ;                 :cljs (core/instance? Symbol iname)) false true))\n                    ;      ;; inserts the same fn name to the inline fn if it does not have one\n                    ;      (assoc m\n                    ;        :inline (cons ifn\n                    ;                  (cons (clojure.lang.Symbol/intern\n                    ;                          (.concat (.getName ^clojure.lang.Symbol name) "__inliner"))\n                    ;                    (next inline))))\n                    ;      m))\n                    m (conj (if (meta name) (meta name) {}) m)]\n           (core/cond\n             (multi-arity-fn? fdecl)\n             (multi-arity-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj "@param {...*} var_args")\n                 m) fdecl (:def-emits-var \x26env))\n\n             (variadic-fn? fdecl)\n             (variadic-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj "@param {...*} var_args")\n                 m) fdecl (:def-emits-var \x26env))\n\n             :else\n             (core/list \'def (with-meta name m)\n               ;;todo - restore propagation of fn name\n               ;;must figure out how to convey primitive hints to self calls first\n               (cons `fn fdecl))))))\n\n#?(:clj  (. (var defn) (setMacro))\n   :cljs (set! (. defn -cljs$lang$macro) true))\n\n(core/defn defmacro\n  "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called."\n  {:arglists \'([name doc-string? attr-map? [params*] body]\n               [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :macro true}\n  [\x26form \x26env name \x26 args]\n  (core/let [prefix (core/loop [p (core/list (vary-meta name assoc :macro true)) args args]\n                      (core/let [f (first args)]\n                        (if (core/string? f)\n                          (recur (cons f p) (next args))\n                          (if (map? f)\n                            (recur (cons f p) (next args))\n                            p))))\n             fdecl (core/loop [fd args]\n                     (if (core/string? (first fd))\n                       (recur (next fd))\n                       (if (map? (first fd))\n                         (recur (next fd))\n                         fd)))\n             fdecl (if (vector? (first fdecl))\n                     (core/list fdecl)\n                     fdecl)\n             add-implicit-args (core/fn [fd]\n                                 (core/let [args (first fd)]\n                                   (cons (vec (cons \'\x26form (cons \'\x26env args))) (next fd))))\n             add-args (core/fn [acc ds]\n                        (if (core/nil? ds)\n                          acc\n                          (core/let [d (first ds)]\n                            (if (map? d)\n                              (conj acc d)\n                              (recur (conj acc (add-implicit-args d)) (next ds))))))\n             fdecl (seq (add-args [] fdecl))\n             decl (core/loop [p prefix d fdecl]\n                    (if p\n                      (recur (next p) (cons (first p) d))\n                      d))]\n    `(let [ret# ~(cons `defn decl)]\n       (set! (. ~name ~\'-cljs$lang$macro) true)\n       ret#)))\n\n#?(:clj  (. (var defmacro) (setMacro))\n   :cljs (set! (. defmacro -cljs$lang$macro) true))\n\n(core/defmacro resolve\n  "Returns the var to which a symbol will be resolved in the namespace else nil."\n  [quoted-sym]\n  (core/assert\n    (core/and (seq? quoted-sym)\n              (\x3d \'quote (first quoted-sym)))\n    "Argument to resolve must be a quoted symbol")\n  (core/let [sym (second quoted-sym)\n             env \x26env\n             [var meta] (try\n                          (core/let [var (ana/resolve-var env sym (ana/confirm-var-exists-throw)) ]\n                            [var (ana/var-meta var)])\n                          (catch #?@(:clj [Throwable t] :cljs [:default e])\n                              [(ana/resolve-var env sym) nil]))\n             resolved (vary-meta (:name var) assoc ::ana/no-resolve true)]\n    `(when (exists? ~resolved)\n       (cljs.core/Var. (fn [] ~resolved) \'~resolved ~meta))))\n'],
null),new p(null,3,[Cl,"clojure/test/check/clojure_test.cljc",Xn,"clojure.test.check.clojure-test",nr,';   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check.clojure-test\n  (:require #?(:clj  [clojure.test :as ct]\n               :cljs [cljs.test :as ct :include-macros true])\n            [clojure.test.check :as tc]\n            [clojure.test.check.clojure-test.assertions]\n            [clojure.test.check.impl :refer [get-current-time-millis]])\n  #?(:cljs (:require-macros [clojure.test.check.clojure-test :refer [defspec]])))\n\n(defn assert-check\n  [{:keys [result result-data] :as m}]\n  (if-let [error (:clojure.test.check.properties/error result-data)]\n    (throw error)\n    (ct/is (clojure.test.check.clojure-test/check? m))))\n\n(def ^:dynamic *default-test-count* 100)\n\n(defn default-reporter-fn\n  "Default function passed as the :reporter-fn to clojure.test.check/quick-check.\n  Delegates to clojure.test/report."\n  [{:keys [type] :as args}]\n  (case type\n    :complete\n    (let [testing-vars #?(:clj ct/*testing-vars*\n                          :cljs (:testing-vars ct/*current-env*))\n          params       (merge (select-keys args [:result :num-tests :seed\n                                                 :time-elapsed-ms])\n                              (when (seq testing-vars)\n                                {:test-var (-\x3e testing-vars first meta :name name)}))]\n      (ct/report {:type :clojure.test.check.clojure-test/complete\n                  :clojure.test.check.clojure-test/property (:property args)\n                  :clojure.test.check.clojure-test/complete params}))\n\n    :trial\n    (ct/report {:type :clojure.test.check.clojure-test/trial\n                :clojure.test.check.clojure-test/property (:property args)\n                :clojure.test.check.clojure-test/trial [(:num-tests args)\n                                                        (:num-tests-total args)]})\n\n    :failure\n    (ct/report {:type :clojure.test.check.clojure-test/shrinking\n                :clojure.test.check.clojure-test/property (:property args)\n                :clojure.test.check.clojure-test/params (vec (:fail args))})\n\n    :shrunk\n    (ct/report {:type :clojure.test.check.clojure-test/shrunk\n                :clojure.test.check.clojure-test/property (:property args)\n                :clojure.test.check.clojure-test/params (-\x3e args :shrunk :smallest vec)})\n    nil))\n\n(def ^:dynamic *default-opts*\n  "The default options passed to clojure.test.check/quick-check\n  by defspec."\n  {:reporter-fn default-reporter-fn})\n\n(defn process-options\n  {:no-doc true}\n  [options]\n  (cond (nil? options) (merge {:num-tests *default-test-count*} *default-opts*)\n        (number? options) (assoc *default-opts* :num-tests options)\n        (map? options) (merge {:num-tests *default-test-count*}\n                              *default-opts*\n                              options)\n        :else (throw (ex-info (str "Invalid defspec options: " (pr-str options))\n                              {:bad-options options}))))\n\n(defmacro defspec\n  "Defines a new clojure.test test var that uses `quick-check` to verify the\n  property, running num-times trials by default.  You can call the function defined as `name`\n  with no arguments to trigger this test directly (i.e., without starting a\n  wider clojure.test run).  If called with arguments, the first argument is the number of\n  trials, optionally followed by keyword arguments as defined for `quick-check`."\n  {:arglists \'([name property] [name num-tests? property] [name options? property])}\n  ([name property] `(defspec ~name nil ~property))\n  ([name options property]\n   `(defn ~(vary-meta name assoc\n                      ::defspec true\n                      :test `(fn []\n                               (clojure.test.check.clojure-test/assert-check\n                                (assoc (~name) :test-var (str \'~name)))))\n      {:arglists \'([] ~\'[num-tests \x26 {:keys [seed max-size reporter-fn]}])}\n      ([] (let [options# (process-options ~options)]\n            (apply ~name (:num-tests options#) (apply concat options#))))\n      ([times# \x26 {:as quick-check-opts#}]\n       (let [options# (merge (process-options ~options) quick-check-opts#)]\n         (apply\n          tc/quick-check\n          times#\n          (vary-meta ~property assoc :name \'~name)\n          (apply concat options#)))))))\n\n(def ^:dynamic *report-trials*\n  "Controls whether property trials should be reported via clojure.test/report.\n  Valid values include:\n\n  * false - no reporting of trials (default)\n  * a function - will be passed a clojure.test/report-style map containing\n  :clojure.test.check/property and :clojure.test.check/trial slots\n  * true - provides quickcheck-style trial reporting (dots) via\n  `trial-report-dots`\n\n  (Note that all reporting requires running `quick-check` within the scope of a\n  clojure.test run (via `test-ns`, `test-all-vars`, etc.))\n\n  Reporting functions offered by clojure.test.check include `trial-report-dots` and\n  `trial-report-periodic` (which prints more verbose trial progress information\n  every `*trial-report-period*` milliseconds)."\n  false)\n\n(def ^:dynamic *report-shrinking*\n  "If true, a verbose report of the property being tested, the\n  failing return value, and the arguments provoking that failure is emitted\n  prior to the start of the shrinking search."\n  false)\n\n(def ^:dynamic *trial-report-period*\n  "Milliseconds between reports emitted by `trial-report-periodic`."\n  10000)\n\n(def ^:private last-trial-report (atom 0))\n\n(defn- get-property-name\n  [{property-fun ::property :as report-map}]\n  (or (-\x3e property-fun meta :name) (ct/testing-vars-str report-map)))\n\n(defn with-test-out* [f]\n  #?(:clj  (ct/with-test-out (f))\n     :cljs (f)))\n\n(defn trial-report-periodic\n  "Intended to be bound as the value of `*report-trials*`; will emit a verbose\n  status every `*trial-report-period*` milliseconds, like this one:\n\n  Passing trial 3286 / 5000 for (your-test-var-name-here) (:)"\n  [m]\n  (let [t (get-current-time-millis)]\n    (when (\x3e (- t *trial-report-period*) @last-trial-report)\n      (with-test-out*\n        (fn []\n          (println "Passing trial"\n                   (-\x3e m ::trial first) "/" (-\x3e m ::trial second)\n                   "for" (get-property-name m))))\n      (reset! last-trial-report t))))\n\n(defn trial-report-dots\n  "Intended to be bound as the value of `*report-trials*`; will emit a single\n  dot every 1000 trials reported."\n  [{[so-far total] ::trial}]\n  (when (pos? so-far)\n    (when (zero? (mod so-far 1000))\n      (print ".")\n      (flush))\n    (when (\x3d\x3d so-far total) (println))))\n\n(def ^:dynamic *report-completion*\n  "If true, completed tests report test-var, num-tests and seed. Failed tests\n  report shrunk results. Defaults to true."\n  true)\n\n(when #?(:clj true :cljs (not (and *ns* (re-matches #".*\\$macros" (name (ns-name *ns*))))))\n  ;; This check accomodates a number of tools that rebind ct/report\n  ;; to be a regular function instead of a multimethod, and may do\n  ;; so before this code is loaded (see TCHECK-125)\n  (if-not (instance? #?(:clj clojure.lang.MultiFn :cljs MultiFn) ct/report)\n    (binding [*out* #?(:clj *err* :cljs *out*)]\n      (println "clojure.test/report is not a multimethod, some reporting functions have been disabled."))\n    (let [begin-test-var-method (get-method ct/report #?(:clj  :begin-test-var\n                                                         :cljs [::ct/default :begin-test-var]))]\n      (defmethod ct/report #?(:clj  :begin-test-var\n                              :cljs [::ct/default :begin-test-var]) [m]\n        (reset! last-trial-report (get-current-time-millis))\n        (when begin-test-var-method (begin-test-var-method m)))\n\n      (defmethod ct/report #?(:clj ::trial :cljs [::ct/default ::trial]) [m]\n        (when-let [trial-report-fn (and *report-trials*\n                                        (if (true? *report-trials*)\n                                          trial-report-dots\n                                          *report-trials*))]\n          (trial-report-fn m)))\n\n      (defmethod ct/report #?(:clj ::shrinking :cljs [::ct/default ::shrinking]) [m]\n        (when *report-shrinking*\n          (with-test-out*\n            (fn []\n              (println "Shrinking" (get-property-name m)\n                "starting with parameters" (pr-str (::params m)))))))\n\n      (defmethod ct/report #?(:clj ::complete :cljs [::ct/default ::complete]) [m]\n        (when *report-completion*\n          (prn (::complete m))))\n\n      (defmethod ct/report #?(:clj ::shrunk :cljs [::ct/default ::shrunk]) [m]\n        (when *report-completion*\n          (with-test-out*\n            (fn [] (prn m))))))))\n'],
null),new p(null,3,[Cl,"cljs/tools/reader/impl/inspect.cljs",Xn,"cljs.tools.reader.impl.inspect",nr,';;   Copyright (c) Russ Olsen, Nicola Mometto, Rich Hickey \x26 contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.tools.reader.impl.inspect)\n\n(declare inspect*)\n\n(defn- inspect*-col [truncate col start end]\n  (let [n (count col)\n        l (if truncate 0 (min 10 n))\n        elements (map (partial inspect* true) (take l col))\n        content (apply str (interpose " " elements))\n        suffix (if (\x3c l n) "...")]\n    (str start content suffix end)))\n\n(defn- dispatch-inspect\n  [_ x]\n  (cond\n   (nil? x) :nil\n   (string? x) :string\n   (keyword? x) :strable\n   (number? x) :strable\n   (symbol? x) :strable\n   (vector? x) :vector\n   (list? x)  :list\n   (map? x) :map\n   (set? x) :set\n   (\x3d x true) :strable\n   (\x3d x false) :strable\n   :default (type x)))\n\n(defmulti inspect* dispatch-inspect)\n\n(defmethod inspect* :string [truncate ^String x]\n  (let [n (if truncate 5 20)\n        suffix (if (\x3e (.-length x) n) "...\\"" "\\"")]\n    (str\n      \\"\n      (.substring ^String x 0 (min n (.-length x)))\n      suffix)))\n\n(defmethod inspect* :strable [truncate x] (str x))\n\n(defmethod inspect* cljs.core/IndexedSeq [truncate x]\n  "\x3cindexed seq\x3e")\n\n(defmethod inspect* cljs.core/PersistentArrayMapSeq [truncate x]\n  "\x3cmap seq\x3e")\n\n(defmethod inspect* cljs.core/NodeSeq [truncate x]\n  "\x3cmap seq\x3e")\n\n(defmethod inspect* cljs.core/Cons [truncate x] "\x3ccons\x3e")\n\n(defmethod inspect* cljs.core/LazySeq [truncate x] "\x3clazy seq\x3e")\n\n(defmethod inspect* :nil [_ _] "nil")\n\n(defmethod inspect* :list [truncate col]\n  (inspect*-col truncate col \\( \\)))\n\n(defmethod inspect* :map [truncate m]\n  (let [len (count m)\n        n-shown (if truncate 0 len)\n        contents (apply concat (take n-shown m))\n        suffix (if (\x3e len n-shown) "...}" \\})]\n    (inspect*-col truncate contents \\{ suffix)))\n\n(defmethod inspect* :set [truncate col]\n  (inspect*-col truncate col "#{" \\}))\n\n(defmethod inspect* :vector [truncate col]\n  (inspect*-col truncate col \\[ \\]))\n\n(defmethod inspect* :default [truncate x]\n  (pr-str (type x)))\n\n(defn inspect\n  "Return a string description of the value supplied.\n   May be the a string version of the value itself (e.g. \\"true\\")\n   or it may be a description (e.g. \\"an instance of Foo\\").\n   If truncate is true then return a very terse version of\n   the inspection."\n  ([x] (inspect* false x))\n  ([truncate x] (inspect* truncate x)))\n'],
null),new p(null,3,[Cl,"cljs/tools/reader/impl/commons.cljs",Xn,"cljs.tools.reader.impl.commons",nr,';;   Copyright (c) Nicola Mometto, Rich Hickey \x26 contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.tools.reader.impl.commons\n  (:refer-clojure :exclude [char])\n  (:require\n   [cljs.tools.reader.impl.errors :refer [reader-error]]\n   [cljs.tools.reader.reader-types :refer [peek-char read-char]]\n   [cljs.tools.reader.impl.utils :refer [numeric? newline? char]]))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; helpers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn ^boolean number-literal?\n  "Checks whether the reader is at the start of a number literal"\n  [^not-native reader initch]\n  (or (numeric? initch)\n      (and (or (identical? \\+ initch) (identical?  \\- initch))\n           (numeric? (peek-char reader)))))\n\n(defn read-past\n  "Read until first character that doesn\'t match pred, returning\n   char."\n  [pred ^not-native rdr]\n  (loop [ch (read-char rdr)]\n    (if ^boolean (pred ch)\n      (recur (read-char rdr))\n      ch)))\n\n(defn skip-line\n  "Advances the reader to the end of a line. Returns the reader"\n  [^not-native reader]\n  (loop []\n    (when-not (newline? (read-char reader))\n      (recur)))\n  reader)\n\n(def int-pattern #"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$")\n(def ratio-pattern #"([-+]?[0-9]+)/([0-9]+)")\n(def float-pattern #"([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")\n\n(defn- match-int\n  [s]\n  (let [m (vec (re-find int-pattern s))]\n    (if-not (nil? (m 2))\n      0\n      (let [^boolean negate? (identical? "-" (m 1))\n            a (cond\n               (not (nil? (m 3))) [(m 3) 10]\n               (not (nil? (m 4))) [(m 4) 16]\n               (not (nil? (m 5))) [(m 5) 8]\n               (not (nil? (m 7))) [(m 7) (js/parseInt (m 6))]\n               :else              [nil nil])\n            n (a 0)]\n        (when-not (nil? n)\n          (let [bn (js/parseInt n (a 1))\n                bn (if negate? (* -1 bn) bn)]\n            (when-not (js/isNaN bn)\n              bn)))))))\n\n(defn- match-ratio\n  [s]\n  (let [m (vec (re-find ratio-pattern s))\n        numerator (m 1)\n        denominator (m 2)\n        numerator (if (re-find #"^\\+" numerator)\n                    (subs numerator 1)\n                    numerator)]\n    (/ (-\x3e numerator   js/parseInt) ;;; No ratio type in cljs\n       (-\x3e denominator js/parseInt)))); So will convert to js/Number\n\n(defn- match-float\n  [s]\n  (let [m (vec (re-find float-pattern s))]\n    (if-not (nil? (m 4)) ;; for BigDecimal "10.03M", as all parsed to js/Number\n      (js/parseFloat (m 1))\n      (js/parseFloat s))))\n\n(defn ^boolean matches? [pattern s]\n  (let [[match] (re-find pattern s)]\n    (identical? match s)))\n\n(defn match-number [s]\n  (if (matches? int-pattern s)\n    (match-int s)\n    (if (matches? float-pattern s)\n      (match-float s)\n      (when (matches? ratio-pattern s)\n        (match-ratio s)))))\n\n(defn parse-symbol\n  "Parses a string into a vector of the namespace and symbol"\n  [token]\n  (when-not (or (identical? "" token)\n                (true? (.test #":$" token))\n                (true? (.test #"^::" token)))\n    (let [ns-idx (.indexOf token "/")\n          ns (when (pos? ns-idx)\n               (subs token 0 ns-idx))]\n      (if-not (nil? ns)\n        (let [ns-idx (inc ns-idx)]\n          (when-not (\x3d\x3d ns-idx (count token))\n            (let [sym (subs token ns-idx)]\n              (when (and (not (numeric? (nth sym 0)))\n                         (not (identical? "" sym))\n                         (false? (.test #":$" ns))\n                         (or (identical? sym "/")\n                             (\x3d\x3d -1 (.indexOf sym "/"))))\n                [ns sym]))))\n        (when (or (identical? token "/")\n                  (\x3d\x3d -1 (.indexOf token "/")))\n          [nil token])))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; readers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn read-comment\n  [rdr \x26 _]\n  (skip-line rdr))\n\n(defn throwing-reader\n  [msg]\n  (fn [rdr \x26 _]\n    (reader-error rdr msg)))\n'],
null),new p(null,3,[Cl,"clojure/walk.clj",Xn,"clojure.walk",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;;; walk.clj - generic tree walker with replacement\n\n;; by Stuart Sierra\n;; December 15, 2008\n\n;; CHANGE LOG:\n;;\n;; * December 15, 2008: replaced \'walk\' with \'prewalk\' \x26 \'postwalk\'\n;;\n;; * December 9, 2008: first version\n\n\n(ns \n  ^{:author "Stuart Sierra",\n     :doc "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\"walk\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function."}\n  clojure.walk)\n\n(defn walk\n  "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."\n\n  {:added "1.1"}\n  [inner outer form]\n  (cond\n   (list? form) (outer (apply list (map inner form)))\n   (instance? clojure.lang.IMapEntry form)\n   (outer (clojure.lang.MapEntry/create (inner (key form)) (inner (val form))))\n   (seq? form) (outer (doall (map inner form)))\n   (instance? clojure.lang.IRecord form)\n     (outer (reduce (fn [r x] (conj r (inner x))) form form))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))\n\n(defn postwalk\n  "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f\'s return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."\n  {:added "1.1"}\n  [f form]\n  (walk (partial postwalk f) f form))\n\n(defn prewalk\n  "Like postwalk, but does pre-order traversal."\n  {:added "1.1"}\n  [f form]\n  (walk (partial prewalk f) identity (f form)))\n\n\n;; Note: I wanted to write:\n;;\n;; (defn walk\n;;   [f form]\n;;   (let [pf (partial walk f)]\n;;     (if (coll? form)\n;;       (f (into (empty form) (map pf form)))\n;;       (f form))))\n;;\n;; but this throws a ClassCastException when applied to a map.\n\n\n(defn postwalk-demo\n  "Demonstrates the behavior of postwalk by printing each form as it is\n  walked.  Returns form."\n  {:added "1.1"}\n  [form]\n  (postwalk (fn [x] (print "Walked: ") (prn x) x) form))\n\n(defn prewalk-demo\n  "Demonstrates the behavior of prewalk by printing each form as it is\n  walked.  Returns form."\n  {:added "1.1"}\n  [form]\n  (prewalk (fn [x] (print "Walked: ") (prn x) x) form))\n\n(defn keywordize-keys\n  "Recursively transforms all map keys from strings to keywords."\n  {:added "1.1"}\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn stringify-keys\n  "Recursively transforms all map keys from keywords to strings."\n  {:added "1.1"}\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn prewalk-replace\n  "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first."\n  {:added "1.1"}\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n\n(defn postwalk-replace\n  "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first."\n  {:added "1.1"}\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n\n(defn macroexpand-all\n  "Recursively performs all possible macroexpansions in form."\n  {:added "1.1"}\n  [form]\n  (prewalk (fn [x] (if (seq? x) (macroexpand x) x)) form))\n\n'],
null),new p(null,3,[Cl,"cljs/repl.cljc",Xn,"cljs.repl",nr,';; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.repl\n  (:refer-clojure :exclude [load load-file])\n  (:require [clojure.java.io :as io]\n            [clojure.string :as string]\n            [clojure.set :as set]\n            [clojure.data.json :as json]\n            [clojure.tools.reader :as reader]\n            [clojure.tools.reader.reader-types :as readers]\n            [cljs.tagged-literals :as tags]\n            [clojure.edn :as edn]\n            [cljs.util :as util]\n            [cljs.compiler :as comp]\n            [cljs.analyzer :as ana]\n            [cljs.analyzer.api :as ana-api]\n            [cljs.env :as env]\n            [cljs.js-deps :as deps]\n            [cljs.closure :as cljsc]\n            [cljs.source-map :as sm])\n  (:import [java.io File PushbackReader FileWriter PrintWriter]\n           [java.net URL]\n           [java.util Base64]\n           [java.util.concurrent.atomic AtomicLong]\n           [clojure.lang IExceptionInfo]\n           [java.util.regex Pattern]\n           [com.google.common.base Throwables]))\n\n(def ^:dynamic *cljs-verbose* false)\n(def ^:dynamic *repl-opts* nil)\n(def ^:dynamic *repl-env* nil)\n\n(def known-repl-opts\n  "Set of all known REPL options."\n  #{:analyze-path :bind-err :caught :compiler-env :def-emits-var :eval :flush\n    :init :inits :need-prompt :print :print-no-newline :prompt :quit-prompt :read\n    :reader :repl-requires :repl-verbose :source-map-inline :watch :watch-fn\n    :wrap})\n\n(defmacro ^:private err-out [\x26 body]\n  `(binding [*out* *err*]\n     ~@body))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Copied over from clojure.main\n\n(defn skip-if-eol\n  "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\\\newline."\n  [s]\n  (let [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      (do (readers/unread s c) :body))))\n\n(defn skip-whitespace\n  "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\\\newline."\n  [s]\n  (loop [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      \\; (do (readers/read-line s) :line-start)\n      (if (or (Character/isWhitespace c) (identical? c \\,))\n        (recur (readers/read-char s))\n        (do (readers/unread s c) :body)))))\n\n(defn repl-read\n  "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\\\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it\'s end of line, then\n        - returns the object."\n  ([request-prompt request-exit]\n   (repl-read request-prompt request-exit *repl-opts*))\n  ([request-prompt request-exit opts]\n   (let [current-in *in*\n         bind-in?   (true? (:source-map-inline opts))]\n     (binding [*in* (if bind-in?\n                      ((:reader opts))\n                      *in*)]\n       (or ({:line-start request-prompt :stream-end request-exit}\n             (skip-whitespace *in*))\n         (let [input (reader/read {:read-cond :allow :features #{:cljs}} *in*)]\n           ;; Transfer 1-char buffer to original *in*\n           (readers/unread current-in (readers/read-char *in*))\n           (skip-if-eol (if bind-in? current-in *in*))\n           input))))))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; CLJS Specifics\n\n(defprotocol IReplEnvOptions\n  (-repl-options [repl-env] "Return default REPL options for a REPL Env"))\n\n(defn repl-options [repl-env]\n  (-repl-options repl-env))\n\n(defprotocol IJavaScriptEnv\n  (-setup [repl-env opts] "initialize the environment")\n  (-evaluate [repl-env filename line js] "evaluate a javascript string")\n  (-load [repl-env provides url] "load code at url into the environment")\n  (-tear-down [repl-env] "dispose of the environment"))\n\n(defn setup [repl-env opts]\n  (-setup repl-env opts))\n\n(defn evaluate [repl-env filename line js]\n  (-evaluate repl-env filename line js))\n\n(defn load [repl-env provides url]\n  (-load repl-env provides url))\n\n(defn tear-down [repl-env]\n  (-tear-down repl-env))\n\n(extend-type\n  Object\n  IReplEnvOptions\n  (-repl-options [_] nil))\n\n(defprotocol IParseError\n  (-parse-error [repl-env error build-options]\n    "Given the original JavaScript error return the error to actually\n     use."))\n\n(defprotocol IGetError\n  (-get-error [repl-env name env build-options]\n    "Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value \x3cstring\x3e\n      :stacktrace \x3cstring\x3e}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string."))\n\n(defprotocol IParseStacktrace\n  (-parse-stacktrace [repl-env stacktrace error build-options]\n    "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file \x3cstring\x3e\n       :function \x3cstring\x3e\n       :line \x3cinteger\x3e\n       :column \x3cinteger\x3e}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \\"\x3ccljs repl\x3e\\"."))\n\n(defprotocol IPrintStacktrace\n  (-print-stacktrace [repl-env stacktrace error build-options]\n    "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing."))\n\n(defn- env-\x3eopts\n  "Returns a hash-map containing all of the entries in [repl-env], translating\n:working-dir to :output-dir."\n  ([repl-env] (env-\x3eopts repl-env nil))\n  ([repl-env opts]\n    ;; some bits in cljs.closure use the options value as an ifn :-/\n   (-\x3e (into {} repl-env)\n     (assoc :optimizations\n            (or (:optimizations opts) (get repl-env :optimizations :none)))\n     (assoc :output-dir\n            (or (:output-dir opts) (get repl-env :working-dir ".repl"))))))\n\n(defn add-url [ijs]\n  (cond-\x3e ijs\n    (not (contains? ijs :url))\n    (assoc :url (io/resource (:file ijs)))))\n\n(defn ns-\x3einput [ns opts]\n  (or (some-\x3e (util/ns-\x3esource ns) (ana/parse-ns opts))\n      (some-\x3e (get-in @env/*compiler* [:js-dependency-index (str ns)]) add-url)\n      (some-\x3e (deps/find-classpath-lib ns))\n      (throw\n        (ex-info (str ns " does not exist")\n          {::error :invalid-ns}))))\n\n(defn compilable? [input]\n  (contains? input :source-file))\n\n(defn- load-sources\n  "Load the compiled `sources` into the REPL."\n  [repl-env sources opts]\n  (if (:output-dir opts)\n    ;; REPLs that read from :output-dir just need to add deps,\n    ;; environment will handle actual loading - David\n    (let [sb (StringBuffer.)]\n      (doseq [source sources]\n        (with-open [rdr (io/reader (:url source))]\n          (.append sb (cljsc/add-dep-string opts source))))\n      (when (:repl-verbose opts)\n        (println (.toString sb)))\n      (-evaluate repl-env "\x3ccljs repl\x3e" 1 (.toString sb)))\n    ;; REPLs that stream must manually load each dep - David\n    (doseq [{:keys [url provides]} sources]\n      (-load repl-env provides url))))\n\n(defn- load-cljs-loader\n  "Compile and load the cljs.loader namespace if it\'s present in `sources`."\n  [repl-env sources opts]\n  (when-let [source (first (filter #(\x3d (:ns %) \'cljs.loader) sources))]\n    (cljsc/compile-loader sources opts)\n    (load-sources repl-env [source] opts)))\n\n(defn load-namespace\n  "Load a namespace and all of its dependencies into the evaluation environment.\n  The environment is responsible for ensuring that each namespace is\n  loaded once and only once. Returns the compiled sources."\n  ([repl-env ns] (load-namespace repl-env ns nil))\n  ([repl-env ns opts]\n   (let [ns      (if (and (seq? ns) (\x3d (first ns) \'quote)) (second ns) ns)\n         sources (seq\n                   (when-not (ana/node-module-dep? ns)\n                     (let [input (ns-\x3einput ns opts)]\n                       (if (compilable? input)\n                         (-\x3e\x3e (cljsc/compile-inputs [input]\n                                (merge (env-\x3eopts repl-env) opts))\n                           (remove (comp #{["goog"]} :provides)))\n                         (map #(cljsc/source-on-disk opts %)\n                              (cljsc/add-js-sources [input] opts))))))]\n     (when (:repl-verbose opts)\n       (println (str "load-namespace " ns " , compiled:") (map :provides sources)))\n     (load-sources repl-env sources opts)\n     sources)))\n\n(defn- load-dependencies\n  "Compile and load the given `requires` and return the compiled sources."\n  ([repl-env requires]\n   (load-dependencies repl-env requires nil))\n  ([repl-env requires opts]\n   (doall (mapcat #(load-namespace repl-env % opts) (distinct requires)))))\n\n(defn ^File js-src-\x3ecljs-src\n  "Map a JavaScript output file back to the original ClojureScript source\n   file (.cljs or .cljc)."\n  [f]\n  (let [f (io/file f)\n        dir (.getParentFile f)\n        base-name (string/replace (.getName f) ".js" "")\n        cljsf (io/file dir (str base-name ".cljs"))]\n    (if (.exists cljsf)\n      cljsf\n      (let [cljcf (io/file dir (str base-name ".cljc"))]\n        (if (.exists cljcf)\n          cljcf)))))\n\n(defn read-source-map\n  "Return the source map for the JavaScript source file."\n  [f]\n  (when-let [smf (util/file-or-resource (str f ".map"))]\n    (let [ns (if (\x3d f "cljs/core.aot.js")\n               \'cljs.core\n               (some-\x3e (js-src-\x3ecljs-src f) ana/parse-ns :ns))]\n      (when ns\n        (as-\x3e @env/*compiler* compiler-env\n          (let [t (util/last-modified smf)]\n            (if (or (and (\x3d ns \'cljs.core)\n                         (nil? (get-in compiler-env [::source-maps ns])))\n                    (and (not\x3d ns \'cljs.core)\n                         (\x3e t (get-in compiler-env [::source-maps ns :last-modified] 0))))\n              (swap! env/*compiler* assoc-in [::source-maps ns]\n                {:last-modified t\n                 :source-map (sm/decode (json/read-str (slurp smf) :key-fn keyword))})\n              compiler-env))\n          (get-in compiler-env [::source-maps ns :source-map]))))))\n\n(defn ns-info\n  "Given a path to a js source file return the ns info for the corresponding\n   ClojureScript file if it exists."\n  [f]\n  (let [f\' (js-src-\x3ecljs-src f)]\n    (when (and f\' (.exists f\'))\n      (ana/parse-ns f\'))))\n\n(defn- mapped-line-column-call\n  "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called."\n  [source-map line column]\n  (let [default [line column nil]]\n    ;; source maps are 0 indexed for lines\n    (if-let [columns (get source-map (dec line))]\n      (vec\n        (map #(%1 %2)\n          [inc inc identity]\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; the last segment seems most accurate\n            (last\n              (or\n                (get columns (last (filter #(\x3c\x3d % (dec column)) (sort (keys columns)))))\n                (second (first columns))))\n            [:line :col :name])))\n      default)))\n\n(defn- mapped-frame\n  "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame."\n  [{:keys [function file line column]} opts]\n  (let [no-source-file? (if-not file\n                          true\n                          (.startsWith file "\x3c"))\n        rfile (when-not no-source-file?\n                (io/file (URL. (.toURL (io/file (util/output-directory opts))) file)))\n        [sm {:keys [ns source-file] :as ns-info}]\n        (when-not no-source-file?\n          ((juxt read-source-map ns-info) rfile))\n        [line\' column\' call] (if ns-info\n                               (mapped-line-column-call sm line column)\n                               [line column])\n        name\' (when (and ns-info function)\n                function)\n        file\' (if no-source-file?\n                file\n                (string/replace\n                  (.getCanonicalFile\n                    (if ns-info\n                      source-file\n                      (io/file rfile)))\n                  (str (System/getProperty "user.dir") File/separator) ""))\n        url (or (and ns-info (util/ns-\x3esource ns))\n                (and file (io/resource file)))]\n    (merge\n      {:function name\'\n       :call     call\n       :file     (if no-source-file?\n                   (str "\x3cNO_SOURCE_FILE\x3e"\n                        (when file\n                          (str " " file)))\n                   (io/file file\'))\n       :line     line\'\n       :column   column\'}\n      (when url\n        {:url url}))))\n\n(defn mapped-stacktrace\n  "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file \x3cstring\x3e\n      :function \x3cstring\x3e\n      :line \x3cinteger\x3e\n      :column \x3cinteger\x3e}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath."\n  ([stacktrace] (mapped-stacktrace stacktrace nil))\n  ([stacktrace opts]\n   (vec\n     (let [mapped-frames (map (memoize #(mapped-frame % opts)) stacktrace)]\n       ;; take each non-nil :call and optionally merge it into :function one-level up\n       ;; to avoid replacing with local symbols, we only replace munged name if we can munge call symbol back to it\n       (map #(merge-with (fn [munged-fn-name unmunged-call-name]\n                           (if (\x3d munged-fn-name (string/replace (cljs.compiler/munge unmunged-call-name) "." "$"))\n                             unmunged-call-name\n                             munged-fn-name)) %1 %2)\n         (map #(dissoc % :call) mapped-frames)\n         (concat (rest (map #(if (:call %)\n                              (hash-map :function (:call %))\n                              {})\n                         mapped-frames)) [{}]))))))\n\n(defn file-display\n  [file {:keys [output-dir temp-output-dir?]}]\n  (if temp-output-dir?\n    (let [canonicalize (fn [file] (.getCanonicalPath (io/file file)))\n          can-file (canonicalize file)\n          can-out (canonicalize output-dir)]\n      (if (.startsWith can-file can-out)\n        (subs can-file (inc (count can-out)))\n        (subs can-file (inc (.lastIndexOf can-file java.io.File/separator)))))\n    file))\n\n(defn print-mapped-stacktrace\n  "Given a vector representing the canonicalized JavaScript stacktrace\n   print the ClojureScript stacktrace. See mapped-stacktrace."\n  ([stacktrace] (print-mapped-stacktrace stacktrace *repl-opts*))\n  ([stacktrace opts]\n   (doseq [{:keys [function file line column]}\n           (mapped-stacktrace stacktrace opts)]\n     (err-out\n       (println "\\t"\n         (str (when function (str function " "))\n           "(" (file-display file opts) (when line (str ":" line)) (when column (str ":" column)) ")"))))))\n\n(comment\n  (def st (env/default-compiler-env))\n\n  (cljsc/build "samples/hello/src"\n    {:optimizations :none\n     :output-dir "samples/hello/out"\n     :output-to "samples/hello/out/hello.js"\n     :source-map true}\n    st)\n\n  (env/with-compiler-env st\n    (mapped-stacktrace\n      [{:file "hello/core.js"\n        :function "first"\n        :line 6\n        :column 0}]\n      {:output-dir "samples/hello/out"}))\n\n  (env/with-compiler-env st\n    (print-mapped-stacktrace\n      [{:file "hello/core.js"\n        :function "first"\n        :line 6\n        :column 0}]\n      {:output-dir "samples/hello/out"}))\n\n  ;; URL example\n\n  (cljsc/build "samples/hello/src"\n    {:optimizations :none\n     :output-dir "out"\n     :output-to "out/hello.js"\n     :source-map true}\n    st)\n\n  (env/with-compiler-env st\n    (mapped-stacktrace\n      [{:file "cljs/core.js"\n        :function "first"\n        :line 2\n        :column 1}]\n      {:output-dir "out"}))\n\n  (env/with-compiler-env st\n    (print-mapped-stacktrace\n      [{:file "cljs/core.js"\n        :function "first"\n        :line 2\n        :column 1}]\n      {:output-dir "out"}))\n  )\n\n(defn- display-error\n  ([repl-env ret form opts]\n   (display-error repl-env ret form (constantly nil) opts))\n  ([repl-env ret form f opts]\n   (err-out\n     (f)\n     (when-let [value (:value ret)]\n       (println value))\n     (when-let [st (:stacktrace ret)]\n       (if (and (true? (:source-map opts))\n             (satisfies? IParseStacktrace repl-env))\n         (let [cst (try\n                     (-parse-stacktrace repl-env st ret opts)\n                     (catch Throwable e\n                       (when (:repl-verbose opts)\n                         (println "Failed to canonicalize stacktrace")\n                         (println (Throwables/getStackTraceAsString e)))))]\n           (if (vector? cst)\n             (if (satisfies? IPrintStacktrace repl-env)\n               (-print-stacktrace repl-env cst ret opts)\n               (print-mapped-stacktrace cst opts))\n             (println st)))\n         (println st))))))\n\n(defn- bytes-to-base64-str\n  "Convert a byte array into a base-64 encoded string."\n  [^bytes bytes]\n  (.encodeToString (Base64/getEncoder) bytes))\n\n(defn evaluate-form\n  "Evaluate a ClojureScript form in the JavaScript environment. Returns a\n  string which is the ClojureScript return value. This string may or may\n  not be readable by the Clojure reader."\n  ([repl-env env filename form]\n    (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n    (evaluate-form repl-env env filename form wrap *repl-opts*))\n  ([repl-env env filename form wrap opts]\n   (binding [ana/*cljs-file* filename]\n     (let [env (merge env\n                 {:root-source-info {:source-type :fragment\n                                     :source-form form}\n                  :repl-env repl-env})\n           def-emits-var (:def-emits-var opts)\n           backup-comp @env/*compiler*\n           -\x3east (fn [form]\n                   (binding [ana/*analyze-deps* false]\n                     (ana/analyze (assoc env :def-emits-var def-emits-var)\n                       (wrap form) nil opts)))\n           ast (-\x3east form)\n           ast (if-not (#{:ns :ns*} (:op ast))\n                 ast\n                 (let [ijs (ana/parse-ns [form])]\n                   (cljsc/handle-js-modules opts\n                     (deps/dependency-order\n                       (cljsc/add-dependency-sources [ijs] opts))\n                     env/*compiler*)\n                   (binding [ana/*check-alias-dupes* false]\n                     (ana/no-warn (-\x3east form))))) ;; need new AST after we know what the modules are - David\n           wrap-js\n           ;; TODO: check opts as well - David\n           (if (:source-map repl-env)\n             (binding [comp/*source-map-data*\n                       (atom {:source-map (sorted-map)\n                              :gen-line 0})\n                       comp/*source-map-data-gen-col* (AtomicLong.)]\n               (let [js (comp/emit-str ast)\n                     t (System/currentTimeMillis)]\n                 (str js\n                   "\\n//# sourceURL\x3drepl-" t ".js"\n                   "\\n//# sourceMappingURL\x3ddata:application/json;base64,"\n                   (bytes-to-base64-str\n                     (.getBytes\n                       (sm/encode\n                         {(str "repl-" t ".cljs")\n                          (:source-map @comp/*source-map-data*)}\n                         {:lines (+ (:gen-line @comp/*source-map-data*) 3)\n                          :file (str "repl-" t ".js")\n                          :sources-content\n                          [(or (:source (meta form))\n                             ;; handle strings / primitives without metadata\n                             (with-out-str (pr form)))]})\n                       "UTF-8")))))\n             (comp/emit-str ast))]\n       ;; NOTE: means macros which expand to ns aren\'t supported for now\n       ;; when eval\'ing individual forms at the REPL - David\n       (when (#{:ns :ns*} (:op ast))\n         (let [ast (try\n                     (ana/no-warn (ana/analyze env form nil opts))\n                     (catch #?(:clj Exception :cljs js/Error) e\n                         (reset! env/*compiler* backup-comp)\n                         (throw e)))\n               sources (load-dependencies repl-env\n                         (into (vals (:requires ast))\n                               (distinct (vals (:uses ast))))\n                         opts)]\n           (load-cljs-loader repl-env sources opts)))\n       (when *cljs-verbose*\n         (err-out (println wrap-js)))\n       (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n         (case (:status ret)\n           :error (throw\n                    (ex-info (:value ret)\n                      {:type :js-eval-error\n                       :error ret\n                       :repl-env repl-env\n                       :form form}))\n           :exception (throw\n                        (ex-info (:value ret)\n                          {:type :js-eval-exception\n                           :error ret\n                           :repl-env repl-env\n                           :form form\n                           :js wrap-js}))\n           :success (:value ret)))))))\n\n(defn load-stream [repl-env filename res]\n  (let [env (ana/empty-env)]\n    (with-open [rdr (io/reader res)]\n      (doseq [form (ana/forms-seq* rdr filename)]\n        (let [env (assoc env :ns (ana/get-namespace ana/*cljs-ns*))]\n          (evaluate-form repl-env env filename form))))))\n\n(defn load-file\n  ([repl-env f] (load-file repl-env f *repl-opts*))\n  ([repl-env f opts]\n    (if (:output-dir opts)\n      (let [src (cond\n                  (util/url? f) f\n                  (.exists (io/file f)) (io/file f)\n                  :else (io/resource f))\n            compiled (binding [ana/*reload-macros* true]\n                       (cljsc/compile src\n                         (assoc opts\n                           :output-file (cljsc/src-file-\x3etarget-file src)\n                           :force true\n                           :mode :interactive)))]\n        ;; copy over the original source file if source maps enabled\n        (when-let [ns (and (:source-map opts) (first (:provides compiled)))]\n          (spit\n            (io/file (io/file (util/output-directory opts))\n              (util/ns-\x3erelpath ns (util/ext (:source-url compiled))))\n            (slurp src)))\n        ;; need to load dependencies first\n        (let [sources (load-dependencies repl-env (:requires compiled) opts)]\n          (load-cljs-loader repl-env (conj sources compiled) opts))\n        (-evaluate repl-env f 1 (cljsc/add-dep-string opts compiled))\n        (-evaluate repl-env f 1\n          (cljsc/src-file-\x3egoog-require src\n            {:wrap true :reload true :macros-ns (:macros-ns compiled)})))\n      (binding [ana/*cljs-ns* ana/*cljs-ns*]\n        (let [res (if (\x3d File/separatorChar (first f)) f (io/resource f))]\n          (assert res (str "Can\'t find " f " in classpath"))\n          (load-stream repl-env f res))))))\n\n(defn- root-resource\n  "Returns the root directory path for a lib"\n  {:tag String}\n  [lib]\n  (str \\/\n       (.. (name lib)\n           (replace \\- \\_)\n           (replace \\. \\/))))\n\n(defn- root-directory\n  "Returns the root resource path for a lib"\n  [lib]\n  (let [d (root-resource lib)]\n    (subs d 0 (.lastIndexOf d "/"))))\n\n(defn- load-path-\x3ecp-path\n  [path]\n  (let [src (if (\x3d File/separatorChar (first path))\n              path\n              (str (root-directory ana/*cljs-ns*) \\/ path))\n        src (.substring src 1)]\n    (or (io/resource (str src ".cljs"))\n        (io/resource (str src ".cljc")))))\n\n(defn- wrap-fn [form]\n  (cond\n    (and (seq? form)\n         (#{\'ns \'require \'require-macros\n            \'use \'use-macros \'import \'refer-clojure} (first form)))\n    identity\n\n    (\'#{*1 *2 *3 *e} form) (fn [x] `(cljs.core.pr-str ~x))\n    :else\n    (fn [x]\n      `(try\n         (cljs.core.pr-str\n           (let [ret# ~x]\n             (set! *3 *2)\n             (set! *2 *1)\n             (set! *1 ret#)\n             ret#))\n         (catch :default e#\n           (set! *e e#)\n           (throw e#))))))\n\n(defn- init-wrap-fn [form]\n  (cond\n    (and (seq? form)\n      (#{\'ns \'require \'require-macros\n         \'use \'use-macros \'import \'refer-clojure} (first form)))\n    identity\n\n    (\'#{*1 *2 *3 *e} form) (fn [x] `(cljs.core.pr-str ~x))\n    :else\n    (fn [x]\n      `(cljs.core.pr-str ~x))))\n\n(defn eval-cljs\n  "Given a REPL evaluation environment, an analysis environment, and a\n   form, evaluate the form and return the result. The result is always the value\n   represented as a string."\n  ([repl-env env form]\n    (eval-cljs repl-env env form *repl-opts*))\n  ([repl-env env form opts]\n   (evaluate-form repl-env\n     (assoc env :ns (ana/get-namespace ana/*cljs-ns*))\n     "\x3ccljs repl\x3e"\n     form\n     ;; the pluggability of :wrap is needed for older JS runtimes like Rhino\n     ;; where catching the error will swallow the original trace\n     ((or (:wrap opts) wrap-fn) form)\n     opts)))\n\n(defn decorate-specs [specs]\n  (if-let [k (some #{:reload :reload-all} specs)]\n    (-\x3e\x3e specs (remove #{k}) (map #(vary-meta % assoc :reload k)))\n    specs))\n\n(comment\n  (ana/canonicalize-specs\n    \'[\'foo.bar \'[bar.core :as bar]])\n\n  (ana/canonicalize-specs\n    \'[\'foo.bar \'[bar.core :as bar] :reload])\n\n  (map meta\n    (decorate-specs\n      (ana/canonicalize-specs\n        \'[\'foo.bar \'[bar.core :as bar] :reload])))\n  )\n\n;; Special REPL fns, these provide compatiblity with Clojure functions\n;; that are not possible to reproduce given ClojureScript\'s compilation model\n;; All functions should have the following signature\n;;\n;; (fn self\n;;   ([repl-env env form]\n;;     (self repl-env env form))\n;;   ([repl-env env form opts]\n;;     ..))\n;;\n;; repl-env - IJavaScriptEnv instance\n;; env      - a cljs.analyzer environment, *not* cljs.env environment\n;; form     - complete form entered at the repl\n;; opts     - REPL options, essentially augmented cljs.closure/build options\n\n(defn- wrap-self\n  "Takes a self-ish fn and returns it wrapped with exception handling.\n  Compiler state is restored if self-ish fn fails."\n  [f]\n  (fn g\n    ([a b c]\n     (g a b c nil))\n    ([a b c d]\n     (let [backup-comp @env/*compiler*]\n       (try\n         (apply f [a b c d])\n         (catch #?(:clj Exception :cljs js/Error) e ;;Exception\n           (reset! env/*compiler* backup-comp)\n           (throw e)))))))\n\n(defn- wrap-special-fns\n  [wfn fns]\n  "Wrap wfn around all (fn) values in fns hashmap."\n  (into {} (for [[k v] fns] [k (wfn v)])))\n\n(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like \'5 which wreaks havoc\n           (when-not (and (\x3d quote \'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. "Argument to in-ns must be a symbol.")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env "\x3ccljs repl\x3e" 1\n               (str "goog.provide(\'" (comp/munge ns-name) "\');")))\n           (set! ana/*cljs-ns* ns-name)))\n        load-fn\n        (fn self\n          ([repl-env env form]\n           (self env repl-env form nil))\n          ([repl-env env [_ \x26 paths :as form] opts]\n           (let [cp-paths (map load-path-\x3ecp-path paths)]\n             (run! #(load-file repl-env % opts) cp-paths))))]\n    (wrap-special-fns wrap-self\n     {\'in-ns in-ns-fn\n      \'clojure.core/in-ns in-ns-fn\n      \'load-file load-file-fn\n      \'clojure.core/load-file load-file-fn\n      \'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))\n      \'load load-fn\n      \'clojure.core/load load-fn})))\n\n(defn analyze-source\n  "Given a source directory, analyzes all .cljs files. Used to populate\n  (:cljs.analyzer/namespaces compiler-env) so as to support code reflection."\n  ([src-dir] (analyze-source src-dir nil))\n  ([src-dir opts]\n    (if-let [src-dir (and (not (empty? src-dir))\n                       (File. src-dir))]\n      (doseq [file (comp/cljs-files-in src-dir)]\n        (ana/analyze-file (str "file://" (.getAbsolutePath file)) opts)))))\n\n(defn repl-title []\n  (when-not (util/synthetic-version?)\n    (println "ClojureScript" (util/clojurescript-version))))\n\n(defn repl-quit-prompt []\n  (println "To quit, type:" :cljs/quit))\n\n(defn repl-prompt []\n  (print (str ana/*cljs-ns* "\x3d\x3e ")))\n\n(defn demunge\n  "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version."\n  [fn-name]\n  (clojure.lang.Compiler/demunge fn-name))\n\n(def ^:private core-namespaces\n  #{"clojure.core" "clojure.core.reducers" "clojure.core.protocols" "clojure.data" "clojure.datafy"\n    "clojure.edn" "clojure.instant" "clojure.java.io" "clojure.main" "clojure.pprint" "clojure.reflect"\n    "clojure.repl" "clojure.set" "clojure.spec.alpha" "clojure.spec.gen.alpha" "clojure.spec.test.alpha"\n    "clojure.string" "clojure.template" "clojure.uuid" "clojure.walk" "clojure.xml" "clojure.zip"})\n\n(defn- core-class?\n  [^String class-name]\n  (and (not (nil? class-name))\n       (or (.startsWith class-name "clojure.lang.")\n           (contains? core-namespaces (second (re-find #"^([^$]+)\\$" class-name))))))\n\n(defn- file-name\n  "Helper to get just the file name part of a path or nil"\n  [^String full-path]\n  (when full-path\n    (try\n      (.getName (java.io.File. full-path))\n      (catch Throwable t))))\n\n(defn- java-loc-\x3esource\n  "Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method."\n  [clazz method]\n  (if (#{\'invoke \'invokeStatic} method)\n    (let [degen #(.replaceAll ^String % "--.*$" "")\n          [ns-name fn-name \x26 nested] (-\x3e\x3e (str clazz) (.split #"\\$") (map demunge) (map degen))]\n      (symbol ns-name (String/join "$" ^"[Ljava.lang.String;" (into-array String (cons fn-name nested)))))\n    (symbol (name clazz) (name method))))\n\n(defn ex-triage\n  "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable-\x3emap. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error"\n  [datafied-throwable]\n  (let [{:keys [via trace phase] :or {phase :execution}} datafied-throwable\n        {:keys [type message data]} (last via)\n        {:keys [:clojure.spec.alpha/problems :clojure.spec.alpha/fn :clojure.spec.test.alpha/caller]} data\n        {:keys [:clojure.error/source] :as top-data} (:data (first via))]\n    (assoc\n     (case phase\n       :read-source\n       (let [{:keys [:clojure.error/line :clojure.error/column]} data]\n         (cond-\x3e (merge (-\x3e via second :data) top-data)\n           source (assoc :clojure.error/source (file-name source))\n           (#{"NO_SOURCE_FILE" "NO_SOURCE_PATH"} source) (dissoc :clojure.error/source)\n           message (assoc :clojure.error/cause message)))\n\n       (:compile-syntax-check :compilation :macro-syntax-check :macroexpansion)\n       (cond-\x3e top-data\n         source (assoc :clojure.error/source (file-name source))\n         (#{"NO_SOURCE_FILE" "NO_SOURCE_PATH"} source) (dissoc :clojure.error/source)\n         type (assoc :clojure.error/class type)\n         message (assoc :clojure.error/cause message)\n         problems (assoc :clojure.error/spec data))\n\n       (:read-eval-result :print-eval-result)\n       (let [[source method file line] (-\x3e trace first)]\n         (cond-\x3e top-data\n           line (assoc :clojure.error/line line)\n           file (assoc :clojure.error/source file)\n           (and source method) (assoc :clojure.error/symbol (java-loc-\x3esource source method))\n           type (assoc :clojure.error/class type)\n           message (assoc :clojure.error/cause message)))\n\n       :execution\n       (let [[source method file line] (-\x3e\x3e trace (drop-while #(core-class? (name (first %)))) first)\n             file (first (remove #(or (nil? %) (#{"NO_SOURCE_FILE" "NO_SOURCE_PATH"} %)) [(:file caller) file]))\n             err-line (or (:line caller) line)]\n         (cond-\x3e {:clojure.error/class type}\n           err-line (assoc :clojure.error/line err-line)\n           message (assoc :clojure.error/cause message)\n           (or fn (and source method)) (assoc :clojure.error/symbol (or fn (java-loc-\x3esource source method)))\n           file (assoc :clojure.error/source file)\n           problems (assoc :clojure.error/spec data))))\n      :clojure.error/phase phase)))\n\n(defn ex-str\n  "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause."\n  [{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column\n           :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec]\n    :as triage-data}]\n  (let [spec-loaded? (some? (resolve \'clojure.spec.alpha/explain-out))\n        loc (str (or source "REPL") ":" (or line 1) (if column (str ":" column) ""))\n        class-name (name (or class ""))\n        simple-class (if class (or (first (re-find #"([^.])++$" class-name)) class-name))\n        cause-type (if (contains? #{"Exception" "RuntimeException"} simple-class)\n                     "" ;; omit, not useful\n                     (str " (" simple-class ")"))]\n    (case phase\n      :read-source\n      (format "Syntax error reading source at (%s).%n%s%n" loc cause)\n\n      :macro-syntax-check\n      (format "Syntax error macroexpanding %sat (%s).%n%s"\n        (if symbol (str symbol " ") "")\n        loc\n        (if (and spec spec-loaded?)\n          (with-out-str\n            ((resolve \'clojure.spec.alpha/explain-out)\n             (if (\x3d @(resolve \'clojure.spec.alpha/*explain-out*) @(resolve \'clojure.spec.alpha/explain-printer))\n                (update spec :clojure.spec.alpha/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec)))\n          (format "%s%n" cause)))\n\n      :macroexpansion\n      (format "Unexpected error%s macroexpanding %sat (%s).%n%s%n"\n        cause-type\n        (if symbol (str symbol " ") "")\n        loc\n        cause)\n\n      :compile-syntax-check\n      (format "Syntax error%s compiling %sat (%s).%n%s%n"\n        cause-type\n        (if symbol (str symbol " ") "")\n        loc\n        cause)\n\n      :compilation\n      (format "Unexpected error%s compiling %sat (%s).%n%s%n"\n        cause-type\n        (if symbol (str symbol " ") "")\n        loc\n        cause)\n\n      :read-eval-result\n      (format "Error reading eval result%s at %s (%s).%n%s%n" cause-type symbol loc cause)\n\n      :print-eval-result\n      (format "Error printing return value%s at %s (%s).%n%s%n" cause-type symbol loc cause)\n\n      :execution\n      (if (and spec spec-loaded?)\n        (format "Execution error - invalid arguments to %s at (%s).%n%s"\n          symbol\n          loc\n          (with-out-str\n            ((resolve \'clojure.spec.alpha/explain-out)\n              (if (\x3d @(resolve \'clojure.spec.alpha/*explain-out*) @(resolve \'clojure.spec.alpha/explain-printer))\n                (update spec :clojure.spec.alpha/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec))))\n        (format "Execution error%s at %s(%s).%n%s%n"\n          cause-type\n          (if symbol (str symbol " ") "")\n          loc\n          cause)))))\n\n(defn repl-caught [e repl-env opts]\n  (if (and (instance? IExceptionInfo e)\n           (#{:js-eval-error :js-eval-exception} (:type (ex-data e))))\n    (let [{:keys [type repl-env error form js]} (ex-data e)]\n      (case type\n        :js-eval-error\n        (display-error repl-env error form opts)\n\n        :js-eval-exception\n        (display-error repl-env error form\n          (if (:repl-verbose opts)\n            #(prn "Error evaluating:" form :as js)\n            (constantly nil))\n          opts)))\n    (binding [*out* *err*]\n      (print (-\x3e e Throwable-\x3emap ex-triage ex-str))\n      (flush))))\n\n(defn repl-nil? [x]\n  (boolean (#{"" "nil"} x)))\n\n(defn run-inits [renv inits]\n  (doseq [{:keys [type] :as init} inits]\n    (case type\n      :init-forms\n      (doseq [form (:forms init)]\n        (eval-cljs renv (ana/empty-env) form))\n      :eval-forms\n      (binding [*repl-opts* (merge *repl-opts* {:def-emits-var true :wrap init-wrap-fn})]\n        (doseq [form (:forms init)]\n          (let [value (eval-cljs renv (ana/empty-env) form *repl-opts*)]\n            (when-not (repl-nil? value)\n              (println value)))))\n      :init-script\n      (let [script (:script init)]\n        (load-stream renv (util/get-name script) script)))))\n\n(defn maybe-install-npm-deps [opts]\n  (when (:install-deps opts)\n    (cljsc/check-npm-deps opts)\n    (swap! env/*compiler* update-in [:npm-deps-installed?]\n      (fn [installed?]\n        (if-not installed?\n          (cljsc/maybe-install-node-deps! opts)\n          installed?)))))\n\n(defn initial-prompt [quit-prompt prompt]\n  (quit-prompt)\n  (prompt)\n  (flush))\n\n(defn repl*\n  [repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader\n                    print-no-newline source-map-inline wrap repl-requires ::fast-initial-prompt?\n                    compiler-env bind-err]\n             :or {need-prompt #(if (readers/indexing-reader? *in*)\n                                (\x3d\x3d (readers/get-column-number *in*) 1)\n                                (identity true))\n                  fast-initial-prompt? false\n                  quit-prompt repl-title\n                  prompt repl-prompt\n                  flush flush\n                  read repl-read\n                  eval eval-cljs\n                  print println\n                  caught repl-caught\n                  reader #(readers/source-logging-push-back-reader\n                           *in*\n                           1 "\x3cNO_SOURCE_FILE\x3e")\n                  print-no-newline print\n                  source-map-inline true\n                  repl-requires \'[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]]\n                                  [cljs.pprint :refer [pprint] :refer-macros [pp]]]\n                  bind-err true}\n             :as opts}]\n  (doseq [[unknown-opt suggested-opt] (util/unknown-opts (set (keys opts)) (set/union known-repl-opts cljsc/known-opts))]\n    (when suggested-opt\n      (println (str "WARNING: Unknown option \'" unknown-opt "\'. Did you mean \'" suggested-opt "\'?"))))\n  (when fast-initial-prompt?\n    (initial-prompt quit-prompt prompt))\n  (let [repl-opts (-repl-options repl-env)\n        repl-requires (into repl-requires (:repl-requires repl-opts))\n        {:keys [analyze-path repl-verbose warn-on-undeclared special-fns\n                checked-arrays static-fns fn-invoke-direct]\n         :as opts\n         :or   {warn-on-undeclared true}}\n        (merge\n          {:def-emits-var true}\n          (cljsc/add-implicit-options\n            (merge-with (fn [a b] (if (nil? b) a b))\n              repl-opts\n              opts\n              {:prompt prompt\n               :need-prompt need-prompt\n               :flush flush\n               :read read\n               :print print\n               :caught caught\n               :reader reader\n               :print-no-newline print-no-newline\n               :source-map-inline source-map-inline})))\n        done? (atom false)]\n    (env/with-compiler-env (or compiler-env env/*compiler* (env/default-compiler-env opts))\n     (when (:source-map opts)\n       (.start (Thread. (bound-fn [] (read-source-map "cljs/core.aot.js")))))\n     (binding [*repl-env* repl-env\n               ana/*unchecked-if* false\n               ana/*unchecked-arrays* false\n               *err* (if bind-err\n                       (cond-\x3e *out*\n                         (not (instance? PrintWriter *out*)) (PrintWriter.))\n                       *err*)\n               ana/*cljs-ns* ana/*cljs-ns*\n               *cljs-verbose* repl-verbose\n               ana/*cljs-warnings*\n               (let [warnings (opts :warnings)]\n                 (merge\n                   ana/*cljs-warnings*\n                   (if (or (true? warnings)\n                           (false? warnings))\n                     (zipmap (keys ana/*cljs-warnings*) (repeat warnings))\n                     warnings)\n                   (zipmap\n                     [:unprovided :undeclared-var\n                      :undeclared-ns :undeclared-ns-form]\n                     (repeat (if (false? warnings)\n                               false\n                               warn-on-undeclared)))\n                   {:infer-warning false}))\n               ana/*checked-arrays* checked-arrays\n               ana/*cljs-static-fns* static-fns\n               ana/*fn-invoke-direct* (and static-fns fn-invoke-direct)\n               *repl-opts* opts]\n       (try\n         (let [env {:context :expr :locals {}}\n               special-fns (merge default-special-fns special-fns)\n               is-special-fn? (set (keys special-fns))\n               request-prompt (Object.)\n               request-exit (Object.)\n               opts (comp/with-core-cljs opts\n                      (fn []\n                        (if-let [merge-opts (:merge-opts (-setup repl-env opts))]\n                          (merge opts merge-opts)\n                          opts)))\n               init (do\n                      (evaluate-form repl-env env "\x3ccljs repl\x3e"\n                        `(~\'set! ~\'cljs.core/*print-namespace-maps* true)\n                        identity opts)\n                      (or init\n                        #(evaluate-form repl-env env "\x3ccljs repl\x3e"\n                           (with-meta\n                             `(~\'ns ~\'cljs.user\n                                (:require ~@repl-requires))\n                             {:line 1 :column 1})\n                           identity opts)))\n               maybe-load-user-file #(when-let [user-resource (util/ns-\x3esource \'user)]\n                                       (when (\x3d "file" (.getProtocol ^URL user-resource))\n                                         (load-file repl-env (io/file user-resource) opts)))\n               read-eval-print\n               (fn []\n                 (let [input (binding [*ns* (create-ns ana/*cljs-ns*)\n                                       reader/resolve-symbol ana/resolve-symbol\n                                       reader/*data-readers* tags/*cljs-data-readers*\n                                       reader/*alias-map*\n                                       (apply merge\n                                         ((juxt :requires :require-macros)\n                                           (ana/get-namespace ana/*cljs-ns*)))]\n                               (try\n                                 (read request-prompt request-exit)\n                                 (catch Throwable e\n                                   (throw (ex-info nil {:clojure.error/phase :read-source} e)))))]\n                   (or ({request-exit request-exit\n                         :cljs/quit request-exit\n                         request-prompt request-prompt} input)\n                     (if (and (seq? input) (is-special-fn? (first input)))\n                       (do\n                         ((get special-fns (first input)) repl-env env input opts)\n                         (print nil))\n                       (let [value (eval repl-env env input opts)]\n                         (try\n                           (print value)\n                           (catch Throwable e\n                             (throw (ex-info nil {:clojure.error/phase :print-eval-result} e)))))))))]\n           (maybe-install-npm-deps opts)\n           (comp/with-core-cljs opts\n             (fn []\n               (binding [*repl-opts* opts]\n                 (try\n                   (when analyze-path\n                     (if (vector? analyze-path)\n                       (run! #(analyze-source % opts) analyze-path)\n                       (analyze-source analyze-path opts)))\n                   (init)\n                   (run-inits repl-env inits)\n                   (maybe-load-user-file)\n                   (catch Throwable e\n                     (caught e repl-env opts)))\n                 (when-let [src (:watch opts)]\n                   (.start\n                     (Thread.\n                       ((ns-resolve \'clojure.core \'binding-conveyor-fn)\n                         (fn []\n                           (let [log-file (io/file (util/output-directory opts) "watch.log")]\n                             (err-out (println "Watch compilation log available at:" (str log-file)))\n                             (try\n                               (let [log-out (FileWriter. log-file)]\n                                 (binding [*err* log-out\n                                           *out* log-out]\n                                   (cljsc/watch src (dissoc opts :watch)\n                                     env/*compiler* done?)))\n                               (catch Throwable e\n                                 (caught e repl-env opts)))))))))\n                 ;; let any setup async messages flush\n                 (Thread/sleep 50)\n                 (binding [*in* (if (true? (:source-map-inline opts))\n                                  *in*\n                                  (reader))]\n                   (when-not fast-initial-prompt?\n                     (initial-prompt quit-prompt prompt))\n                   (loop []\n                     (when-not\n                       (try\n                         (identical? (read-eval-print) request-exit)\n                         (catch Throwable e\n                           (caught e repl-env opts)\n                           nil))\n                       (when (need-prompt)\n                         (prompt)\n                         (flush))\n                       (recur))))))))\n         (finally\n           (reset! done? true)\n           (-tear-down repl-env)))))))\n\n(defn repl\n  "Generic, reusable, read-eval-print loop. By default, reads from *in* using\n  a c.t.r.reader-types/source-logging-push-back-reader,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  c.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\n  unread and collapsing CR, LF, and CRLF into a single \\\\newline. Options\n  are sequential keyword-value pairs. The first argument is the JavaScript\n  evaluation environment, the second argument is an extended version of the\n  standard ClojureScript compiler options. In addition to ClojureScript compiler\n  build options it also take a set of options similar to clojure.main/repl with\n  adjustments for ClojureScript evalution and compilation model:\n\n  Available clojure.main/repl style options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                   (\x3d\x3d (c.t.r.reader-types/get-column-number *in*) 1)\n                   (identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument. The eval function must take repl-env, the JavaScript evaluation\n       environment, env, the ClojureScript analysis environment, the form\n       and opts, the standard ClojureScript REPL/compiler options.\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: println\n\n     - :caught, function of three arguments, a throwable, called when\n       read, eval, or print throws an exception or error default. The second\n       argument is the JavaScript evaluation environment this permits context\n       sensitive handling if necessary. The third argument is opts, the standard\n       ClojureScript REPL/compiler options. In the case of errors or exception\n       in the JavaScript target, these will be thrown as\n       clojure.lang.IExceptionInfo instances.\n       default: repl-caught\n\n     - :reader, the c.t.r reader to use.\n       default: c.t.r.reader-types/source-logging-push-back-reader\n\n     - :print-no-newline, print without a newline.\n       default: print\n\n     - :source-map-inline, whether inline source maps should be enabled. Most\n       useful in browser context. Implies using a fresh reader for each form.\n       default: true"\n  [repl-env \x26 opts]\n  (assert (even? (count opts))\n    "Arguments after repl-env must be interleaved key value pairs")\n  (repl* repl-env (apply hash-map opts)))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; ClojureScript REPL interaction support\n\n(def special-doc-map\n  \'{. {:forms [(.instanceMethod instance args*)\n               (.-instanceField instance)]\n       :doc "The instance member form works for methods and fields.\n  They all expand into calls to the dot operator at macroexpansion time."}\n    ns {:forms [(name docstring? attr-map? references*)]\n        :doc "You must currently use the ns form only with the following caveats\n\n    * You must use the :only form of :use\n    * :require supports :as, :refer, and :rename\n      - all options can be skipped\n      - in this case a symbol can be used as a libspec directly\n        - that is, (:require lib.foo) and (:require [lib.foo]) are both\n          supported and mean the same thing\n      - :rename specifies a map from referred var names to different\n        symbols (and can be used to prevent clashes)\n      - prefix lists are not supported\n    * The only options for :refer-clojure are :exclude and :rename\n    * :import is available for importing Google Closure classes\n      - ClojureScript types and records should be brought in with :use\n        or :require :refer, not :import ed\n    * Macros must be defined in a different compilation stage than the one\n      from where they are consumed. One way to achieve this is to define\n      them in one namespace and use them from another. They are referenced\n      via the :require-macros / :use-macros options to ns\n      - :require-macros and :use-macros support the same forms that\n        :require and :use do\n\n  Implicit macro loading: If a namespace is required or used, and that\n  namespace itself requires or uses macros from its own namespace, then\n  the macros will be implicitly required or used using the same\n  specifications. Furthermore, in this case, macro vars may be included\n  in a :refer or :only spec. This oftentimes leads to simplified library\n  usage, such that the consuming namespace need not be concerned about\n  explicitly distinguishing between whether certain vars are functions\n  or macros. For example:\n\n  (ns testme.core (:require [cljs.test :as test :refer [test-var deftest]]))\n\n  will result in test/is resolving properly, along with the test-var\n  function and the deftest macro being available unqualified.\n\n  Inline macro specification: As a convenience, :require can be given\n  either :include-macros true or :refer-macros [syms...]. Both desugar\n  into forms which explicitly load the matching Clojure file containing\n  macros. (This works independently of whether the namespace being\n  required internally requires or uses its own macros.) For example:\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn] :include-macros true]\n            [woz.core :as woz :refer [woz-fn] :refer-macros [app jx]]))\n\n  is sugar for\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn]]\n            [woz.core :as woz :refer [woz-fn]])\n  (:require-macros [foo.core :as foo]\n                   [woz.core :as woz :refer [app jx]]))\n\n  Auto-aliasing clojure namespaces: If a non-existing clojure.* namespace\n  is required or used and a matching cljs.* namespace exists, the cljs.*\n  namespace will be loaded and an alias will be automatically established\n  from the clojure.* namespace to the cljs.* namespace. For example:\n\n  (ns testme.core (:require [clojure.test]))\n\n  will be automatically converted to\n\n  (ns testme.core (:require [cljs.test :as clojure.test]))"}\n    def {:forms [(def symbol doc-string? init?)]\n         :doc "Creates and interns a global var with the name\n  of symbol in the current namespace (*ns*) or locates such a var if\n  it already exists.  If init is supplied, it is evaluated, and the\n  root binding of the var is set to the resulting value.  If init is\n  not supplied, the root binding of the var is unaffected."}\n    do {:forms [(do exprs*)]\n        :doc "Evaluates the expressions in order and returns the value of\n  the last. If no expressions are supplied, returns nil."}\n    if {:forms [(if test then else?)]\n        :doc "Evaluates test. If not the singular values nil or false,\n  evaluates and yields then, otherwise, evaluates and yields else. If\n  else is not supplied it defaults to nil."}\n    new {:forms [(Constructor. args*) (new Constructor args*)]\n         :url "java_interop#new"\n         :doc "The args, if any, are evaluated from left to right, and\n  passed to the JavaScript constructor. The constructed object is\n  returned."}\n    quote {:forms [(quote form)]\n           :doc "Yields the unevaluated form."}\n    recur {:forms [(recur exprs*)]\n           :doc "Evaluates the exprs in order, then, in parallel, rebinds\n  the bindings of the recursion point to the values of the exprs.\n  Execution then jumps back to the recursion point, a loop or fn method."}\n    set! {:forms[(set! var-symbol expr)\n                 (set! (.- instance-expr instanceFieldName-symbol) expr)]\n          :url "vars#set"\n          :doc "Used to set vars and JavaScript object fields"}\n    throw {:forms [(throw expr)]\n           :doc "The expr is evaluated and thrown."}\n    try {:forms [(try expr* catch-clause* finally-clause?)]\n         :doc "catch-clause \x3d\x3e (catch classname name expr*)\n  finally-clause \x3d\x3e (finally expr*)\n  Catches and handles JavaScript exceptions."}\n    var {:forms [(var symbol)]\n         :doc "The symbol must resolve to a var, and the Var object\nitself (not its value) is returned. The reader macro #\'x expands to (var x)."}})\n\n(defn- special-doc [name-symbol]\n  (assoc (or (special-doc-map name-symbol) (meta (resolve name-symbol)))\n    :name name-symbol\n    :special-form true))\n\n(def repl-special-doc-map\n  \'{in-ns {:arglists ([name])\n           :doc "Sets *cljs-ns* to the namespace named by the symbol, creating it if needed."}\n    load-file {:arglists ([name])\n               :doc "Sequentially read and evaluate the set of forms contained in the file."}\n    load {:arglists ([\x26 paths])\n               :doc "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise."}})\n\n(defn- repl-special-doc [name-symbol]\n  (assoc (repl-special-doc-map name-symbol)\n    :name name-symbol\n    :repl-special-function true))\n\n(defmacro doc\n  "Prints documentation for a var or special form given its name,\n  or for a spec if given a keyword"\n  [name]\n  `(print\n     (binding [cljs.core/*print-newline* true]\n       (with-out-str\n         ~(if-let [special-name (\'{\x26 fn catch try finally try} name)]\n            `(doc ~special-name)\n            (cond\n              (special-doc-map name)\n              `(cljs.repl/print-doc (quote ~(special-doc name)))\n\n              (repl-special-doc-map name)\n              `(cljs.repl/print-doc (quote ~(repl-special-doc name)))\n\n              (keyword? name)\n              `(cljs.repl/print-doc {:spec ~name :doc (cljs.spec.alpha/describe ~name)})\n\n              (ana-api/find-ns name)\n              `(cljs.repl/print-doc\n                 (quote ~(select-keys (ana-api/find-ns name) [:name :doc])))\n\n              (ana-api/resolve \x26env name)\n              `(cljs.repl/print-doc\n                 (quote ~(let [var (ana-api/resolve \x26env name)\n                               m (select-keys var\n                                   [:ns :name :doc :forms :arglists :macro :url])]\n                           (cond-\x3e (update-in m [:name] clojure.core/name)\n                             (:protocol-symbol var)\n                             (assoc :protocol true\n                                    :methods\n                                    (-\x3e\x3e (get-in var [:protocol-info :methods])\n                                      (map (fn [[fname sigs]]\n                                             [fname {:doc (:doc\n                                                            (ana-api/resolve \x26env\n                                                              (symbol (str (:ns var)) (str fname))))\n                                                     :arglists (seq sigs)}]))\n                                      (into {})))))))))))))\n\n(defmacro find-doc\n  "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern"\n  [re-string-or-pattern]\n  (let [re (re-pattern re-string-or-pattern)\n        ms (concat\n             (mapcat\n               (fn [ns]\n                 (map\n                   (fn [m]\n                     (update-in (select-keys m [:ns :name :doc :forms :arglists :macro :url])\n                       [:name] #(if-not (nil? %) (clojure.core/name %) %)))\n                   (sort-by :name (vals (ana-api/ns-interns ns)))))\n               (ana-api/all-ns))\n             (map #(select-keys (ana-api/find-ns %) [:name :doc]) (ana-api/all-ns))\n             (map special-doc (keys special-doc-map)))\n        ms (for [m ms\n                 :when (and (:doc m)\n                            (or (re-find (re-matcher re (:doc m)))\n                                (re-find (re-matcher re (str (:name m))))))]\n             m)]\n    `(doseq [m# (quote ~ms)]\n       (cljs.repl/print-doc m#))))\n\n(defn source-fn\n  "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can\'t find the source.  For most REPL usage, \'source\' is more\n  convenient.\n\n  Example: (source-fn \'filter)"\n  [env x]\n  (when-let [v (ana-api/resolve env x)]\n    (when-let [filepath (:file v)]\n      (let [f (io/file filepath)\n            f (if (.exists f)\n                f\n                (io/resource filepath))]\n        (when f\n          (with-open [pbr (PushbackReader. (io/reader f))]\n            (let [rdr (readers/source-logging-push-back-reader pbr)]\n              (dotimes [_ (dec (:line v))] (readers/read-line rdr))\n              (binding [reader/*alias-map*    identity\n                        reader/*data-readers* tags/*cljs-data-readers*]\n                (-\x3e (reader/read {:read-cond :allow :features #{:cljs}} rdr)\n                  meta :source)))))))))\n\n(comment\n  (def cenv (env/default-compiler-env))\n  (def aenv (assoc-in (ana/empty-env) [:ns :name] \'cljs.user))\n\n  (binding [ana/*cljs-ns* \'cljs.user]\n    (env/with-compiler-env cenv\n      (comp/with-core-cljs {}\n        (fn []\n          (source-fn aenv \'cljs.core/first)))))\n  )\n\n(defmacro source\n  "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .cljs is in the classpath.\n\n  Example: (source filter)"\n  [n]\n  `(println ~(or (source-fn \x26env n) (str "Source not found"))))\n\n(defn- named-publics-vars\n  "Gets the public vars in a namespace that are not anonymous."\n  [ns]\n  (-\x3e\x3e (ana-api/ns-publics ns)\n       (remove (comp :anonymous val))\n       (map key)))\n\n(defmacro apropos\n  "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern."\n  [str-or-pattern]\n  (let [matches? (if (instance? Pattern str-or-pattern)\n                   #(re-find str-or-pattern (str %))\n                   #(.contains (str %) (str str-or-pattern)))]\n    `(quote\n       ~(sort\n          (mapcat\n            (fn [ns]\n              (let [ns-name (str ns)]\n                (map #(symbol ns-name (str %))\n                  (filter matches? (named-publics-vars ns)))))\n            (ana-api/all-ns))))))\n\n(defn- resolve-ns\n  "Resolves a namespace symbol to a namespace by first checking to see if it\n  is a namespace alias."\n  [ns-sym]\n  (or (get-in @env/*compiler* [::ana/namespaces ana/*cljs-ns* :requires ns-sym])\n      (get-in @env/*compiler* [::ana/namespaces ana/*cljs-ns* :require-macros ns-sym])\n      ns-sym))\n\n(defmacro dir\n  "Prints a sorted directory of public vars in a namespace"\n  [ns]\n  `(doseq [sym# (quote ~(sort (named-publics-vars (resolve-ns ns))))]\n     (println sym#)))\n\n(defmacro pst\n  ([] `(pst *e))\n  ([e]\n   (let [{:keys [repl-env] :as env} \x26env]\n     (when (and e repl-env)\n       (when-let [ret (if (satisfies? IGetError repl-env)\n                   (-get-error repl-env e env *repl-opts*)\n                   (edn/read-string\n                     (evaluate-form repl-env env "\x3ccljs repl\x3e"\n                       `(when ~e\n                          (pr-str\n                            {:value (str ~e)\n                             :stacktrace (.-stack ~e)})))))]\n         (display-error repl-env\n           (if (satisfies? IParseError repl-env)\n             (-parse-error repl-env ret *repl-opts*)\n             ret)\n           nil *repl-opts*))))))\n'],
null),new p(null,3,[Cl,"clojure/string.cljs",Xn,"clojure.string",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.string\n  (:refer-clojure :exclude [replace reverse])\n  (:require [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))\n\n(defn- seq-reverse\n  [coll]\n  (reduce conj () coll))\n\n(def ^:private re-surrogate-pair\n  (js/RegExp. "([\\\\uD800-\\\\uDBFF])([\\\\uDC00-\\\\uDFFF])" "g"))\n\n(defn reverse\n  "Returns s with its characters reversed."\n  [s]\n  (-\x3e (.replace s re-surrogate-pair "$2$1")\n      (.. (split "") (reverse) (join ""))))\n\n(defn- replace-all\n  [s re replacement]\n  (let [r (js/RegExp. (.-source re)\n                      (cond-\x3e "g"\n                        (.-ignoreCase re) (str "i")\n                        (.-multiline re) (str "m")\n                        (.-unicode re) (str "u")))]\n    (.replace s r replacement)))\n\n(defn- replace-with\n  [f]\n  (fn [\x26 args]\n    (let [matches (drop-last 2 args)]\n      (if (\x3d (count matches) 1)\n        (f (first matches))\n        (f (vec matches))))))\n\n(defn replace\n  "Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.\n\n   Example:\n   (clojure.string/replace \\"Almost Pig Latin\\" #\\"\\\\b(\\\\w)(\\\\w+)\\\\b\\" \\"$2$1ay\\")\n   -\x3e \\"lmostAay igPay atinLay\\""\n  [s match replacement]\n  (cond\n    (string? match)\n    (.replace s (js/RegExp. (gstring/regExpEscape match) "g") replacement)\n\n    (instance? js/RegExp match)\n    (if (string? replacement)\n      (replace-all s match replacement)\n      (replace-all s match (replace-with replacement)))\n\n    :else (throw (str "Invalid match arg: " match))))\n\n(defn replace-first\n  "Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.\n\n   Example:\n   (clojure.string/replace-first \\"swap first two words\\"\n                                 #\\"(\\\\w+)(\\\\s+)(\\\\w+)\\" \\"$3$2$1\\")\n   -\x3e \\"first swap two words\\""\n  [s match replacement]\n  (.replace s match replacement))\n\n(defn join\n  "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator."\n  ([coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (recur (. sb (append (str (first coll)))) (next coll))\n       (.toString sb))))\n  ([separator coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (do\n         (. sb (append (str (first coll))))\n         (let [coll (next coll)]\n           (when-not (nil? coll)\n             (. sb (append separator)))\n           (recur sb coll)))\n       (.toString sb)))))\n\n(defn upper-case\n  "Converts string to all upper-case."\n  [s]\n  (.toUpperCase s))\n\n(defn lower-case\n  "Converts string to all lower-case."\n  [s]\n  (.toLowerCase s))\n\n(defn capitalize\n  "Converts first character of the string to upper-case, all other\n  characters to lower-case."\n  [s]\n  (gstring/capitalize s))\n\n;; The JavaScript split function takes a limit argument but the return\n;; value is not the same as the Java split function.\n;;\n;; Java: (.split "a-b-c" #"-" 2) \x3d\x3e ["a" "b-c"]\n;; JavaScript: (.split "a-b-c" #"-" 2) \x3d\x3e ["a" "b"]\n;;\n;; For consistency, the three arg version has been implemented to\n;; mimic Java\'s behavior.\n\n(defn- pop-last-while-empty\n  [v]\n  (loop [v v]\n    (if (identical? "" (peek v))\n      (recur (pop v))\n      v)))\n\n(defn- discard-trailing-if-needed\n  [limit v]\n  (if (and (\x3d\x3d 0 limit) (\x3c 1 (count v)))\n    (pop-last-while-empty v)\n    v))\n\n(defn- split-with-empty-regex\n  [s limit]\n  (if (or (\x3c\x3d limit 0) (\x3e\x3d limit (+ 2 (count s))))\n    (conj (vec (cons "" (map str (seq s)))) "")\n    (condp \x3d\x3d limit\n      1 (vector s)\n      2 (vector "" s)\n      (let [c (- limit 2)]\n        (conj (vec (cons "" (subvec (vec (map str (seq s))) 0 c))) (subs s c))))))\n\n(defn split\n  "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits."\n  ([s re]\n     (split s re 0))\n    ([s re limit]\n     (discard-trailing-if-needed limit\n       (if (identical? "/(?:)/" (str re))\n         (split-with-empty-regex s limit)\n         (if (\x3c limit 1)\n           (vec (.split (str s) re))\n           (loop [s s\n                  limit limit\n                  parts []]\n             (if (\x3d\x3d 1 limit)\n               (conj parts s)\n               (let [m (re-find re s)]\n                 (if-not (nil? m)\n                   (let [index (.indexOf s m)]\n                     (recur (.substring s (+ index (count m)))\n                       (dec limit)\n                       (conj parts (.substring s 0 index))))\n                   (conj parts s))))))))))\n\n(defn split-lines\n  "Splits s on \\\\n or \\\\r\\\\n."\n  [s]\n  (split s #"\\n|\\r\\n"))\n\n(defn trim\n  "Removes whitespace from both ends of string."\n  [s]\n  (gstring/trim s))\n\n(defn triml\n  "Removes whitespace from the left side of string."\n  [s]\n  (gstring/trimLeft s))\n\n(defn trimr\n  "Removes whitespace from the right side of string."\n  [s]\n  (gstring/trimRight s))\n\n(defn trim-newline\n  "Removes all trailing newline \\\\n or return \\\\r characters from\n  string.  Similar to Perl\'s chomp."\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      ""\n      (let [ch (get s (dec index))]\n        (if (or (identical? \\newline ch)\n                (identical? \\return ch))\n          (recur (dec index))\n          (.substring s 0 index))))))\n\n(defn ^boolean blank?\n  "True is s is nil, empty, or contains only whitespace."\n  [s]\n  (gstring/isEmptySafe s))\n\n(defn escape\n  "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead."\n  [s cmap]\n  (let [buffer (StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (\x3d\x3d length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)\n              replacement (get cmap ch)]\n          (if-not (nil? replacement)\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))\n\n(defn index-of\n  "Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found."\n  ([s value]\n   (let [result (.indexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.indexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))\n\n(defn last-index-of\n  "Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found."\n  ([s value]\n   (let [result (.lastIndexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.lastIndexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))\n\n(defn ^boolean starts-with?\n  "True if s starts with substr."\n  [s substr]\n  (gstring/startsWith s substr))\n\n(defn ^boolean ends-with?\n  "True if s ends with substr."\n  [s substr]\n  (gstring/endsWith s substr))\n\n(defn ^boolean includes?\n  "True if s includes substr."\n  [s substr]\n  (gstring/contains s substr))\n'],
null),new p(null,3,[Cl,"cljs/tagged_literals.cljc",Xn,"cljs.tagged-literals",nr,';; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.tagged-literals\n  #?(:clj  (:require [clojure.instant :as inst])\n     :cljs (:require [cljs.reader :as reader])))\n\n(defn read-queue\n  [form]\n  (when-not (vector? form)\n    (throw\n      #?(:clj  (RuntimeException.\n                 "Queue literal expects a vector for its elements.")\n         :cljs (js/Error.\n                 "Queue literal expects a vector for its elements."))))\n  (list \'cljs.core/into \'cljs.core.PersistentQueue.EMPTY form))\n\n#?(:clj\n   (defn read-uuid\n     [form]\n     (when-not (string? form)\n       (throw (RuntimeException. "UUID literal expects a string as its representation.")))\n     (try\n       (java.util.UUID/fromString form)\n       (catch Throwable e\n         (throw (RuntimeException. (.getMessage e)))))))\n\n#?(:cljs\n   (defn read-uuid\n     [form]\n     (when-not (string? form)\n       (throw (js/Error. "UUID literal expects a string as its representation.")))\n     (try\n       (uuid form)\n       (catch :default e\n         (throw (js/Error. (. e -message)))))))\n\n#?(:clj\n   (defn read-inst\n     [form]\n     (when-not (string? form)\n       (throw (RuntimeException. "Instance literal expects a string for its timestamp.")))\n     (try\n       (inst/read-instant-date form)\n       (catch Throwable e\n         (throw (RuntimeException. (.getMessage e)))))))\n\n#?(:cljs\n   (defn read-inst\n     [form]\n     (when-not (string? form)\n       (throw (js/Error. "Instance literal expects a string for its timestamp.")))\n     (try\n       (#\'reader/read-date form)\n       (catch :default e\n         (throw (js/Error. (. e -message)))))))\n\n(defn valid-js-literal-key? [k]\n  (or (string? k)\n      (and (keyword? k)\n           (nil? (namespace k)))))\n\n(deftype JSValue [val])\n\n(defn read-js\n  [form]\n  (when-not (or (vector? form) (map? form))\n    (throw\n      #?(:clj  (RuntimeException.\n                 "JavaScript literal must use map or vector notation")\n         :cljs (js/Error.\n                 "JavaScript literal must use map or vector notation"))))\n  (when-not (or (not (map? form))\n                (every? valid-js-literal-key? (keys form)))\n    (throw\n      #?(:clj  (RuntimeException.\n                 "JavaScript literal keys must be strings or unqualified keywords")\n         :cljs (js/Error.\n                 "JavaScript literal keys must be strings or unqualified keywords"))))\n  (JSValue. form))\n\n(def ^:dynamic *cljs-data-readers*\n  (merge ;; assumes we can read all data_readers\n    #?(:clj *data-readers*)\n    {\'queue read-queue\n     \'uuid  read-uuid\n     \'inst  read-inst\n     \'js    read-js}))\n'],
null),new p(null,3,[Cl,"cljs/test.cljc",Xn,"cljs.test",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.test\n  #?(:cljs (:require-macros [clojure.template :as temp]))\n  (:require [cljs.env :as env]\n            [cljs.analyzer :as ana]\n            [cljs.analyzer.api :as ana-api]\n            #?(:clj [clojure.template :as temp])))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Utilities for assertions\n\n(defn function?\n  "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro)."\n  [menv x]\n  (and (symbol? x) (:fn-var (ana-api/resolve menv x))))\n\n(defn assert-predicate\n  "Returns generic assertion code for any functional predicate.  The\n  \'expected\' argument to \'report\' will contains the original form, the\n  \'actual\' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the \'actual\' form will\n  be wrapped in (not...)."\n  [msg form]\n  (let [args (rest form)\n        pred (first form)]\n    `(let [values# (list ~@args)\n           result# (apply ~pred values#)]\n       (if result#\n         (do-report\n           {:type :pass, :message ~msg,\n            :expected \'~form, :actual (cons ~pred values#)})\n         (do-report\n           {:type :fail, :message ~msg,\n            :expected \'~form, :actual (list \'~\'not (cons \'~pred values#))}))\n       result#)))\n\n(defn assert-any\n  "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols."\n  [msg form]\n  `(let [value# ~form]\n     (if value#\n       (do-report\n         {:type :pass, :message ~msg,\n          :expected \'~form, :actual value#})\n       (do-report\n         {:type :fail, :message ~msg,\n          :expected \'~form, :actual value#}))\n     value#))\n\n(defmacro ^:private cljs-output-dir []\n  (let [{:keys [output-dir]} (ana-api/get-options)]\n    (or output-dir "out")))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Assertion Methods\n\n;; You don\'t call these, but you can add methods to extend the \'is\'\n;; macro.  These define different kinds of tests, based on the first\n;; symbol in the test expression.\n\n(defmulti assert-expr \n  (fn [menv msg form]\n    (cond\n      (nil? form) :always-fail\n      (seq? form) (first form)\n      :else :default)))\n\n(defmethod assert-expr :always-fail [menv msg form]\n  ;; nil test: always fail\n  `(do-report {:type :fail, :message ~msg}))\n\n(defmethod assert-expr :default [menv msg form]\n  (if (and (sequential? form)\n           (function? menv (first form)))\n    (assert-predicate msg form)\n    (assert-any msg form)))\n\n(defmethod assert-expr \'instance? [menv msg form]\n  ;; Test if x is an instance of y.\n  `(let [klass# ~(nth form 1)\n         object# ~(nth form 2)]\n     (let [result# (instance? klass# object#)]\n       (if result#\n         (do-report\n           {:type :pass, :message ~msg,\n            :expected \'~form, :actual (type object#)})\n         (do-report\n           {:type :fail, :message ~msg,\n            :expected \'~form, :actual (type object#)}))\n       result#)))\n\n(defmethod assert-expr \'thrown? [menv msg form]\n  ;; (is (thrown? c expr))\n  ;; Asserts that evaluating expr throws an exception of class c.\n  ;; Returns the exception thrown.\n  (let [klass (second form)\n        body (nthnext form 2)]\n    `(try\n       ~@body\n       (do-report\n         {:type :fail, :message ~msg,\n          :expected \'~form, :actual nil})\n       (catch ~klass e#\n         (do-report\n           {:type :pass, :message ~msg,\n            :expected \'~form, :actual e#})\n         e#))))\n\n(defmethod assert-expr \'thrown-with-msg? [menv msg form]\n  ;; (is (thrown-with-msg? c re expr))\n  ;; Asserts that evaluating expr throws an exception of class c.\n  ;; Also asserts that the message string of the exception matches\n  ;; (with re-find) the regular expression re.\n  (let [klass (nth form 1)\n        re (nth form 2)\n        body (nthnext form 3)]\n    `(try\n       ~@body\n       (do-report {:type :fail, :message ~msg, :expected \'~form, :actual nil})\n       (catch ~klass e#\n         (let [m# (.-message e#)]\n           (if (re-find ~re m#)\n             (do-report\n               {:type :pass, :message ~msg,\n                :expected \'~form, :actual e#})\n             (do-report\n               {:type :fail, :message ~msg,\n                :expected \'~form, :actual e#}))\n           e#)))))\n\n(defmacro try-expr\n  "Used by the \'is\' macro to catch unexpected exceptions.\n  You don\'t call this."\n  [msg form]\n  `(try\n     ~(assert-expr \x26env msg form)\n     (catch :default t#\n       (do-report\n         {:type :error, :message ~msg,\n          :expected \'~form, :actual t#}))))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Assertion Macros\n\n(defmacro is\n  "Generic assertion macro.  \'form\' is any predicate test.\n  \'msg\' is an optional message to attach to the assertion.\n  \n  Example: (is (\x3d 4 (+ 2 2)) \\"Two plus two should be 4\\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re."\n  ([form] `(cljs.test/is ~form nil))\n  ([form msg]\n   `(try-expr ~msg ~form)))\n\n(defmacro are\n  "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (\x3d x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (\x3d 2 (+ 1 1)))\n               (is (\x3d 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers."\n  [argv expr \x26 args]\n  (if (or\n        ;; (are [] true) is meaningless but ok\n        (and (empty? argv) (empty? args))\n        ;; Catch wrong number of args\n        (and (pos? (count argv))\n          (pos? (count args))\n          (zero? (mod (count args) (count argv)))))\n    `(clojure.template/do-template ~argv (is ~expr) ~@args)\n    (throw (#?(:clj Exception. :cljs js/Error.) "The number of args doesn\'t match are\'s argv."))))\n\n(defmacro testing\n  "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest)."\n  ([string \x26 body]\n   `(do\n      (update-current-env! [:testing-contexts] conj ~string)\n      (try\n        ~@body\n        (finally\n          (update-current-env! [:testing-contexts] rest))))))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Defining Tests\n\n(defmacro deftest\n  "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored."\n  [name \x26 body]\n  (when ana/*load-tests*\n    `(do\n       (def ~(vary-meta name assoc :test `(fn [] ~@body))\n         (fn [] (cljs.test/test-var (.-cljs$lang$var ~name))))\n       (set! (.-cljs$lang$var ~name) (var ~name)))))\n\n(defmacro async\n  "Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))"\n  [done \x26 body]\n  `(reify\n     cljs.test/IAsyncTest\n     cljs.core/IFn\n     (~\'-invoke [_# ~done]\n       ~@body)))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Running Tests\n\n(defn ns? [x]\n  (and (seq? x) (\x3d (first x) \'quote)))\n\n(defmacro run-tests-block\n  "Like test-vars, but returns a block for further composition and\n  later execution."\n  [env-or-ns \x26 namespaces]\n  (assert (every?\n           (fn [[quote ns]] (and (\x3d quote \'quote) (symbol? ns)))\n           namespaces)\n          "All arguments to run-tests must be quoted symbols")\n  (let [is-ns (ns? env-or-ns)\n        env (gensym "env")\n        summary (gensym "summary")]\n    `(let [~env ~(if is-ns\n                   `(empty-env)\n                   env-or-ns)\n           ~summary (cljs.core/volatile!\n                     {:test 0 :pass 0 :fail 0 :error 0\n                      :type :summary})]\n       (concat ~@(map\n                  (fn [ns]\n                    `(concat (test-ns-block ~env ~ns)\n                             [(fn []\n                                (cljs.core/vswap!\n                                 ~summary\n                                 (partial merge-with +)\n                                 (:report-counters\n                                  (get-and-clear-env!))))]))\n                  (if is-ns\n                    (concat [env-or-ns] namespaces)\n                    namespaces))\n               [(fn []\n                   (set-env! ~env)\n                   (do-report (deref ~summary))\n                   (report (assoc (deref ~summary) :type :end-run-tests))\n                   (clear-env!))]))))\n\n(defmacro run-tests\n  "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod."\n  ([] `(run-tests (empty-env) \'~ana/*cljs-ns*))\n  ([env-or-ns]\n   (if (ns? env-or-ns)\n     `(run-tests (empty-env) ~env-or-ns)\n     `(run-tests ~env-or-ns \'~ana/*cljs-ns*)))\n  ([env-or-ns \x26 namespaces]\n   `(run-block (run-tests-block ~env-or-ns ~@namespaces))))\n\n(defmacro run-all-tests\n  "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested."\n  ([] `(run-all-tests nil (empty-env)))\n  ([re] `(run-all-tests ~re (empty-env)))\n  ([re env]\n   `(run-tests ~env\n      ~@(map\n          (fn [ns] `(quote ~ns))\n          (cond-\x3e\x3e (ana-api/all-ns)\n            re (filter #(re-matches re (name %))))))))\n\n(defmacro test-all-vars-block\n  ([[quote ns]]\n   `(let [env# (get-current-env)]\n      (concat\n       [(fn []\n          (when (nil? env#)\n            (set-env! (empty-env)))\n          ~(when (ana-api/ns-resolve ns \'cljs-test-once-fixtures)\n             `(update-current-env! [:once-fixtures] assoc \'~ns\n                                             ~(symbol (name ns) "cljs-test-once-fixtures")))\n          ~(when (ana-api/ns-resolve ns \'cljs-test-each-fixtures)\n             `(update-current-env! [:each-fixtures] assoc \'~ns\n                                             ~(symbol (name ns) "cljs-test-each-fixtures"))))]\n       (test-vars-block\n        [~@(-\x3e\x3e (ana-api/ns-interns ns)\n                (filter (fn [[_ v]] (:test v)))\n                (sort-by (fn [[_ v]] (:line v)))\n                (map (fn [[k _]]\n                       `(var ~(symbol (name ns) (name k))))))])\n       [(fn []\n          (when (nil? env#)\n            (clear-env!)))]))))\n\n(defmacro test-all-vars\n  "Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures."\n  [[quote ns :as form]]\n  `(run-block\n     (concat (test-all-vars-block ~form)\n             [(fn []\n                (report {:type :end-test-all-vars :ns ~form}))])))\n\n(defmacro test-ns-block\n  "Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env."\n  ([env [quote ns :as form]]\n   (assert (and (\x3d quote \'quote) (symbol? ns)) "Argument to test-ns must be a quoted symbol")\n   (assert (ana-api/find-ns ns) (str "Namespace " ns " does not exist"))\n   `[(fn []\n       (set-env! ~env)\n       (do-report {:type :begin-test-ns, :ns ~form})\n       ;; If the namespace has a test-ns-hook function, call that:\n       ~(if-let [v (ana-api/ns-resolve ns \'test-ns-hook)]\n          `(~(symbol (name ns) "test-ns-hook"))\n          ;; Otherwise, just test every var in the namespace.\n          `(block (test-all-vars-block ~form))))\n     (fn []\n       (do-report {:type :end-test-ns, :ns ~form}))]))\n\n(defmacro test-ns\n  "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  \'ns\' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  "\n  ([ns] `(test-ns (empty-env) ~ns))\n  ([env [quote ns :as form]]\n   `(run-block\n     (concat (test-ns-block ~env ~form)\n             [(fn []\n                (clear-env!))]))))\n\n;; \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n;; Fixes\n\n(defmacro use-fixtures [type \x26 fns]\n  (condp \x3d type\n    :once\n    `(def ~\'cljs-test-once-fixtures\n       [~@fns])\n    :each\n    `(def ~\'cljs-test-each-fixtures\n       [~@fns])\n    :else\n    (throw\n      (#?(:clj Exception. :cljs js/Error.) "First argument to cljs.test/use-fixtures must be :once or :each"))))\n'],
null),new p(null,3,[Cl,"clojure/core/reducers.clj",Xn,"clojure.core.reducers",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc\n      "A library for reduction and parallel folding. Alpha and subject\n      to change."\n      :author "Rich Hickey"}\n  clojure.core.reducers\n  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten cat])\n  (:require [clojure.walk :as walk]))\n\n(alias \'core \'clojure.core)\n(set! *warn-on-reflection* true)\n\n;;;;;;;;;;;;;; some fj stuff ;;;;;;;;;;\n\n(def pool (delay (java.util.concurrent.ForkJoinPool.)))\n\n(defn fjtask [^Callable f]\n  (java.util.concurrent.ForkJoinTask/adapt f))\n\n(defn- fjinvoke [f]\n  (if (java.util.concurrent.ForkJoinTask/inForkJoinPool)\n    (f)\n    (.invoke ^java.util.concurrent.ForkJoinPool @pool ^java.util.concurrent.ForkJoinTask (fjtask f))))\n\n(defn- fjfork [task] (.fork ^java.util.concurrent.ForkJoinTask task))\n\n(defn- fjjoin [task] (.join ^java.util.concurrent.ForkJoinTask task))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn reduce\n  "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv"\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (instance? java.util.Map coll)\n       (clojure.core.protocols/kv-reduce coll f init)\n       (clojure.core.protocols/coll-reduce coll f init))))\n\n(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))\n\n(defn fold\n  "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order."\n  {:added "1.5"}\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))\n\n(defn reducer\n  "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."\n  {:added "1.5"}\n  ([coll xf]\n     (reify\n      clojure.core.protocols/CollReduce\n      (coll-reduce [this f1]\n                   (clojure.core.protocols/coll-reduce this f1 (f1)))\n      (coll-reduce [_ f1 init]\n                   (clojure.core.protocols/coll-reduce coll (xf f1) init)))))\n\n(defn folder\n  "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."\n  {:added "1.5"}\n  ([coll xf]\n     (reify\n      clojure.core.protocols/CollReduce\n      (coll-reduce [_ f1]\n                   (clojure.core.protocols/coll-reduce coll (xf f1) (f1)))\n      (coll-reduce [_ f1 init]\n                   (clojure.core.protocols/coll-reduce coll (xf f1) init))\n\n      CollFold\n      (coll-fold [_ n combinef reducef]\n                 (coll-fold coll n combinef (xf reducef))))))\n\n(defn- do-curried\n  [name doc meta args body]\n  (let [cargs (vec (butlast args))]\n    `(defn ~name ~doc ~meta\n       (~cargs (fn [x#] (~name ~@cargs x#)))\n       (~args ~@body))))\n\n(defmacro ^:private defcurried\n  "Builds another arity of the fn that returns a fn awaiting the last\n  param"\n  [name doc meta args \x26 body]\n  (do-curried name doc meta args body))\n\n(defn- do-rfn [f1 k fkv]\n  `(fn\n     ([] (~f1))\n     ~(clojure.walk/postwalk\n       #(if (sequential? %)\n          ((if (vector? %) vec identity)\n           (core/remove #{k} %))\n          %)\n       fkv)\n     ~fkv))\n\n(defmacro ^:private rfn\n  "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl."\n  [[f1 k] fkv]\n  (do-rfn f1 k fkv))\n\n(defcurried map\n  "Applies f to every value in the reduction of coll. Foldable."\n  {:added "1.5"}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))\n\n(defcurried mapcat\n  "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."\n  {:added "1.5"}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (let [f1 (fn\n                ([ret v]\n                  (let [x (f1 ret v)] (if (reduced? x) (reduced x) x)))\n                ([ret k v]\n                  (let [x (f1 ret k v)] (if (reduced? x) (reduced x) x))))]\n       (rfn [f1 k]\n            ([ret k v]\n               (reduce f1 ret (f k v))))))))\n\n(defcurried filter\n  "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."\n  {:added "1.5"}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))\n\n(defcurried remove\n  "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."\n  {:added "1.5"}\n  [pred coll]\n  (filter (complement pred) coll))\n\n(defcurried flatten\n  "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."\n  {:added "1.5"}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (clojure.core.protocols/coll-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))\n\n(defcurried take-while\n  "Ends the reduction of coll when (pred val) returns logical false."\n  {:added "1.5"}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))\n\n(defcurried take\n  "Ends the reduction of coll after consuming n values."\n  {:added "1.5"}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))\n\n(defcurried drop\n  "Elides the first n values from the reduction of coll."\n  {:added "1.5"}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))\n\n;;do not construct this directly, use cat\n(deftype Cat [cnt left right]\n  clojure.lang.Counted\n  (count [_] cnt)\n\n  clojure.lang.Seqable\n  (seq [_] (concat (seq left) (seq right)))\n\n  clojure.core.protocols/CollReduce\n  (coll-reduce [this f1] (clojure.core.protocols/coll-reduce this f1 (f1)))\n  (coll-reduce\n   [_  f1 init]\n   (clojure.core.protocols/coll-reduce\n    right f1\n    (clojure.core.protocols/coll-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n   [_ n combinef reducef]\n   (fjinvoke\n    (fn []\n      (let [rt (fjfork (fjtask #(coll-fold right n combinef reducef)))]\n        (combinef\n         (coll-fold left n combinef reducef)\n         (fjjoin rt)))))))\n\n(defn cat\n  "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat."\n  {:added "1.5"}\n  ([] (java.util.ArrayList.))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n      (zero? (count left)) right\n      (zero? (count right)) left\n      :else\n      (Cat. (+ (count left) (count right)) left right))))\n\n(defn append!\n  ".adds x to acc and returns acc"\n  {:added "1.5"}\n  [^java.util.Collection acc x]\n  (doto acc (.add x)))\n\n(defn foldcat\n  "Equivalent to (fold cat append! coll)"\n  {:added "1.5"}\n  [coll]\n  (fold cat append! coll))\n\n(defn monoid\n  "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it."\n  {:added "1.5"}\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fold impls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn- foldvec\n  [v n combinef reducef]\n  (cond\n   (empty? v) (combinef)\n   (\x3c\x3d (count v) n) (reduce reducef (combinef) v)\n   :else\n   (let [split (quot (count v) 2)\n         v1 (subvec v 0 split)\n         v2 (subvec v split (count v))\n         fc (fn [child] #(foldvec child n combinef reducef))]\n     (fjinvoke\n      #(let [f1 (fc v1)\n             t2 (fjtask (fc v2))]\n         (fjfork t2)\n         (combinef (f1) (fjjoin t2)))))))\n\n(extend-protocol CollFold\n nil\n (coll-fold\n  [coll n combinef reducef]\n  (combinef))\n\n Object\n (coll-fold\n  [coll n combinef reducef]\n  ;;can\'t fold, single reduce\n  (reduce reducef (combinef) coll))\n\n clojure.lang.IPersistentVector\n (coll-fold\n  [v n combinef reducef]\n  (foldvec v n combinef reducef))\n\n clojure.lang.PersistentHashMap\n (coll-fold\n  [m n combinef reducef]\n  (.fold m n combinef reducef fjinvoke fjtask fjfork fjjoin)))\n'],
null),new p(null,3,[Cl,"cljs/js.cljs",Xn,"cljs.js",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.js\n  (:refer-clojure :exclude [require eval])\n  (:require-macros [cljs.js :refer [dump-core]]\n                   [cljs.env.macros :as env])\n  (:require [clojure.string :as string]\n            [clojure.walk :as walk]\n            [cljs.env :as env]\n            [cljs.spec.alpha]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]\n            [cljs.tools.reader :as r]\n            [cljs.tools.reader.reader-types :as rt]\n            [cljs.tagged-literals :as tags]\n            [goog.crypt.base64 :as base64]\n            [cljs.source-map :as sm])\n  (:import [goog.string StringBuffer]))\n\n(js/goog.require "cljs.core$macros")\n\n(defn- debug-prn\n  [\x26 args]\n  (binding [*print-fn* *print-err-fn*]\n    (apply println args)))\n\n(defn ns-\x3erelpath\n  "Given a namespace as a symbol return the relative path sans extension"\n  [ns-sym]\n  (string/replace (ana/munge-path ns-sym) \\. \\/))\n\n(defn file-\x3ens\n  [file]\n  (let [lib-name (subs (string/replace file "/" ".")\n                   0 (- (count file) 5))]\n    (symbol (demunge lib-name))))\n\n(defn- drop-macros-suffix\n  [ns-name]\n  (when ns-name\n    (if (string/ends-with? ns-name "$macros")\n      (subs ns-name 0 (- (count ns-name) 7))\n      ns-name)))\n\n(defn- elide-macros-suffix\n  [sym]\n  (symbol (drop-macros-suffix (namespace sym)) (name sym)))\n\n(defn- resolve-symbol\n  [sym]\n  (if (string/starts-with? (str sym) ".")\n    sym\n    (elide-macros-suffix (ana/resolve-symbol sym))))\n\n(defn- read [eof rdr]\n  (binding [*ns* (symbol (drop-macros-suffix (str *ns*)))]\n    (r/read {:eof eof :read-cond :allow :features #{:cljs}} rdr)))\n\n(defn- atom? [x]\n  (instance? Atom x))\n\n(defn- valid-name? [x]\n  (or (nil? x) (symbol? x) (string? x)))\n\n(defn- valid-opts? [x]\n  (or (nil? x) (map? x)))\n\n(defonce\n  ^{:doc "Each runtime environment provides a different way to load a library.\n  Whatever function *load-fn* is bound to will be passed two arguments - a\n  map and a callback function: The map will have the following keys:\n\n  :name   - the name of the library (a symbol)\n  :macros - modifier signaling a macros namespace load\n  :path   - munged relative library path (a string)\n\n  It is up to the implementor to correctly resolve the corresponding .cljs,\n  .cljc, or .js resource (the order must be respected). If :macros is true\n  resolution should only consider .clj or .cljc resources (the order must be\n  respected). Upon resolution the callback should be invoked with a map\n  containing the following keys:\n\n  :lang       - the language, :clj or :js\n  :source     - the source of the library (a string)\n  :file       - optional, the file path, it will be added to AST\'s :file keyword\n                (but not in :meta)\n  :cache      - optional, if a :clj namespace has been precompiled to :js, can\n                give an analysis cache for faster loads.\n  :source-map - optional, if a :clj namespace has been precompiled to :js, can\n                give a V3 source map JSON\n\n  If the resource could not be resolved, the callback should be invoked with\n  nil."\n    :dynamic true}\n  *load-fn*\n  (fn [m cb]\n    (throw (js/Error. "No *load-fn* set"))))\n\n(defonce\n  ^{:doc "Each runtime environment provides various ways to eval JavaScript\n  source. Whatever function *eval-fn* is bound to will be passed a map\n  containing the following keys:\n\n  :source - the source of the library (string)\n  :name   - used to unique identify the script (symbol)\n  :cache  - if the source was originally ClojureScript, will be given the\n            analysis cache.\n\n  The result of evaluation should be the return value."\n    :dynamic true}\n  *eval-fn*\n  (fn [m]\n    (throw (js/Error. "No *eval-fn* set"))))\n\n(defn js-eval\n  "A default JavaScript evaluation function."\n  [{:keys [source] :as resource}]\n  (js/eval source))\n\n(defn- wrap-error [ex]\n  {:error ex})\n\n(defn empty-state\n  "Construct an empty compiler state. Required to invoke analyze, compile,\n   eval and eval-str."\n  ([]\n   (doto (env/default-compiler-env)\n     (swap!\n       (fn [state]\n         (-\x3e state\n           (assoc-in [::ana/namespaces \'cljs.core] (dump-core)))))))\n  ([init]\n   (doto (empty-state) (swap! init))))\n\n(defn load-analysis-cache! [state ns cache]\n  (swap! state assoc-in [::ana/namespaces ns] cache))\n\n(defn load-source-map! [state ns sm-json]\n  (let [sm (sm/decode (.parse js/JSON sm-json))]\n    (swap! state assoc-in [:source-maps ns] sm)))\n\n(defn- sm-data []\n  (atom\n    {:source-map (sorted-map)\n     :gen-col    0\n     :gen-line   0}))\n\n(defn- prefix [s pre]\n  (str pre s))\n\n(defn- append-source-map\n  [state name source sb sm-data {:keys [output-dir asset-path source-map-timestamp] :as opts}]\n   (let [t    (.valueOf (js/Date.))\n         mn   (if name\n                (munge (str name))\n                (str "cljs-" t))\n         smn  (cond-\x3e mn\n                name (string/replace "." "/"))\n         ts   (.valueOf (js/Date.))\n         out  (or output-dir asset-path)\n         src  (cond-\x3e (str smn ".cljs")\n                (true? source-map-timestamp) (str "?rel\x3d" ts)\n                out (prefix (str out "/")))\n         file (cond-\x3e (str smn ".js")\n                (true? source-map-timestamp) (str "?rel\x3d" ts)\n                out (prefix (str out "/")))\n         json (sm/encode {src (:source-map sm-data)}\n                {:lines (+ (:gen-line sm-data) 3)\n                 :file  file :sources-content [source]})]\n     (when (:verbose opts) (debug-prn json))\n     (swap! state assoc-in\n       [:source-maps (symbol mn)] (sm/invert-reverse-map (:source-map sm-data)))\n     (.append sb\n       (str "\\n//# sourceURL\x3d" file\n            "\\n//# sourceMappingURL\x3ddata:application/json;base64,"\n            (-\x3e (js/encodeURIComponent json)\n                (string/replace #"%([0-9A-F]{2})" (fn [[_ match]]\n                                                    (.fromCharCode js/String (str "0x" match))))\n                (base64/encodeString))))))\n\n(defn- alias-map\n  [compiler cljs-ns]\n  (-\x3e\x3e (merge (get-in compiler [::ana/namespaces cljs-ns :requires])\n         (get-in compiler [::ana/namespaces cljs-ns :require-macros]))\n    (remove (fn [[k v]] (symbol-identical? k v)))\n    (into {})))\n\n;; -----------------------------------------------------------------------------\n;; Analyze\n\n(declare ^{:arglists \'([bound-vars source name opts cb])} eval-str*)\n\n(def *loaded* (atom #{}))\n\n(defn- run-async!\n  "Like cljs.core/run!, but for an async procedure, and with the\n  ability to break prior to processing the entire collection.\n\n  Chains successive calls to the supplied procedure for items in\n  the collection. The procedure should accept an item from the\n  collection and a callback of one argument. If the break? predicate,\n  when applied to the procedure callback value, yields a truthy\n  result, terminates early calling the supplied cb with the callback\n  value. Otherwise, when complete, calls cb with nil."\n  [proc coll break? cb]\n  (if (seq coll)\n    (proc (first coll)\n      (fn [res]\n        (if (break? res)\n          (cb res)\n          (run-async! proc (rest coll) break? cb))))\n    (cb nil)))\n\n(declare ^{:arglists \'([name cb]\n                       [name opts cb]\n                       [bound-vars name opts cb]\n                       [bound-vars name reload opts cb])} require)\n\n(defn- process-deps\n  [bound-vars names opts cb]\n  (run-async! (fn [name cb]\n                (require bound-vars name nil opts cb))\n    names\n    :error\n    cb))\n\n(defn- process-macros-deps\n  [bound-vars cache opts cb]\n  (process-deps bound-vars\n    (distinct (vals (:require-macros cache)))\n    (-\x3e opts\n      (assoc :macros-ns true)\n      (dissoc :emit-constants :optimize-constants))\n    cb))\n\n(defn- process-libs-deps\n  [bound-vars cache opts cb]\n  (process-deps bound-vars\n    (distinct (concat (vals (:requires cache)) (vals (:imports cache))))\n    (dissoc opts :macros-ns)\n    cb))\n\n(defn- pre-file-side-effects\n  [st name file opts]\n  (when (:verbose opts)\n    (debug-prn "Pre-file side-effects" file))\n  ;; In case any constants are defined in the namespace, flush any analysis metadata\n  ;; so that the constants can be defined wihtout triggering re-defined errors.\n  (when (and (get-in @st [::ana/namespaces name :defs])\n             (not (\'#{cljs.core cljs.core$macros} name)))\n    (swap! st update ::ana/namespaces dissoc name)))\n\n(defn- post-file-side-effects\n  [file opts]\n  (when (:verbose opts)\n    (debug-prn "Post-file side-effects" file))\n  ;; Note, we don\'t (set! *unchecked-arrays* false) here, as that would interpreted\n  ;; an intrinsic affecting the compilation of this file, emitting a no-op. We bypass this\n  ;; and emit our own runtime assignment code.\n  (js* "cljs.core._STAR_unchecked_arrays_STAR_ \x3d false;"))\n\n(defn require\n  ([name cb]\n    (require name nil cb))\n  ([name opts cb]\n    (require nil name opts cb))\n  ([bound-vars name opts cb]\n   (require bound-vars name nil opts cb))\n  ([bound-vars name reload opts cb]\n   (let [bound-vars (merge\n                      {:*compiler*     (env/default-compiler-env)\n                       :*data-readers* tags/*cljs-data-readers*\n                       :*load-macros*  (:load-macros opts true)\n                       :*analyze-deps* (:analyze-deps opts true)\n                       :*load-fn*      (or (:load opts) *load-fn*)\n                       :*eval-fn*      (or (:eval opts) *eval-fn*)}\n                      bound-vars)\n         aname (cond-\x3e name (:macros-ns opts) ana/macro-ns-name)]\n     (when (\x3d :reload reload)\n       (swap! *loaded* disj aname))\n     (when (\x3d :reload-all reload)\n       (reset! *loaded* #{}))\n     (when (:verbose opts)\n       (debug-prn (str "Loading " name (when (:macros-ns opts) " macros") " namespace")))\n     (if-not (contains? @*loaded* aname)\n       (let [env (:*env* bound-vars)]\n         (try\n           ((:*load-fn* bound-vars)\n             {:name name\n              :macros (:macros-ns opts)\n              :path (ns-\x3erelpath name)}\n             (fn [resource]\n               (assert (or (map? resource) (nil? resource))\n                 "*load-fn* may only return a map or nil")\n               (if resource\n                 (let [{:keys [lang source cache source-map file]} resource]\n                   (condp keyword-identical? lang\n                     :clj (do\n                            (pre-file-side-effects (:*compiler* bound-vars) aname file opts)\n                            (eval-str* bound-vars source name (assoc opts :cljs-file file)\n                              (fn [res]\n                                (post-file-side-effects file opts)\n                                (if (:error res)\n                                  (cb res)\n                                  (do\n                                    (swap! *loaded* conj aname)\n                                    (cb {:value true}))))))\n                     :js (process-macros-deps bound-vars cache opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (process-libs-deps bound-vars cache opts\n                                 (fn [res]\n                                   (if (:error res)\n                                     (cb res)\n                                     (let [res (try\n                                                 ((:*eval-fn* bound-vars) resource)\n                                                 (when cache\n                                                   (load-analysis-cache!\n                                                     (:*compiler* bound-vars) aname cache)\n                                                   (ana/register-specs cache))\n                                                 (when source-map\n                                                   (load-source-map!\n                                                     (:*compiler* bound-vars) aname source-map))\n                                                 (catch :default cause\n                                                   (wrap-error\n                                                     (ana/error env\n                                                       (str "Could not require " name) cause))))]\n                                       (if (:error res)\n                                         (cb res)\n                                         (do\n                                           (swap! *loaded* conj aname)\n                                           (cb {:value true}))))))))))\n                     (cb (wrap-error\n                           (ana/error env\n                             (str "Invalid :lang specified " lang ", only :clj or :js allowed"))))))\n                 (cb (wrap-error\n                       (ana/error env\n                         (ana/error-message (if (:macros-ns opts)\n                                              :undeclared-macros-ns\n                                              :undeclared-ns)\n                           {:ns-sym name :js-provide (cljs.core/name name)})))))))\n           (catch :default cause\n             (cb (wrap-error\n                   (ana/error env\n                     (str "Could not require " name) cause))))))\n       (cb {:value true})))))\n\n(defn- patch-alias-map\n  [compiler in from to]\n  (let [patch (fn [k add-if-present?]\n                (swap! compiler update-in [::ana/namespaces in k]\n                  (fn [m]\n                    (let [replaced (walk/postwalk-replace {from to} m)]\n                      (if (and add-if-present?\n                               (some #{to} (vals replaced)))\n                        (assoc replaced from to)\n                        replaced)))))\n        patch-renames (fn [k]\n                        (swap! compiler update-in [::ana/namespaces in k]\n                          (fn [m]\n                            (when m\n                              (reduce (fn [acc [renamed qualified-sym :as entry]]\n                                        (if (\x3d (str from) (namespace qualified-sym))\n                                          (assoc acc renamed (symbol (str to) (name qualified-sym)))\n                                          (merge acc entry)))\n                                {} m)))))]\n    (patch :requires true)\n    (patch :require-macros true)\n    (patch :uses false)\n    (patch :use-macros false)\n    (patch-renames :renames)\n    (patch-renames :rename-macros)))\n\n(defn- self-require? [deps opts]\n  (and (true? (:def-emits-var opts)) (some #{ana/*cljs-ns*} deps)))\n\n(defn- load-deps\n  ([bound-vars ana-env lib deps cb]\n   (load-deps bound-vars ana-env lib deps nil nil cb))\n  ([bound-vars ana-env lib deps reload opts cb]\n   (when (:verbose opts)\n     (debug-prn "Loading dependencies for" lib))\n   (binding [ana/*cljs-dep-set* (let [lib (if (self-require? deps opts)\n                                            \'cljs.user\n                                            lib)]\n                                  (vary-meta (conj (:*cljs-dep-set* bound-vars) lib)\n                                    update-in [:dep-path] conj lib))]\n     (let [bound-vars (assoc bound-vars :*cljs-dep-set* ana/*cljs-dep-set*)]\n       (if-not (every? #(not (contains? ana/*cljs-dep-set* %)) deps)\n         (cb (wrap-error\n               (ana/error ana-env\n                 (str "Circular dependency detected "\n                   (apply str\n                     (interpose " -\x3e "\n                       (conj (-\x3e ana/*cljs-dep-set* meta :dep-path)\n                         (some ana/*cljs-dep-set* deps))))))))\n         (if (seq deps)\n           (let [dep (first deps)\n                 opts\' (-\x3e opts\n                         (dissoc :context)\n                         (dissoc :def-emits-var)\n                         (dissoc :ns))]\n             (require bound-vars dep reload opts\'\n               (fn [res]\n                 (when (:verbose opts)\n                   (debug-prn "Loading result:" res))\n                 (if-not (:error res)\n                   (load-deps bound-vars ana-env lib (next deps) nil opts cb)\n                   (if-let [cljs-dep (let [cljs-ns (ana/clj-ns-\x3ecljs-ns dep)]\n                                       (get {dep nil} cljs-ns cljs-ns))]\n                     (require bound-vars cljs-dep opts\'\n                       (fn [res]\n                         (if (:error res)\n                           (cb res)\n                           (do\n                             (patch-alias-map (:*compiler* bound-vars) lib dep cljs-dep)\n                             (load-deps bound-vars ana-env lib (next deps) nil opts\n                               (fn [res]\n                                 (if (:error res)\n                                   (cb res)\n                                   (cb (update res :aliased-loads assoc dep cljs-dep)))))))))\n                     (cb res))))))\n           (cb {:value nil})))))))\n\n(declare ^{:arglists \'([bound-vars source name opts cb])} analyze-str*)\n\n(defn- analyze-deps\n  ([bound-vars ana-env lib deps cb]\n   (analyze-deps bound-vars ana-env lib deps nil cb))\n  ([bound-vars ana-env lib deps opts cb]\n   (binding [ana/*cljs-dep-set* (vary-meta (conj (:*cljs-dep-set* bound-vars) lib)\n                                  update-in [:dep-path] conj lib)]\n     (let [compiler @(:*compiler* bound-vars)\n           bound-vars (assoc bound-vars :*cljs-dep-set* ana/*cljs-dep-set*)]\n       (if-not (every? #(not (contains? ana/*cljs-dep-set* %)) deps)\n         (cb (wrap-error\n               (ana/error ana-env\n                 (str "Circular dependency detected "\n                   (apply str\n                     (interpose " -\x3e "\n                       (conj (-\x3e ana/*cljs-dep-set* meta :dep-path)\n                         (some ana/*cljs-dep-set* deps))))))))\n         (if (seq deps)\n           (let [dep (first deps)]\n             (try\n               ((:*load-fn* bound-vars) {:name dep :path (ns-\x3erelpath dep)}\n                (fn [resource]\n                  (assert (or (map? resource) (nil? resource))\n                    "*load-fn* may only return a map or nil")\n                  (if-not resource\n                    (if-let [cljs-dep (let [cljs-ns (ana/clj-ns-\x3ecljs-ns dep)]\n                                        (get {dep nil} cljs-ns cljs-ns))]\n                      (do\n                        (patch-alias-map (:*compiler* bound-vars) lib dep cljs-dep)\n                        (analyze-deps bound-vars ana-env lib (cons cljs-dep (next deps)) opts\n                          (fn [res]\n                            (if (:error res)\n                              (cb res)\n                              (cb (update res :aliased-loads assoc dep cljs-dep))))))\n                      (cb (wrap-error\n                            (ana/error ana-env\n                              (ana/error-message :undeclared-ns\n                                {:ns-sym dep :js-provide (name dep)})))))\n                    (let [{:keys [name lang source file]} resource]\n                      (condp keyword-identical? lang\n                        :clj (do\n                               (pre-file-side-effects (:*compiler* bound-vars) name file opts)\n                               (analyze-str* bound-vars source name (assoc opts :cljs-file file)\n                                 (fn [res]\n                                   (post-file-side-effects file opts)\n                                   (if-not (:error res)\n                                     (analyze-deps bound-vars ana-env lib (next deps) opts cb)\n                                     (cb res)))))\n                        :js (analyze-deps bound-vars ana-env lib (next deps) opts cb)\n                        (wrap-error\n                          (ana/error ana-env\n                            (str "Invalid :lang specified " lang ", only :clj or :js allowed"))))))))\n               (catch :default cause\n                 (cb (wrap-error\n                       (ana/error ana-env\n                         (str "Could not analyze dep " dep) cause))))))\n           (cb {:value nil})))))))\n\n(defn- load-macros [bound-vars k macros lib reload reloads opts cb]\n  (if (seq macros)\n    (let [nsym (first (vals macros))\n          k    (or (reload k)\n                   (get-in reloads [k nsym])\n                   (and (\x3d nsym name) (:*reload-macros* bound-vars) :reload)\n                   nil)\n          opts\' (-\x3e opts\n                  (assoc :macros-ns true)\n                  (dissoc :context)\n                  (dissoc :def-emits-var)\n                  (dissoc :ns)\n                  (dissoc :emit-constants :optimize-constants))]\n      (require bound-vars nsym k opts\'\n        (fn [res]\n          (if-not (:error res)\n            (load-macros bound-vars k (next macros) lib reload reloads opts cb)\n            (if-let [cljs-dep (let [cljs-ns (ana/clj-ns-\x3ecljs-ns nsym)]\n                                (get {nsym nil} cljs-ns cljs-ns))]\n              (require bound-vars cljs-dep k opts\'\n                (fn [res]\n                  (if (:error res)\n                    (cb res)\n                    (do\n                      (patch-alias-map (:*compiler* bound-vars) lib nsym cljs-dep)\n                      (load-macros bound-vars k (next macros) lib reload reloads opts\n                        (fn [res]\n                          (if (:error res)\n                            (cb res)\n                            (cb (update res :aliased-loads assoc nsym cljs-dep)))))))))\n              (cb res))))))\n    (cb {:value nil})))\n\n(defn- rewrite-ns-ast\n  ([ast smap]\n   (rewrite-ns-ast ast smap false))\n  ([ast smap macros?]\n   (let [[uk rk renk] (if macros?\n                        [:use-macros :require-macros :rename-macros]\n                        [:uses :requires :renames])\n         rewrite-renames (fn [m]\n                           (when m\n                             (reduce (fn [acc [renamed qualified-sym :as entry]]\n                                       (let [from (symbol (namespace qualified-sym))\n                                             to   (get smap from)]\n                                         (if (some? to)\n                                           (assoc acc renamed (symbol (str to) (name qualified-sym)))\n                                           (merge acc entry))))\n                               {} m)))\n         rewrite-deps (fn [deps]\n                        (into []\n                          (map (fn [dep]\n                                 (if-let [new-dep (get smap dep)]\n                                   new-dep\n                                   dep)))\n                          deps))]\n     (-\x3e ast\n       (update uk #(walk/postwalk-replace smap %))\n       (update rk #(merge smap (walk/postwalk-replace smap %)))\n       (update renk rewrite-renames)\n       (update :deps rewrite-deps)))))\n\n(defn- check-macro-autoload-inferring-missing\n  [{:keys [requires name] :as ast} cenv]\n  (let [namespaces (-\x3e @cenv ::ana/namespaces)\n        missing-require-macros (into {}\n                                 (filter (fn [[_ full-ns]]\n                                           (let [{:keys [use-macros require-macros]} (get namespaces full-ns)]\n                                             (or (some #{full-ns} (vals use-macros))\n                                                 (some #{full-ns} (vals require-macros))))))\n                                 requires)\n        ast\' (update-in ast [:require-macros] merge missing-require-macros)]\n    (swap! cenv update-in [::ana/namespaces name :require-macros] merge missing-require-macros)\n    ast\'))\n\n(defn- ns-side-effects\n  ([bound-vars ana-env ast opts cb]\n    (ns-side-effects false bound-vars ana-env ast opts cb))\n  ([load bound-vars ana-env {:keys [op] :as ast} opts cb]\n   (when (:verbose opts)\n     (debug-prn "Namespace side effects for" (:name ast)))\n   (if (#{:ns :ns*} op)\n     (letfn [(check-uses-and-load-macros [res rewritten-ast]\n               (let [env (:*compiler* bound-vars)\n                     {:keys [uses use-macros reload reloads name]} rewritten-ast]\n                 (if (:error res)\n                   (cb res)\n                   (if (:*load-macros* bound-vars)\n                     (do\n                       (when (:verbose opts) (debug-prn "Processing :use-macros for" name))\n                       (load-macros bound-vars :use-macros use-macros name reload reloads opts\n                         (fn [res]\n                           (if (:error res)\n                             (cb res)\n                             (let [{:keys [require-macros] :as rewritten-ast} (rewrite-ns-ast rewritten-ast (:aliased-loads res) true)]\n                               (when (:verbose opts) (debug-prn "Processing :require-macros for" (:name ast)))\n                               (load-macros bound-vars :require-macros require-macros name reload reloads opts\n                                 (fn [res\']\n                                   (if (:error res\')\n                                     (cb res\')\n                                     (let [{:keys [use-macros] :as rewritten-ast} (rewrite-ns-ast rewritten-ast (:aliased-loads res) true)\n                                           res\' (try\n                                                  (when (seq use-macros)\n                                                    (when (:verbose opts) (debug-prn "Checking :use-macros for" (:name ast)))\n                                                    (binding [ana/*analyze-deps* (:*analyze-deps* bound-vars)\n                                                              env/*compiler* (:*compiler* bound-vars)]\n                                                      (ana/check-use-macros use-macros env)))\n                                                  {:value nil}\n                                                  (catch :default cause\n                                                    (wrap-error\n                                                      (ana/error ana-env\n                                                        (str "Could not parse ns form " (:name ast)) cause))))]\n                                       (if (:error res\')\n                                         (cb res\')\n                                         (try\n                                           (binding [ana/*analyze-deps* (:*analyze-deps* bound-vars)\n                                                     env/*compiler* (:*compiler* bound-vars)]\n                                             (let [ast\' (-\x3e rewritten-ast\n                                                          (ana/check-use-macros-inferring-missing env)\n                                                          (ana/check-rename-macros-inferring-missing env)\n                                                          (check-macro-autoload-inferring-missing env))]\n                                               (cb {:value ast\'})))\n                                           (catch :default cause\n                                             (cb (wrap-error\n                                                   (ana/error ana-env\n                                                     (str "Could not parse ns form " (:name ast)) cause)))))))))))))))\n                     (try\n                       (when (:verbose opts) (debug-prn "Checking uses"))\n                       (ana/check-uses\n                         (when (and (:*analyze-deps* bound-vars) (seq uses))\n                           (ana/missing-uses uses env))\n                         env)\n                       (cb {:value ast})\n                       (catch :default cause\n                         (cb (wrap-error\n                               (ana/error ana-env\n                                 (str "Could not parse ns form " (:name ast)) cause)))))))))]\n       (cond\n         (and load (seq (:deps ast)))\n         (let [{:keys [reload name deps]} ast]\n           (load-deps bound-vars ana-env name deps (or (:require reload) (:use reload)) (dissoc opts :macros-ns)\n             #(check-uses-and-load-macros % (rewrite-ns-ast ast (:aliased-loads %)))))\n\n         (and (not load) (:*analyze-deps* bound-vars) (seq (:deps ast)))\n         (analyze-deps bound-vars ana-env (:name ast) (:deps ast) (dissoc opts :macros-ns)\n           #(check-uses-and-load-macros % (rewrite-ns-ast ast (:aliased-loads %))))\n\n         :else\n         (check-uses-and-load-macros {:value nil} ast)))\n     (cb {:value ast}))))\n\n(defn- node-side-effects\n  [bound-vars sb deps ns-name emit-nil-result?]\n  (doseq [dep deps]\n    (.append sb\n      (with-out-str\n        (comp/emitln (munge ns-name) "."\n          (ana/munge-node-lib dep)\n          " \x3d require(\'" dep "\');"))))\n  (when (and (seq deps) emit-nil-result?)\n    (.append sb "null;")))\n\n(defn- global-exports-side-effects\n  [bound-vars sb deps ns-name emit-nil-result?]\n  (let [{:keys [js-dependency-index]} @(:*compiler* bound-vars)]\n    (doseq [dep deps]\n      (let [{:keys [global-exports]} (get js-dependency-index (name dep))]\n        (.append sb\n          (with-out-str\n            (comp/emit-global-export ns-name global-exports dep)))))\n    (when (and (seq deps) emit-nil-result?)\n      (.append sb "null;"))))\n\n(defn- trampoline-safe\n  "Returns a new function that calls f but discards any return value,\n  returning nil instead, thus avoiding any inadvertent trampoline continuation\n  if a function happens to be returned."\n  [f]\n  (comp (constantly nil) f))\n\n(defn- analyze-str* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        cb         (trampoline-safe cb)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        the-ns     (or (:ns opts) \'cljs.user)\n        bound-vars (cond-\x3e (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (trampoline\n     (fn analyze-loop [last-ast ns]\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 ana/*cljs-ns*          ns\n                 ana/*checked-arrays*   (:checked-arrays opts)\n                 ana/*cljs-static-fns*  (:static-fns opts)\n                 ana/*fn-invoke-direct* (and (:static-fns opts) (:fn-invoke-direct opts))\n                 *ns*                   (create-ns ns)\n                 ana/*passes*           (:*passes* bound-vars)\n                 r/*alias-map*          (alias-map @(:*compiler* bound-vars) ns)\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 r/resolve-symbol       resolve-symbol\n                 comp/*source-map-data* (:*sm-data* bound-vars)\n                 ana/*cljs-file*        (:cljs-file opts)]\n         (let [res (try\n                     {:value (read eof rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str "Could not analyze " name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-\x3e (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str "Could not analyze " name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)]\n                       (if (#{:ns :ns*} (:op ast))\n                         ((trampoline-safe ns-side-effects) bound-vars aenv ast opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (trampoline analyze-loop ast (:name ast)))))\n                         #(analyze-loop ast ns)))))\n                 (cb {:value last-ast}))))))) nil the-ns)))\n\n(defn analyze-str\n  "Analyze ClojureScript source. The compiler state will be populated with\n   the results of analyzes. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false).\n                          Defaults to false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value, the actual value is not meaningful. If unsuccessful the\n     map will contain a key :error with an ex-info instance describing the cause\n     of failure."\n  ([state source cb]\n   (analyze-str state source nil cb))\n  ([state source name cb]\n   (analyze-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (analyze-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*passes*       (or (:passes opts) ana/*passes*)\n      :*analyze-deps* (:analyze-deps opts true)\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))\n\n;; -----------------------------------------------------------------------------\n;; Eval\n\n(declare ^{:arglists \'([])} clear-fns!)\n\n(defn- eval* [bound-vars form opts cb]\n  (let [the-ns     (or (:ns opts) \'cljs.user)\n        bound-vars (cond-\x3e (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (clear-fns!)\n    (binding [env/*compiler*         (:*compiler* bound-vars)\n              *eval-fn*              (:*eval-fn* bound-vars)\n              ana/*cljs-ns*          (:*cljs-ns* bound-vars)\n              ana/*checked-arrays*   (:checked-arrays opts)\n              ana/*cljs-static-fns*  (:static-fns opts)\n              ana/*fn-invoke-direct* (and (:static-fns opts) (:fn-invoke-direct opts))\n              *ns*                   (create-ns (:*cljs-ns* bound-vars))\n              r/*alias-map*          (alias-map @(:*compiler* bound-vars) (:*cljs-ns* bound-vars))\n              r/*data-readers*       (:*data-readers* bound-vars)\n              r/resolve-symbol       resolve-symbol\n              comp/*source-map-data* (:*sm-data* bound-vars)]\n      (let [aenv (ana/empty-env)\n            aenv (cond-\x3e (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                   (:context opts) (assoc :context (:context opts))\n                   (:def-emits-var opts) (assoc :def-emits-var true))\n            res  (try\n                   {:value (ana/analyze aenv form nil opts)}\n                   (catch :default cause\n                     (wrap-error\n                       (ana/error aenv\n                         (str "Could not eval " form) cause))))]\n        (if (:error res)\n          (cb res)\n          (let [ast (:value res)\n                [node-deps ast] (if (keyword-identical? (:target opts) :nodejs)\n                                  (let [{node-libs true libs-to-load false} (group-by ana/node-module-dep? (:deps ast))]\n                                    [node-libs (assoc ast :deps libs-to-load)])\n                                  [nil ast])]\n            (if (#{:ns :ns*} (:op ast))\n              (ns-side-effects true bound-vars aenv ast opts\n                (fn [res]\n                  (if (:error res)\n                    (cb res)\n                    (let [ns-name (:name ast)\n                          sb (StringBuffer.)]\n                      (.append sb\n                        (with-out-str (comp/emitln (str "goog.provide(\\"" (comp/munge ns-name) "\\");"))))\n                      (when-not (nil? node-deps)\n                        (node-side-effects bound-vars sb node-deps ns-name (:def-emits-var opts)))\n                      (global-exports-side-effects bound-vars sb\n                        (filter ana/dep-has-global-exports? (:deps ast))\n                        ns-name\n                        (:def-emits-var opts))\n                      (cb {:value (*eval-fn* {:source (.toString sb)})})))))\n              (let [src (with-out-str (comp/emit ast))]\n                (cb {:value (*eval-fn* {:source src})})))))))))\n\n(defn eval\n  "Evaluate a single ClojureScript form. The parameters:\n\n   state (atom)\n     the compiler state\n\n   form (s-expr)\n     the ClojureScript source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the result of evalution. If unsuccessful the map will\n     contain a key :error with an ex-info instance describing the cause of\n     failure."\n  ([state form cb]\n   (eval state form nil cb))\n  ([state form opts cb]\n   (eval*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (:analyze-deps opts true)\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     form opts cb)))\n\n;; -----------------------------------------------------------------------------\n;; Compile\n\n(defn- compile-str* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        cb         (trampoline-safe cb)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        sb         (StringBuffer.)\n        the-ns     (or (:ns opts) \'cljs.user)\n        bound-vars (cond-\x3e (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (trampoline\n     (fn compile-loop [ns]\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 *eval-fn*              (:*eval-fn* bound-vars)\n                 ana/*cljs-ns*          ns\n                 ana/*checked-arrays*   (:checked-arrays opts)\n                 ana/*cljs-static-fns*  (:static-fns opts)\n                 ana/*fn-invoke-direct* (and (:static-fns opts) (:fn-invoke-direct opts))\n                 *ns*                   (create-ns ns)\n                 r/*alias-map*          (alias-map @(:*compiler* bound-vars) ns)\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 r/resolve-symbol       resolve-symbol\n                 comp/*source-map-data* (:*sm-data* bound-vars)]\n         (let [res (try\n                     {:value (read eof rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str "Could not compile " name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-\x3e (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str "Could not compile " name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)\n                           [node-deps ast] (if (keyword-identical? (:target opts) :nodejs)\n                                             (let [{node-libs true libs-to-load false} (group-by ana/node-module-dep? (:deps ast))]\n                                               [node-libs (assoc ast :deps libs-to-load)])\n                                             [nil ast])]\n                       (if (#{:ns :ns*} (:op ast))\n                         ((trampoline-safe ns-side-effects) bound-vars aenv ast opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (let [ns-name (:name ast)]\n                                 (.append sb (with-out-str (comp/emit (:value res))))\n                                 (when-not (nil? node-deps)\n                                   (node-side-effects bound-vars sb node-deps ns-name (:def-emits-var opts)))\n                                 (trampoline compile-loop (:name ast))))))\n                         (do\n                           (.append sb (with-out-str (comp/emit ast)))\n                           #(compile-loop ns))))))\n                 (do\n                   (when (:source-map opts)\n                     (append-source-map env/*compiler*\n                       name source sb @comp/*source-map-data* opts))\n                   (cb {:value (.toString sb)})))))))) the-ns)))\n\n(defn compile-str\n  "Compile ClojureScript source into JavaScript. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source - used as key in :source-maps\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the compilation result (string). If unsuccessful the map\n     will contain a key :error with an ex-info instance describing the cause\n     of failure."\n  ([state source cb]\n   (compile-str state source nil cb))\n  ([state source name cb]\n   (compile-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (compile-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*analyze-deps* (:analyze-deps opts true)\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)\n      :*sm-data*      (when (:source-map opts) (sm-data))}\n     source name opts cb)))\n\n;; -----------------------------------------------------------------------------\n;; Evaluate String\n\n(defn- eval-str* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        cb         (trampoline-safe cb)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        sb         (StringBuffer.)\n        the-ns     (or (:ns opts) \'cljs.user)\n        bound-vars (cond-\x3e (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))\n        aname      (cond-\x3e name (:macros-ns opts) ana/macro-ns-name)]\n    (when (:verbose opts) (debug-prn "Evaluating" name))\n    (clear-fns!)\n    (trampoline\n     (fn compile-loop [ns]\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 *eval-fn*              (:*eval-fn* bound-vars)\n                 ana/*cljs-ns*          ns\n                 ana/*checked-arrays*   (:checked-arrays opts)\n                 ana/*cljs-static-fns*  (:static-fns opts)\n                 ana/*fn-invoke-direct* (and (:static-fns opts) (:fn-invoke-direct opts))\n                 *ns*                   (create-ns ns)\n                 r/*alias-map*          (alias-map @(:*compiler* bound-vars) ns)\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 r/resolve-symbol       resolve-symbol\n                 comp/*source-map-data* (:*sm-data* bound-vars)\n                 ana/*cljs-file*        (:cljs-file opts)]\n         (let [res (try\n                     {:value (read eof rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str "Could not eval " name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-\x3e (assoc aenv :ns (ana/get-namespace ns))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str "Could not eval " name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)\n                           ns\' ana/*cljs-ns*\n                           [node-deps ast] (if (keyword-identical? (:target opts) :nodejs)\n                                             (let [{node-libs true libs-to-load false} (group-by ana/node-module-dep? (:deps ast))]\n                                               [node-libs (assoc ast :deps libs-to-load)])\n                                             [nil ast])]\n                      (if (#{:ns :ns*} (:op ast))\n                        (do\n                          (.append sb\n                            (with-out-str (comp/emitln (str "goog.provide(\\"" (comp/munge (:name ast)) "\\");"))))\n                          ((trampoline-safe ns-side-effects) true bound-vars aenv ast opts\n                            (fn [res]\n                              (if (:error res)\n                                (cb res)\n                                (let [ns-name (:name ast)]\n                                  (when-not (nil? node-deps)\n                                    (node-side-effects bound-vars sb node-deps ns-name (:def-emits-var opts)))\n                                  (global-exports-side-effects bound-vars sb\n                                    (filter ana/dep-has-global-exports? (:deps ast))\n                                    ns-name\n                                    (:def-emits-var opts))\n                                  (trampoline compile-loop ns\'))))))\n                        (do\n                          (env/with-compiler-env (assoc @(:*compiler* bound-vars) :options opts)\n                            (.append sb (with-out-str (comp/emit ast))))\n                          #(compile-loop ns\'))))))\n                 (do\n                   (when (:source-map opts)\n                     (append-source-map env/*compiler*\n                       aname source sb @comp/*source-map-data* opts))\n                   (when (symbol? aname)\n                     (ana/dump-specs aname))\n                   (let [js-source (.toString sb)\n                         evalm     {:lang   :clj\n                                    :name   name\n                                    :path   (ns-\x3erelpath name)\n                                    :source js-source\n                                    :cache  (get-in @env/*compiler* [::ana/namespaces aname])}\n                         complete  (fn [res]\n                                     (if (:error res)\n                                       (cb res)\n                                       (do\n                                         (when (:verbose opts)\n                                           (debug-prn js-source))\n                                         (let [res (try\n                                                     {:ns ns :value (*eval-fn* evalm)}\n                                                     (catch :default cause\n                                                       (wrap-error (ana/error aenv "ERROR" cause))))]\n                                           (cb res)))))]\n                     (if-let [f (:cache-source opts)]\n                       ((trampoline-safe f) evalm complete)\n                       (complete {:value nil}))))))))))\n      (:*cljs-ns* bound-vars))))\n\n(defn eval-str\n  "Evalute ClojureScript source given as a string. The parameters:\n\n  state (atom)\n    the compiler state\n\n  source (string)\n    the ClojureScript source\n\n  name (symbol or string)\n    optional, the name of the source - used as key in :source-maps\n\n  opts (map)\n    compilation options.\n\n    :eval             - eval function to invoke, see *eval-fn*\n    :load             - library resolution function, see *load-fn*\n    :source-map       - set to true to generate inline source map information\n    :cache-source     - optional, a function to run side-effects with the\n                        compilation result prior to actual evalution. This function\n                        takes two arguments, the first is the eval map, the source\n                        will be under :source. The second argument is a callback of\n                        one argument. If an error occurs an :error key should be\n                        supplied.\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\n                        (if set to true) or the def init value (if false). Default\n                        is false.\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                        to aget/aset. Logs for incorrect values if :warn, throws if\n                        :error. Defaults to false.\n    :static-fns       - employ static dispatch to specific function arities in\n                        emitted JavaScript, as opposed to making use of the\n                        `call` construct. Defaults to false.\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                        unknown functions, but instead direct invokes via\n                        `f(a0,a1...)`. Defaults to `false`.\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                        at the moment.\n    :ns               - optional, the namespace in which to evaluate the source.\n    :verbose          - optional, emit details from compiler activity. Defaults to\n                        false.\n    :context          - optional, sets the context for the source. Possible values\n                     are `:expr`, `:statement` and `:return`. Defaults to\n                      `:expr`.\n\n  cb (function)\n    callback, will be invoked with a map. If succesful the map will contain\n    a :value key with the result of evaluation and :ns the current namespace.\n    If unsuccessful will contain a :error key with an ex-info instance describing\n    the cause of failure."\n  ([state source cb]\n   (eval-str state source nil cb))\n  ([state source name cb]\n   (eval-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (eval-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (:analyze-deps opts true)\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))\n\n;;; Support for cljs.core/eval\n\n;; The following volatiles and fns set up a scheme to\n;; emit function values into JavaScript as numeric\n;; references that are looked up. Needed to implement eval.\n\n(defonce ^:private fn-index (volatile! 0))\n(defonce ^:private fn-refs (volatile! {}))\n\n(defn- clear-fns!\n  "Clears saved functions."\n  []\n  (vreset! fn-refs {}))\n\n(defn- put-fn\n  "Saves a function, returning a numeric representation."\n  [f]\n  (let [n (vswap! fn-index inc)]\n    (vswap! fn-refs assoc n f)\n    n))\n\n(defn- get-fn\n  "Gets a function, given its numeric representation."\n  [n]\n  (get @fn-refs n))\n\n(defn- emit-fn [f]\n  (print "cljs.js.get_fn(" (put-fn f) ")"))\n\n(defmethod comp/emit-constant* js/Function\n  [f]\n  (emit-fn f))\n\n(defmethod comp/emit-constant* cljs.core/Var\n  [f]\n  (emit-fn f))\n\n(defn- eval-impl\n  ([form]\n   (eval-impl form (.-name *ns*)))\n  ([form ns]\n   (let [result (atom nil)]\n     (let [st env/*compiler*]\n       (eval st form\n         {:ns            ns\n          :context       :expr\n          :def-emits-var true}\n         (fn [{:keys [value error]}]\n           (if error\n             (throw error)\n             (reset! result value)))))\n     @result)))\n\n(set! *eval* eval-impl)\n\n(comment\n  (require \'[cljs.js :as cljs]\n           \'[cljs.analyzer :as ana])\n\n  (def vm (js/require "vm"))\n  (def fs (js/require "fs"))\n  (def st (cljs/empty-state))\n\n  (set! *target* "nodejs")\n\n  (defn node-eval [{:keys [name source]}]\n    (.runInThisContext vm source (str (munge name) ".js")))\n\n  (def libs\n    {\'bootstrap-test.core :cljs\n     \'bootstrap-test.macros :clj\n     \'bootstrap-test.helper :clj})\n\n  (defn node-load [{:keys [name macros]} cb]\n    (if (contains? libs name)\n      (let [path (str "src/test/cljs/" (cljs/ns-\x3erelpath name)\n                      "." (cljs.core/name (get libs name)))]\n        (.readFile fs path "utf-8"\n          (fn [err src]\n            (cb (if-not err\n                  {:lang :clj :source src}\n                  (.error js/console err))))))\n      (cb nil)))\n\n  (defn elide-env [env ast opts]\n    (dissoc ast :env))\n\n  (cljs/analyze-str st "(+ 1 1)" nil\n    {:passes [ana/infer-type elide-env]\n     :eval node-eval}\n    (fn [{:keys [value]}]\n      (println value)))\n\n  (cljs/eval st \'(defn foo [a b] (+ a b))\n    {:eval node-eval}\n    (fn [res]\n      (println res)))\n\n  (cljs/compile-str st "(defprotocol IFoo (foo [this]))"\n    (fn [{:keys [value]}]\n      (println "Source:")\n      (println value)))\n\n  (cljs/eval-str st\n    "(defn foo [a b] (+ a b))\n     (defn bar [c d] (+ c d))"\n    nil\n    {:eval node-eval}\n    (fn [res]\n      (println res)))\n\n  (cljs/eval-str st "1"\n    nil\n    {:eval node-eval\n     :context :expr}\n    (fn [res]\n      (println res)))\n\n  (cljs/eval-str st "(def x 1)"\n    nil\n    {:eval node-eval\n     :context :expr\n     :def-emits-var true}\n    (fn [res]\n      (println res)))\n\n  (cljs/eval st \'(ns foo.bar)\n    {:eval node-eval}\n    (fn [res]\n      (println res)))\n\n  (cljs/eval st \'(def x 1)\n    {:eval node-eval\n     :context :expr\n     :def-emits-var true\n     :ns \'foo.bar}\n    (fn [res]\n      (println res)))\n\n  (cljs/compile-str st "(defn foo\\n[a b]\\n(+ a b))" \'cljs.foo\n    {:verbose true :source-map true}\n    (fn [js-source]\n      (println "Source:")\n      (println js-source)))\n\n  (cljs/eval-str st\n    "(ns foo.bar (:require [bootstrap-test.core]))\\n(bootstrap-test.core/foo 3 4)"\n    \'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [ret]\n      (println ret)))\n\n  (cljs/eval-str st\n    "(ns foo.bar (:require-macros [bootstrap-test.macros :refer [foo]]))\\n(foo 4 4)"\n    \'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println "Error:" error)\n          (println (.. error -cause -stack)))\n        (println "Result:" res))))\n\n  (cljs/compile-str st\n    "(ns foo.bar (:require-macros [bootstrap-test.macros :refer [foo]]))\\n(foo 4 4)"\n    \'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println "Error:" error)\n          (println (.. error -cause -stack)))\n        (println "Result:" res))))\n\n  (cljs/eval-str st\n    "(ns foo.bar)\\n(first [1 2 3])"\n    \'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println error)\n          (println (.. error -cause -stack)))\n        (println res))))\n\n  (cljs/eval-str st\n    "(ns foo.bar)\\n(map inc [1 2 3])"\n    \'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println error)\n          (println (.. error -cause -stack)))\n        (println res))))\n\n  ;; *NOT* source mapped under Node.js\n  ;; source-map-support does not yet work, users will need to map\n  ;; themselves\n  (cljs/eval-str st\n    "(ns foo.bar)\\n(ffirst [1 2 3])"\n    \'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println error)\n          (println (.. error -cause -stack)))\n        (println res))))\n  )\n'],
null),new p(null,3,[Cl,"clojure/set.clj",Xn,"clojure.set",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc "Set operations such as union/intersection."\n       :author "Rich Hickey"}\n       clojure.set)\n\n(defn- bubble-max-key\n  "Move a maximal element of coll according to fn k (which returns a\n  number) to the front of coll."\n  [k coll]\n  (let [max (apply max-key k coll)]\n    (cons max (remove #(identical? max %) coll))))\n\n(defn union\n  "Return a set that is the union of the input sets"\n  {:added "1.0"}\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (\x3c (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 \x26 sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn intersection\n  "Return a set that is the intersection of the input sets"\n  {:added "1.0"}\n  ([s1] s1)\n  ([s1 s2]\n     (if (\x3c (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 \x26 sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn difference\n  "Return a set that is the first set without elements of the remaining sets"\n  {:added "1.0"}\n  ([s1] s1)\n  ([s1 s2] \n     (if (\x3c (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 \x26 sets] \n     (reduce difference s1 (conj sets s2))))\n\n\n(defn select\n  "Returns a set of the elements for which pred is true"\n  {:added "1.0"}\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))\n\n(defn project\n  "Returns a rel of the elements of xrel with only the keys in ks"\n  {:added "1.0"}\n  [xrel ks]\n  (with-meta (set (map #(select-keys % ks) xrel)) (meta xrel)))\n\n(defn rename-keys\n  "Returns the map with the keys in kmap renamed to the vals in kmap"\n  {:added "1.0"}\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m)) \n     (apply dissoc map (keys kmap)) kmap))\n\n(defn rename\n  "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"\n  {:added "1.0"}\n  [xrel kmap]\n  (with-meta (set (map #(rename-keys % kmap) xrel)) (meta xrel)))\n\n(defn index\n  "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks."\n  {:added "1.0"}\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))\n   \n(defn map-invert\n  "Returns the map with the vals mapped to the keys."\n  {:added "1.0"}\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))\n\n(defn join\n  "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys."\n  {:added "1.0"}\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (\x3c\x3d (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (\x3c\x3d (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))\n\n(defn subset? \n  "Is set1 a subset of set2?"\n  {:added "1.2",\n   :tag Boolean}\n  [set1 set2]\n  (and (\x3c\x3d (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))\n\n(defn superset? \n  "Is set1 a superset of set2?"\n  {:added "1.2",\n   :tag Boolean}\n  [set1 set2]\n  (and (\x3e\x3d (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))\n\n(comment\n(refer \'set)\n(def xs #{{:a 11 :b 1 :c 1 :d 4}\n         {:a 2 :b 12 :c 2 :d 6}\n         {:a 3 :b 3 :c 3 :d 8 :f 42}})\n\n(def ys #{{:a 11 :b 11 :c 11 :e 5}\n         {:a 12 :b 11 :c 12 :e 3}\n         {:a 3 :b 3 :c 3 :e 7 }})\n\n(join xs ys)\n(join xs (rename ys {:b :yb :c :yc}) {:a :a})\n\n(union #{:a :b :c} #{:c :d :e })\n(difference #{:a :b :c} #{:c :d :e})\n(intersection #{:a :b :c} #{:c :d :e})\n\n(index ys [:b])\n)\n\n'],
null),new p(null,3,[Cl,"clojure/walk.cljs",Xn,"clojure.walk",nr,';   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;;; walk.cljs - generic tree walker with replacement\n\n;; by Stuart Sierra\n;; Jul5 17, 2011\n\n;; CHANGE LOG:\n;;\n;; * July 17, 2011: Port to ClojureScript\n;; \n;; * December 15, 2008: replaced \'walk\' with \'prewalk\' \x26 \'postwalk\'\n;;\n;; * December 9, 2008: first version\n\n\n(ns \n  ^{:author "Stuart Sierra",\n     :doc "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\"walk\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function."}\n  clojure.walk)\n\n(defn walk\n  "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."\n\n  {:added "1.1"}\n  [inner outer form]\n  (cond\n    (list? form)      (outer (apply list (map inner form)))\n    (map-entry? form)\n    (outer (MapEntry. (inner (key form)) (inner (val form)) nil))\n    (seq? form)       (outer (doall (map inner form)))\n    (record? form)    (outer (reduce (fn [r x] (conj r (inner x))) form form))\n    (coll? form)      (outer (into (empty form) (map inner form)))\n    :else             (outer form)))\n\n(defn postwalk\n  "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f\'s return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."\n  {:added "1.1"}\n  [f form]\n  (walk (partial postwalk f) f form))\n\n(defn prewalk\n  "Like postwalk, but does pre-order traversal."\n  {:added "1.1"}\n  [f form]\n  (walk (partial prewalk f) identity (f form)))\n\n(defn keywordize-keys\n  "Recursively transforms all map keys from strings to keywords."\n  {:added "1.1"}\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn stringify-keys\n  "Recursively transforms all map keys from keywords to strings."\n  {:added "1.1"}\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn prewalk-replace\n  "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first."\n  {:added "1.1"}\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n\n(defn postwalk-replace\n  "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first."\n  {:added "1.1"}\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n'],
null),new p(null,3,[Cl,"cljs/tools/reader.cljs",Xn,"cljs.tools.reader",nr,';;   Copyright (c) Nicola Mometto, Rich Hickey \x26 contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc "A clojure reader in clojure"\n      :author "Bronsa"}\n  cljs.tools.reader\n  (:refer-clojure :exclude [read read-line read-string char read+string\n                            default-data-readers *default-data-reader-fn*\n                            *data-readers* *suppress-read*])\n  (:require-macros [cljs.tools.reader.reader-types :refer [log-source]])\n  (:require [cljs.tools.reader.reader-types :refer\n             [read-char unread peek-char indexing-reader?\n              get-line-number get-column-number get-file-name\n              string-push-back-reader]]\n            [cljs.tools.reader.impl.utils :refer\n             [char ex-info? whitespace? numeric? desugar-meta next-id namespace-keys second\'\n              ReaderConditional reader-conditional reader-conditional? char-code]]\n            [cljs.tools.reader.impl.commons :refer\n             [number-literal? read-past match-number parse-symbol read-comment throwing-reader]]\n            [cljs.tools.reader.impl.errors :as err]\n            [goog.array :as garray]\n            [goog.string :as gstring])\n  (:import goog.string.StringBuffer))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; helpers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare ^:private read*\n         macros dispatch-macros\n         ^:dynamic *data-readers*\n         ^:dynamic *default-data-reader-fn*\n         ^:dynamic *suppress-read*\n         default-data-readers)\n\n(defn- ^boolean macro-terminating? [ch]\n  (case ch\n    (\\" \\; \\@ \\^ \\` \\~ \\( \\) \\[ \\] \\{ \\} \\\\) true\n    false))\n\n(def sb (StringBuffer.))\n\n(defn- read-token\n  "Read in a single logical token from the reader"\n  [^not-native rdr kind initch]\n  (if (nil? initch)\n    (err/throw-eof-at-start rdr kind)\n    (do\n      (.clear sb)\n      (loop [ch initch]\n        (if (or (whitespace? ch)\n                (macro-terminating? ch)\n                (nil? ch))\n          (do\n            (when-not (nil? ch)\n              (unread rdr ch))\n            (.toString sb))\n          (do\n            (.append sb ch)\n            (recur (read-char rdr))))))))\n\n(declare read-tagged)\n\n(defn- read-dispatch\n  [^not-native rdr _ opts pending-forms]\n  (if-let [ch (read-char rdr)]\n    (if-let [dm (dispatch-macros ch)]\n      (dm rdr ch opts pending-forms)\n      (read-tagged (doto rdr (unread ch)) ch opts pending-forms)) ;; ctor reader is implemented as a tagged literal\n    (err/throw-eof-at-dispatch rdr)))\n\n(defn- read-unmatched-delimiter\n  [rdr ch opts pending-forms]\n  (err/throw-unmatch-delimiter rdr ch))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; readers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn read-regex\n  [^not-native rdr ch opts pending-forms]\n  (let [sb (StringBuffer.)]\n    (loop [ch (read-char rdr)]\n      (if (identical? \\" ch)\n        (re-pattern (str sb))\n        (if (nil? ch)\n          (err/throw-eof-reading rdr :regex sb)\n          (do\n            (.append sb ch )\n            (when (identical? \\\\ ch)\n              (let [ch (read-char rdr)]\n                (if (nil? ch)\n                  (err/throw-eof-reading rdr :regex sb))\n                (.append sb ch)))\n            (recur (read-char rdr))))))))\n\n(defn- read-unicode-char\n  ([token offset length base]\n     (let [l (+ offset length)]\n       (when-not (\x3d\x3d (count token) l)\n         (err/throw-invalid-unicode-literal nil token))\n       (loop [i offset uc 0]\n         (if (\x3d\x3d i l)\n           (js/String.fromCharCode uc)\n           (let [d (char-code (nth token i) base)]\n             (if (\x3d\x3d d -1)\n               (err/throw-invalid-unicode-digit-in-token nil (nth token i) token)\n               (recur (inc i) (+ d (* uc base)))))))))\n\n  ([^not-native rdr initch base length exact?]\n     (loop [i 1 uc (char-code initch base)]\n       (if (\x3d\x3d uc -1)\n         (err/throw-invalid-unicode-digit rdr initch)\n         (if-not (\x3d\x3d i length)\n           (let [ch (peek-char rdr)]\n             (if (or (whitespace? ch)\n                     (macros ch)\n                     (nil? ch))\n               (if exact?\n                 (err/throw-invalid-unicode-len rdr i length)\n                 (js/String.fromCharCode uc))\n               (let [d (char-code ch base)]\n                 (read-char rdr)\n                 (if (\x3d\x3d d -1)\n                   (err/throw-invalid-unicode-digit rdr ch)\n                   (recur (inc i) (+ d (* uc base)))))))\n           (js/String.fromCharCode uc))))))\n\n(def ^:private ^:const upper-limit (.charCodeAt \\uD7ff 0))\n(def ^:private ^:const lower-limit (.charCodeAt \\uE000 0))\n\n(defn- valid-octal? [token base]\n  (\x3c\x3d (js/parseInt token base) 0377))\n\n(defn- read-char*\n  "Read in a character literal"\n  [^not-native rdr backslash opts pending-forms]\n  (let [ch (read-char rdr)]\n    (if-not (nil? ch)\n      (let [token (if (or (macro-terminating? ch)\n                          (whitespace? ch))\n                    (str ch)\n                    (read-token rdr :character ch))\n            token-len (. token -length)]\n        (cond\n\n         (\x3d\x3d 1 token-len)  (.charAt token 0) ;;; no char type - so can\'t ensure/cache char\n\n         (\x3d token "newline") \\newline\n         (\x3d token "space") \\space\n         (\x3d token "tab") \\tab\n         (\x3d token "backspace") \\backspace\n         (\x3d token "formfeed") \\formfeed\n         (\x3d token "return") \\return\n\n         (gstring/startsWith token "u")\n         (let [c (read-unicode-char token 1 4 16)\n               ic (.charCodeAt c 0)]\n           (if (and (\x3e ic upper-limit)\n                    (\x3c ic lower-limit))\n             (err/throw-invalid-character-literal rdr (.toString ic 16))\n             c))\n\n         (gstring/startsWith token "o")\n         (let [len (dec token-len)]\n           (if (\x3e len 3)\n             (err/throw-invalid-octal-len rdr token)\n             (let [offset 1\n                   base 8\n                   uc (read-unicode-char token offset len base)]\n               (if-not (valid-octal? (subs token offset) base)\n                 (err/throw-bad-octal-number rdr)\n                 uc))))\n\n         :else (err/throw-unsupported-character rdr token)))\n      (err/throw-eof-in-character rdr))))\n\n(defn- starting-line-col-info [^not-native rdr]\n  (when (indexing-reader? rdr)\n    [(get-line-number rdr) (int (dec (get-column-number rdr)))]))\n\n(defn- ending-line-col-info [^not-native rdr]\n  (when (indexing-reader? rdr)\n    [(get-line-number rdr) (get-column-number rdr)]))\n\n(defonce ^:private READ_EOF (js/Object.))\n(defonce ^:private READ_FINISHED (js/Object.))\n\n(def ^:dynamic *read-delim* false)\n\n(defn- read-delimited-internal [kind delim rdr opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        delim (char delim)]\n    (loop [a (transient [])]\n      (let [form (read* rdr false READ_EOF delim opts pending-forms)]\n        (if (identical? form READ_FINISHED)\n          (persistent! a)\n          (if (identical? form READ_EOF)\n            (err/throw-eof-delimited rdr kind start-line start-column (count a))\n            (recur (conj! a form))))))))\n\n(defn- read-delimited\n  "Reads and returns a collection ended with delim"\n  [kind delim rdr opts pending-forms]\n  (binding [*read-delim* true]\n    (read-delimited-internal kind delim rdr opts pending-forms)))\n\n(defn- read-list\n  "Read in a list, including its location if the reader is an indexing reader"\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-list (read-delimited :list \\) rdr opts pending-forms)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta (if (empty? the-list)\n                 \'()\n                 (apply list the-list))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))\n\n(defn- read-vector\n  "Read in a vector, including its location if the reader is an indexing reader"\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-vector (read-delimited :vector \\] rdr opts pending-forms)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta the-vector\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))\n\n(defn- read-map\n  "Read in a map, including its location if the reader is an indexing reader"\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-map (read-delimited :map \\} rdr opts pending-forms)\n        map-count (count the-map)\n        ks (take-nth 2 the-map)\n        key-set (set ks)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (when (odd? map-count)\n      (err/throw-odd-map rdr start-line start-column the-map))\n    (when-not (\x3d (count key-set) (count ks))\n      (err/throw-dup-keys rdr :map ks))\n    (with-meta\n      (if (\x3c\x3d map-count (* 2 (.-HASHMAP-THRESHOLD cljs.core/PersistentArrayMap)))\n        (.fromArray cljs.core/PersistentArrayMap (to-array the-map) true true)\n        (.fromArray cljs.core/PersistentHashMap (to-array the-map) true))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))\n\n(defn- read-number\n  [^not-native rdr initch]\n  (loop [sb (doto (StringBuffer.) (.append initch))\n         ch (read-char rdr)]\n    (if (or (whitespace? ch) (macros ch) (nil? ch))\n      (let [s (str sb)]\n        (unread rdr ch)\n        (or (match-number s)\n            (err/throw-invalid-number rdr s)))\n      (recur (doto sb (.append ch)) (read-char rdr)))))\n\n(defn- escape-char [sb ^not-native rdr]\n  (let [ch (read-char rdr)]\n    (case ch\n      \\t "\\t"\n      \\r "\\r"\n      \\n "\\n"\n      \\\\ "\\\\"\n      \\" "\\""\n      \\b "\\b"\n      \\f "\\f"\n      \\u (let [ch (read-char rdr)]\n           (if (\x3d\x3d -1 (js/parseInt (int ch) 16))\n             (err/throw-invalid-unicode-escape rdr ch)\n             (read-unicode-char rdr ch 16 4 true)))\n      (if (numeric? ch)\n        (let [ch (read-unicode-char rdr ch 8 3 false)]\n          (if (\x3e (int ch) 0377)\n            (err/throw-bad-octal-number rdr)\n            ch))\n        (err/throw-bad-escape-char rdr ch)))))\n\n(defn- read-string*\n  [^not-native reader _ opts pending-forms]\n  (loop [sb (StringBuffer.)\n         ch (read-char reader)]\n    (if (nil? ch)\n      (err/throw-eof-reading reader :string \\" sb)\n      (case ch\n        \\\\ (recur (doto sb (.append (escape-char sb reader)))\n             (read-char reader))\n        \\" (str sb)\n        (recur (doto sb (.append ch)) (read-char reader))))))\n\n(defn- loc-info [rdr line column]\n  (when-not (nil? line)\n    (let [file (get-file-name rdr)\n          filem (when-not (nil? file) {:file file})\n          [end-line end-column] (ending-line-col-info rdr)\n          lcm {:line line\n               :column column\n               :end-line end-line\n               :end-column end-column}]\n      (merge filem lcm))))\n\n(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)\n        token (read-token rdr :symbol initch)]\n    (when-not (nil? token)\n      (case token\n\n        ;; special symbols\n        "nil" nil\n        "true" true\n        "false" false\n        "/" \'/\n\n        (let [^not-native p (parse-symbol token)]\n          (if-not (nil? p)\n            (let [^not-native sym (symbol (-nth p 0) (-nth p 1))]\n              (-with-meta sym (loc-info rdr line column)))\n            (err/throw-invalid rdr :symbol token)))))))\n\n(def ^:dynamic *alias-map*\n  "Map from ns alias to ns, if non-nil, it will be used to resolve read-time\n   ns aliases.\n\n   Defaults to nil"\n  nil)\n\n(defn- resolve-alias [sym]\n  (get *alias-map* sym))\n\n(defn- resolve-ns [sym]\n  (or (resolve-alias sym)\n      (when-let [ns (find-ns sym)]\n        (symbol (ns-name ns)))))\n\n(defn- read-keyword\n  [^not-native reader initch opts pending-forms]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader :keyword ch)\n            ^not-native s (parse-symbol token)]\n        (if-not (nil? s)\n          (let [ns (-nth s 0)\n                name (-nth s 1)]\n            (if (identical? \\: (.charAt token 0))\n              (if-not (nil? ns)\n                (if-let [ns (resolve-alias (symbol (subs ns 1)))]\n                  (keyword (str ns) name)\n                  (err/throw-invalid reader :keyword (str \\: token)))\n                (if-let [ns *ns*]\n                  (keyword (str ns) (subs name 1))\n                  (err/reader-error reader "Invalid token: :" token)))\n              (keyword ns name)))\n          (err/throw-invalid reader :keyword (str \\: token))))\n      (err/throw-single-colon reader))))\n\n(defn- wrapping-reader\n  "Returns a function which wraps a reader in a call to sym"\n  [sym]\n  (fn [rdr _ opts pending-forms]\n    (list sym (read* rdr true nil opts pending-forms))))\n\n(defn- read-meta\n  "Read metadata and return the following object with the metadata applied"\n  [rdr _ opts pending-forms]\n  (log-source rdr\n    (let [[line column] (starting-line-col-info rdr)\n          m (desugar-meta (read* rdr true nil opts pending-forms))]\n      (when-not (map? m)\n        (err/throw-bad-metadata rdr m))\n      (let [o (read* rdr true nil opts pending-forms)]\n        (if (implements? IMeta o)\n          (let [m (if (and line (seq? o))\n                    (assoc m :line line :column column)\n                    m)]\n            (if (implements? IWithMeta o)\n              (with-meta o (merge (meta o) m))\n              (reset-meta! o m)))\n          (err/throw-bad-metadata-target rdr o))))))\n\n(defn- read-set\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        ;; subtract 1 from start-column so it includes the # in the leading #{\n        start-column (if start-column (int (dec start-column)))\n        coll (read-delimited :set \\} rdr opts pending-forms)\n        the-set (set coll)\n        [end-line end-column] (ending-line-col-info rdr)]\n      (when-not (\x3d (count coll) (count the-set))\n        (err/reader-error rdr (err/throw-dup-keys rdr :set coll)))\n      (with-meta the-set\n        (when start-line\n          (merge\n           (when-let [file (get-file-name rdr)]\n             {:file file})\n           {:line start-line\n            :column start-column\n            :end-line end-line\n            :end-column end-column})))))\n\n(defn- read-discard\n  "Read and discard the first object from rdr"\n  [rdr _ opts pending-forms]\n  (doto rdr\n    (read* true nil opts pending-forms)))\n\n(defn- read-symbolic-value\n  [rdr _ opts pending-forms]\n  (let [sym (read* rdr true nil opts pending-forms)]\n    (case sym\n\n      NaN js/Number.NaN\n      -Inf js/Number.NEGATIVE_INFINITY\n      Inf js/Number.POSITIVE_INFINITY\n\n      (err/reader-error rdr (str "Invalid token: ##" sym)))))\n\n(def ^:private RESERVED_FEATURES #{:else :none})\n\n(defn- has-feature?\n  [rdr feature opts]\n  (if (keyword? feature)\n    (or (\x3d :default feature) (contains? (get opts :features) feature))\n    (err/reader-error rdr "Feature should be a keyword: " feature)))\n\n(defn- check-eof-error\n  [form rdr first-line]\n  (when (identical? form READ_EOF)\n    (err/throw-eof-error rdr (and (\x3c first-line 0) first-line))))\n\n(defn- check-reserved-features\n  [rdr form]\n  (when (get RESERVED_FEATURES form)\n    (err/reader-error rdr "Feature name " form " is reserved")))\n\n(defn- check-invalid-read-cond\n  [form rdr first-line]\n  (when (identical? form READ_FINISHED)\n    (if (\x3c first-line 0)\n      (err/reader-error rdr "read-cond requires an even number of forms")\n      (err/reader-error rdr "read-cond starting on line " first-line " requires an even number of forms"))))\n\n(defn- read-suppress\n  "Read next form and suppress. Return nil or READ_FINISHED."\n  [first-line rdr opts pending-forms]\n  (binding [*suppress-read* true]\n    (let [form (read* rdr false READ_EOF \\) opts pending-forms)]\n      (check-eof-error form rdr first-line)\n      (when (identical? form READ_FINISHED)\n        READ_FINISHED))))\n\n(defonce ^:private NO_MATCH (js/Object.))\n\n(defn- match-feature\n  "Read next feature. If matched, read next form and return.\n   Otherwise, read and skip next form, returning READ_FINISHED or nil."\n  [first-line rdr opts pending-forms]\n  (let [feature (read* rdr false READ_EOF \\) opts pending-forms)]\n    (check-eof-error feature rdr first-line)\n    (if (\x3d feature READ_FINISHED)\n      READ_FINISHED\n      (do\n        (check-reserved-features rdr feature)\n        (if (has-feature? rdr feature opts)\n          ;; feature matched, read selected form\n          (doto (read* rdr false READ_EOF \\) opts pending-forms)\n            (check-eof-error rdr first-line)\n            (check-invalid-read-cond rdr first-line))\n          ;; feature not matched, ignore next form\n          (or (read-suppress first-line rdr opts pending-forms)\n              NO_MATCH))))))\n\n(defn- read-cond-delimited\n  [rdr splicing opts pending-forms]\n  (let [first-line (if (indexing-reader? rdr) (get-line-number rdr) -1)\n        result (loop [matched NO_MATCH\n                      finished nil]\n                 (cond\n                  ;; still looking for match, read feature+form\n                  (identical? matched NO_MATCH)\n                  (let [match (match-feature first-line rdr opts pending-forms)]\n                    (if (identical? match READ_FINISHED)\n                      READ_FINISHED\n                      (recur match nil)))\n\n                  ;; found match, just read and ignore the rest\n                  (not (identical? finished READ_FINISHED))\n                  (recur matched (read-suppress first-line rdr opts pending-forms))\n\n                  :else\n                  matched))]\n    (if (identical? result READ_FINISHED)\n      rdr\n      (if splicing\n        (do\n          (if (implements? ISequential result)\n            (do\n              (garray/insertArrayAt pending-forms (to-array result) 0)\n              rdr)\n            (err/reader-error rdr "Spliced form list in read-cond-splicing must implement ISequential")))\n        result))))\n\n(defn- read-cond\n  [^not-native rdr _ opts pending-forms]\n  (when (not (and opts (#{:allow :preserve} (:read-cond opts))))\n    (throw (ex-info "Conditional read not allowed"\n                    {:type :runtime-exception})))\n  (if-let [ch (read-char rdr)]\n    (let [splicing (\x3d ch \\@)\n          ch (if splicing (read-char rdr) ch)]\n      (when splicing\n        (when-not *read-delim*\n          (err/reader-error rdr "cond-splice not in list")))\n      (if-let [ch (if (whitespace? ch) (read-past whitespace? rdr) ch)]\n        (if (not\x3d ch \\()\n          (throw (ex-info "read-cond body must be a list"\n                          {:type :runtime-exception}))\n          (binding [*suppress-read* (or *suppress-read* (\x3d :preserve (:read-cond opts)))]\n            (if *suppress-read*\n              (reader-conditional (read-list rdr ch opts pending-forms) splicing)\n              (read-cond-delimited rdr splicing opts pending-forms))))\n        (err/throw-eof-in-character rdr)))\n    (err/throw-eof-in-character rdr)))\n\n(def ^:private ^:dynamic arg-env nil)\n\n(defn- garg\n  "Get a symbol for an anonymous ?argument?"\n  [n]\n  (symbol (str (if (\x3d\x3d -1 n) "rest" (str "p" n))\n               "__" (next-id) "#")))\n\n(defn- read-fn\n  [rdr _ opts pending-forms]\n  (if arg-env\n    (throw (ex-info "Nested #()s are not allowed" {:type :illegal-state})))\n  (binding [arg-env (sorted-map)]\n    (let [form (read* (doto rdr (unread \\()) true nil opts pending-forms) ;; this sets bindings\n          rargs (rseq arg-env)\n          args (if rargs\n                 (let [higharg (key (first rargs))]\n                   (let [args (loop [i 1 args (transient [])]\n                                (if (\x3e i higharg)\n                                  (persistent! args)\n                                  (recur (inc i) (conj! args (or (get arg-env i)\n                                                                 (garg i))))))\n                         args (if (arg-env -1)\n                                (conj args \'\x26 (arg-env -1))\n                                args)]\n                     args))\n                 [])]\n      (list \'fn* args form))))\n\n(defn- register-arg\n  "Registers an argument to the arg-env"\n  [n]\n  (if arg-env\n    (if-let [ret (arg-env n)]\n      ret\n      (let [g (garg n)]\n        (set! arg-env (assoc arg-env n g))\n        g))\n    (throw (ex-info "Arg literal not in #()"\n                    {:type :illegal-state})))) ;; should never hit this\n\n(declare read-symbol)\n\n(defn- read-arg\n  [^not-native rdr pct opts pending-forms]\n  (if (nil? arg-env)\n    (read-symbol rdr pct)\n    (let [ch (peek-char rdr)]\n      (cond\n       (or (whitespace? ch)\n           (macro-terminating? ch)\n           (nil? ch))\n       (register-arg 1)\n\n       (\x3d ch \\\x26)\n       (do (read-char rdr)\n           (register-arg -1))\n\n       :else\n       (let [n (read* rdr true nil opts pending-forms)]\n         (if-not (integer? n)\n           (throw (ex-info "Arg literal must be %, %\x26 or %integer"\n                           {:type :illegal-state}))\n           (register-arg n)))))))\n\n(def ^:private ^:dynamic gensym-env nil)\n\n(defn- read-unquote\n  [^not-native rdr comma opts pending-forms]\n  (if-let [ch (peek-char rdr)]\n    (if (\x3d \\@ ch)\n      ((wrapping-reader \'clojure.core/unquote-splicing) (doto rdr read-char) \\@ opts pending-forms)\n      ((wrapping-reader \'clojure.core/unquote) rdr \\~ opts pending-forms))))\n\n(declare syntax-quote*)\n\n(defn- unquote-splicing? [form]\n  (and (seq? form)\n       (\x3d (first form) \'clojure.core/unquote-splicing)))\n\n(defn- unquote? [form]\n  (and (seq? form)\n       (\x3d (first form) \'clojure.core/unquote)))\n\n(defn- expand-list\n  "Expand a list by resolving its syntax quotes and unquotes"\n  [s]\n  (loop [s (seq s) r (transient [])]\n    (if s\n      (let [item (first s)\n            ret (conj! r\n                       (cond\n                        (unquote? item)          (list \'clojure.core/list (second item))\n                        (unquote-splicing? item) (second item)\n                        :else                    (list \'clojure.core/list (syntax-quote* item))))]\n        (recur (next s) ret))\n      (seq (persistent! r)))))\n\n(defn- flatten-map\n  "Flatten a map into a seq of alternate keys and values"\n  [form]\n  (loop [s (seq form) key-vals (transient [])]\n    (if s\n      (let [e (first s)]\n        (recur (next s) (-\x3e key-vals\n                          (conj! (key e))\n                          (conj! (val e)))))\n      (seq (persistent! key-vals)))))\n\n(defn- register-gensym [sym]\n  (if-not gensym-env\n    (throw (ex-info "Gensym literal not in syntax-quote"\n                    {:type :illegal-state})))\n  (or (get gensym-env sym)\n      (let [gs (symbol (str (subs (name sym)\n                                  0 (dec (count (name sym))))\n                            "__" (next-id) "__auto__"))]\n        (set! gensym-env (assoc gensym-env sym gs))\n        gs)))\n\n(defn- add-meta [form ret]\n  (if (and (implements? IWithMeta form)\n           (seq (dissoc (meta form) :line :column :end-line :end-column :file :source)))\n    (list \'cljs.core/with-meta ret (syntax-quote* (meta form)))\n    ret))\n\n(defn- syntax-quote-coll [type coll]\n  (let [res (list \'cljs.core/sequence\n                  (cons \'cljs.core/concat\n                        (expand-list coll)))]\n    (if type\n      (list \'cljs.core/apply type res)\n      res)))\n\n(defn map-func\n  "Decide which map type to use, array-map if less than 16 elements"\n  [coll]\n  (if (\x3e\x3d (count coll) 16)\n    \'cljs.core/hash-map\n    \'cljs.core/array-map))\n\n(defn bool? [x]\n  (or (instance? js/Boolean x)\n      (true? x)\n      (false? x)))\n\n(defn ^:dynamic resolve-symbol\n  "Resolve a symbol s into its fully qualified namespace version"\n  [s]\n  (throw (ex-info "resolve-symbol is not implemented" {:sym s})))\n\n(defn- syntax-quote* [form]\n  (-\x3e\x3e\n   (cond\n    (special-symbol? form) (list \'quote form)\n\n    (symbol? form)\n    (list \'quote\n          (if (and (not (namespace form))\n                   (gstring/endsWith (name form) "#"))\n            (register-gensym form)\n            (let [sym (str form)]\n              (if (gstring/endsWith sym ".")\n                (let [csym (symbol (subs sym 0 (dec (count sym))))]\n                  (symbol (str (resolve-symbol csym) ".")))\n                (resolve-symbol form)))))\n\n    (unquote? form) (second form)\n    (unquote-splicing? form) (throw (ex-info "unquote-splice not in list"\n                                             {:type :illegal-state}))\n\n    (coll? form)\n    (cond\n\n     (implements? IRecord form) form\n     (map? form) (syntax-quote-coll (map-func form) (flatten-map form))\n     (vector? form) (list \'cljs.core/vec (syntax-quote-coll nil form))\n     (set? form) (syntax-quote-coll \'cljs.core/hash-set form)\n     (or (seq? form) (list? form))\n     (let [seq (seq form)]\n       (if seq\n         (syntax-quote-coll nil seq)\n         \'(cljs.core/list)))\n\n     :else (throw (ex-info "Unknown Collection type"\n                           {:type :unsupported-operation})))\n\n    (or (keyword? form)\n        (number? form)\n        (string? form)\n        (nil? form)\n        (bool? form)\n        (instance? js/RegExp form))\n    form\n\n    :else (list \'quote form))\n   (add-meta form)))\n\n(defn- read-syntax-quote\n  [rdr backquote opts pending-forms]\n  (binding [gensym-env {}]\n    (-\x3e (read* rdr true nil opts pending-forms)\n      syntax-quote*)))\n\n(defn- read-namespaced-map\n  [rdr _ opts pending-forms]\n  (let [token (read-token rdr :namespaced-map (read-char rdr))]\n    (if-let [ns (cond\n                  (\x3d token ":")\n                  (ns-name *ns*)\n\n                  (\x3d \\: (first token))\n                  (some-\x3e token (subs 1) parse-symbol second\' symbol resolve-ns)\n\n                  :else\n                  (some-\x3e token parse-symbol second\'))]\n\n      (let [ch (read-past whitespace? rdr)]\n        (if (identical? ch \\{)\n          (let [items (read-delimited :namespaced-map \\} rdr opts pending-forms)]\n            (when (odd? (count items))\n              (err/throw-odd-map rdr nil nil items))\n            (let [keys (namespace-keys (str ns) (take-nth 2 items))\n                  vals (take-nth 2 (rest items))]\n              (when-not (\x3d (count (set keys)) (count keys))\n                (err/throw-dup-keys rdr :namespaced-map keys))\n              (zipmap keys vals)))\n              (err/throw-ns-map-no-map rdr token)))\n          (err/throw-bad-ns rdr token))))\n\n(defn- macros [ch]\n  (case ch\n    \\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\\' (wrapping-reader \'quote)\n    \\@ (wrapping-reader \'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))\n\n(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;; deprecated\n    \\\' (wrapping-reader \'var)\n    \\( read-fn\n    \\{ read-set\n    \\\x3c (throwing-reader "Unreadable form")\n    \\\x3d (throwing-reader "read-eval not supported")\n    \\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))\n\n(defn- read-tagged [^not-native rdr initch opts pending-forms]\n  (let [tag (read* rdr true nil opts pending-forms)]\n    (if-not (symbol? tag)\n      (err/throw-bad-reader-tag rdr tag))\n    (if *suppress-read*\n      (tagged-literal tag (read* rdr true nil opts pending-forms))\n      (if-let [f (or (*data-readers* tag)\n                     (default-data-readers tag))]\n        (f (read* rdr true nil opts pending-forms))\n        (if-let [f *default-data-reader-fn*]\n          (f tag (read* rdr true nil opts pending-forms))\n          (err/throw-unknown-reader-tag rdr tag))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Public API\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^:dynamic *data-readers*\n  "Map from reader tag symbols to data reader Vars.\n  Reader tags without namespace qualifiers are reserved for Clojure.\n  This light version of tools.reader has no implementation for default\n  reader tags such as #inst and #uuid."\n  {})\n\n(def ^:dynamic *default-data-reader-fn*\n  "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments, the tag and the value.\n  If *default-data-reader-fn* is nil (the default value), an exception\n  will be thrown for the unknown tag."\n  nil)\n\n(def ^:dynamic *suppress-read* false)\n\n(def default-data-readers\n  "Default map of data reader functions provided by Clojure.\n  May be overridden by binding *data-readers*"\n  {})\n\n(defn- read*-internal\n  [^not-native reader ^boolean eof-error? sentinel return-on opts pending-forms]\n  (loop []\n    (log-source reader\n      (if-not ^boolean (garray/isEmpty pending-forms)\n        (let [form (aget pending-forms 0)]\n          (garray/removeAt pending-forms 0)\n          form)\n        (let [ch (read-char reader)]\n          (cond\n            (whitespace? ch) (recur)\n            (nil? ch) (if eof-error? (err/throw-eof-error reader nil) sentinel)\n            (identical? ch return-on) READ_FINISHED\n            (number-literal? reader ch) (read-number reader ch)\n            :else (let [f (macros ch)]\n                    (if-not (nil? f)\n                      (let [res (f reader ch opts pending-forms)]\n                        (if (identical? res reader)\n                          (recur)\n                          res))\n                      (read-symbol reader ch)))))))))\n\n(defn- read*\n  ([reader eof-error? sentinel opts pending-forms]\n     (read* reader eof-error? sentinel nil opts pending-forms))\n  ([^not-native reader eof-error? sentinel return-on opts pending-forms]\n     (try\n       (read*-internal reader eof-error? sentinel return-on opts pending-forms)\n       (catch js/Error e\n         (if (ex-info? e)\n           (let [d (ex-data e)]\n             (if (\x3d :reader-exception (:type d))\n               (throw e)\n               (throw (ex-info (.-message e)\n                               (merge {:type :reader-exception}\n                                      d\n                                      (if (indexing-reader? reader)\n                                        {:line   (get-line-number reader)\n                                         :column (get-column-number reader)\n                                         :file   (get-file-name reader)}))\n                               e))))\n           (throw (ex-info (.-message e)\n                           (merge {:type :reader-exception}\n                                  (if (indexing-reader? reader)\n                                    {:line   (get-line-number reader)\n                                     :column (get-column-number reader)\n                                     :file   (get-file-name reader)}))\n                           e)))))))\n\n(defn read\n  "Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true.\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\n\n   Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n   To read data structures only, use clojure.tools.reader.edn/read\n\n   Note that the function signature of clojure.tools.reader/read and\n   clojure.tools.reader.edn/read is not the same for eof-handling"\n  {:arglists \'([reader] [opts reader] [reader eof-error? eof-value])}\n  ([reader] (read reader true nil))\n  ([{eof :eof :as opts :or {eof :eofthrow}} reader] (read* reader (\x3d eof :eofthrow) eof nil opts (to-array [])))\n  ([reader eof-error? sentinel] (read* reader eof-error? sentinel nil {} (to-array []))))\n\n(defn read-string\n  "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   To read data structures only, use clojure.tools.reader.edn/read-string\n\n   Note that the function signature of clojure.tools.reader/read-string and\n   clojure.tools.reader.edn/read-string is not the same for eof-handling"\n  ([s]\n     (read-string {} s))\n  ([opts s]\n     (when (and s (not (identical? s "")))\n       (read opts (string-push-back-reader s)))))\n\n(defn read+string\n  "Like read, and taking the same args. reader must be a SourceLoggingPushbackReader.\n  Returns a vector containing the object read and the (whitespace-trimmed) string read."\n  ([reader \x26 args]\n   (let [buf (fn [reader] (str (:buffer @(.-frames reader))))\n         offset (count (buf reader))\n         o (log-source reader (if (\x3d 1 (count args))\n                                (read (first args) reader)\n                                (apply read reader args)))\n         s (.trim (subs (buf reader) offset))]\n     [o s])))\n'],
null),new p(null,3,[Cl,"clojure/reflect.cljs",Xn,"clojure.reflect",nr,'(ns clojure.reflect\n  ^{:doc "DEPRECATED. Do not use, superceded by REPL enhancements."}\n  (:refer-clojure :exclude [meta macroexpand])\n  (:require [clojure.browser.net :as net]\n            [clojure.browser.event :as event]))\n\n(defn- evaluate-javascript [block]\n  (let [result (try (js* "eval(~{block})")\n                    (catch :default e\n                      (.log js/console e)))]\n    result))\n\n(defn- query-reflection\n  "Issues a GET to /reflect with a single query-parameter string.\n  Calls cb with the result."\n  [query-param cb]\n  (let [conn (net/xhr-connection)\n        url  (str "/reflect?" query-param)]\n    (event/listen conn :success (fn [e]\n                                  (let [resp (.getResponseText (.-currentTarget e) ())]\n                                    (cb resp))))\n    (event/listen conn :error #(println "Reflection query failed."))\n    (net/transmit conn url)))\n\n(defn meta\n  "Queries the reflection api with a fully qualified symbol, then calls\n  callback fn cb with the evaluated cljs map containing that symbol\'s\n  meta information."\n  [sym cb]\n  (query-reflection (str "var\x3d" (js/encodeURIComponent (str sym)))\n                    #(cb (evaluate-javascript %))))\n\n(defn macroexpand\n  "Queries the reflection api with a quoted macro form, then calls the\n  callback function with the macroexpanded form, as a string."\n  [form]\n  (query-reflection (str "macroform\x3d" (js/encodeURIComponent (str form))) println))\n\n(defn print-doc [{:keys [name method-params doc]}]\n  (when-not (empty? name)\n    (println name)\n    (println method-params)\n    (println doc)))\n\n(defn doc\n  "Queries the reflection api with a fully qualified symbol, then prints\n  documentation information at the repl."\n  [sym]\n  (meta sym print-doc))\n'],
null),new p(null,3,[Cl,"cljs/reader.clj",Xn,"cljs.reader",nr,";; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.reader\n  (:require [cljs.env :as env]))\n\n(defmacro add-data-readers [default-readers]\n  (let [data-readers\n        (-\x3e\x3e (get @env/*compiler* :cljs.analyzer/data-readers)\n          (map (fn [[k v]]\n                 `['~k (fn [x#] (~(vary-meta v assoc :cljs.analyzer/no-resolve true) x#))]))\n          (into {}))]\n    `(do (merge ~default-readers ~data-readers))))\n"],
null),new p(null,3,[Cl,"cljs/spec/alpha.cljc",Xn,"cljs.spec.alpha",nr,";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.alpha\n  (:refer-clojure :exclude [+ * and or cat def keys merge resolve assert])\n  (:require [cljs.core :as c]\n            [cljs.analyzer :as ana]\n            [cljs.env :as env]\n            [cljs.analyzer.api :refer [resolve]]\n            [clojure.walk :as walk]\n            [cljs.spec.gen.alpha :as gen]\n            [clojure.string :as str]))\n\n(defonce registry-ref (atom {}))\n\n(defn- -\x3esym\n  \"Returns a symbol from a symbol or var\"\n  [x]\n  (if (map? x)\n    (:name x)\n    x))\n\n(defn- unfn [expr]\n  (if (clojure.core/and (seq? expr)\n             (symbol? (first expr))\n             (\x3d \"fn*\" (name (first expr))))\n    (let [[[s] \x26 form] (rest expr)]\n      (conj (walk/postwalk-replace {s '%} form) '[%] 'cljs.core/fn))\n    expr))\n\n(defn- res [env form]\n  (cond\n    (keyword? form) form\n    (symbol? form) #?(:clj  (clojure.core/or (-\x3e\x3e form (resolve env) -\x3esym) form)\n                      :cljs (let [resolved (clojure.core/or (-\x3e\x3e form (resolve env) -\x3esym) form)\n                                  ns-name (namespace resolved)]\n                              (symbol\n                                (if (clojure.core/and ns-name (str/ends-with? ns-name \"$macros\"))\n                                  (subs ns-name 0 (- (count ns-name) 7))\n                                  ns-name)\n                                (name resolved))))\n    (sequential? form) (walk/postwalk #(if (symbol? %) (res env %) %) (unfn form))\n    :else form))\n\n(defmacro ^:private mres\n  \"a compile time res, for use in cljs/spec/alpha.cljs\"\n  [form]\n  (res \x26env form))\n\n(defn- ns-qualify\n  \"Qualify symbol s by resolving it or using the current *ns*.\"\n  [env s]\n  (if (namespace s)\n    (-\x3esym (binding [ana/*private-var-access-nowarn* true]\n             (ana/resolve-var env s)))\n    (symbol (str ana/*cljs-ns*) (str s))))\n\n(defmacro def\n  \"Given a namespace-qualified keyword or resolveable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec. Use nil to remove an entry in\n  the registry for k.\"\n  [k spec-form]\n  (let [k    (if (symbol? k) (ns-qualify \x26env k) k)\n        form (res \x26env spec-form)]\n    (swap! registry-ref (fn [r]\n                          (if (nil? form)\n                            (dissoc r k)\n                            (assoc r k form))))\n    `(def-impl '~k '~form ~spec-form)))\n\n(defmacro spec\n  \"Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(\x3c % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.\"\n  [form \x26 {:keys [gen]}]\n  (when form\n    `(spec-impl '~(res \x26env form) ~form ~gen nil)))\n\n(defmacro multi-spec\n  \"Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n\"\n  [mm retag]\n  `(multi-spec-impl '~(res \x26env mm) (var ~mm) ~retag))\n\n(defmacro keys\n  \"Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y\n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\"\n  [\x26 {:keys [req req-un opt opt-un gen]}]\n  (let [unk #(-\x3e % name keyword)\n        req-keys (filterv keyword? (flatten req))\n        req-un-specs (filterv keyword? (flatten req-un))\n        _ (clojure.core/assert (every? #(clojure.core/and (keyword? %) (namespace %)) (concat req-keys req-un-specs opt opt-un))\n                  \"all keys must be namespace-qualified keywords\")\n        req-specs (into req-keys req-un-specs)\n        req-keys (into req-keys (map unk req-un-specs))\n        opt-keys (into (vec opt) (map unk opt-un))\n        opt-specs (into (vec opt) opt-un)\n        gx (gensym)\n        parse-req (fn [rk f]\n                    (map (fn [x]\n                           (if (keyword? x)\n                             `(contains? ~gx ~(f x))\n                             (walk/postwalk\n                               (fn [y] (if (keyword? y) `(contains? ~gx ~(f y)) y))\n                               x)))\n                         rk))\n        pred-exprs [`(map? ~gx)]\n        pred-exprs (into pred-exprs (parse-req req identity))\n        pred-exprs (into pred-exprs (parse-req req-un unk))\n        keys-pred `(fn* [~gx] (c/and ~@pred-exprs))\n        pred-exprs (mapv (fn [e] `(fn* [~gx] ~e)) pred-exprs)\n        pred-forms (walk/postwalk #(res \x26env %) pred-exprs)]\n    ;; `(map-spec-impl ~req-keys '~req ~opt '~pred-forms ~pred-exprs ~gen)\n    `(map-spec-impl {:req '~req :opt '~opt :req-un '~req-un :opt-un '~opt-un\n                     :req-keys '~req-keys :req-specs '~req-specs\n                     :opt-keys '~opt-keys :opt-specs '~opt-specs\n                     :pred-forms '~pred-forms\n                     :pred-exprs ~pred-exprs\n                     :keys-pred ~keys-pred\n                     :gfn ~gen})))\n\n(defmacro or\n  \"Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(\x3c % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.\"\n  [\x26 key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res \x26env %) pred-forms)]\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"spec/or expects k1 p1 k2 p2..., where ks are keywords\")\n    `(or-spec-impl ~keys '~pf ~pred-forms nil)))\n\n(defmacro and\n  \"Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(\x3c % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.\"\n  [\x26 pred-forms]\n  `(and-spec-impl '~(mapv #(res \x26env %) pred-forms) ~(vec pred-forms) nil))\n\n(defn- res-kind\n  [env opts]\n  (let [{kind :kind :as mopts} opts]\n    (-\x3e\x3e\n      (if kind\n        (assoc mopts :kind `~(res env kind))\n        mopts)\n      (mapcat identity))))\n\n(defmacro every\n  \"takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred that the collection type must satisfy, e.g. vector?\n          (default nil) Note that if :kind is specified and :into is\n          not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (\x3c\x3d min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default same as :kind if supplied, else []\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n\"\n  [pred \x26 {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]\n  (let [desc (::describe opts)\n        nopts (-\x3e opts\n                (dissoc :gen ::describe)\n                (assoc ::kind-form `'~(res \x26env (:kind opts))\n                       ::describe (clojure.core/or desc `'(every ~(res \x26env pred) ~@(res-kind \x26env opts)))))\n        gx (gensym)\n        cpreds (cond-\x3e [(list (clojure.core/or kind `coll?) gx)]\n                 count (conj `(\x3d ~count (c/bounded-count ~count ~gx)))\n\n                 (clojure.core/or min-count max-count)\n                 (conj `(\x3c\x3d (c/or ~min-count 0)\n                          (c/bounded-count (if ~max-count (inc ~max-count) ~min-count) ~gx)\n                          (c/or ~max-count MAX_INT)))\n\n                 distinct\n                 (conj `(c/or (empty? ~gx) (apply distinct? ~gx))))]\n    `(every-impl '~pred ~pred ~(assoc nopts ::cpred `(fn* [~gx] (c/and ~@cpreds))) ~gen)))\n\n(defmacro every-kv\n  \"like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of\"\n\n  [kpred vpred \x26 opts]\n  (let [desc `(every-kv ~(res \x26env kpred) ~(res \x26env vpred) ~@(res-kind \x26env opts))]\n    `(every (tuple ~kpred ~vpred) ::kfn (fn [i# v#] (nth v# 0)) :into {} ::describe '~desc ~@opts)))\n\n(defmacro coll-of\n  \"Returns a spec for a collection of items satisfying pred. Unlike\n  generator will fill an empty init-coll.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  Same options as 'every'.\n\n  See also - every, map-of\"\n  [pred \x26 opts]\n  (let [desc `(coll-of ~(res \x26env pred) ~@(res-kind \x26env opts))]\n    `(every ~pred ::conform-all true ::describe '~desc ~@opts)))\n\n(defmacro map-of\n  \"Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv\"\n  [kpred vpred \x26 opts]\n  (let [desc `(map-of ~(res \x26env kpred) ~(res \x26env vpred) ~@(res-kind \x26env opts))]\n    `(every-kv ~kpred ~vpred ::conform-all true :kind map? ::describe '~desc ~@opts)))\n\n(defmacro *\n  \"Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match\"\n  [pred-form]\n  `(rep-impl '~(res \x26env pred-form) ~pred-form))\n\n(defmacro +\n  \"Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches\"\n  [pred-form]\n  `(rep+impl '~(res \x26env pred-form) ~pred-form))\n\n(defmacro ?\n  \"Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.\"\n  [pred-form]\n  `(maybe-impl ~pred-form '~(res \x26env pred-form)))\n\n(defmacro alt\n  \"Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(\x3c % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.\"\n  [\x26 key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res \x26env %) pred-forms)]\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"alt expects k1 p1 k2 p2..., where ks are keywords\")\n    `(alt-impl ~keys ~pred-forms '~pf)))\n\n(defmacro cat\n  \"Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.\"\n  [\x26 key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res \x26env %) pred-forms)]\n    ;;(prn key-pred-forms)\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"cat expects k1 p1 k2 p2..., where ks are keywords\")\n    `(cat-impl ~keys ~pred-forms '~pf)))\n\n(defmacro \x26\n  \"takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.\"\n  [re \x26 preds]\n  (let [pv (vec preds)]\n    `(amp-impl ~re '~(res \x26env re) ~pv '~(mapv #(res \x26env %) pv))))\n\n(defmacro conformer\n  \"takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :cljs.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first\"\n  ([f] `(spec-impl '(conformer ~(res \x26env f)) ~f nil true))\n  ([f unf] `(spec-impl '(conformer ~(res \x26env f) ~(res \x26env unf)) ~f nil true ~unf)))\n\n(defmacro fspec\n  \"takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.\"\n  [\x26 {:keys [args ret fn gen] :or {ret `cljs.core/any?}}]\n  (let [env \x26env]\n    `(fspec-impl (spec ~args) '~(res env args)\n                           (spec ~ret) '~(res env ret)\n                           (spec ~fn) '~(res env fn) ~gen)))\n\n(defmacro tuple\n  \"takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.\"\n  [\x26 preds]\n  (clojure.core/assert (not (empty? preds)))\n  `(tuple-impl '~(mapv #(res \x26env %) preds) ~(vec preds)))\n\n(defonce ^:private _speced_vars (atom #{}))\n\n(defn speced-vars []\n  @_speced_vars)\n\n(defmacro fdef\n  \"Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner cljs.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef cljs.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)\"\n  [fn-sym \x26 specs]\n  (swap! _speced_vars conj\n    (vary-meta (ns-qualify \x26env fn-sym)\n      assoc :fdef-ns (-\x3e \x26env :ns :name)))\n  `(cljs.spec.alpha/def ~fn-sym (fspec ~@specs)))\n\n(defmacro keys*\n  \"takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user\x3d\x3e (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user\x3d\x3e (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user\x3d\x3e (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}\"\n  [\x26 kspecs]\n  `(let [mspec# (keys ~@kspecs)]\n     (with-gen (cljs.spec.alpha/\x26 (* (cat ::k keyword? ::v cljs.core/any?)) ::kvs-\x3emap mspec#)\n       (fn [] (gen/fmap (fn [m#] (apply concat m#)) (gen mspec#))))))\n\n(defmacro nilable\n  \"returns a spec that accepts nil and values satisfiying pred\"\n  [pred]\n  (let [pf (res \x26env pred)]\n    `(nilable-impl '~pf ~pred nil)))\n\n(defmacro inst-in\n  \"Returns a spec that validates insts in the range from start\n  (inclusive) to end (exclusive).\"\n  [start end]\n  `(let [st# (cljs.core/inst-ms ~start)\n         et# (cljs.core/inst-ms ~end)\n         mkdate# (fn [d#] (js/Date. d#))]\n     (spec (and cljs.core/inst? #(inst-in-range? ~start ~end %))\n       :gen (fn []\n              (gen/fmap mkdate#\n                (gen/large-integer* {:min st# :max et#}))))))\n\n(defmacro int-in\n  \"Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).\"\n  [start end]\n  `(spec (and c/int? #(int-in-range? ~start ~end %))\n     :gen #(gen/large-integer* {:min ~start :max (dec ~end)})))\n\n(defmacro double-in\n  \"Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\"\n  [\x26 {:keys [infinite? NaN? min max]\n      :or {infinite? true NaN? true}\n      :as m}]\n  `(spec (and c/double?\n           ~@(when-not infinite? '[#(not (infinite? %))])\n           ~@(when-not NaN? '[#(not (js/isNaN %))])\n           ~@(when max `[#(\x3c\x3d % ~max)])\n           ~@(when min `[#(\x3c\x3d ~min %)]))\n     :gen #(gen/double* ~m)))\n\n(defmacro merge\n  \"Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Successive conformed values propagate through rest of\n  predicates. Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.\"\n  [\x26 pred-forms]\n  `(merge-spec-impl '~(mapv #(res \x26env %) pred-forms) ~(vec pred-forms) nil))\n\n(defmacro exercise-fn\n  \"exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. \"\n  ([sym]\n   `(exercise-fn ~sym 10))\n  ([sym n]\n   `(exercise-fn ~sym ~n nil))\n  ([sym n fspec]\n   (let [sym (cond-\x3e sym\n               (clojure.core/and (sequential? sym)\n                                 (\x3d (first sym) 'quote))\n               second)]\n     `(let [fspec# ~(if-not fspec\n                      `(get-spec '~(:name (resolve \x26env sym)))\n                      fspec)\n            f#     ~sym]\n        (if-let [arg-spec# (c/and fspec# (:args fspec#))]\n          (for [args# (gen/sample (gen arg-spec#) ~n)]\n            [args# (apply f# args#)])\n          (throw (js/Error. \"No :args spec found, can't generate\")))))))\n\n(defmacro ^:private init-compile-asserts []\n  (let [compile-asserts (not (-\x3e env/*compiler* deref :options :elide-asserts))]\n    compile-asserts))\n\n(defmacro assert\n  \"spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).\"\n  [spec x]\n  `(if *compile-asserts*\n     (if @#'*runtime-asserts*\n       (assert* ~spec ~x)\n       ~x)\n    ~x))\n"],
null)]),xG=function xG(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return xG.l(0<c.length?new D(c.slice(0),0,null):null)};xG.l=function(a){throw ii("Unsupported",new p(null,2,[Gn,"REPLETE_REQUEST",yi,a],null));};xG.D=0;xG.C=function(a){return this.l(B(a))};aa.ae=function(a){return nr.h(A.c(wG,a))};aa.de=function(a){a:{a=(new Date).getTime()+a;for(var b=(new Date).getTime();;){if(b>a)break a;b=(new Date).getTime()}}return null};
aa.be=function(a,b){throw ii("Unsupported",new p(null,3,[Gn,"REPLETE_LOAD_FROM_JAR",Xx,a,Jw,b],null));};aa.ce=xG;var yG={},zG={},AG={},BG=/[\s]/;function CG(a){return null==a?null:","===a?!0:BG.test(a)}function DG(a){return null==a?null:!/[^0-9]/.test(a)}
function EG(a,b){return function e(b){return new Be(null,function(){for(;;){var d=B(b);if(d){if(Td(d)){var h=wc(d),l=K(h),m=Fe(l);return function(){for(var b=0;;)if(b<l){var d=zb.c(h,b),e=m;if(d instanceof Sc||d instanceof q){var g=th();var n=g.h?g.h(d):g.call(null,d);g=M(n,0,null);n=M(n,1,null);var C=d instanceof Sc?Tc:ze;d=null==g?C.c?C.c(a,n):C.call(null,a,n):H.c("_",g)?C.h?C.h(n):C.call(null,n):d}e.add(d);b+=1}else return!0}()?He(m.ka(),e(xc(d))):He(m.ka(),null)}var n=E(d);return ud(n instanceof
Sc||n instanceof q?function(){var b=th();var d=b.h?b.h(n):b.call(null,n);b=M(d,0,null);d=M(d,1,null);var e=n instanceof Sc?Tc:ze;return null==b?e.c?e.c(a,d):e.call(null,a,d):H.c("_",b)?e.h?e.h(d):e.call(null,d):n}():n,e(Vc(d)))}return null}},null,null)}(b)}function FG(a,b){a=parseInt(a,b);return t(isNaN(a))?-1:a};var GG=function GG(a){if(null!=a&&null!=a.yb)return a.yb(a);var c=GG[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=GG._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("Reader.read-char",a);},HG=function HG(a){if(null!=a&&null!=a.Zb)return a.Zb(a);var c=HG[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=HG._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("Reader.peek-char",a);},IG=function IG(a,b){if(null!=a&&null!=a.Xc)return a.Xc(a,b);var d=IG[da(null==
a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=IG._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("IPushbackReader.unread",a);},JG=function JG(a){if(null!=a&&null!=a.Dd)return a.Dd(a);var c=JG[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=JG._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IndexingReader.get-line-number",a);},KG=function KG(a){if(null!=a&&null!=a.Bd)return a.Bd(a);var c=KG[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,
a);c=KG._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IndexingReader.get-column-number",a);},LG=function LG(a){if(null!=a&&null!=a.Cd)return a.Cd(a);var c=LG[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=LG._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("IndexingReader.get-file-name",a);};function MG(a,b){this.s=a;this.gd=b;this.Qb=0}MG.prototype.yb=function(){if(this.gd>this.Qb){var a=this.s.charAt(this.Qb);this.Qb+=1;return a}return null};
MG.prototype.Zb=function(){return this.gd>this.Qb?this.s.charAt(this.Qb):null};function NG(a,b){this.cd=a;this.ub=b;this.Va=this.Cc=1}NG.prototype.yb=function(){var a=this.Va<this.Cc?this.ub[this.Va]:this.cd.yb(null);this.Va<this.Cc&&(this.Va+=1);return null==a?null:pe(a)};NG.prototype.Zb=function(){var a=this.Va<this.Cc?this.ub[this.Va]:this.cd.Zb(null);return null==a?null:pe(a)};
NG.prototype.Xc=function(a,b){if(t(b)){if(0===this.Va)throw Error("Pushback buffer is full");--this.Va;return this.ub[this.Va]=b}return null};function OG(a){return null!=a?k===a.Fe?!0:!1:!1};var PG={};function QG(a,b,c,d){var e=K(b);a=t(a)?0:10<e?10:e;b=qf.c(gf.c(fi,!0),rf(a,b));b=N.c(u,xf(" ",b));e=a<e?"...":null;return[u.h(c),u.h(b),e,u.h(d)].join("")}function bi(a,b){return null==b?Qw:"string"===typeof b?Fr:b instanceof q?os:"number"===typeof b?os:b instanceof Sc?os:Sd(b)?Kr:se(b)?Av:Qd(b)?jC:Od(b)?bA:H.c(b,!0)?os:H.c(b,!1)?os:hb(b)}
if("undefined"===typeof Qa||"undefined"===typeof yG||"undefined"===typeof zG||"undefined"===typeof AG||"undefined"===typeof PG||"undefined"===typeof fi){var fi,Yh=nf(Xe),Zh=nf(Xe),$h=nf(Xe),ai=nf(Xe),Xh=A.j(Xe,KA,Oh.B?Oh.B():Oh.call(null));fi=new Wh}ei(Fr,function(a,b){a=t(a)?5:20;var c=b.length>a?'..."':'"',d=b.length;return['"',u.h(b.substring(0,a<d?a:d)),c].join("")});ei(os,function(a,b){return u.h(b)});ei(D,function(){return"\x3cindexed seq\x3e"});ei(vg,function(){return"\x3cmap seq\x3e"});
ei(Rg,function(){return"\x3cmap seq\x3e"});ei(we,function(){return"\x3ccons\x3e"});ei(Be,function(){return"\x3clazy seq\x3e"});ei(Qw,function(){return"nil"});ei(Av,function(a,b){return QG(a,b,"(",")")});ei(jC,function(a,b){var c=K(b),d=t(a)?0:c;b=N.c(Me,rf(d,b));return QG(a,b,"{",c>d?"...}":"}")});ei(bA,function(a,b){return QG(a,b,"#{","}")});ei(Kr,function(a,b){return QG(a,b,"[","]")});ei(ci,function(a,b){return Gh(L([hb(b)]))});function RG(a){return fi.c?fi.c(!1,a):fi.call(null,!1,a)};function SG(a,b,c){b=new p(null,2,[U,wm,dj,b],null);a=OG(a)?Dd.l(b,kp,LG(a),L([tv,JG(a),lw,KG(a)])):b;var d=kp.h(a);b=tv.h(a);var e=lw.h(a);d=t(d)?[u.h(d)," "].join(""):null;b=t(b)?["[line ",u.h(b),", col ",u.h(e),"]"].join(""):null;c=N.J(u,d,b,t(t(d)?d:b)?" ":null,c);throw ii(c,a);}function TG(a,b){return SG(a,Gj,L([N.c(u,b)]))}function UG(a,b){return SG(a,Tr,L([N.c(u,b)]))}function VG(a,b){return SG(a,FA,L([N.c(u,b)]))}
function WG(a,b,c,d){TG(a,L(["The map literal starting with ",RG(E(d)),t(b)?[" on line ",u.h(b)," column ",u.h(c)].join(""):null," contains ",K(d)," form(s). Map literals must contain an even number of forms."]))}function XG(a,b,c){return TG(a,L(["Invalid ",Ae(b),": ",c,"."]))}function YG(a,b,c){return TG(a,L(["Invalid character: ",c," found while reading ",Ae(b),"."]))}
function ZG(a,b){a:{var c=Fr instanceof q?Fr.U:null;switch(c){case "regex":c='#"';break a;case "string":c='"';break a;default:throw Error(["No matching clause: ",u.h(c)].join(""));}}return VG(a,L(["Unexpected EOF reading ",Ae(Fr)," starting ",N.j(u,c,b),"."]))}function $G(a,b){return UG(a,L(["Invalid digit ",b," in unicode character."]))}function aH(a){return TG(a,L(["Octal escape sequence must be in range [0, 377]."]))}
function bH(a,b){b=function(a){return function g(a){return new Be(null,function(){for(var b=a;;)if(b=B(b)){if(Td(b)){var c=wc(b),e=K(c),n=Fe(e);a:for(var r=0;;)if(r<e){var v=zb.c(c,r),x=M(v,0,null);1<M(v,1,null)&&n.add(x);r+=1}else{c=!0;break a}return c?He(n.ka(),g(xc(b))):He(n.ka(),null)}n=E(b);c=M(n,0,null);if(1<M(n,1,null))return ud(c,g(Vc(b)));b=Vc(b)}else return null},null,null)}(sh(a))}(b);return N.J(u,a,1<K(b)?"s":null,": ",xf(", ",b))}
function cH(a,b,c){TG(a,L([bH([u.h(ta(Ae(b)))," literal contains duplicate key"].join(""),c)]))};function dH(a){for(var b=a.yb(null);;)if(CG.h?CG.h(b):CG.call(null,b))b=a.yb(null);else return b}var eH=/^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$/,fH=/([-+]?[0-9]+)\/([0-9]+)/,gH=/([-+]?[0-9]+(\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?/;function hH(a,b){a=wh(a,b);return M(a,0,null)===b}
function iH(a){if(hH(eH,a)){var b=bg(wh(eH,a));if(null!=(b.h?b.h(2):b.call(null,2)))a=0;else{a="-"===(b.h?b.h(1):b.call(null,1));b=null!=(b.h?b.h(3):b.call(null,3))?new O(null,2,5,P,[b.h?b.h(3):b.call(null,3),10],null):null!=(b.h?b.h(4):b.call(null,4))?new O(null,2,5,P,[b.h?b.h(4):b.call(null,4),16],null):null!=(b.h?b.h(5):b.call(null,5))?new O(null,2,5,P,[b.h?b.h(5):b.call(null,5),8],null):null!=(b.h?b.h(7):b.call(null,7))?new O(null,2,5,P,[b.h?b.h(7):b.call(null,7),parseInt(b.h?b.h(6):b.call(null,
6))],null):new O(null,2,5,P,[null,null],null);var c=b.h?b.h(0):b.call(null,0);null==c?a=null:(b=parseInt(c,b.h?b.h(1):b.call(null,1)),a=a?-1*b:b,a=t(isNaN(a))?null:a)}}else hH(gH,a)?(b=bg(wh(gH,a)),a=null!=(b.h?b.h(4):b.call(null,4))?parseFloat(b.h?b.h(1):b.call(null,1)):parseFloat(a)):hH(fH,a)?(b=bg(wh(fH,a)),a=b.h?b.h(1):b.call(null,1),b=b.h?b.h(2):b.call(null,2),a=t(wh(/^\+/,a))?a.substring(1):a,a=parseInt(a)/parseInt(b)):a=null;return a}
function jH(a){if(""===a||!0===/:$/.test(a)||!0===/^::/.test(a))return null;var b=a.indexOf("/"),c=0<b?a.substring(0,b):null;if(null!=c){b+=1;if(b===K(a))return null;a=a.substring(b);return DG(pd(a,0))||""===a||!1!==/:$/.test(c)||"/"!==a&&-1!==a.indexOf("/")?null:new O(null,2,5,P,[c,a],null)}return"/"===a||-1===a.indexOf("/")?new O(null,2,5,P,[null,a],null):null}
var kH=function kH(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return kH.l(arguments[0],1<c.length?new D(c.slice(1),0,null):null)};kH.l=function(a){for(;;){var b=a.yb(null);if("\n"===b||"\n"===b||null==b)break}return a};kH.D=1;kH.C=function(a){var b=E(a);a=G(a);return this.l(b,a)};
function lH(){return function(){function a(a,d){var c=null;if(1<arguments.length){c=0;for(var g=Array(arguments.length-1);c<g.length;)g[c]=arguments[c+1],++c;c=new D(g,0,null)}return b.call(this,a,c)}function b(a){return TG(a,L(["Unreadable form"]))}a.D=1;a.C=function(a){var c=E(a);a=Vc(a);return b(c,a)};a.l=b;return a}()};new Pa;if("undefined"===typeof Qa||"undefined"===typeof yG||"undefined"===typeof zG||"undefined"===typeof mH)var mH={};if("undefined"===typeof Qa||"undefined"===typeof yG||"undefined"===typeof zG||"undefined"===typeof nH)var nH={};if("undefined"===typeof Qa||"undefined"===typeof yG||"undefined"===typeof zG||"undefined"===typeof oH)var oH={};function pH(a){var b="#"!==a;return b&&(b="'"!==a)?(b=":"!==a)?qH.h?qH.h(a):qH.call(null,a):b:b}function rH(a){return"@"===a||"`"===a||"~"===a}function sH(a,b,c,d){if(eb(c))return VG(a,L(["Unexpected EOF while reading start of ",Ae(b),"."]));if(t(t(d)?rH(c):d))return YG(a,b,c);d=new Pa;for(IG(a,c);;){if(CG(c)||pH(c)||null==c)return u.h(d);if(rH(c))return YG(a,b,c);d.append(GG(a));c=HG(a)}}
function tH(a,b,c){b=GG(a);if(t(b)){var d=uH.h?uH.h(b):uH.call(null,b);if(t(d))return d.j?d.j(a,b,c):d.call(null,a,b,c);IG(a,b);c=vH.j?vH.j(a,b,c):vH.call(null,a,b,c);return t(c)?c:TG(a,L(["No dispatch macro for ",b,"."]))}return VG(a,L(["Unexpected EOF while reading dispatch character."]))}function wH(a,b){return TG(a,L(["Unmatched delimiter ",b,"."]))}
function xH(a,b,c){b=1+b;if(K(a)!==b)throw UG(null,L(["Invalid unicode literal: \\",a,"."]));for(var d=1,e=0;;){if(d===b)return String.fromCharCode(e);var g=FG(pd(a,d),c);if(-1===g)return c=pd(a,d),UG(null,L(["Invalid digit ",c," in unicode character \\",a,"."]));e=g+e*c;d+=1}}
function yH(a,b,c,d,e){for(var g=1,h=FG(b,c);;){if(-1===h)return $G(a,b);if(g!==d){var l=HG(a);var m=CG(l);m||(m=qH.h?qH.h(l):qH.call(null,l),m=t(m)?m:null==l);if(t(m))return t(e)?UG(a,L(["Invalid unicode literal. Unicode literals should be ",d,"characters long.  ","value suppled is ",g,"characters long."])):String.fromCharCode(h);m=FG(l,c);GG(a);if(-1===m)return $G(a,l);h=m+h*c;g+=1}else return String.fromCharCode(h)}}
function zH(a){var b=GG(a);if(null!=b){b=pH(b)||rH(b)||CG(b)?u.h(b):sH(a,gC,b,!1);var c=K(b);if(1===c)return pd(b,0);if("newline"===b)return"\n";if("space"===b)return" ";if("tab"===b)return"\t";if("backspace"===b)return"\b";if("formfeed"===b)return"\f";if("return"===b)return"\r";if(t(0==b.lastIndexOf("u",0)))return b=xH(b,4,16),c=b.charCodeAt(),55295<c&&57344>c?(b=c.toString(16),a=TG(a,L(["Invalid character literal \\u",b,"."]))):a=b,a;if(t(0==b.lastIndexOf("o",0))){--c;if(3<c)return TG(a,L(["Invalid octal escape sequence in a character literal:",
b,". Octal escape sequences must be 3 or fewer digits."]));b=xH(b,c,8);return 255<(b|0)?aH(a):b}return TG(a,L(["Unsupported character: ",b,"."]))}return VG(a,L(["Unexpected EOF while reading character."]))}function AH(a){return OG(a)?new O(null,2,5,P,[JG(a),(KG(a)|0)-1|0],null):null}
function BH(a,b,c,d){var e=AH(c),g=M(e,0,null);e=M(e,1,null);b=null==b?null:pe(b);for(var h=rc(zd);;){var l=dH(c);if(!t(l)){var m=a,n=g,r=e,v=K(h);VG(c,L(["Unexpected EOF while reading ",t(v)?["item ",u.h(v)," of "].join(""):null,Ae(m),t(n)?[", starting at line ",u.h(n)," and column ",u.h(r)].join(""):null,"."]))}if(H.c(b,null==l?null:pe(l)))return tc(h);m=qH.h?qH.h(l):qH.call(null,l);t(m)?(l=m.j?m.j(c,l,d):m.call(null,c,l,d),h=l!==c?Ne.c(h,l):h):(IG(c,l),l=CH?CH(c,!0,null,d):DH.call(null,c,!0,null,
d),h=l!==c?Ne.c(h,l):h)}}function EH(a,b,c){a=BH(Av,")",a,c);return Md(a)?Wc:N.c(ve,a)}function FH(a,b,c){return BH(Kr,"]",a,c)}function GH(a,b,c){var d=AH(a);b=M(d,0,null);d=M(d,1,null);c=BH(jC,"}",a,c);var e=K(c),g=rh(2,c),h=hh(g);!cf(e)&&WG(a,b,d,c);H.c(K(h),K(g))||cH(a,jC,g);if(e<=2*Ag)a=Je(c),a=new p(null,a.length/2,a,null);else a:for(a=Je(c),b=a.length,d=0,e=rc(Bg);;)if(d<b)c=d+2,e=uc(e,a[d],a[d+1]),d=c;else{a=tc(e);break a}return a}
function HH(a,b){for(var c=function(){var a=new Pa;a.append(b);return a}(),d=GG(a);;){if(t(function(){var a=CG(d);if(a)return a;a=qH.h?qH.h(d):qH.call(null,d);return t(a)?a:null==d}())){var e=u.h(c);IG(a,d);var g=iH(e);return t(g)?g:TG(a,L(["Invalid number: ",e,"."]))}e=function(){var a=c;a.append(d);return a}();g=GG(a);c=e;d=g}}
function IH(a){var b=GG(a);switch(b){case "t":return"\t";case "r":return"\r";case "n":return"\n";case "\\":return"\\";case '"':return'"';case "b":return"\b";case "f":return"\f";case "u":return b=GG(a),-1===parseInt(b|0,16)?TG(a,L(["Invalid unicode escape: \\u",b,"."])):yH(a,b,16,4,!0);default:return DG(b)?(b=yH(a,b,8,3,!1),255<(b|0)?aH(a):b):TG(a,L(["Unsupported escape character: \\",b,"."]))}}
function JH(a){for(var b=new Pa,c=GG(a);;){var d=c;if(H.c(null,d))return ZG(a,L(['"',b]));if(H.c("\\",d)){d=function(){var c=b;c.append(IH(a));return c}();var e=GG(a);b=d;c=e}else{if(H.c('"',d))return u.h(b);d=function(){var a=b;a.append(c);return a}();e=GG(a);b=d;c=e}}}
function KH(a,b){b=sH(a,ao,b,!0);if(t(b))switch(b){case "nil":return null;case "true":return!0;case "false":return!1;case "/":return mx;default:var c=jH(b);c=t(c)?Tc.c(c.h?c.h(0):c.call(null,0),c.h?c.h(1):c.call(null,1)):null;return t(c)?c:XG(a,ao,b)}else return null}
function LH(a){var b=GG(a);if(CG(b))return TG(a,L(["A single colon is not a valid keyword."]));b=sH(a,Iv,b,!0);var c=jH(b);if(t(t(c)?-1===b.indexOf("::"):c)){var d=c.h?c.h(0):c.call(null,0);c=c.h?c.h(1):c.call(null,1);return":"===pd(b,0)?XG(a,Iv,b):ze.c(d,c)}return XG(a,Iv,b)}
function MH(a,b,c){b=CH?CH(a,!0,null,c):DH.call(null,a,!0,null,c);b=b instanceof q?Ed([b,!0]):b instanceof Sc?new p(null,1,[Iz,b],null):"string"===typeof b?new p(null,1,[Iz,b],null):b;Qd(b)||TG(a,L(["Metadata cannot be ",RG(b),". Metadata must be a Symbol, Keyword, String or Map."]));c=CH?CH(a,!0,null,c):DH.call(null,a,!0,null,c);return null!=c&&(c.o&131072||k===c.Sc)?Id(c,ah.l(L([Jd(c),b]))):TG(a,L(["Metadata can not be applied to ",RG(c),". ","Metadata can only be applied to IMetas."]))}
function NH(a,b,c){b=BH(bA,"}",a,c);c=hh(b);H.c(K(b),K(c))||cH(a,bA,b);return c}function OH(a){CH?CH(a,!0,null,!0):DH.call(null,a,!0,null,!0);return a}
function PH(a,b,c){b=GG(a);b=sH(a,nl,b,!0);var d=null==b?null:jH(b);if(null==d)var e=null;else e=M(d,0,null),d=M(d,1,null),e=t(e)?null:d;return t(e)?"{"===dH(a)?(c=BH(nl,"}",a,c),!cf(K(c))&&WG(a,null,null,c),b=EG(u.h(e),rh(2,c)),c=rh(2,Vc(c)),H.c(K(hh(b)),K(b))||cH(a,nl,b),jh(b,c)):TG(a,L(["Namespaced map with namespace ",b," does not specify a map."])):TG(a,L(["Invalid value used as namespace in namespaced map: ",b,"."]))}
function QH(a,b,c){b=CH?CH(a,!0,null,c):DH.call(null,a,!0,null,c);return H.c(wo,b)?Number.NaN:H.c(yy,b)?Number.NEGATIVE_INFINITY:H.c(mr,b)?Number.POSITIVE_INFINITY:TG(a,L([["Invalid token: ##",u.h(b)].join("")]))}function qH(a){switch(a){case '"':return JH;case ":":return LH;case ";":return kH;case "^":return MH;case "(":return EH;case ")":return wH;case "[":return FH;case "]":return wH;case "{":return GH;case "}":return wH;case "\\":return zH;case "#":return tH;default:return null}}
function uH(a){switch(a){case "^":return MH;case "{":return NH;case "\x3c":return lH();case "!":return kH;case "_":return OH;case ":":return PH;case "#":return QH;default:return null}}
function vH(a,b,c){b=CH?CH(a,!0,null,c):DH.call(null,a,!0,null,c);var d=CH?CH(a,!0,null,c):DH.call(null,a,!0,null,c);b instanceof Sc||TG(a,L(["Invalid reader tag: ",RG("Reader tag must be a symbol"),". Reader tags must be symbols."]));var e=A.c(xp.h(c),b);e=t(e)?e:Xe.h?Xe.h(b):Xe.call(null,b);if(t(e))return e.h?e.h(d):e.call(null,d);c=ci.h(c);return t(c)?c.c?c.c(b,d):c.call(null,b,d):TG(a,L(["No reader function for tag ",RG(b),"."]))}
function DH(a){switch(arguments.length){case 1:return RH(Xe,arguments[0]);case 2:return RH(arguments[0],arguments[1]);case 4:return CH(arguments[0],arguments[1],arguments[2],arguments[3]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}}function RH(a,b){a=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a;var c=A.c(a,FA),d=!fe(a,FA);return CH(b,d,c,a)}
function CH(a,b,c,d){try{for(;;){var e=GG(a);if(!CG(e)){if(null==e){if(t(b)){b=a;var g=t(null)?VG(b,L(["EOF while reading, starting at line ",null,"."])):VG(b,L(["EOF while reading."]))}else g=c;return g}if(DG(e)||("+"===e||"-"===e)&&DG(a.Zb(null)))return HH(a,e);var h=qH(e);if(t(h)){var l=h.j?h.j(a,e,d):h.call(null,a,e,d);if(l!==a)return l}else return KH(a,e)}}}catch(m){if(m instanceof Error){g=m;if(g instanceof hi){b=g instanceof hi?g.data:null;if(H.c(wm,U.h(b)))throw g;a=ah.l(L([new p(null,1,[U,
wm],null),b,OG(a)?new p(null,3,[tv,JG(a),Hs,KG(a),kp,LG(a)],null):null]));throw new hi(g.message,a,g);}a=ah.l(L([new p(null,1,[U,wm],null),OG(a)?new p(null,3,[tv,JG(a),Hs,KG(a),kp,LG(a)],null):null]));throw new hi(g.message,a,g);}throw m;}};var SH=function(a,b){return function(c,d){return A.c(t(d)?b:a,c)}}(new O(null,13,5,P,[null,31,28,31,30,31,30,31,31,30,31,30,31],null),new O(null,13,5,P,[null,31,29,31,30,31,30,31,31,30,31,30,31],null)),TH=/(\d\d\d\d)(?:-(\d\d)(?:-(\d\d)(?:[T](\d\d)(?::(\d\d)(?::(\d\d)(?:[.](\d+))?)?)?)?)?)?(?:[Z]|([-+])(\d\d):(\d\d))?/;function UH(a){a=parseInt(a,10);return eb(isNaN(a))?a:null}
function VH(a,b,c,d){if(!(a<=b&&b<=c))throw Error([u.h(d)," Failed:  ",u.h(a),"\x3c\x3d",u.h(b),"\x3c\x3d",u.h(c)].join(""));return b}
function WH(a){var b=vh(TH,a);M(b,0,null);var c=M(b,1,null),d=M(b,2,null),e=M(b,3,null),g=M(b,4,null),h=M(b,5,null),l=M(b,6,null),m=M(b,7,null),n=M(b,8,null),r=M(b,9,null),v=M(b,10,null);if(eb(b))throw Error(["Unrecognized date/time syntax: ",u.h(a)].join(""));var x=UH(c),y=function(){var a=UH(d);return t(a)?a:1}();a=function(){var a=UH(e);return t(a)?a:1}();b=function(){var a=UH(g);return t(a)?a:0}();c=function(){var a=UH(h);return t(a)?a:0}();var z=function(){var a=UH(l);return t(a)?a:0}(),C=function(){a:if(H.c(3,
K(m)))var a=m;else if(3<K(m))a=m.substring(0,3);else for(a=new Pa(m);;)if(3>a.qb.length)a=a.append("0");else{a=a.toString();break a}a=UH(a);return t(a)?a:0}();n=(H.c(n,"-")?-1:1)*(60*function(){var a=UH(r);return t(a)?a:0}()+function(){var a=UH(v);return t(a)?a:0}());return new O(null,8,5,P,[x,VH(1,y,12,"timestamp month field must be in range 1..12"),VH(1,a,function(){var a=0===(x%4+4)%4&&(0!==(x%100+100)%100||0===(x%400+400)%400);return SH.c?SH.c(y,a):SH.call(null,y,a)}(),"timestamp day field must be in range 1..last day in month"),
VH(0,b,23,"timestamp hour field must be in range 0..23"),VH(0,c,59,"timestamp minute field must be in range 0..59"),VH(0,z,H.c(c,59)?60:59,"timestamp second field must be in range 0..60"),VH(0,C,999,"timestamp millisecond field must be in range 0..999"),n],null)}
var XH=nf(null),YH=nf(ah.l(L([new p(null,4,[Aq,function(a){if("string"===typeof a){var b=WH(a);if(t(b)){a=M(b,0,null);var c=M(b,1,null),d=M(b,2,null),e=M(b,3,null),g=M(b,4,null),h=M(b,5,null),l=M(b,6,null);b=M(b,7,null);b=new Date(Date.UTC(a,c-1,d,e,g,h,l)-6E4*b)}else throw Error(["Unrecognized date/time syntax: ",u.h(a)].join(""));return b}throw Error("Instance literal expects a string for its timestamp.");},Ji,function(a){if("string"===typeof a){if("string"!==typeof a)throw Error("Assert failed: (string? s)");
return new gi(a.toLowerCase())}throw Error("UUID literal expects a string as its representation.");},Hr,function(a){if(Sd(a))return jf.c(ng,a);throw Error("Queue literal expects a vector for its elements.");},wp,function(a){if(Sd(a)){var b=[];a=B(a);for(var c=null,d=0,e=0;;)if(e<d){var g=c.N(null,e);b.push(g);e+=1}else if(a=B(a))c=a,Td(c)?(a=wc(c),e=xc(c),c=a,d=K(a),a=e):(a=E(c),b.push(a),a=G(c),c=null,d=0),e=0;else break;return b}if(Qd(a)){b={};a=B(a);c=null;for(e=d=0;;)if(e<d){var h=c.N(null,e);
g=M(h,0,null);h=M(h,1,null);var l=b;g=Ae(g);l[g]=h;e+=1}else if(a=B(a))Td(a)?(d=wc(a),a=xc(a),c=d,d=K(d)):(d=E(a),c=M(d,0,null),d=M(d,1,null),e=b,c=Ae(c),e[c]=d,a=G(a),c=null,d=0),e=0;else break;return b}throw Error("JS literal expects a vector or map containing only string or unqualified keyword keys");}],null),Xe])));var ZH;a:{var $H=aa.navigator;if($H){var aI=$H.userAgent;if(aI){ZH=aI;break a}}ZH=""}function bI(a){return-1!=ZH.indexOf(a)};function cI(a,b,c){var d=a;b&&(d=ma(a,b));d=cI.Rd(d);fa(aa.setImmediate)&&(c||cI.Qd())?aa.setImmediate(d):(cI.hd||(cI.hd=cI.Jd()),cI.hd(d))}cI.Qd=function(){return aa.Window&&aa.Window.prototype&&!bI("Edge")&&aa.Window.prototype.setImmediate==aa.setImmediate?!1:!0};
cI.Jd=function(){var a=aa.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&!bI("Presto")&&(a=function(){var a=document.createElement("IFRAME");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow;a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+"//"+b.location.host;a=ma(function(a){if(("*"==d||a.origin==d)&&a.data==
c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&!bI("Trident")&&!bI("MSIE")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(void 0!==c.next){c=c.next;var a=c.Qc;c.Qc=null;a()}};return function(a){d.next={Qc:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in document.createElement("SCRIPT")?function(a){var b=document.createElement("SCRIPT");
b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){aa.setTimeout(a,0)}};cI.Rd=function(a){return a};var dI={},kf=jf.c(ng,zd);function eI(a){return null!=a?k===a.gc?!0:a.Jc?!1:gb(OE,a):gb(OE,a)}function fI(a){return null!=a?a.o&32768||k===a.oc?!0:a.o?!1:gb(Ub,a):gb(Ub,a)}function gI(a,b){YE(a,b)}function hI(a,b){setTimeout(a,b)}function iI(a){return null!=a&&k===a.gc?[t(Rc.c?Rc.c(PE,a):Rc.call(null,PE,a))?"ra":t(Rc.c?Rc.c(UE,a):Rc.call(null,UE,a))?"rc":t(Rc.c?Rc.c(ZE,a):Rc.call(null,ZE,a))?"rx":t(Rc.c?Rc.c(TE,a):Rc.call(null,TE,a))?"tr":"other",u.h(Pc(a))].join(""):null};var jI=nf(new p(null,5,[UB,console.log.bind(console),bo,console.warn.bind(console),cz,console.error.bind(console),pl,t(console.group)?console.group.bind(console):console.log.bind(console),tA,t(console.groupEnd)?console.groupEnd.bind(console):function(){return Wc}],null));function kI(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;lI(arguments[0],1<b.length?new D(b.slice(1),0,null):null)}
function lI(a,b){if(!fe(w(jI),a))throw Error(["Assert failed: ",["re-frame: log called with unknown level: ",u.h(a)].join(""),"\n(contains? (clojure.core/deref loggers) level)"].join(""));return N.c(function(){var b=w(jI);return a.h?a.h(b):a.call(null,b)}(),b)};var mI={};if("undefined"===typeof dI||"undefined"===typeof mI||"undefined"===typeof nI)var nI=nf(zd);if("undefined"===typeof dI||"undefined"===typeof mI||"undefined"===typeof oI)var oI=nf(0);var pI=new dh(null,new p(null,3,[Vu,null,qw,null,yB,null],null),null);function qI(a){return Qd(a)&&H.c(pI,hh(xg(a)))}function rI(a){a=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a;var b=A.c(a,qw),c=A.c(a,yB),d=A.c(a,Vu),e=B(vE.c(hh(xg(a)),pI));e&&lI(cz,L(["re-frame: -\x3einterceptor",a,"has unknown keys:",e]));return new p(null,3,[qw,t(b)?b:Hi,yB,c,Vu,d],null)}function sI(a,b){return pb(A,a,new O(null,2,5,P,[Hf,b],null))}
function tI(a,b){for(var c=a;;){var d=Jf.h(c);if(Md(d))return c;a=Kd(d);var e=Mx.h(c);c=Dd.l(c,Jf,null==d?null:Rb(d),L([Mx,yd.c(e,a)]));a=A.c(a,b);c=t(a)?a.h?a.h(c):a.call(null,c):c}};var uI=new dh(null,new p(null,4,[nn,null,Ru,null,OA,null,oB,null],null),null),vI=nf(Xe);function wI(a,b){return A.c(A.c(w(vI),a),b)}function xI(a,b,c){var d=wI(a,b);t(t(c)?null==d:c)&&lI(cz,L(["re-frame: no",u.h(a),"handler registered for:",b]));return d}function yI(a,b,c){t(xI(a,b,!1))&&lI(bo,L(["re-frame: overwriting",u.h(a),"handler for:",b]));pf.G(vI,Ef,new O(null,2,5,P,[a,b],null),c);return c}
var zI=function zI(a){switch(arguments.length){case 0:return zI.B();case 1:return zI.h(arguments[0]);case 2:return zI.c(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};zI.B=function(){return of(vI,Xe)};zI.h=function(a){if(!t(uI.h?uI.h(a):uI.call(null,a)))throw Error("Assert failed: (kinds kind)");return pf.j(vI,Fd,a)};
zI.c=function(a,b){if(!t(uI.h?uI.h(a):uI.call(null,a)))throw Error("Assert failed: (kinds kind)");return t(wI(a,b))?pf.l(vI,Ff,new O(null,1,5,P,[a],null),Fd,L([b])):lI(bo,L(["re-frame: can't clear",u.h(a),"handler for",[u.h(b),". Handler not found."].join("")]))};zI.D=2;var AI=function AI(a,b){var d=B(b);b=E(d);if(d=G(d)){var e=A.c(a,b);return t(e)?(d=AI.c?AI.c(e,d):AI.call(null,e,d),B(d)?Dd.j(a,b,d):Fd.c(a,b)):a}return Fd.c(a,b)};function BI(a){return Sd(a)?E(a):lI(cz,L(["re-frame: expected a vector, but got:",a]))};var CI=tG(Xe);if(!t(uI.h?uI.h(Ru):uI.call(null,Ru)))throw Error("Assert failed: (re-frame.registrar/kinds kind)");
function DI(a,b){Nd(b)||lI(cz,L(["re-frame: when registering",a,", expected a collection of interceptors, got:",b]));b=zf(ab,Bf(b));Md(b)&&lI(cz,L(["re-frame: when registering",a,", given an empty interceptor chain"]));var c=E(zf(qI,b));t(c)&&(Gd(c)?lI(cz,L(["re-frame: when registering",a,", got a function instead of an interceptor. Did you provide old style middleware by mistake? Got:",c])):lI(cz,L(["re-frame: when registering",a,", expected interceptors, but got:",c])));return b}var EI=null;
function FI(a){var b=BI(a);b=xI(Ru,b,!0);if(t(b))if(t(EI))lI(cz,L(["re-frame: while handling",EI,", dispatch-sync was called for",a,". You can't call dispatch-sync within an event handler."]));else{var c=EI;EI=a;try{var d=Ef(Xe,new O(null,2,5,P,[Hf,Ru],null),a);var e=If(d,b);var g=tI(e,yB),h=Fd.c(g,Jf),l=Mx.h(g);var m=If(h,l);tI(m,Vu)}finally{EI=c}}};var GI=new p(null,2,[ft,function(a){function b(){return cI.h?cI.h(a):cI.call(null,a)}return uG.h?uG.h(b):uG.call(null,b)},hj,cI],null);function HI(a){for(var b=K(a.Fa);;){if(0===b)return II(a,nC,null);var c=bf(GI,xg(Jd(Kd(a.Fa))));if(t(c))return II(a,az,c);JI(a);--b}}function KI(a){a=function(a){return function(){return II(a,sx,null)}}(a);return cI.h?cI.h(a):cI.call(null,a)}
function II(a,b,c){var d=function(){var d=new O(null,2,5,P,[a.xc,b],null);if(H.c(new O(null,2,5,P,[Qk,Wi],null),d))return new O(null,2,5,P,[ty,function(a,b){return function(){b.Fa=yd.c(b.Fa,c);return KI(b)}}(d,a)],null);if(H.c(new O(null,2,5,P,[Ds,qz],null),d))return new O(null,2,5,P,[Qk,function(a,b){return function(){b.Fa=kf;throw c;}}(d,a)],null);if(H.c(new O(null,2,5,P,[Ds,nC],null),d))return Md(a.Fa)?new O(null,1,5,P,[Qk],null):new O(null,2,5,P,[ty,function(a,b){return function(){return KI(b)}}(d,
a)],null);if(H.c(new O(null,2,5,P,[Ds,az],null),d))return new O(null,2,5,P,[Hj,function(a,b){return function(){return LI(b,c)}}(d,a)],null);if(H.c(new O(null,2,5,P,[Hj,bB],null),d))return new O(null,2,5,P,[Ds,function(a,b){return function(){JI(b);return HI(b)}}(d,a)],null);if(H.c(new O(null,2,5,P,[ty,sx],null),d))return new O(null,2,5,P,[Ds,function(a,b){return function(){return HI(b)}}(d,a)],null);if(H.c(new O(null,2,5,P,[Hj,Wi],null),d))return new O(null,2,5,P,[Hj,function(a,b){return function(){return b.Fa=
yd.c(b.Fa,c)}}(d,a)],null);if(H.c(new O(null,2,5,P,[Ds,Wi],null),d))return new O(null,2,5,P,[Ds,function(a,b){return function(){return b.Fa=yd.c(b.Fa,c)}}(d,a)],null);if(H.c(new O(null,2,5,P,[ty,Wi],null),d))return new O(null,2,5,P,[ty,function(a,b){return function(){return b.Fa=yd.c(b.Fa,c)}}(d,a)],null);throw ii(["re-frame: router state transition not found. ",u.h(a.xc)," ",u.h(b)].join(""),new p(null,2,[jm,a.xc,CA,b],null));}();var e=M(d,0,null);d=M(d,1,null);a.xc=e;return t(d)?d.B?d.B():d.call(null):
null}function LI(a,b){a=function(a){return function(){return II(a,bB,null)}}(a);return b.h?b.h(a):b.call(null,a)}function JI(a){var b=Kd(a.Fa);try{FI(b);var c=a.Fa;var d=null==c?null:Rb(c);a.Fa=d;MI(a,b)}catch(e){II(a,qz,e)}}function MI(a,b){for(var c=B(yg(a.Md)),d=null,e=0,g=0;;)if(g<e){var h=d.N(null,g);h.c?h.c(b,a.Fa):h.call(null,b,a.Fa);g+=1}else if(c=B(c))d=c,Td(d)?(c=wc(d),e=xc(d),d=c,h=K(c),c=e,e=h):(h=E(d),h.c?h.c(b,a.Fa):h.call(null,b,a.Fa),c=G(d),d=null,e=0),g=0;else break}
var NI=new function(a,b,c){this.xc=a;this.Fa=b;this.Md=c}(Qk,kf,Xe);function OI(a){if(null==a)throw ii('re-frame: you called "dispatch" without an event vector.',Xe);II(NI,Wi,a);return null}function PI(a){FI(a);MI(NI,a);return null};if(!t(uI.h?uI.h(oB):uI.call(null,oB)))throw Error("Assert failed: (re-frame.registrar/kinds kind)");function QI(a,b){return yI(oB,a,b)}
var RI=rI(L([qw,Bp,Vu,function(a){for(var b,c=B(Aw.h(a)),d=null,e=0,g=0;;)if(g<e){a=d.N(null,g);b=M(a,0,null);a=M(a,1,null);var h=xI(oB,b,!1);t(h)?(b=h,b.h?b.h(a):b.call(null,a)):lI(cz,L(["re-frame: no handler registered for effect:",b,". Ignoring."]));g+=1}else if(a=B(c))c=a,Td(c)?(b=wc(c),c=xc(c),a=b,b=K(b),d=a,e=b):(a=E(c),b=M(a,0,null),a=M(a,1,null),d=xI(oB,b,!1),t(d)?(b=d,b.h?b.h(a):b.call(null,a)):lI(cz,L(["re-frame: no handler registered for effect:",b,". Ignoring."])),c=G(c),d=null,e=0),g=
0;else return null}]));
QI(SC,function(a){a=B(zf(ab,a));for(var b=null,c=0,d=0;;)if(d<c){var e=b.N(null,d),g=null!=e&&(e.o&64||k===e.M)?N.c(Yg,e):e,h=g,l=A.c(g,hB),m=A.c(g,St);Md(m)||"number"!==typeof l?lI(cz,L(["re-frame: ignoring bad :dispatch-later value:",h])):hI(function(a,b,c,d,e,g,h,l,m){return function(){return OI(m)}}(a,b,c,d,e,g,h,l,m),l);d+=1}else if(g=B(a)){e=g;if(Td(e))a=wc(e),d=xc(e),b=a,c=K(a),a=d;else{var n=E(e),r=null!=n&&(n.o&64||k===n.M)?N.c(Yg,n):n;h=r;l=A.c(r,hB);m=A.c(r,St);Md(m)||"number"!==typeof l?
lI(cz,L(["re-frame: ignoring bad :dispatch-later value:",h])):hI(function(a,b,c,d,e,g,h,l,m){return function(){return OI(m)}}(a,b,c,d,n,r,h,l,m,e,g),l);a=G(e);b=null;c=0}d=0}else return null});QI(St,function(a){return Sd(a)?OI(a):lI(cz,L(["re-frame: ignoring bad :dispatch value. Expected a vector, but got:",a]))});
QI(xq,function(a){if(Pd(a)){a=B(zf(ab,a));for(var b=null,c=0,d=0;;)if(d<c){var e=b.N(null,d);OI(e);d+=1}else if(a=B(a))b=a,Td(b)?(a=wc(b),c=xc(b),b=a,e=K(a),a=c,c=e):(e=E(b),OI(e),a=G(b),b=null,c=0),d=0;else return null}else return lI(cz,L(["re-frame: ignoring bad :dispatch-n value. Expected a collection, got got:",a]))});
QI(Yr,function(a){var b=gf.c(zI,Ru);if(Pd(a)){a=B(a);for(var c=null,d=0,e=0;;)if(e<d){var g=c.N(null,e);b.h?b.h(g):b.call(null,g);e+=1}else if(a=B(a))c=a,Td(c)?(a=wc(c),d=xc(c),c=a,g=K(a),a=d,d=g):(g=E(c),b.h?b.h(g):b.call(null,g),a=G(c),c=null,d=0),e=0;else return null}else return b.h?b.h(a):b.call(null,a)});QI(kn,function(a){return w(CI)!==a?of(CI,a):null});if(!t(uI.h?uI.h(OA):uI.call(null,OA)))throw Error("Assert failed: (re-frame.registrar/kinds kind)");yI(OA,kn,function(a){return Dd.j(a,kn,w(CI))});var SI=function(a){return rI(L([qw,Hf,yB,function(b){var c=wI(OA,a);return t(c)?Gf(b,c):lI(cz,L(["No cofx handler registered for",a]))}]))}(kn);function TI(a,b){return H.c(a,b)?new O(null,3,5,P,[null,null,a],null):new O(null,3,5,P,[a,b,null],null)}function UI(a){return B(a)?pb(function(a,c){var b=M(c,0,null);c=M(c,1,null);return Dd.j(a,b,c)},bg(vf(N.c(oe,xg(a)))),a):null}function VI(a,b,c){var d=A.c(a,c),e=A.c(b,c),g=WI(d,e),h=M(g,0,null),l=M(g,1,null);g=M(g,2,null);a=fe(a,c);b=fe(b,c);d=a&&b&&(null!=g||null==d&&null==e);return new O(null,3,5,P,[!a||null==h&&d?null:Ed([c,h]),!b||null==l&&d?null:Ed([c,l]),d?Ed([c,g]):null],null)}
var XI=function XI(a){switch(arguments.length){case 2:return XI.c(arguments[0],arguments[1]);case 3:return XI.j(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};XI.c=function(a,b){return XI.j(a,b,tE(xg(a),xg(b)))};XI.j=function(a,b,c){return pb(function(a,b){return uh(qf.j(ah,a,b))},new O(null,3,5,P,[null,null,null],null),qf.c(gf.j(VI,a,b),c))};XI.D=3;
function YI(a,b){return bg(qf.c(UI,XI.j(Sd(a)?a:bg(a),Sd(b)?b:bg(b),qh(function(){var c=K(a),d=K(b);return c>d?c:d}()))))}function ZI(a,b){return new O(null,3,5,P,[Ve(vE.c(a,b)),Ve(vE.c(b,a)),Ve(uE.c(a,b))],null)}
var $I=function $I(a){if(null!=a&&null!=a.Fd)return a.Fd(a);var c=$I[da(null==a?null:a)];if(null!=c)return c.h?c.h(a):c.call(null,a);c=$I._;if(null!=c)return c.h?c.h(a):c.call(null,a);throw jb("EqualityPartition.equality-partition",a);},aJ=function aJ(a,b){if(null!=a&&null!=a.Ed)return a.Ed(a,b);var d=aJ[da(null==a?null:a)];if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);d=aJ._;if(null!=d)return d.c?d.c(a,b):d.call(null,a,b);throw jb("Diff.diff-similar",a);};$I["null"]=function(){return vA};
$I.string=function(){return vA};$I.number=function(){return vA};$I.array=function(){return Pn};$I["function"]=function(){return vA};$I["boolean"]=function(){return vA};$I._=function(a){return(null!=a?a.o&1024||k===a.vd||(a.o?0:gb(Kb,a)):gb(Kb,a))?jC:(null!=a?a.o&4096||k===a.Ad||(a.o?0:gb(Ob,a)):gb(Ob,a))?bA:(null!=a?a.o&16777216||k===a.Ic||(a.o?0:gb(gc,a)):gb(gc,a))?Pn:vA};aJ["null"]=function(a,b){return TI(a,b)};aJ.string=function(a,b){return TI(a,b)};aJ.number=function(a,b){return TI(a,b)};
aJ.array=function(a,b){return YI(a,b)};aJ["function"]=function(a,b){return TI(a,b)};aJ["boolean"]=function(a,b){return TI(a,b)};aJ._=function(a,b){var c=function(){var b=$I(a);b=b instanceof q?b.U:null;switch(b){case "atom":return TI;case "set":return ZI;case "sequential":return YI;case "map":return XI;default:throw Error(["No matching clause: ",u.h(b)].join(""));}}();return c.c?c.c(a,b):c.call(null,a,b)};
function WI(a,b){return H.c(a,b)?new O(null,3,5,P,[null,null,a],null):H.c($I(a),$I(b))?aJ(a,b):TI(a,b)};rI(L([qw,Oq,yB,function(a){lI(UB,L(["Handling re-frame event:",sI(a,Ru)]));return a},Vu,function(a){var b=sI(a,Ru),c=sI(a,kn);a:{var d=Vd;for(var e=a,g=B(new O(null,2,5,P,[Aw,kn],null));;)if(null!=g){e=A.j(e,E(g),d);if(d===e){d=vn;break a}g=G(g)}else{d=e;break a}}H.c(d,vn)?lI(UB,L(["No :db changes caused by:",b])):(d=WI(c,d),c=M(d,0,null),d=M(d,1,null),null!=c||null!=d?(lI(pl,L(["db clojure.data/diff for:",b])),lI(UB,L(["only before:",c])),lI(UB,L(["only after :",d])),kI(tA)):lI(UB,L(["no app-db changes caused by:",
b])));return a}]));rI(L([qw,Ft,yB,function(a){return Ef(Ff.G(a,new O(null,2,5,P,[Hf,Ru],null),gg,1),new O(null,2,5,P,[Hf,aC],null),sI(a,Ru))},Vu,function(a){return Ef(AI(a,new O(null,2,5,P,[Hf,aC],null)),new O(null,2,5,P,[Hf,Ru],null),sI(a,aC))}]));function bJ(a){return rI(L([qw,Ku,yB,function(b){var c=Hf.h(b),d=null!=c&&(c.o&64||k===c.M)?N.c(Yg,c):c;c=A.c(d,kn);d=A.c(d,Ru);c=a.c?a.c(c,d):a.call(null,c,d);return Ef(b,new O(null,2,5,P,[Aw,kn],null),c)}]))}
function cJ(a){return rI(L([qw,mn,yB,function(b){var c=Hf.h(b);c=null!=c&&(c.o&64||k===c.M)?N.c(Yg,c):c;var d=A.c(c,Ru);return Dd.j(b,Aw,a.c?a.c(c,d):a.call(null,c,d))}]))};if(!t(uI.h?uI.h(nn):uI.call(null,nn)))throw Error("Assert failed: (re-frame.registrar/kinds kind)");var dJ=nf(Xe);function eJ(){for(var a=B(w(dJ)),b=null,c=0,d=0;;)if(d<c){var e=b.N(null,d);M(e,0,null);e=M(e,1,null);XE(e);d+=1}else if(a=B(a))Td(a)?(c=wc(a),a=xc(a),b=c,c=K(c)):(b=E(a),M(b,0,null),b=M(b,1,null),XE(b),a=G(a),b=null,c=0),d=0;else break;return t(Ve(w(dJ)))?lI(bo,L(["Subscription cache should be empty after clearing it."])):null}
function fJ(a,b,c){a=new O(null,2,5,P,[a,b],null);gI(c,function(a){return function(){return pf.c(dJ,function(a){return function(b){return fe(b,a)&&c===A.c(b,a)?Fd.c(b,a):b}}(a))}}(a));pf.c(dJ,function(a){return function(b){fe(b,a)&&lI(bo,L(["re-frame: Adding a new subscription to the cache while there is an existing subscription in the cache",a]));return Dd.j(b,a,c)}}(a));return c}function gJ(a,b){return A.c(w(dJ),new O(null,2,5,P,[a,b],null))}
var hJ=function hJ(a){switch(arguments.length){case 1:return hJ.h(arguments[0]);case 2:return hJ.c(arguments[0],arguments[1]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};hJ.h=function(a){var b=gJ(a,zd);if(t(b))return b;var c=BI(a);b=wI(nn,c);return null==b?lI(cz,L([["re-frame: no subscription handler registered for: ",u.h(c),". Returning a nil subscription."].join("")])):fJ(a,zd,b.c?b.c(CI,a):b.call(null,CI,a))};
hJ.c=function(a,b){var c=gJ(a,b);if(t(c))return c;var d=BI(a);var e=wI(nn,d);var g=Ve(zf(eI,b));t(g)&&lI(bo,L(["re-frame: your subscription's dynamic parameters that don't implement IReactiveAtom:",g]));if(null==e)return lI(cz,L([["re-frame: no subscription handler registered for: ",u.h(d),". Returning a nil subscription."].join("")]));var h=SE(function(){return function(){return Cf(b)}}(d,e,c));g=SE(function(b,c,d){return function(){var c=w(b);return d.j?d.j(CI,a,c):d.call(null,CI,a,c)}}(h,d,e,c));
return fJ(a,b,SE(function(a,b){return function(){return w(w(b))}}(h,g,d,e,c)))};hJ.D=2;function iJ(a){return jf.j(Bd(a),qf.h(function(a){var b=M(a,0,null);a=M(a,1,null);return new O(null,2,5,P,[b,gd.h?gd.h(a):gd.call(null,a)],null)}),a)}function jJ(a,b){var c=Pd(a)?qf.c(gd,a):Qd(a)?iJ(a):fI(a)?gd.h?gd.h(a):gd.call(null,a):Wc;Pd(a)?qf.c(gd,a):Qd(a)?iJ(a):fI(a)?w(a):lI(cz,L(["re-frame: in the reg-sub for",b,", the input-signals function returns:",a]));return c}
function kJ(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return lJ(arguments[0],1<b.length?new D(b.slice(1),0,null):null)}
function lJ(a,b){var c=xd(b),d=ih(b),e=["re-frame: reg-sub for ",u.h(a),", "].join("");b=function(){var a=K(d);switch(a){case 0:return function(){return function(){var a=null;a=function(a,b){switch(arguments.length){case 1:return CI;case 2:return CI}throw Error("Invalid arity: "+arguments.length);};a.h=function(){return CI};a.c=function(){return CI};return a}()}(a,c,d,e);case 1:return a=E(d),Gd(a)||lI(cz,L([e,"2nd argument expected to be an inputs function, got:",a])),a;case 2:var b=M(d,0,null),l=
M(d,1,null);H.c(Pm,b)||lI(cz,L([e,"expected :\x3c-, got:",b]));return function(a,b,c){return function(){function a(){return hJ.h(c)}function b(){return hJ.h(c)}var d=null;d=function(c,d){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,d)}throw Error("Invalid arity: "+arguments.length);};d.h=b;d.c=a;return d}()}(d,b,l,a,c,d,e);default:b=Df(2,2,d);l=qf.c(E,b);var m=qf.c(xd,b);af(new dh(null,new p(null,1,[Pm,null],null),null),l)&&af(Sd,m)||lI(cz,L([e,"expected pairs of :\x3c- and vectors, got:",
b]));return function(a,b,c){return function(){function a(){return qf.c(hJ,c)}function b(){return qf.c(hJ,c)}var d=null;d=function(c,d){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,d)}throw Error("Invalid arity: "+arguments.length);};d.h=b;d.c=a;return d}()}(b,l,m,a,c,d,e)}}();return yI(nn,a,function(b,c,d,e){return function(){function g(g,h,l){var m=e.c?e.c(h,l):e.call(null,h,l);g=nf(null);m=SE(function(b,c,d){return function(){var c=jJ(b,a);return d.j?d.j(c,h,
l):d.call(null,c,h,l)}}(m,g,b,c,d,e));of(g,iI(m));return m}function h(g,h){var l=e.h?e.h(h):e.call(null,h);g=nf(null);l=SE(function(b,c,d){return function(){var c=jJ(b,a);return d.c?d.c(c,h):d.call(null,c,h)}}(l,g,b,c,d,e));of(g,iI(l));return l}var l=null;l=function(a,b,c){switch(arguments.length){case 2:return h.call(this,a,b);case 3:return g.call(this,a,b,c)}throw Error("Invalid arity: "+arguments.length);};l.c=h;l.j=g;return l}()}(c,d,e,b))};gf.c(zI,nn);gf.c(zI,oB);gf.c(zI,OA);var mJ=function mJ(a){switch(arguments.length){case 2:return mJ.c(arguments[0],arguments[1]);case 3:return mJ.j(arguments[0],arguments[1],arguments[2]);default:throw Error(["Invalid arity: ",u.h(arguments.length)].join(""));}};mJ.c=function(a,b){return mJ.j(a,null,b)};mJ.j=function(a,b,c){b=new O(null,4,5,P,[SI,RI,b,bJ(c)],null);return yI(Ru,a,DI(a,b))};mJ.D=3;function nJ(a,b){b=new O(null,4,5,P,[SI,RI,null,cJ(b)],null);yI(Ru,a,DI(a,b))}gf.c(zI,Ru);var oJ={};function pJ(a){var b=a.data;a=new p(null,3,[xp,w(YH),ci,w(XH),FA,null],null);if(t(t(b)?Ue.c(b,""):b)){b=new MG(b,K(b));a:{var c=Array(1);if(Xd(null))for(var d=0,e=B(null);;)if(e&&1>d)c[d]=E(e),d+=1,e=G(e);else break a;else for(d=0;;)if(1>d)c[d]=null,d+=1;else break}a=RH(a,new NG(b,c))}else a=null;return OI.h?OI.h(a):OI.call(null,a)}if("undefined"===typeof vG||"undefined"===typeof oJ||"undefined"===typeof qJ)var qJ=nf(null);var rJ={};function sJ(){var a=H.c(tJ,Nm)?"cmd":"ctrl",b=new O(null,5,5,P,["enter","up","down","left","right"],null);return jf.c(Xe,qf.j(function(){return function(a,b){return new O(null,2,5,P,[ze.h(b),ze.h([u.h(ta(a)),"-",u.h(ta(b))].join(""))],null)}}(a,b),new uf(null,-1,a,null),b))}
if("undefined"===typeof vG||"undefined"===typeof rJ||"undefined"===typeof uJ){var uJ,vJ=navigator.appVersion,tJ=t(wh(/Win/,vJ))?km:t(wh(/X11/,vJ))?Iq:t(wh(/Linux/,vJ))?cA:t(wh(/Mac/,vJ))?Nm:Iw;uJ=new p(null,2,[Hz,tJ,dk,sJ()],null)}mJ.c(ui,function(){return ah.l(L([new p(null,1,[Sq,"replete-web"],null),uJ]))});mJ.c(fv,function(a,b){M(b,0,null);b=M(b,1,null);return Dd.l(a,Ni,b,L([Yt,null]))});mJ.c(uu,function(a){return Dd.j(a,Yt,new p(null,1,[tp,!0],null))});
mJ.c(Au,function(a,b){M(b,0,null);b=M(b,1,null);var c=$u.h(a);c=t(c)?c:zd;return Dd.l(a,$u,yd.c(c,b),L([cx,K(c)+1]))});mJ.c(zm,function(a,b){M(b,0,null);b=M(b,1,null);return Dd.j(a,Km,b)});function wJ(a){var b=new O(null,2,5,P,[gm,a],null);w(qJ).postMessage(u.h(b));a=new O(null,2,5,P,[Au,a],null);return OI.h?OI.h(a):OI.call(null,a)}QI.c?QI.c(Vx,wJ):QI.call(null,Vx,wJ);
nJ(gD,function(a,b){M(b,0,null);a=M(b,1,null);return new p(null,1,[xq,new Ad(null,new O(null,2,5,P,[zm,a],null),new Ad(null,new O(null,1,5,P,[uu],null),null,1,null),2,null)],null)});nJ(CD,function(a){a=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a;a=A.c(a,kn);return new p(null,2,[kn,Dd.j(a,Zi,null),Vx,Ni.h(a)],null)});mJ.c(Qm,function(a,b){M(b,0,null);b=M(b,1,null);return Dd.j(a,Gm,b)});mJ.c(Ow,function(a,b){M(b,0,null);b=M(b,1,null);return Dd.j(a,qx,b)});
function xJ(a,b){var c=cx.h(a);b=b.h?b.h(c):b.call(null,c);c=$u.h(a);c=M(c,b,Sv);if(H.c(c,Sv))return a;var d=bh(a,new O(null,2,5,P,[Gm,qx],null)),e=null!=d&&(d.o&64||k===d.M)?N.c(Yg,d):d;d=A.c(e,Gm);e=A.c(e,qx);e=M(e,b,Sv);if(!H.c(e,Sv)){var g=null!=e&&(e.o&64||k===e.M)?N.c(Yg,e):e;e=A.c(g,Np);g=A.c(g,iA);d.extendSelection({line:e,ch:0},{line:g+1,ch:0});d.scrollIntoView({line:15>e?0:2+g})}return Dd.l(a,cx,b,L([Zi,c,Ni,c]))}mJ.c(Ro,function(a){return xJ(a,ne)});mJ.c(vm,function(a){return xJ(a,dd)});function yJ(a,b){a=CodeMirror.fromTextArea(a,Mh(ah.l(L([new p(null,2,[qj,!0,Jp,bn],null),b]))));a.setSize("100%","100%");parinferCodeMirror.init(a);return a};function zJ(a){a=pa(a.getValue());return B(a)?(a=new O(null,2,5,P,[fv,a],null),OI.h?OI.h(a):OI.call(null,a)):null}function AJ(a,b){b=Ly.h(sG(b));return t(b)?w(a).setValue(t(tp.h(b))?"":b):null}
function BJ(a){var b=nf(null),c=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,d=A.c(c,Yv),e=A.c(c,$t),g=A.c(c,Az),h=A.c(c,li),l=gf.c(t(e)?e:AJ,b),m=t(g)?g:zJ;return xF(new p(null,5,[kv,function(a,b,c,d){return function(){return new O(null,2,5,P,[lt,new p(null,2,[qw,d,Ti,Yw],null)],null)}}(b,a,c,d,e,g,h,l,m),jp,function(a,b,c,d,e,g,h,l,m){return function(b){var c=rG(b);c=yJ(c,h);c.on("change",m);of(a,c);return l.h?l.h(b):l.call(null,b)}}(b,a,c,d,e,g,h,l,m),zx,function(a){return function(){w(a).toTextArea();
return of(a,null)}}(b,a,c,d,e,g,h,l,m),mq,l,py,d],null))};function CJ(a){a=null==a?null:$D(a,/\n|\r\n/);a=null==a?null:qf.c(K,a);a=null==a?null:ie(oe,a);return t(a)?a:0};var DJ={Wd:["BC","AD"],Vd:["Before Christ","Anno Domini"],Yd:"JFMAMJJASOND".split(""),ie:"JFMAMJJASOND".split(""),Xd:"January February March April May June July August September October November December".split(" "),he:"January February March April May June July August September October November December".split(" "),ee:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),ke:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),oe:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
me:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ge:"Sun Mon Tue Wed Thu Fri Sat".split(" "),le:"Sun Mon Tue Wed Thu Fri Sat".split(" "),Zd:"SMTWTFS".split(""),je:"SMTWTFS".split(""),fe:["Q1","Q2","Q3","Q4"],$d:["1st quarter","2nd quarter","3rd quarter","4th quarter"],Sd:["AM","PM"],Td:["EEEE, MMMM d, y","MMMM d, y","MMM d, y","M/d/yy"],ne:["h:mm:ss a zzzz","h:mm:ss a z","h:mm:ss a","h:mm a"],Ud:["{1} 'at' {0}","{1} 'at' {0}","{1}, {0}","{1}, {0}"],jd:6,pe:[5,6],kd:5},EJ=DJ;
EJ=DJ;function FJ(a,b,c,d,e,g){ba(a)?(this.Sa=a==GJ?b:0,this.Pa=a==HJ?b:0,this.Ta=a==IJ?b:0,this.Na=a==JJ?b:0,this.Oa=a==KJ?b:0,this.Ra=a==LJ?b:0):(this.Sa=a||0,this.Pa=b||0,this.Ta=c||0,this.Na=d||0,this.Oa=e||0,this.Ra=g||0)}
FJ.prototype.ic=function(a){var b=Math.min(this.Sa,this.Pa,this.Ta,this.Na,this.Oa,this.Ra),c=Math.max(this.Sa,this.Pa,this.Ta,this.Na,this.Oa,this.Ra);if(0>b&&0<c)return null;if(!a&&0==b&&0==c)return"PT0S";c=[];0>b&&c.push("-");c.push("P");(this.Sa||a)&&c.push(Math.abs(this.Sa)+"Y");(this.Pa||a)&&c.push(Math.abs(this.Pa)+"M");(this.Ta||a)&&c.push(Math.abs(this.Ta)+"D");if(this.Na||this.Oa||this.Ra||a)c.push("T"),(this.Na||a)&&c.push(Math.abs(this.Na)+"H"),(this.Oa||a)&&c.push(Math.abs(this.Oa)+"M"),
(this.Ra||a)&&c.push(Math.abs(this.Ra)+"S");return c.join("")};FJ.prototype.clone=function(){return new FJ(this.Sa,this.Pa,this.Ta,this.Na,this.Oa,this.Ra)};var GJ="y",HJ="m",IJ="d",JJ="h",KJ="n",LJ="s";FJ.prototype.ib=function(){return 0==this.Sa&&0==this.Pa&&0==this.Ta&&0==this.Na&&0==this.Oa&&0==this.Ra};FJ.prototype.add=function(a){this.Sa+=a.Sa;this.Pa+=a.Pa;this.Ta+=a.Ta;this.Na+=a.Na;this.Oa+=a.Oa;this.Ra+=a.Ra};
function MJ(a,b,c){"number"==typeof a?(this.date=NJ(a,b||0,c||1),OJ(this,c||1)):(b=typeof a,"object"==b&&null!=a||"function"==b?(this.date=NJ(a.getFullYear(),a.getMonth(),a.getDate()),OJ(this,a.getDate())):(this.date=new Date(na()),a=this.date.getDate(),this.date.setHours(0),this.date.setMinutes(0),this.date.setSeconds(0),this.date.setMilliseconds(0),OJ(this,a)))}function NJ(a,b,c){b=new Date(a,b,c);0<=a&&100>a&&b.setFullYear(b.getFullYear()-1900);return b}f=MJ.prototype;f.Lb=EJ.jd;f.Mb=EJ.kd;
f.clone=function(){var a=new MJ(this.date);a.Lb=this.Lb;a.Mb=this.Mb;return a};f.getFullYear=function(){return this.date.getFullYear()};f.getYear=function(){return this.getFullYear()};f.getMonth=function(){return this.date.getMonth()};f.getDate=function(){return this.date.getDate()};f.getTime=function(){return this.date.getTime()};f.getDay=function(){return this.date.getDay()};f.getUTCFullYear=function(){return this.date.getUTCFullYear()};f.getUTCMonth=function(){return this.date.getUTCMonth()};
f.getUTCDate=function(){return this.date.getUTCDate()};f.getUTCDay=function(){return this.date.getDay()};f.getUTCHours=function(){return this.date.getUTCHours()};f.getUTCMinutes=function(){return this.date.getUTCMinutes()};f.getTimezoneOffset=function(){return this.date.getTimezoneOffset()};f.set=function(a){this.date=new Date(a.getFullYear(),a.getMonth(),a.getDate())};f.setFullYear=function(a){this.date.setFullYear(a)};f.setYear=function(a){this.setFullYear(a)};f.setMonth=function(a){this.date.setMonth(a)};
f.setDate=function(a){this.date.setDate(a)};f.setTime=function(a){this.date.setTime(a)};f.setUTCFullYear=function(a){this.date.setUTCFullYear(a)};f.setUTCMonth=function(a){this.date.setUTCMonth(a)};f.setUTCDate=function(a){this.date.setUTCDate(a)};
f.add=function(a){if(a.Sa||a.Pa){var b=this.getMonth()+a.Pa+12*a.Sa,c=this.getYear()+Math.floor(b/12);b%=12;0>b&&(b+=12);a:{switch(b){case 1:var d=0!=c%4||0==c%100&&0!=c%400?28:29;break a;case 5:case 8:case 10:case 3:d=30;break a}d=31}d=Math.min(d,this.getDate());this.setDate(1);this.setFullYear(c);this.setMonth(b);this.setDate(d)}a.Ta&&(b=new Date(this.getYear(),this.getMonth(),this.getDate(),12),a=new Date(b.getTime()+864E5*a.Ta),this.setDate(1),this.setFullYear(a.getFullYear()),this.setMonth(a.getMonth()),
this.setDate(a.getDate()),OJ(this,a.getDate()))};f.ic=function(a){return[this.getFullYear(),sa(this.getMonth()+1),sa(this.getDate())].join(a?"-":"")+""};f.toString=function(){return this.ic()};function OJ(a,b){a.getDate()!=b&&(b=a.getDate()<b?1:-1,a.date.setUTCHours(a.date.getUTCHours()+b))}f.valueOf=function(){return this.date.valueOf()};function PJ(a,b,c,d,e,g,h){this.date="number"==typeof a?new Date(a,b||0,c||1,d||0,e||0,g||0,h||0):new Date(a&&a.getTime?a.getTime():na())}oa(PJ,MJ);f=PJ.prototype;
f.getHours=function(){return this.date.getHours()};f.getMinutes=function(){return this.date.getMinutes()};f.getSeconds=function(){return this.date.getSeconds()};f.getMilliseconds=function(){return this.date.getMilliseconds()};f.getUTCDay=function(){return this.date.getUTCDay()};f.getUTCHours=function(){return this.date.getUTCHours()};f.getUTCMinutes=function(){return this.date.getUTCMinutes()};f.getUTCSeconds=function(){return this.date.getUTCSeconds()};f.getUTCMilliseconds=function(){return this.date.getUTCMilliseconds()};
f.setHours=function(a){this.date.setHours(a)};f.setMinutes=function(a){this.date.setMinutes(a)};f.setSeconds=function(a){this.date.setSeconds(a)};f.setMilliseconds=function(a){this.date.setMilliseconds(a)};f.setUTCHours=function(a){this.date.setUTCHours(a)};f.setUTCMinutes=function(a){this.date.setUTCMinutes(a)};f.setUTCSeconds=function(a){this.date.setUTCSeconds(a)};f.setUTCMilliseconds=function(a){this.date.setUTCMilliseconds(a)};
f.add=function(a){MJ.prototype.add.call(this,a);a.Na&&this.setUTCHours(this.date.getUTCHours()+a.Na);a.Oa&&this.setUTCMinutes(this.date.getUTCMinutes()+a.Oa);a.Ra&&this.setUTCSeconds(this.date.getUTCSeconds()+a.Ra)};f.ic=function(a){var b=MJ.prototype.ic.call(this,a);return a?b+" "+sa(this.getHours())+":"+sa(this.getMinutes())+":"+sa(this.getSeconds()):b+"T"+sa(this.getHours())+sa(this.getMinutes())+sa(this.getSeconds())};f.toString=function(){return this.ic()};
f.clone=function(){var a=new PJ(this.date);a.Lb=this.Lb;a.Mb=this.Mb;return a};function QJ(a,b,c,d,e,g,h){a="number"==typeof a?Date.UTC(a,b||0,c||1,d||0,e||0,g||0,h||0):a?a.getTime():na();this.date=new Date(a)}oa(QJ,PJ);f=QJ.prototype;f.clone=function(){var a=new QJ(this.date);a.Lb=this.Lb;a.Mb=this.Mb;return a};f.add=function(a){(a.Sa||a.Pa)&&MJ.prototype.add.call(this,new FJ(a.Sa,a.Pa));this.date=new Date(this.date.getTime()+1E3*(a.Ra+60*(a.Oa+60*(a.Na+24*a.Ta))))};f.getTimezoneOffset=function(){return 0};f.getFullYear=PJ.prototype.getUTCFullYear;f.getMonth=PJ.prototype.getUTCMonth;
f.getDate=PJ.prototype.getUTCDate;f.getHours=PJ.prototype.getUTCHours;f.getMinutes=PJ.prototype.getUTCMinutes;f.getSeconds=PJ.prototype.getUTCSeconds;f.getMilliseconds=PJ.prototype.getUTCMilliseconds;f.getDay=PJ.prototype.getUTCDay;f.setFullYear=PJ.prototype.setUTCFullYear;f.setMonth=PJ.prototype.setUTCMonth;f.setDate=PJ.prototype.setUTCDate;f.setHours=PJ.prototype.setUTCHours;f.setMinutes=PJ.prototype.setUTCMinutes;f.setSeconds=PJ.prototype.setUTCSeconds;f.setMilliseconds=PJ.prototype.setUTCMilliseconds;function RJ(a){return(null!=a?a.o&32768||k===a.oc||(a.o?0:gb(Ub,a)):gb(Ub,a))?w(a):a}function SJ(a){if(null!=a?a.o&32768||k===a.oc||(a.o?0:gb(Ub,a)):gb(Ub,a)){if(a instanceof PE)return a.state;if(a instanceof ZE)return $E(a);if(a instanceof UE)return VE(a);if(a instanceof TE)return w(a);throw Error("Unknown reactive data type");}return a}
function TJ(a){for(var b=[],c=arguments.length,d=0;;)if(d<c)b.push(arguments[d]),d+=1;else break;return UJ(arguments[0],1<b.length?new D(b.slice(1),0,null):null)}function UJ(a,b){return[u.h(t(b)?-a:a),"px"].join("")};function VJ(a,b){a=u.h(a);a.length>b&&(a=a.substring(0,b-3)+"...");return a}var WJ=function WJ(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return WJ.l(0<c.length?new D(c.slice(0),0,null):null)};WJ.l=function(a){console.error(N.c(u,a));return!1};WJ.D=0;WJ.C=function(a){return this.l(B(a))};var XJ=function XJ(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return XJ.l(0<c.length?new D(c.slice(0),0,null):null)};
XJ.l=function(a){console.warn(N.c(u,a));return!0};XJ.D=0;XJ.C=function(a){return this.l(B(a))};function YJ(a){var b=hh(qf.c(S,a)),c=hh(qf.c(S,yf(Z,a)));a=bg(yf(V,a));a=jh(qf.c(S,a),a);return new p(null,3,[Bw,b,uo,c,nm,a],null)}
function ZJ(a,b,c){return af(Wd,qf.c(function(a){M(a,0,null);var d=M(a,1,null);a=S.h(d);var g=SJ(a.h?a.h(b):a.call(null,b)),h=Z.h(d),l=V.h(d);var m=l.h?l.h(g):l.call(null,g);a=["Validation failed for argument '",u.h(a),"' in component '",u.h(c),"': "].join("");var n=[" at ",zF(gF)].join("");l=H.c(Nv.h(m),nu);return!0===m||null==g&&eb(h)?!0:!1===m?WJ.l(L([a,"Expected '",U.h(d),"'. Got '",null==g?"nil":VJ(g,60),"'",n])):Qd(m)?(d=ZC.h(m),g=l?n:null,h=l?XJ:WJ,h.j?h.j(a,d,g):h.call(null,a,d,g)):WJ.l(L(["Invalid return from validate-fn: ",
m,n]))},bh(a,bg(xg(b)))))}function $J(a,b,c){var d=hh(xg(b)),e=Bw.h(a),g=wE(e,d);if(e=g?g:WJ.l(L(["Invalid argument(s): ",zf(e,d)])))e=uo.h(a),e=(g=wE(d,e))?g:WJ.l(L(["Missing required argument(s): ",zf(d,e)]));return e&&ZJ(nm.h(a),b,E(c))}
var aK=new O(null,5,5,P,[Np,iA,Ws,qq,iD],null),bK=new O(null,5,5,P,[Np,iA,Ws,ej,wB],null),cK=new O(null,4,5,P,[PB,Yw,gz,ks],null),dK=new O(null,4,5,P,[IC,Gx,nu,av],null),eK=new O(null,3,5,P,[ek,Fm,Qv],null),fK=new O(null,4,5,P,[ek,Fm,it,Ci],null),gK=new O(null,4,5,P,[bv,nu,cz,Ms],null),hK=new O(null,5,5,P,[bv,nu,cz,Ms,Gx],null),iK=new O(null,4,5,P,[fC,Yo,jn,Gs],null),jK=new O(null,12,5,P,[pi,vi,OC,Eq,Wp,NB,To,ik,ky,nx,Xu,Ck],null);
function kK(a,b,c){a=SJ(a);var d=Ue.c(bf(gh([a]),c),null);return d?d:["Invalid ",u.h(b),". Expected one of ",u.h(c),". Got '",u.h(VJ(a,40)),"'"].join("")}function lK(a){return kK(a,":justify-style",aK)}function mK(a){return kK(a,":align-style",bK)}function nK(a){return kK(a,":position",jK)}function oK(a){return jf.c(new O(null,1,5,P,[AD],null),xf(", ",qf.c(function(a){return new O(null,2,5,P,[Jx,u.h(a)],null)},a)))}var pK=oK(aK),qK=oK(bK);oK(cK);oK(dK);oK(eK);oK(fK);oK(gK);var rK=oK(hK);oK(iK);
var sK=oK(jK),tK=new dh(null,new p(null,492,[ni,null,qi,null,ti,null,zi,null,Bi,null,Di,null,Ei,null,Gi,null,Ii,null,Ki,null,Li,null,Oi,null,Pi,null,Ti,null,Ui,null,Yi,null,aj,null,cj,null,gj,null,ij,null,jj,null,kj,null,mj,null,nj,null,pj,null,tj,null,uj,null,wj,null,xj,null,yj,null,Aj,null,Bj,null,Cj,null,Dj,null,Ij,null,Jj,null,Kj,null,Nj,null,Oj,null,Pj,null,Qj,null,Uj,null,Vj,null,Wj,null,gk,null,jk,null,mk,null,ok,null,rk,null,vk,null,yk,null,Ak,null,Bk,null,Fk,null,Hk,null,Ik,null,Rk,null,
Tk,null,Uk,null,Vk,null,Xk,null,Yk,null,fl,null,gl,null,hl,null,jl,null,ml,null,ol,null,rl,null,vl,null,yl,null,Al,null,Fl,null,Gl,null,Hl,null,Ll,null,Ol,null,Sl,null,Tl,null,Ul,null,Xl,null,am,null,fm,null,hm,null,im,null,mm,null,om,null,qm,null,rm,null,um,null,Dm,null,Em,null,Mm,null,Om,null,Rm,null,Tm,null,Wm,null,Ym,null,Zm,null,$m,null,en,null,gn,null,hn,null,ln,null,on,null,pn,null,rn,null,sn,null,xn,null,zn,null,Bn,null,En,null,Fn,null,Gn,null,Hn,null,Jn,null,Kn,null,ci,null,Mn,null,Nn,null,
On,null,Rn,null,Wn,null,Zn,null,$n,null,io,null,ko,null,lo,null,S,null,po,null,qo,null,ro,null,so,null,xo,null,Co,null,Eo,null,Go,null,Io,null,Ko,null,Lo,null,Qo,null,So,null,ap,null,ep,null,ip,null,lp,null,qp,null,rp,null,sp,null,vp,null,Ap,null,Cp,null,Dp,null,Fp,null,Gp,null,Jp,null,Lp,null,Np,null,Pp,null,Qp,null,Rp,null,Sp,null,Vp,null,Yp,null,Zp,null,aq,null,cq,null,eq,null,hq,null,nq,null,tq,null,vq,null,yq,null,Cq,null,Dq,null,U,null,Kq,null,Lq,null,Nq,null,Qq,null,Rq,null,Uq,null,Xq,null,
Yq,null,$q,null,ar,null,cr,null,dr,null,er,null,fr,null,gr,null,jr,null,kr,null,pr,null,qr,null,sr,null,tr,null,ur,null,wr,null,xr,null,yr,null,Cr,null,Er,null,Fr,null,Gr,null,Or,null,Qr,null,bs,null,es,null,hs,null,ms,null,ns,null,ps,null,qs,null,ws,null,ys,null,zs,null,As,null,Bs,null,Cs,null,Fs,null,Is,null,Ns,null,Os,null,Qs,null,Ts,null,Us,null,Xs,null,Zs,null,at,null,dt,null,gt,null,nt,null,ot,null,pt,null,st,null,tt,null,ut,null,vt,null,xt,null,yt,null,zt,null,At,null,Bt,null,Ct,null,Ht,null,
Jt,null,Lt,null,Qt,null,Rt,null,Ut,null,Vt,null,Wt,null,Xt,null,au,null,bu,null,eu,null,hu,null,iu,null,ku,null,mu,null,ru,null,su,null,tu,null,yu,null,zu,null,Bu,null,Cu,null,Du,null,Eu,null,Iu,null,Ju,null,Lu,null,Mu,null,Ou,null,Tu,null,Wu,null,Yu,null,dv,null,gv,null,iv,null,jv,null,lv,null,nv,null,pv,null,rv,null,uv,null,vv,null,wv,null,xv,null,yv,null,Av,null,Dv,null,Ev,null,Lv,null,Mv,null,Ov,null,Rv,null,Tv,null,Xv,null,Zv,null,$v,null,aw,null,bw,null,iw,null,kw,null,mw,null,ow,null,pw,null,
qw,null,sw,null,tw,null,uw,null,ww,null,yw,null,zw,null,Cw,null,Dw,null,Fw,null,Gw,null,Hw,null,Kw,null,Lw,null,Mw,null,Nw,null,Rw,null,Tw,null,Uw,null,Xw,null,Zw,null,$w,null,dx,null,ix,null,jx,null,kx,null,lx,null,tx,null,vx,null,yx,null,Ax,null,Bx,null,Dx,null,Kx,null,Ox,null,Px,null,Qx,null,Rx,null,Sx,null,dy,null,fy,null,hy,null,iy,null,jy,null,ly,null,my,null,ry,null,uy,null,wy,null,Ay,null,Cy,null,Dy,null,Ey,null,Fy,null,Hy,null,Jy,null,My,null,Ny,null,Oy,null,Py,null,Ty,null,Vy,null,Wy,null,
Xy,null,Zy,null,$y,null,bz,null,dz,null,ez,null,hz,null,kz,null,lz,null,mz,null,oz,null,rz,null,uz,null,vz,null,wz,null,xz,null,yz,null,Bz,null,Dz,null,Ez,null,Fz,null,Jz,null,Kz,null,Pz,null,Rz,null,Sz,null,Tz,null,Uz,null,Vz,null,Xz,null,Yz,null,Zz,null,$z,null,aA,null,hA,null,iA,null,lA,null,pA,null,qA,null,sA,null,uA,null,wA,null,zA,null,DA,null,EA,null,GA,null,HA,null,LA,null,MA,null,PA,null,QA,null,UA,null,WA,null,ZA,null,$A,null,fB,null,iB,null,jB,null,kB,null,oB,null,qB,null,vB,null,AB,null,
CB,null,DB,null,EB,null,FB,null,IB,null,LB,null,QB,null,RB,null,SB,null,WB,null,XB,null,YB,null,ZB,null,dC,null,eC,null,hC,null,kC,null,lC,null,pC,null,qC,null,rC,null,vC,null,wC,null,yC,null,zC,null,BC,null,CC,null,DC,null,EC,null,GC,null,Z,null,MC,null,NC,null,QC,null,TC,null,VC,null,WC,null,aD,null,bD,null,cD,null,eD,null,fD,null,kD,null,lD,null,pD,null,qD,null,rD,null,tD,null,wD,null,xD,null,AD,null,DD,null,ED,null,FD,null,GD,null,KD,null,MD,null],null),null),uK=new dh(null,new p(null,2,[hv,null,
KD,null],null),null),vK=new dh(null,new p(null,332,[mi,null,oi,null,ri,null,si,null,wi,null,Ai,null,Fi,null,Ki,null,Mi,null,Oi,null,Qi,null,Vi,null,Xi,null,bj,null,fj,null,gj,null,ij,null,lj,null,oj,null,rj,null,sj,null,zj,null,Ej,null,Fj,null,Pj,null,Rj,null,Sj,null,Tj,null,ak,null,bk,null,hk,null,nk,null,pk,null,qk,null,tk,null,xk,null,Dk,null,Lk,null,Pk,null,Sk,null,Uk,null,Wk,null,Zk,null,al,null,cl,null,dl,null,ll,null,ol,null,ql,null,sl,null,ul,null,xl,null,Dl,null,El,null,Il,null,Jl,null,Kl,
null,Ml,null,Ql,null,Rl,null,Wl,null,Yl,null,Zl,null,bm,null,cm,null,dm,null,lm,null,sm,null,tm,null,Am,null,Bm,null,Cm,null,Hm,null,Im,null,Mm,null,Um,null,Vm,null,cn,null,fn,null,on,null,pn,null,rn,null,tn,null,yn,null,Jn,null,Ln,null,Qn,null,Sn,null,Tn,null,Un,null,Vn,null,Wn,null,Yn,null,fo,null,go,null,jo,null,oo,null,Ao,null,Bo,null,Ho,null,Jo,null,Mo,null,No,null,Oo,null,Po,null,Uo,null,Vo,null,Zo,null,$o,null,bp,null,cp,null,dp,null,gp,null,hp,null,mp,null,np,null,up,null,Ep,null,Hp,null,
Ip,null,Kp,null,Lp,null,Mp,null,Op,null,Tp,null,Up,null,Xp,null,$p,null,dq,null,gq,null,iq,null,jq,null,kq,null,lq,null,oq,null,pq,null,rq,null,sq,null,vq,null,Bq,null,Gq,null,Jq,null,Pq,null,Tq,null,Vq,null,hr,null,ir,null,or,null,vr,null,zr,null,Dr,null,Ir,null,Jr,null,Mr,null,Pr,null,Rr,null,Sr,null,Ur,null,Wr,null,Xr,null,Zr,null,as,null,cs,null,es,null,fs,null,is,null,js,null,ls,null,ts,null,us,null,vs,null,xs,null,Es,null,Js,null,Ks,null,Ls,null,Ps,null,Rs,null,Ss,null,Vs,null,ct,null,ht,null,
mt,null,ot,null,pt,null,qt,null,rt,null,Gt,null,Kt,null,Ot,null,Tt,null,Zt,null,fu,null,vu,null,wu,null,Gu,null,Mu,null,Pu,null,Su,null,Uu,null,Zu,null,cv,null,ev,null,mv,null,ov,null,qv,null,sv,null,zv,null,Gv,null,Hv,null,Jv,null,Uv,null,Wv,null,cw,null,dw,null,ew,null,fw,null,gw,null,jw,null,kw,null,vw,null,Ww,null,ax,null,ex,null,fx,null,gx,null,hx,null,ox,null,px,null,xx,null,Fx,null,Ix,null,Lx,null,Ux,null,Yx,null,Zx,null,$x,null,ay,null,by,null,cy,null,ey,null,ny,null,oy,null,qy,null,sy,null,
vy,null,zy,null,Ay,null,By,null,Gy,null,Hy,null,Iy,null,Ky,null,Py,null,Ry,null,Sy,null,Uy,null,iz,null,pz,null,sz,null,tz,null,vz,null,Cz,null,Mz,null,Oz,null,Qz,null,aA,null,eA,null,fA,null,gA,null,jA,null,mA,null,oA,null,rA,null,xA,null,BA,null,IA,null,NA,null,SA,null,TA,null,XA,null,aB,null,cB,null,dB,null,eB,null,hB,null,kB,null,lB,null,mB,null,nB,null,rB,null,uB,null,xB,null,AB,null,BB,null,GB,null,HB,null,KB,null,MB,null,OB,null,TB,null,VB,null,$B,null,bC,null,iC,null,mC,null,pC,null,sC,null,
xC,null,AC,null,BC,null,HC,null,JC,null,KC,null,LC,null,RC,null,TC,null,UC,null,YC,null,$C,null,bD,null,dD,null,lD,null,mD,null,nD,null,oD,null,sD,null,yD,null,HD,null,ID,null,JD,null,ND,null],null),null);function wK(a){a=SJ(a);return HF(a)||ee(a)||!1}function xK(a){a=SJ(a);var b=Qd(a);return b?(a=xg(a),(b=wE(vK,a))?b:new p(null,2,[Nv,nu,ZC,["Unknown CSS style(s): ",u.h(zf(vK,a))].join("")],null)):b}
function yK(a){a=Ae(a);var b=function(a){return function(b){return H.c(a.indexOf(b),0)&&K(a)>K(b)}}(a);return bf(ef.j(b,function(){return function(a){return[u.h(a),"-"].join("")}}(a,b),Ae),uK)}function zK(a){return zf(function(a){var b=tK.h?tK.h(a):tK.call(null,a);return t(b)?b:yK(a)},a)}
function AK(a){a=SJ(a);var b=Qd(a);if(b){var c=hh(xg(a));a=fe(c,xw);b=fe(c,jt);a?c=":class not allowed in :attr argument":b?c=":style not allowed in :attr argument":(c=Ve(zK(c)),c=t(c)?["Unknown HTML attribute(s): ",u.h(c)].join(""):null);var d=null==c;return d?d:new p(null,2,[Nv,a||b?cz:nu,ZC,c],null)}return b}function BK(a){a=SJ(a);return H.c(QJ,hb(a))||H.c(MJ,hb(a))}function CK(a){a=SJ(a);return"number"===typeof a||"string"===typeof a};function DK(a){var b=$D(pa(a),/\s+/),c=K(b);if(!fe(new dh(null,new p(null,2,[1,null,3,null],null),null),c))throw Error("Assert failed: Must pass either 1 or 3 words to flex-child-style\n(contains? #{1 3} split-count)");b=H.c(c,1)?E(b):null;c=t(b)?$D(b,/(\d+)(.*)/):null;var d=t(b)?c:null;M(d,0,null);c=M(d,1,null);var e=M(d,2,null);d=null==c;var g=(e=H.c(e,"%")||H.c(e,"")||null==e)?"1":"0",h=e?"0px":a;a=t(t(b)?!d:b)?[u.h(e?c:"0")," ",g," ",u.h(h)].join(""):a;return new p(null,2,[Hp,a,Jq,a],null)}
function EK(a){return new p(null,2,[$o,a,HD,a],null)}function FK(a){var b=function(){var b=a instanceof q?a.U:null;switch(b){case "start":return"flex-start";case "end":return"flex-end";case "center":return"center";case "between":return"space-between";case "around":return"space-around";default:throw Error(["No matching clause: ",u.h(b)].join(""));}}();return new p(null,2,[Kp,b,xx,b],null)}
function GK(a,b){var c=ze.h(["-webkit-",Ae(a)].join("")),d=function(){var a=b instanceof q?b.U:null;switch(a){case "start":return"flex-start";case "end":return"flex-end";case "center":return"center";case "baseline":return"baseline";case "stretch":return"stretch";default:throw Error(["No matching clause: ",u.h(a)].join(""));}}();return Ed([c,d,a,d])}
function HK(a,b){return Ed([a,function(){var a=b instanceof q?b.U:null;switch(a){case "auto":return"auto";case "off":return"hidden";case "on":return"scroll";case "spill":return"visible";default:throw Error(["No matching clause: ",u.h(a)].join(""));}}()])}
var IK=new O(null,6,5,P,[new p(null,5,[S,ws,Z,!0,U,"string",V,fb,R,"the length of the whitespace.  Typically, an absolute CSS length like 10px or 10em, but can be a stretchy proportional amount like 2"],null),new p(null,5,[S,Lp,Z,!1,U,"string",V,fb,R,"a CSS width style"],null),new p(null,5,[S,bD,Z,!1,U,"string",V,fb,R,"a CSS height style"],null),new p(null,5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated"],null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"CSS styles to add or override"],
null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,2,5,P,[Jx,":style"],null),"allowed"],null)],null)],null),JK=function JK(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return JK.l(0<c.length?new D(c.slice(0),0,null):null)};
JK.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,ws),d=A.c(b,Lp),e=A.c(b,bD);a=A.c(b,xw);var g=A.c(b,jt),h=A.c(b,QD);if(!$J(YJ(IK),b,L(["gap"])))throw Error('Assert failed: (validate-args-macro gap-args-desc args "gap")');b=ah.l(L([t(c)?DK(c):null,t(d)?new p(null,1,[Lp,d],null):null,t(e)?new p(null,1,[bD,e],null):null,null,g]));return new O(null,2,5,P,[Et,ah.l(L([new p(null,2,[xw,["rc-gap ",u.h(a)].join(""),jt,b],null),h]))],null)};JK.D=0;JK.C=function(a){return this.l(B(a))};
var KK=new O(null,17,5,P,[new p(null,5,[S,Xj,Z,!0,U,"vector",V,Pd,R,"a vector (or list) of components"],null),new p(null,6,[S,ws,Z,!1,ci,"none",U,"string",V,fb,R,new O(null,17,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"flex"],null),".",new O(null,1,5,P,[fz],null),"Examples: ",new O(null,2,5,P,[Jx,"initial"],null),", ",new O(null,2,5,P,[Jx,"auto"],null),", ",new O(null,2,5,P,[Jx,"none"],null),", ",new O(null,2,5,P,[Jx,"100px"],null),", ",new O(null,2,5,P,[Jx,"2"],null)," or a generic triple of ",
new O(null,2,5,P,[Jx,"grow shrink basis"],null)],null)],null),new p(null,5,[S,Lp,Z,!1,U,"string",V,fb,R,"a CSS width style"],null),new p(null,5,[S,bD,Z,!1,U,"string",V,fb,R,"a CSS height style"],null),new p(null,5,[S,Mi,Z,!1,U,"string",V,fb,R,"a CSS width style. The minimum width to which the box can shrink"],null),new p(null,5,[S,Yl,Z,!1,U,"string",V,fb,R,"a CSS height style. The minimum height to which the box can shrink"],null),new p(null,5,[S,vr,Z,!1,U,"string",V,fb,R,"a CSS width style. The maximum width to which the box can grow"],
null),new p(null,5,[S,Zk,Z,!1,U,"string",V,fb,R,"a CSS height style. The maximum height to which the box can grow"],null),new p(null,6,[S,In,Z,!1,ci,Np,U,"keyword",V,lK,R,new O(null,7,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"justify-content"],null),".",new O(null,1,5,P,[fz],null),"One of ",pK],null)],null),new p(null,6,[S,ck,Z,!1,ci,wB,U,"keyword",V,mK,R,new O(null,7,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"align-items"],null),".",new O(null,1,5,P,[fz],null)," One of ",
qK],null)],null),new p(null,5,[S,fA,Z,!1,U,"keyword",V,mK,R,new O(null,6,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"align-self"],null),".",new O(null,1,5,P,[fz],null),"Used when a child must override the parent's align-items setting."],null)],null),new p(null,5,[S,JD,Z,!1,U,"string",V,fb,R,"a CSS margin style"],null),new p(null,5,[S,Ww,Z,!1,U,"string",V,fb,R,"a CSS padding style"],null),new p(null,5,[S,Ex,Z,!1,U,"string",V,fb,R,"the amount of whitespace to put between each child. Typically, an absolute CSS length like 10px or 10em, but can be a stretchy proportional amount like 2"],
null),new p(null,5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated"],null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"CSS styles to add or override"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,2,5,P,[Jx,":style"],null),"allowed"],null)],null)],null),LK=function LK(a){for(var c=[],d=arguments.length,
e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return LK.l(0<c.length?new D(c.slice(0),0,null):null)};
LK.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,fA),d=A.c(b,bD),e=A.c(b,JD);a=A.c(b,QD);var g=A.c(b,Mi),h=A.c(b,Xj),l=A.j(b,ck,wB),m=A.c(b,Zk),n=A.c(b,Yl),r=A.j(b,In,Np),v=A.c(b,Lp),x=A.c(b,vr),y=A.j(b,ws,"none"),z=A.c(b,jt),C=A.c(b,xw),F=A.c(b,Ww),I=A.c(b,Ex);if(!$J(YJ(KK),b,L(["h-box"])))throw Error('Assert failed: (validate-args-macro h-box-args-desc args "h-box")');b=ah.l(L([EK("row nowrap"),DK(y),t(v)?new p(null,1,[Lp,v],null):null,t(d)?new p(null,1,[bD,d],null):null,t(g)?
new p(null,1,[Mi,g],null):null,t(n)?new p(null,1,[Yl,n],null):null,t(x)?new p(null,1,[vr,x],null):null,t(m)?new p(null,1,[Zk,m],null):null,FK(r),GK(bk,l),t(c)?GK(fA,c):null,t(e)?new p(null,1,[JD,e],null):null,t(F)?new p(null,1,[Ww,F],null):null,null,z]));c=t(I)?new O(null,5,5,P,[JK,ws,I,Lp,I],null):null;h=t(I)?xf(c,yf(ke,h)):h;return jf.c(new O(null,2,5,P,[Et,ah.l(L([new p(null,2,[xw,["rc-h-box display-flex ",u.h(C)].join(""),jt,b],null),a]))],null),h)};LK.D=0;LK.C=function(a){return this.l(B(a))};
var MK=new O(null,17,5,P,[new p(null,5,[S,Xj,Z,!0,U,"vector",V,Pd,R,"a vector (or list) of components"],null),new p(null,6,[S,ws,Z,!1,ci,"none",U,"string",V,fb,R,new O(null,17,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"flex"],null),".",new O(null,1,5,P,[fz],null),"Examples: ",new O(null,2,5,P,[Jx,"initial"],null),", ",new O(null,2,5,P,[Jx,"auto"],null),", ",new O(null,2,5,P,[Jx,"none"],null),", ",new O(null,2,5,P,[Jx,"100px"],null),", ",new O(null,2,5,P,[Jx,"2"],null)," or a generic triple of ",
new O(null,2,5,P,[Jx,"grow shrink basis"],null)],null)],null),new p(null,5,[S,Lp,Z,!1,U,"string",V,fb,R,"a CSS width style"],null),new p(null,5,[S,bD,Z,!1,U,"string",V,fb,R,"a CSS height style"],null),new p(null,5,[S,Mi,Z,!1,U,"string",V,fb,R,"a CSS width style. The minimum width to which the box can shrink"],null),new p(null,5,[S,Yl,Z,!1,U,"string",V,fb,R,"a CSS height style. The minimum height to which the box can shrink"],null),new p(null,5,[S,vr,Z,!1,U,"string",V,fb,R,"a CSS width style. The maximum width to which the box can grow"],
null),new p(null,5,[S,Zk,Z,!1,U,"string",V,fb,R,"a CSS height style. The maximum height to which the box can grow"],null),new p(null,6,[S,In,Z,!1,ci,Np,U,"keyword",V,lK,R,new O(null,7,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"justify-content"],null),".",new O(null,1,5,P,[fz],null),"One of ",pK],null)],null),new p(null,6,[S,ck,Z,!1,ci,wB,U,"keyword",V,mK,R,new O(null,7,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"align-items"],null),".",new O(null,1,5,P,[fz],null)," One of ",
qK],null)],null),new p(null,5,[S,fA,Z,!1,U,"keyword",V,mK,R,new O(null,6,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"align-self"],null),".",new O(null,1,5,P,[fz],null),"Used when a child must override the parent's align-items setting."],null)],null),new p(null,5,[S,JD,Z,!1,U,"string",V,fb,R,"a CSS margin style"],null),new p(null,5,[S,Ww,Z,!1,U,"string",V,fb,R,"a CSS padding style"],null),new p(null,5,[S,Ex,Z,!1,U,"string",V,fb,R,"the amount of whitespace to put between each child. Typically, an absolute CSS length like 10px or 10em, but can be a stretchy proportional amount like 2"],
null),new p(null,5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated"],null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"CSS styles to add or override"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,2,5,P,[Jx,":style"],null),"allowed"],null)],null)],null),NK=function NK(a){for(var c=[],d=arguments.length,
e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return NK.l(0<c.length?new D(c.slice(0),0,null):null)};
NK.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,fA),d=A.c(b,bD),e=A.c(b,JD);a=A.c(b,QD);var g=A.c(b,Mi),h=A.c(b,Xj),l=A.j(b,ck,wB),m=A.c(b,Zk),n=A.c(b,Yl),r=A.j(b,In,Np),v=A.c(b,Lp),x=A.c(b,vr),y=A.j(b,ws,"none"),z=A.c(b,jt),C=A.c(b,xw),F=A.c(b,Ww),I=A.c(b,Ex);if(!$J(YJ(MK),b,L(["v-box"])))throw Error('Assert failed: (validate-args-macro v-box-args-desc args "v-box")');b=ah.l(L([EK("column nowrap"),DK(y),t(v)?new p(null,1,[Lp,v],null):null,t(d)?new p(null,1,[bD,d],null):null,
t(g)?new p(null,1,[Mi,g],null):null,t(n)?new p(null,1,[Yl,n],null):null,t(x)?new p(null,1,[vr,x],null):null,t(m)?new p(null,1,[Zk,m],null):null,FK(r),GK(bk,l),t(c)?GK(fA,c):null,t(e)?new p(null,1,[JD,e],null):null,t(F)?new p(null,1,[Ww,F],null):null,null,z]));c=t(I)?new O(null,5,5,P,[JK,ws,I,bD,I],null):null;h=t(I)?xf(c,yf(ke,h)):h;return jf.c(new O(null,2,5,P,[Et,ah.l(L([new p(null,2,[xw,["rc-v-box display-flex ",u.h(C)].join(""),jt,b],null),a]))],null),h)};NK.D=0;NK.C=function(a){return this.l(B(a))};
var OK=new O(null,16,5,P,[new p(null,5,[S,zz,Z,!0,U,"string | hiccup",V,wK,R,"a component (or string)"],null),new p(null,6,[S,ws,Z,!1,ci,"none",U,"string",V,fb,R,new O(null,17,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"flex"],null),".",new O(null,1,5,P,[fz],null),"Examples: ",new O(null,2,5,P,[Jx,"initial"],null),", ",new O(null,2,5,P,[Jx,"auto"],null),", ",new O(null,2,5,P,[Jx,"none"],null),", ",new O(null,2,5,P,[Jx,"100px"],null),", ",new O(null,2,5,P,[Jx,"2"],null)," or a generic triple of ",
new O(null,2,5,P,[Jx,"grow shrink basis"],null)],null)],null),new p(null,5,[S,Lp,Z,!1,U,"string",V,fb,R,"a CSS width style"],null),new p(null,5,[S,bD,Z,!1,U,"string",V,fb,R,"a CSS height style"],null),new p(null,5,[S,Mi,Z,!1,U,"string",V,fb,R,"a CSS width style. The minimum width to which the box can shrink"],null),new p(null,5,[S,Yl,Z,!1,U,"string",V,fb,R,"a CSS height style. The minimum height to which the box can shrink"],null),new p(null,5,[S,vr,Z,!1,U,"string",V,fb,R,"a CSS width style. The maximum width to which the box can grow"],
null),new p(null,5,[S,Zk,Z,!1,U,"string",V,fb,R,"a CSS height style. The maximum height to which the box can grow"],null),new p(null,6,[S,In,Z,!1,ci,Np,U,"keyword",V,lK,R,new O(null,7,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"justify-content"],null),".",new O(null,1,5,P,[fz],null),"One of ",pK],null)],null),new p(null,6,[S,ck,Z,!1,ci,wB,U,"keyword",V,mK,R,new O(null,7,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"align-items"],null),".",new O(null,1,5,P,[fz],null)," One of ",
qK],null)],null),new p(null,5,[S,fA,Z,!1,U,"keyword",V,mK,R,new O(null,6,5,P,[AD,"equivalent to CSS style ",new O(null,2,5,P,[ou,"align-self"],null),".",new O(null,1,5,P,[fz],null),"Used when a child must override the parent's align-items setting."],null)],null),new p(null,5,[S,JD,Z,!1,U,"string",V,fb,R,"a CSS margin style"],null),new p(null,5,[S,Ww,Z,!1,U,"string",V,fb,R,"a CSS padding style"],null),new p(null,5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated"],null),new p(null,5,
[S,jt,Z,!1,U,"CSS style map",V,xK,R,"CSS styles to add or override"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,2,5,P,[Jx,":style"],null),"allowed"],null)],null)],null),PK=function PK(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return PK.l(0<c.length?new D(c.slice(0),
0,null):null)};
PK.l=function(a){a=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a;var b=A.c(a,zz),c=A.c(a,fA),d=A.c(a,bD),e=A.c(a,JD),g=A.c(a,QD),h=A.c(a,Mi),l=A.c(a,ck),m=A.c(a,Zk),n=A.c(a,Yl),r=A.c(a,In),v=A.c(a,Lp),x=A.c(a,vr),y=A.j(a,ws,"none"),z=A.c(a,jt),C=A.c(a,xw),F=A.c(a,Ww);if(!$J(YJ(OK),a,L(["box"])))throw Error('Assert failed: (validate-args-macro box-args-desc args "box")');a=L([ws,y,Lp,v,bD,d,Mi,h,Yl,n,vr,x,Zk,m,In,r,ck,l,fA,c,JD,e,Ww,F,zz,b,hz,"rc-box ",xw,C,jt,z,QD,g]);var I=null!=a&&(a.o&64||k===a.M)?N.c(Yg,
a):a;a=A.c(I,zz);d=A.c(I,fA);e=A.c(I,NA);g=A.c(I,JB);h=A.c(I,bD);l=A.c(I,JD);b=A.c(I,QD);m=A.c(I,Mi);n=A.c(I,ck);r=A.c(I,Ek);v=A.c(I,Zk);x=A.c(I,Yl);y=A.c(I,qn);z=A.c(I,In);C=A.c(I,zp);F=A.c(I,Lp);var T=A.c(I,lr),W=A.c(I,vr),ea=A.c(I,Qr),Ha=A.c(I,ws),Q=A.c(I,jt),X=A.c(I,Pv);c=A.c(I,xw);var Y=A.c(I,Vv),qa=A.c(I,Ww),ib=A.c(I,Hx);I=A.c(I,hz);d=ah.l(L([EK("inherit"),DK(Ha),t(X)?HK(Wn,X):null,t(C)?HK(Lx,C):null,t(g)?HK(cB,g):null,t(F)?new p(null,1,[Lp,F],null):null,t(h)?new p(null,1,[bD,h],null):null,
t(m)?new p(null,1,[Mi,m],null):null,t(x)?new p(null,1,[Yl,x],null):null,t(W)?new p(null,1,[vr,W],null):null,t(v)?new p(null,1,[Zk,v],null):null,t(z)?FK(z):null,t(n)?GK(bk,n):null,t(d)?GK(fA,d):null,t(l)?new p(null,1,[JD,l],null):null,t(qa)?new p(null,1,[Ww,qa],null):null,t(e)?new p(null,1,[NA,e],null):null,t(Y)?new p(null,1,[as,Y],null):null,t(y)?new p(null,1,[dl,y],null):null,t(ib)?new p(null,1,[XA,ib],null):null,t(T)?new p(null,1,[dD,T],null):null,t(ea)?new p(null,1,[dB,ea],null):null,t(r)?new p(null,
1,[mp,r],null):Xe,Q]));return new O(null,3,5,P,[Et,ah.l(L([new p(null,2,[xw,[u.h(I),"display-flex ",u.h(c)].join(""),jt,d],null),b])),a],null)};PK.D=0;PK.C=function(a){return this.l(B(a))};var QK=new O(null,12,5,P,[new p(null,5,[S,ns,Z,!1,U,"-\x3e nil",V,Gd,R,"a function which takes no params and returns nothing. Called when the button is clicked"],null),new p(null,6,[S,bq,Z,!1,ci,16,U,"number",V,cb,R,"numeric px size of the div containing the close button (can be 0 because the 'x' button text is absolutely positioned and centered within the div)"],null),new p(null,6,[S,Mm,Z,!1,ci,16,U,"number",V,cb,R,"numeric px font size of the 'x' button text"],null),new p(null,6,[S,Il,Z,!1,ci,"#ccc",
U,"string",V,fb,R,"HTML color of the 'x' button text"],null),new p(null,6,[S,Tx,Z,!1,ci,"#999",U,"string",V,fb,R,"HTML color of the button text when the mouse is hovering over it"],null),new p(null,5,[S,FC,Z,!1,U,"string | hiccup",V,wK,R,"what to show in the tooltip"],null),new p(null,5,[S,rx,Z,!1,U,"number",V,cb,R,"offset the 'x' button text up or down from it's default position in the containing div (can be positive or negative)"],null),new p(null,5,[S,pm,Z,!1,U,"number",V,cb,R,"offset the 'x' button text left or right from it's default position in the containing div (can be positive or negative)"],
null),new p(null,5,[S,YA,Z,!1,ci,!1,U,"boolean | atom",R,"if true, the user can't click the button"],null),new p(null,5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated (applies to the button, not the wrapping div)"],null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"CSS styles (applies to the button, not the wrapping div)"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,
1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,2,5,P,[Jx,":style"],null),"allowed (applies to the button, not the wrapping div)"],null)],null)],null);
function RK(){return function(a){return function(){function b(a){var b=null;if(0<arguments.length){b=0;for(var d=Array(arguments.length-0);b<d.length;)d[b]=arguments[b+0],++b;b=new D(d,0,null)}return c.call(this,b)}function c(b){var c=null!=b&&(b.o&64||k===b.M)?N.c(Yg,b):b,d=A.c(c,YA),h=A.c(c,FC),l=A.c(c,QD),m=A.c(c,pm),n=A.j(c,Il,"#ccc"),r=A.j(c,Mm,16),v=A.j(c,bq,16),x=A.c(c,ns),y=A.c(c,jt),z=A.c(c,xw),C=A.c(c,rx),F=A.j(c,Tx,"#999");if(!$J(YJ(QK),c,L(["close-button"])))throw Error('Assert failed: (validate-args-macro close-button-args-desc args "close-button")');
var I=RJ(d);return new O(null,7,5,P,[PK,xw,"rc-close-button",jt,new p(null,4,[Hy,"inline-block",Ky,"relative",Lp,TJ(v),bD,TJ(v)],null),zz,new O(null,9,5,P,[PK,xw,z,jt,ah.l(L([new p(null,6,[Ky,"absolute",vq,t(I)?null:"pointer",Mm,TJ(r),Il,t(w(a))?F:n,fn,UJ((r-v)/2-C,L([op])),nD,UJ((r-v)/2-m,L([op]))],null),y])),QD,ah.l(L([new p(null,4,[As,h,ns,function(a,b,c,d,e,g,h,l,m,n,v,r){return function(b){t(t(r)?eb(a):r)&&(r.h?r.h(b):r.call(null,b),b.stopPropagation());return null}}(I,b,c,c,d,h,l,m,n,r,v,x,
y,z,C,F,a),Tk,function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F){return function(){of(F,!0);return null}}(I,b,c,c,d,h,l,m,n,r,v,x,y,z,C,F,a),$y,function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F){return function(){of(F,!1);return null}}(I,b,c,c,d,h,l,m,n,r,v,x,y,z,C,F,a)],null),l])),zz,new O(null,2,5,P,[uC,new p(null,1,[xw,"zmdi zmdi-hc-fw-rc zmdi zmdi-close"],null)],null)],null)],null)}b.D=0;b.C=function(a){a=B(a);return c(a)};b.l=c;return b}()}(tG(!1))};function SK(a,b){return[u.h(a),",",u.h(b)," "].join("")}function TK(a){a=u.h(a);var b=["[",u.h("-"),":]"].join("");if(!(b instanceof RegExp)){var c=wh(/^\(\?([idmsux]*)\)/,b),d=M(c,0,null);c=M(c,1,null);d=K(d);b=new RegExp(b.substring(d),t(c)?c:"")}a=$D(a,b);return new O(null,2,5,P,[ze.h(a.h?a.h(1):a.call(null,1)),ze.h(a.h?a.h(2):a.call(null,2))],null)}
function UK(a,b,c,d,e,g){var h=e+g;e=function(){var c=a instanceof q?a.U:null;switch(c){case "left":return"initial";case "right":return TJ(h);case "above":case "below":return UJ(t(d)?d:b/2,L([op]));default:throw Error(["No matching clause: ",u.h(c)].join(""));}}();g=function(){var b=a instanceof q?a.U:null;switch(b){case "left":case "right":return UJ(t(d)?d:c/2,L([op]));case "above":return"initial";case "below":return TJ(h);default:throw Error(["No matching clause: ",u.h(b)].join(""));}}();var l=
function(){var b=a instanceof q?a.U:null;switch(b){case "left":return TJ(h);case "right":return null;case "above":return null;case "below":return null;default:throw Error(["No matching clause: ",u.h(b)].join(""));}}(),m=function(){var b=a instanceof q?a.U:null;switch(b){case "left":return null;case "right":return null;case "above":return TJ(h);case "below":return null;default:throw Error(["No matching clause: ",u.h(b)].join(""));}}();return new p(null,4,[nD,e,fn,g,sy,l,tm,m],null)}
function VK(a,b,c,d,e,g,h,l){var m=d/2,n=new p(null,4,[nD,[SK(0,0),SK(c,m),SK(0,d)].join(""),sy,[SK(c,0),SK(0,m),SK(c,d)].join(""),dA,[SK(0,0),SK(m,c),SK(d,0)].join(""),cC,[SK(0,c),SK(m,0),SK(d,c)].join("")],null);return new O(null,3,5,P,[Cx,new p(null,2,[xw,"popover-arrow",jt,Ed([Ky,"absolute",function(){var b=a instanceof q?a.U:null;switch(b){case "left":return sy;case "right":return nD;case "above":return tm;case "below":return fn;default:throw Error(["No matching clause: ",u.h(b)].join(""));}}(),
UJ(c,L([op])),function(){var b=a instanceof q?a.U:null;switch(b){case "left":case "right":return fn;case "above":case "below":return nD;default:throw Error(["No matching clause: ",u.h(b)].join(""));}}(),null==b?"50%":TJ(b),function(){var b=a instanceof q?a.U:null;switch(b){case "left":case "right":return Ep;case "above":case "below":return Oo;default:throw Error(["No matching clause: ",u.h(b)].join(""));}}(),UJ(m,L([op])),Lp,TJ(function(){var b=a instanceof q?a.U:null;switch(b){case "left":case "right":return c;
case "above":case "below":return d;default:throw Error(["No matching clause: ",u.h(b)].join(""));}}()),bD,TJ(function(){var b=a instanceof q?a.U:null;switch(b){case "left":case "right":return d;case "above":case "below":return c;default:throw Error(["No matching clause: ",u.h(b)].join(""));}}())])],null),new O(null,2,5,P,[tB,new p(null,2,[ar,n.h?n.h(a):n.call(null,a),jt,new p(null,3,[Lo,t(h)?h:t(e)?"#f7f7f7":"white",Fk,t(l)?l:t(g)?null:"rgba(0, 0, 0, .2)",xv,"1"],null)],null)],null)],null)}
var WK=new O(null,2,5,P,[new p(null,6,[S,kw,Z,!1,ci,0,U,"double | string",V,CK,R,new O(null,4,5,P,[AD,"opacity of backdrop from:",new O(null,1,5,P,[fz],null),"0.0 (transparent) to 1.0 (opaque)"],null)],null),new p(null,5,[S,ns,Z,!1,U,"-\x3e nil",V,Gd,R,"a function which takes no params and returns nothing. Called when the backdrop is clicked"],null)],null),XK=function XK(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return XK.l(0<c.length?new D(c.slice(0),0,
null):null)};XK.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,kw),d=A.c(b,ns);if(!$J(YJ(WK),b,L(["backdrop"])))throw Error('Assert failed: (validate-args-macro backdrop-args-desc args "backdrop")');return new O(null,2,5,P,[Cv,new p(null,2,[jt,new p(null,7,[Ky,"fixed",nD,"0px",fn,"0px",Lp,"100%",bD,"100%",mp,"black",kw,t(c)?c:0],null),ns,function(a,b,c,d,m){return function(){m.B?m.B():m.call(null);return null}}(a,b,b,c,d)],null)],null)};XK.D=0;XK.C=function(a){return this.l(B(a))};
var YK=new O(null,4,5,P,[new p(null,4,[S,It,Z,!0,U,"boolean atom",R,"an atom. When the value is true, the popover shows."],null),new p(null,5,[S,As,Z,!1,U,"string | hiccup",V,wK,R,"describes the title of the popover. Default font size is 18px to make it stand out"],null),new p(null,5,[S,to,Z,!1,ci,!0,U,"boolean",R,"when true, displays the close button"],null),new p(null,5,[S,$r,Z,!1,U,"-\x3e nil",V,Gd,R,new O(null,6,5,P,[AD,"a function which takes no params and returns nothing. Called when the close button is pressed. Not required if ",
new O(null,2,5,P,[Jx,":showing?"],null)," atom passed in OR ",new O(null,2,5,P,[Jx,":close-button?"],null)," is set to false"],null)],null)],null),ZK=function ZK(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return ZK.l(0<c.length?new D(c.slice(0),0,null):null)};
ZK.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,It),d=A.c(b,As),e=A.c(b,to),g=A.c(b,$r);if(!$J(YJ(YK),b,L(["popover-title"])))throw Error('Assert failed: (validate-args-macro popover-title-args-desc args "popover-title")');if(!t(function(){var a=df(ab);a=a.h?a.h(c):a.call(null,c);if(t(a))return a;a=df(ab);return a.h?a.h(g):a.call(null,g)}()))throw Error("Assert failed: Must specify either showing? OR close-callback\n(or ((complement nil?) showing?) ((complement nil?) close-callback))");
var h=null==e?!0:e;return new O(null,3,5,P,[br,new p(null,1,[jt,ah.l(L([DK("inherit"),new p(null,1,[Mm,"18px"],null)]))],null),new O(null,7,5,P,[LK,In,qq,ck,Ws,Xj,new O(null,2,5,P,[d,t(h)?new O(null,11,5,P,[RK,ns,function(a,b,c,d,e,g,h,z){return function(){return t(z)?z.B?z.B():z.call(null):of(e,!1)}}(h,a,b,b,c,d,e,g),bq,0,Mm,26,rx,-1,pm,-5],null):null],null)],null)],null)};ZK.D=0;ZK.C=function(a){return this.l(B(a))};
var $K=new O(null,15,5,P,[new p(null,5,[S,Xj,Z,!0,U,"vector",V,Pd,R,"a vector of component markups"],null),new p(null,5,[S,Ky,Z,!0,U,"keyword atom",V,nK,R,new O(null,3,5,P,[AD,"relative to this anchor. One of ",sK],null)],null),new p(null,5,[S,sk,Z,!1,U,"integer",V,cb,R,new O(null,8,5,P,[AD,"px offset of the arrow from its default ",new O(null,2,5,P,[Jx,":position"],null)," along the popover border. Is ignored when ",new O(null,2,5,P,[Jx,":position"],null)," is one of the ",new O(null,2,5,P,[Jx,":xxx-center"],
null)," variants. Positive numbers slide the popover toward its center"],null)],null),new p(null,5,[S,Lp,Z,!1,U,"string",V,fb,R,"a CSS style describing the popover width"],null),new p(null,6,[S,bD,Z,!1,ci,"auto",U,"string",V,fb,R,"a CSS style describing the popover height"],null),new p(null,6,[S,vj,Z,!1,ci,"white",U,"string",V,fb,R,"fill color of the popover"],null),new p(null,5,[S,AA,Z,!1,U,"string",V,fb,R,"color of the popover border, including the arrow"],null),new p(null,6,[S,Gk,Z,!1,ci,11,U,
"integer | string",V,CK,R,"the length in pixels of the arrow (from pointy part to middle of arrow base)"],null),new p(null,6,[S,Do,Z,!1,ci,22,U,"integer | string",V,CK,R,"the width in pixels of arrow base"],null),new p(null,6,[S,gu,Z,!1,ci,-1,U,"integer",V,cb,R,"px gap between the anchor and the arrow tip. Positive numbers push the popover away from the anchor"],null),new p(null,5,[S,Ww,Z,!1,U,"string",V,fb,R,"a CSS style which overrides the inner padding of the popover"],null),new p(null,5,[S,Oo,
Z,!1,U,"string",V,fb,R,"a CSS style describing the horiztonal offset from anchor after position"],null),new p(null,5,[S,Ep,Z,!1,U,"string",V,fb,R,"a CSS style describing the vertical offset from anchor after position"],null),new p(null,5,[S,PD,Z,!1,ci,!1,U,"boolean",R,"setup popover styles for a tooltip"],null),new p(null,4,[S,As,Z,!1,U,"string | markup",R,"describes a title"],null)],null),aL=function aL(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return aL.l(0<
c.length?new D(c.slice(0),0,null):null)};
aL.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,Ky),d=A.c(b,sk),e=A.c(b,As);if(!$J(YJ($K),b,L(["popover-border"])))throw Error('Assert failed: (validate-args-macro popover-border-args-desc args "popover-border")');var g=Jh("popover-"),h=tG(!1),l=tG(!1),m=tG(0),n=tG(0),r=tG(0),v=tG(!1),x=function(a,b,c,d,e,g,h,l,m,n,v,r,x){return function(b){var c=document.getElementById(a),h=TK(b);b=M(h,0,null);var l=M(h,1,null);h=t(x)?H.c(b,cC)||H.c(l,cC):x;of(d,t(c)?2*((c.clientWidth+1)/2|
0):0);of(e,t(c)?2*((c.clientHeight+1)/2|0):0);a:{c=w(d);var m=w(e);l=l instanceof q?l.U:null;switch(l){case "center":c=null;break a;case "right":c=20+r;break a;case "below":c=20+r;break a;case "left":c=t(c)?c-25-r:c;break a;case "above":c=t(m)?m-25-r:m;break a;default:throw Error(["No matching clause: ",u.h(l)].join(""));}}of(g,c);return new O(null,2,5,P,[b,h],null)}}(g,h,l,m,n,r,v,a,b,b,c,d,e);return xF(new p(null,4,[py,"popover-border",jp,function(a,b){return function(){return of(b,!0)}}(g,h,l,
m,n,r,v,x,a,b,b,c,d,e),mq,function(a,b,c,d,e,g,h,l,m,n,v,r){return function(a){var b=rG(a);a=window.innerWidth;var d=window.innerHeight,e=b.getBoundingClientRect(),g=e.left,m=e.right,n=e.top;e=e.bottom;b=b.parentNode.parentNode.parentNode;null==(0>g?-g:null)&&null==(m>a?m-a:null)&&null==(0>n?-n:null)&&null==(e>d?e-d:null)||!eb(w(h))||(a=b.getBoundingClientRect(),d=new O(null,2,5,P,[(a.right+a.left)/2,(a.bottom+a.top)/2],null),a=M(d,0,null),d=M(d,1,null),g=qe(window.innerWidth,3),a=ze.h([d<qe(window.innerHeight,
2)?"below":"above","-",a<g?"right":a<2*g?"center":"left"].join("")),of(r,a),of(h,!0));l(w(r));return of(c,!0)}}(g,h,l,m,n,r,v,x,a,b,b,c,d,e),kv,function(a,b,c,d,e,g,h,l){return function(){function h(a){var b=null;if(0<arguments.length){b=0;for(var c=Array(arguments.length-0);b<c.length;)c[b]=arguments[b+0],++b;b=new D(c,0,null)}return m.call(this,b)}function m(h){var m=null!=h&&(h.o&64||k===h.M)?N.c(Yg,h):h;h=A.c(m,AA);var n=A.c(m,bD),v=A.c(m,PD),r=A.c(m,vj),x=A.c(m,Xj),y=A.j(m,Gk,11);A.c(m,sk);var z=
A.c(m,Oo),C=A.j(m,Do,22),F=A.c(m,Ep),I=A.c(m,Lp),Q=A.c(m,As),X=A.j(m,gu,-1),T=A.c(m,Ww),W=A.c(m,Ky);if(!$J(YJ($K),m,L(["popover-border"])))throw Error('Assert failed: (validate-args-macro popover-border-args-desc args "popover-border")');m=l(w(W));var ea=M(m,0,null);m=M(m,1,null);return new O(null,5,5,P,[bt,new p(null,2,[qw,a,jt,ah.l(L([t(w(b))?t(a)?UK(ea,w(d),w(e),w(g),y,X):null:new p(null,2,[fn,"-10000px",nD,"-10000px"],null),t(I)?new p(null,1,[Lp,I],null):null,t(n)?new p(null,1,[bD,n],null):null,
t(r)?new p(null,1,[mp,r],null):null,t(h)?new p(null,1,[zy,h],null):null,t(v)?new p(null,3,[dB,"4px",Sk,"none",NA,"none"],null):null,function(){var a=ea instanceof q?ea.U:null;switch(a){case "left":return new p(null,1,[Oo,"-2000px"],null);case "right":case "above":case "below":return new p(null,1,[gA,"-2000px"],null);default:throw Error(["No matching clause: ",u.h(a)].join(""));}}(),t(z)?new p(null,1,[Oo,z],null):null,t(F)?new p(null,1,[Ep,F],null):null,new p(null,4,[Hy,"block",kw,t(w(c))?"1":"0",
vr,"none",Ww,"0px"],null)]))],null),new O(null,9,5,P,[VK,ea,w(g),y,C,m,v,r,h],null),t(Q)?Q:null,jf.c(new O(null,2,5,P,[wx,new p(null,1,[jt,new p(null,1,[Ww,T],null)],null)],null),x)],null)}h.D=0;h.C=function(a){a=B(a);return m(a)};h.l=m;return h}()}(g,h,l,m,n,r,v,x,a,b,b,c,d,e)],null))};aL.D=0;aL.C=function(a){return this.l(B(a))};
var bL=new O(null,21,5,P,[new p(null,4,[S,XC,Z,!0,U,"boolean atom",R,new O(null,7,5,P,[AD,"an atom. When the value is true, the popover shows.",new O(null,1,5,P,[fz],null),new O(null,2,5,P,[co,"NOTE: "],null),"When used as direct ",new O(null,2,5,P,[Jx,":popover"],null)," arg in popover-anchor-wrapper, this arg will be injected automatically by popover-anchor-wrapper. If using your own popover function, you must add this yourself"],null)],null),new p(null,5,[S,eo,Z,!0,U,"keyword atom",V,nK,R,new O(null,
8,5,P,[AD,"relative to this anchor. One of ",sK,new O(null,1,5,P,[fz],null),new O(null,2,5,P,[co,"NOTE: "],null),"See above NOTE for ",new O(null,2,5,P,[Jx,":showing-injected?"],null),". Same applies"],null)],null),new p(null,5,[S,sk,Z,!1,U,"integer",V,cb,R,new O(null,8,5,P,[AD,"px offset of the arrow from its default ",new O(null,2,5,P,[Jx,":position"],null)," along the popover border. Is ignored when ",new O(null,2,5,P,[Jx,":position"],null)," is one of the ",new O(null,2,5,P,[Jx,":xxx-center"],
null)," variants. Positive numbers slide the popover toward its center"],null)],null),new p(null,5,[S,no,Z,!1,ci,!1,U,"boolean",R,"when an anchor is in a scrolling region (e.g. scroller component), the popover can sometimes be clipped. By passing true for this parameter, re-com will use a different CSS method to show the popover. This method is slightly inferior because the popover can't track the anchor if it is repositioned"],null),new p(null,5,[S,Lp,Z,!1,U,"string",V,fb,R,"a CSS style representing the popover width"],
null),new p(null,5,[S,bD,Z,!1,U,"string",V,fb,R,"a CSS style representing the popover height"],null),new p(null,6,[S,$l,Z,!1,ci,0,U,"double | string",V,CK,R,"indicates the opacity of the backdrop where 0.0\x3dtransparent, 1.0\x3dopaque"],null),new p(null,5,[S,pB,Z,!1,U,"-\x3e nil",V,Gd,R,"a function which takes no params and returns nothing. Called when the popover is cancelled (e.g. user clicks away)"],null),new p(null,5,[S,As,Z,!1,U,"string | hiccup",V,wK,R,"describes the title of the popover. The default font size is 18px to make it stand out"],
null),new p(null,5,[S,to,Z,!1,ci,!0,U,"boolean",R,"when true, displays the close button"],null),new p(null,5,[S,VA,Z,!1,U,"string | hiccup",V,wK,R,"describes the popover body. Must be a single component"],null),new p(null,5,[S,PD,Z,!1,ci,!1,U,"boolean",R,"setup popover styles for a tooltip"],null),new p(null,6,[S,vj,Z,!1,ci,"white",U,"string",V,fb,R,"fill color of the popover"],null),new p(null,5,[S,AA,Z,!1,U,"string",V,fb,R,"color of the popover border, including the arrow"],null),new p(null,6,[S,
Gk,Z,!1,ci,11,U,"integer | string",V,CK,R,"the length in pixels of the arrow (from pointy part to middle of arrow base)"],null),new p(null,6,[S,Do,Z,!1,ci,22,U,"integer | string",V,CK,R,"the width in pixels of arrow base"],null),new p(null,6,[S,gu,Z,!1,ci,-1,U,"integer",V,cb,R,"px gap between the anchor and the arrow tip. Positive numbers push the popover away from the anchor"],null),new p(null,5,[S,Ww,Z,!1,U,"string",V,fb,R,"a CSS style which overrides the inner padding of the popover"],null),new p(null,
5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated (applies to the outer container)"],null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"override component style(s) with a style map, only use in case of emergency (applies to the outer container)"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,
2,5,P,[Jx,":style"],null),"allowed (applies to the outer container)"],null)],null)],null),cL=function cL(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return cL.l(0<c.length?new D(c.slice(0),0,null):null)};
cL.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,no);if(!$J(YJ(bL),b,L(["popover-content-wrapper"])))throw Error('Assert failed: (validate-args-macro popover-content-wrapper-args-desc args "popover-content-wrapper")');var d=tG(0),e=tG(0),g=function(a,b,c,d,e,g){return function(c){return t(g)?(c=rG(c).parentNode.getBoundingClientRect(),of(a,c.left),of(b,c.top)):null}}(d,e,a,b,b,c);return xF(new p(null,4,[py,"popover-content-wrapper",jp,function(a,b,c){return function(a){return c(a)}}(d,
e,g,a,b,b,c),mq,function(a,b,c){return function(a){return c(a)}}(d,e,g,a,b,b,c),kv,function(a,b){return function(){function c(a){var b=null;if(0<arguments.length){b=0;for(var c=Array(arguments.length-0);b<c.length;)c[b]=arguments[b+0],++b;b=new D(c,0,null)}return d.call(this,b)}function d(c){var d=null!=c&&(c.o&64||k===c.M)?N.c(Yg,c):c;c=A.c(d,VA);var e=A.c(d,AA),g=A.c(d,pB),h=A.c(d,XC),l=A.c(d,bD),m=A.c(d,PD),n=A.c(d,QD),r=A.c(d,vj),W=A.j(d,Gk,11),ea=A.c(d,sk),Ha=A.c(d,$l),Q=A.c(d,eo),X=A.c(d,no),
Y=A.c(d,to),qa=A.j(d,Do,22),ib=A.c(d,Lp),Aa=A.c(d,As),Ka=A.c(d,jt),La=A.j(d,gu,-1),Oa=A.c(d,xw),Ra=A.c(d,Ww);if(!$J(YJ(bL),d,L(["popover-content-wrapper"])))throw Error('Assert failed: (validate-args-macro popover-content-wrapper-args-desc args "popover-content-wrapper")');w(Q);d=P;n=ah.l(L([new p(null,2,[xw,["popover-content-wrapper ",u.h(Oa)].join(""),jt,ah.l(L([DK("inherit"),t(X)?new p(null,3,[Ky,"fixed",nD,TJ(w(a)),fn,TJ(w(b))],null):null,Ka]))],null),n]));X=w(h);return new O(null,4,5,d,[Et,n,
t(t(X)?g:X)?new O(null,5,5,P,[XK,kw,Ha,ns,g],null):null,new O(null,27,5,P,[aL,Ky,Q,sk,ea,Lp,ib,bD,l,PD,m,vj,r,AA,e,Gk,W,Do,qa,gu,La,Ww,Ra,As,t(Aa)?new O(null,9,5,P,[ZK,As,Aa,It,h,to,Y,$r,g],null):null,Xj,new O(null,1,5,P,[c],null)],null)],null)}c.D=0;c.C=function(a){a=B(a);return d(a)};c.l=d;return c}()}(d,e,g,a,b,b,c)],null))};cL.D=0;cL.C=function(a){return this.l(B(a))};
var dL=new O(null,7,5,P,[new p(null,4,[S,It,Z,!0,U,"boolean atom",R,"an atom. When the value is true, the popover shows"],null),new p(null,5,[S,Ky,Z,!0,U,"keyword",V,nK,R,new O(null,3,5,P,[AD,"relative to this anchor. One of ",sK],null)],null),new p(null,5,[S,Lz,Z,!0,U,"string | hiccup",V,wK,R,"the component the popover is attached to"],null),new p(null,5,[S,ho,Z,!0,U,"string | hiccup",V,wK,R,"the popover body component"],null),new p(null,5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated (applies to the outer container)"],
null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"override component style(s) with a style map, only use in case of emergency (applies to the outer container)"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,2,5,P,[Jx,":style"],null),"allowed (applies to the outer container)"],null)],null)],null),eL=function eL(a){for(var c=
[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return eL.l(0<c.length?new D(c.slice(0),0,null):null)};
eL.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,It),d=A.c(b,Ky);if(!$J(YJ(dL),b,L(["popover-anchor-wrapper"])))throw Error('Assert failed: (validate-args-macro popover-anchor-wrapper-args-desc args "popover-anchor-wrapper")');var e=tG(d),g=tG(w(e)),h=SE(function(a,b,c,d,e,g){return function(){return t(w(g))?null:of(b,w(a))}}(e,g,a,b,b,c,d));return xF(new p(null,2,[py,"popover-anchor-wrapper",kv,function(a,b,c){return function(){function d(a){var b=null;if(0<arguments.length){b=
0;for(var c=Array(arguments.length-0);b<c.length;)c[b]=arguments[b+0],++b;b=new D(c,0,null)}return e.call(this,b)}function e(d){var e=null!=d&&(d.o&64||k===d.M)?N.c(Yg,d):d;d=A.c(e,It);var g=A.c(e,Ky),h=A.c(e,Lz),l=A.c(e,ho),m=A.c(e,xw),n=A.c(e,jt),r=A.c(e,QD);if(!$J(YJ(dL),e,L(["popover-anchor-wrapper"])))throw Error('Assert failed: (validate-args-macro popover-anchor-wrapper-args-desc args "popover-anchor-wrapper")');w(c);Ue.c(w(a),g)&&(of(a,g),of(b,w(a)));g=TK(w(b));e=M(g,0,null);M(g,1,null);a:switch(e instanceof
q?e.U:null){case "left":case "above":g=!1;break a;default:g=!0}a:switch(e instanceof q?e.U:null){case "left":case "right":e="row";break a;default:e="column"}return new O(null,3,5,P,[Et,ah.l(L([new p(null,2,[xw,["rc-popover-anchor-wrapper display-inline-flex ",u.h(m)].join(""),jt,ah.l(L([DK("inherit"),n]))],null),r])),new O(null,5,5,P,[Et,new p(null,2,[xw,"rc-point-wrapper display-inline-flex",jt,ah.l(L([DK("auto"),EK(e),GK(bk,Ws)]))],null),t(g)?h:null,t(w(d))?new O(null,3,5,P,[Et,new p(null,2,[xw,
"rc-popover-point display-inline-flex",jt,ah.l(L([DK("auto"),new p(null,2,[Ky,"relative",ev,4],null)]))],null),jf.c(l,new O(null,4,5,P,[XC,d,eo,b],null))],null):null,t(g)?null:h],null)],null)}d.D=0;d.C=function(a){a=B(a);return e(a)};d.l=e;return d}()}(e,g,h,a,b,b,c,d)],null))};eL.D=0;eL.C=function(a){return this.l(B(a))};
var fL=new O(null,12,5,P,[new p(null,5,[S,pw,Z,!0,U,"string | hiccup | atom",V,wK,R,"the text (or component) for the tooltip"],null),new p(null,4,[S,It,Z,!0,U,"boolean atom",R,"an atom. When the value is true, the tooltip shows"],null),new p(null,5,[S,pB,Z,!1,U,"-\x3e nil",V,Gd,R,"a function which takes no params and returns nothing. Called when the popover is cancelled (e.g. user clicks away)"],null),new p(null,5,[S,to,Z,!1,ci,!1,U,"boolean",R,"when true, displays the close button"],null),new p(null,
5,[S,Nv,Z,!1,U,"keyword",V,function(a){return kK(a,":status",hK)},R,new O(null,8,5,P,[AD,"controls background color of the tooltip. ",new O(null,2,5,P,[Jx,"nil/omitted"],null)," for black or one of ",rK," (although ",new O(null,2,5,P,[Jx,":validating"],null)," is only used by the input-text component)"],null)],null),new p(null,5,[S,Lz,Z,!0,U,"hiccup",V,wK,R,"the component the tooltip is attached to"],null),new p(null,6,[S,Ky,Z,!1,ci,Wp,U,"keyword",V,nK,R,new O(null,3,5,P,[AD,"relative to this anchor. One of ",
sK],null)],null),new p(null,5,[S,no,Z,!1,ci,!0,U,"boolean",R,"when an anchor is in a scrolling region (e.g. scroller component), the popover can sometimes be clipped. When this parameter is true (which is the default), re-com will use a different CSS method to show the popover. This method is slightly inferior because the popover can't track the anchor if it is repositioned"],null),new p(null,5,[S,Lp,Z,!1,U,"string",V,fb,R,"specifies width of the tooltip"],null),new p(null,5,[S,xw,Z,!1,U,"string",
V,fb,R,"CSS class names, space separated (applies to popover-anchor-wrapper component)"],null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"override component style(s) with a style map, only use in case of emergency (applies to popover-anchor-wrapper component)"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,
2,5,P,[Jx,":style"],null),"allowed (applies to popover-anchor-wrapper component)"],null)],null)],null),gL=function gL(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return gL.l(0<c.length?new D(c.slice(0),0,null):null)};
gL.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,Lz),d=A.c(b,pB),e=A.c(b,QD),g=A.j(b,no,!0),h=A.c(b,to),l=A.c(b,Lp),m=A.c(b,It),n=A.c(b,jt),r=A.c(b,Nv),v=A.c(b,pw),x=A.c(b,xw),y=A.c(b,Ky);if(!$J(YJ(fL),b,L(["popover-tooltip"])))throw Error('Assert failed: (validate-args-macro popover-tooltip-args-desc args "popover-tooltip")');var z=RJ(v),C=function(){switch(r instanceof q?r.U:null){case "warning":return"#f57c00";case "error":return"#d50000";case "info":return"#333333";case "success":return"#13C200";
default:return"black"}}();return new O(null,15,5,P,[eL,It,m,Ky,t(y)?y:Wp,Lz,c,xw,["rc-popover-tooltip ",u.h(x)].join(""),jt,n,QD,e,ho,new O(null,21,5,P,[cL,no,g,pB,d,Lp,l,PD,!0,vj,C,Ww,"3px 8px",Gk,6,Do,12,gu,4,VA,new O(null,5,5,P,[NK,jt,H.c(r,Gx)?new p(null,3,[Il,"white",Mm,"14px",Ww,"4px"],null):new p(null,4,[Il,"white",Mm,"12px",rn,"bold",Ql,"center"],null),Xj,new O(null,2,5,P,[t(h)?new O(null,5,5,P,[PK,fA,iA,zz,new O(null,9,5,P,[RK,ns,function(a,b,c,d,e,g,h,l,m,n,r,v){return function(){return t(h)?
h.B?h.B():h.call(null):of(v,!1)}}(z,C,a,b,b,c,d,e,g,h,l,m,n,r,v,x,y),bq,15,Mm,20,pm,5],null)],null):null,z],null)],null)],null)],null)};gL.D=0;gL.C=function(a){return this.l(B(a))};var hL={},iL,jL={};var kL={};if("undefined"===typeof Qa||"undefined"===typeof Sa||"undefined"===typeof hL||"undefined"===typeof jL||"undefined"===typeof kL||"undefined"===typeof lL)var lL={};(function(a){if("undefined"===typeof Qa||"undefined"===typeof Sa||"undefined"===typeof hL||"undefined"===typeof iL)iL=function(a,c,d){this.Ma=a;this.ld=c;this.Ld=d;this.o=393216;this.I=0},iL.prototype.T=function(a,c){return new iL(this.Ma,this.ld,c)},iL.prototype.S=function(){return this.Ld},iL.Id=function(){return new O(null,3,5,P,[OD,Pl,Sa.Ge],null)},iL.Kc=!0,iL.Yb="cljs.core.async/t_cljs$core$async17468",iL.Wc=function(a){return mc(a,"cljs.core.async/t_cljs$core$async17468")};return new iL(a,!0,
Xe)})(function(){return null});function mL(){return bI("iPhone")&&!bI("iPod")&&!bI("iPad")};bI("Opera");bI("Trident")||bI("MSIE");bI("Edge");!bI("Gecko")||-1!=ZH.toLowerCase().indexOf("webkit")&&!bI("Edge")||bI("Trident")||bI("MSIE")||bI("Edge");-1!=ZH.toLowerCase().indexOf("webkit")&&!bI("Edge")&&bI("Mobile");bI("Macintosh");bI("Windows");bI("Linux")||bI("CrOS");var nL=aa.navigator||null;nL&&(nL.appVersion||"").indexOf("X11");bI("Android");mL();bI("iPad");bI("iPod");mL()||bI("iPad")||bI("iPod");Ed([S,LD,Z,!1,ci,null,U,"object | atom",R,"the initial value of the typeahead (should match the suggestion objects returned by ",new O(null,2,5,P,[Jx,":data-source"],null),")."]);var oL=new O(null,8,5,P,[new p(null,5,[S,pw,Z,!0,U,"string | hiccup",V,wK,R,"label for the button"],null),new p(null,5,[S,ns,Z,!1,U,"-\x3e nil",V,Gd,R,"a function which takes no params and returns nothing. Called when the button is clicked"],null),new p(null,5,[S,FC,Z,!1,U,"string | hiccup",V,wK,R,"what to show in the tooltip"],null),new p(null,6,[S,ux,Z,!1,ci,Wp,U,"keyword",V,nK,R,new O(null,3,5,P,[AD,"relative to this anchor. One of ",sK],null)],null),new p(null,5,[S,YA,Z,!1,ci,!1,U,"boolean | atom",
R,"if true, the user can't click the button"],null),new p(null,5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated (applies to the button, not the wrapping div)"],null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"CSS styles (applies to the button, not the wrapping div)"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],
null)," or ",new O(null,2,5,P,[Jx,":style"],null),"allowed (applies to the button, not the wrapping div)"],null)],null)],null);
function pL(){return function(a){return function(){function b(a){var b=null;if(0<arguments.length){b=0;for(var d=Array(arguments.length-0);b<d.length;)d[b]=arguments[b+0],++b;b=new D(d,0,null)}return c.call(this,b)}function c(b){var c=null!=b&&(b.o&64||k===b.M)?N.c(Yg,b):b,d=A.c(c,pw),h=A.c(c,ns),l=A.c(c,FC),m=A.c(c,ux),n=A.c(c,YA),r=A.j(c,xw,"btn-default"),v=A.c(c,jt),x=A.c(c,QD);if(!$J(YJ(oL),c,L(["button"])))throw Error('Assert failed: (validate-args-macro button-args-desc args "button")');t(l)||
of(a,!1);var y=RJ(n);b=new O(null,3,5,P,[dn,ah.l(L([new p(null,4,[xw,["rc-button btn ",u.h(r)].join(""),jt,ah.l(L([DK("none"),v])),um,y,ns,function(a,b,c,d,e,g){return function(b){t(t(g)?eb(a):g)&&(g.h?g.h(b):g.call(null,b));return null}}(y,b,c,c,d,h,l,m,n,r,v,x,a)],null),t(l)?new p(null,2,[mz,function(a,b,c,d,e,g,h,l,m,n,r,v,x){return function(){of(x,!0);return null}}(y,b,c,c,d,h,l,m,n,r,v,x,a),Bn,function(a,b,c,d,e,g,h,l,m,n,r,v,x){return function(){of(x,!1);return null}}(y,b,c,c,d,h,l,m,n,r,v,
x,a)],null):null,x])),d],null);t(y)&&of(a,!1);return new O(null,7,5,P,[PK,xw,"rc-button-wrapper display-inline-flex",ck,Np,zz,t(l)?new O(null,9,5,P,[gL,pw,l,Ky,t(m)?m:Wp,It,a,Lz,b],null):b],null)}b.D=0;b.C=function(a){a=B(a);return c(a)};b.l=c;return b}()}(tG(!1))};function qL(a,b){var c=Array.prototype.slice.call(arguments),d=c.shift();if("undefined"==typeof d)throw Error("[goog.string.format] Template required");return d.replace(/%([0\- \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g,function(a,b,d,l,m,n,r,v){if("%"==n)return"%";var e=c.shift();if("undefined"==typeof e)throw Error("[goog.string.format] Not enough arguments");arguments[0]=e;return qL.lb[n].apply(null,arguments)})}qL.lb={};
qL.lb.s=function(a,b,c){return isNaN(c)||""==c||a.length>=Number(c)?a:a=-1<b.indexOf("-",0)?a+ra(" ",Number(c)-a.length):ra(" ",Number(c)-a.length)+a};
qL.lb.f=function(a,b,c,d,e){d=a.toString();isNaN(e)||""==e||(d=parseFloat(a).toFixed(e));var g=0>Number(a)?"-":0<=b.indexOf("+")?"+":0<=b.indexOf(" ")?" ":"";0<=Number(a)&&(d=g+d);if(isNaN(c)||d.length>=Number(c))return d;d=isNaN(e)?Math.abs(Number(a)).toString():Math.abs(Number(a)).toFixed(e);a=Number(c)-d.length-g.length;0<=b.indexOf("-",0)?d=g+d+ra(" ",a):(b=0<=b.indexOf("0",0)?"0":" ",d=g+ra(b,a)+d);return d};qL.lb.d=function(a,b,c,d,e,g,h,l){return qL.lb.f(parseInt(a,10),b,c,d,0,g,h,l)};
qL.lb.i=qL.lb.d;qL.lb.u=qL.lb.d;function rL(a){a=qf.c(function(a){return a instanceof q||a instanceof Sc?u.h(a):a},a);return N.j(qL,"%s not implemented yet",a)};var sL={id:"UTC",std_offset:0,names:new O(null,1,5,P,["UTC"],null),transitions:zd};function tL(a,b,c,d,e,g,h){this.Xa=a;this.cb=b;this.Wa=c;this.eb=d;this.pb=e;this.Ka=g;this.F=h;this.o=2230716170;this.I=139264}f=tL.prototype;f.Z=function(a,b){return this.L(null,b,null)};f.L=function(a,b,c){switch(b instanceof q?b.U:null){case "format-str":return this.Xa;case "overrides":return this.cb;case "default-year":return this.Wa;case "timezone":return this.eb;default:return A.j(this.Ka,b,c)}};
f.Hb=function(a,b,c){return pb(function(){return function(a,c){var d=M(c,0,null);c=M(c,1,null);return b.j?b.j(a,d,c):b.call(null,a,d,c)}}(this),c,this)};f.P=function(a,b,c){return xh(b,function(){return function(a){return xh(b,Dh,""," ","",c,a)}}(this),"#cljs-time.format.Formatter{",", ","}",c,Me.c(new O(null,4,5,P,[new O(null,2,5,P,[wq,this.Xa],null),new O(null,2,5,P,[Nk,this.cb],null),new O(null,2,5,P,[uD,this.Wa],null),new O(null,2,5,P,[wk,this.eb],null)],null),this.Ka))};
f.La=function(){return new rg(this,new O(null,4,5,P,[wq,Nk,uD,wk],null),t(this.Ka)?Ec(this.Ka):We())};f.S=function(){return this.pb};f.Y=function(){return 4+K(this.Ka)};f.R=function(){var a=this,b=this.F;if(null!=b)return b;var c=function(){return function(){return function(a){return-987738732^bd(a)}}(b,a)(a)}();return this.F=c};f.H=function(a,b){return null!=b&&this.constructor===b.constructor&&H.c(this.Xa,b.Xa)&&H.c(this.cb,b.cb)&&H.c(this.Wa,b.Wa)&&H.c(this.eb,b.eb)&&H.c(this.Ka,b.Ka)};
f.pc=function(a,b){return fe(new dh(null,new p(null,4,[wk,null,Nk,null,wq,null,uD,null],null),null),b)?Fd.c(Yb(jf.c(Xe,this),this.pb),b):new tL(this.Xa,this.cb,this.Wa,this.eb,this.pb,Ve(Fd.c(this.Ka,b)),null)};
f.hb=function(a,b,c){return t(xe.c?xe.c(wq,b):xe.call(null,wq,b))?new tL(c,this.cb,this.Wa,this.eb,this.pb,this.Ka,null):t(xe.c?xe.c(Nk,b):xe.call(null,Nk,b))?new tL(this.Xa,c,this.Wa,this.eb,this.pb,this.Ka,null):t(xe.c?xe.c(uD,b):xe.call(null,uD,b))?new tL(this.Xa,this.cb,c,this.eb,this.pb,this.Ka,null):t(xe.c?xe.c(wk,b):xe.call(null,wk,b))?new tL(this.Xa,this.cb,this.Wa,c,this.pb,this.Ka,null):new tL(this.Xa,this.cb,this.Wa,this.eb,this.pb,Dd.j(this.Ka,b,c),null)};
f.V=function(){return B(Me.c(new O(null,4,5,P,[new Yf(wq,this.Xa),new Yf(Nk,this.cb),new Yf(uD,this.Wa),new Yf(wk,this.eb)],null),this.Ka))};f.T=function(a,b){return new tL(this.Xa,this.cb,this.Wa,this.eb,b,this.Ka,this.F)};f.$=function(a,b){return Sd(b)?this.hb(null,zb.c(b,0),zb.c(b,1)):pb(xb,this,b)};function uL(a){a=new p(null,2,[wq,a,wk,sL],null);var b=Fd.l(a,wq,L([Nk,uD,wk]));b=Rd(a)?jf.c(Xe,b):b;return new tL(wq.h(a),Nk.h(a),uD.h(a),wk.h(a),null,Ve(b),null)}
function vL(a){return function(){throw{name:kA,message:rL(L([Ae(a)]))};}}
var wL=Wg([Si,$i,Yj,fk,kk,lk,Kk,Mk,bl,el,zl,Al,Bl,Nl,Vl,Jm,Lm,Xm,an,un,An,mo,vo,zo,Fo,Wo,Xo,yp,Fq,Wq,Lr,Vr,gs,ss,et,Mt,cu,ju,pu,Nu,Kv,hw,nw,Sw,gy,xy,Gz,gB,sB,zB,oC,PC,jD],[vL(lu),uL("HH:mm"),uL("'T'HH:mm:ss.SSSZZ"),uL("yyyyDDD"),uL("yyyy-MM-dd"),uL("HH"),uL("HH:mm:ssZZ"),uL("xxxx-'W'ww-e"),uL("xxxx-'W'ww-e'T'HH:mm:ss.SSSZZ"),uL("yyyy-MM-dd'T'HH:mm:ss.SSS"),uL("yyyyMMdd'T'HHmmss.SSSZ"),uL("yyyy-MM-dd'T'HH:mm:ss.SSSZZ"),uL("HHmmssZ"),vL(ds),uL("xxxx'W'wwe"),uL("'T'HHmmssZ"),vL(xi),uL("yyyy-MM-dd'T'HH:mm:ssZZ"),
uL("yyyy-MM-dd"),vL(xm),uL("EEE, dd MMM yyyy HH:mm:ss Z"),uL("yyyy-MM-dd'T'HH:mm:ss.SSS"),uL("yyyyDDD'T'HHmmss.SSSZ"),uL("yyyy-DDD"),uL("HH:mm:ss.SSS"),uL("yyyy-MM-dd'T'HH:mm"),uL("HH:mm:ss.SSSZZ"),uL("xxxx'W'wwe'T'HHmmss.SSSZ"),uL("xxxx"),uL("HHmmss.SSSZ"),uL("HH:mm:ss"),uL("yyyy-DDD'T'HH:mm:ss.SSSZZ"),uL("yyyy-DDD'T'HH:mm:ssZZ"),uL("HH:mm:ss.SSS"),uL(Zj),vL(Wx),uL("yyyy"),uL("'T'HH:mm:ssZZ"),uL("xxxx'W'wwe'T'HHmmssZ"),uL("yyyyMMdd"),uL("xxxx-'W'ww"),vL(Zq),uL("yyyyDDD'T'HHmmssZ"),uL("yyyy-MM"),
vL(qu),uL("xxxx-'W'ww-e"),uL("yyyy-MM-dd'T'HH"),vL(yo),uL("yyyy-MM-dd'T'HH:mm:ss"),uL("xxxx-'W'ww-e'T'HH:mm:ssZZ"),uL("yyyyMMdd'T'HHmmssZ"),uL("yyyy-MM-dd HH:mm:ss"),uL("'T'HHmmss.SSSZ")]),xL=new dh(null,new p(null,9,[Si,null,Nl,null,Lm,null,un,null,et,null,Mt,null,hw,null,gy,null,gB,null],null),null);vE.c(hh(xg(wL)),xL);uL("MMMM yyyy");uL("ww");uL("yyyy MMM dd");
yd.l(new O(null,13,5,P,[new p(null,5,[S,LD,Z,!1,U,"goog.date.UtcDateTime/Date | atom",V,BK,R,new O(null,5,5,P,[AD,"the selected date. If provided, should pass pred ",new O(null,2,5,P,[Jx,":selectable-fn"],null),". If not provided, (now-\x3eutc) will be used and the returned date will be a ",new O(null,2,5,P,[Jx,"goog.date.UtcDateTime"],null)],null)],null),new p(null,5,[S,EA,Z,!0,U,"goog.date.UtcDateTime/Date -\x3e nil",V,Gd,R,new O(null,4,5,P,[AD,"called when a new selection is made. Returned type is the same as model (unless model is nil, in which case it will be ",new O(null,
2,5,P,[Jx,"goog.date.UtcDateTime"],null),")"],null)],null),new p(null,5,[S,YA,Z,!1,ci,!1,U,"boolean | atom",R,"when true, the user can't select dates but can navigate"],null),new p(null,6,[S,Nx,Z,!1,ci,"(fn [date] true)",U,"pred",V,Gd,R,"Predicate is passed a date. If it answers false, day will be shown disabled and can't be selected."],null),new p(null,5,[S,fq,Z,!1,ci,!1,U,"boolean",R,"when true, week numbers are shown to the left"],null),new p(null,5,[S,BD,Z,!1,ci,!1,U,"boolean",R,"when true, today's date is highlighted"],
null),new p(null,5,[S,Vw,Z,!1,U,"goog.date.UtcDateTime/Date | atom",V,BK,R,"no selection or navigation before this date"],null),new p(null,5,[S,fp,Z,!1,U,"goog.date.UtcDateTime/Date | atom",V,BK,R,"no selection or navigation after this date"],null),new p(null,5,[S,Nt,Z,!1,ci,6,U,"int",R,"first day of week (Monday \x3d 0 ... Sunday \x3d 6)"],null),new p(null,5,[S,pp,Z,!1,ci,!1,U,"boolean",R,"when true, the border is not displayed"],null),new p(null,5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated (applies to the outer border div, not the wrapping div)"],
null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"CSS styles to add or override (applies to the outer border div, not the wrapping div)"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,2,5,P,[Jx,":style"],null)," allowed (applies to the outer border div, not the wrapping div)"],null)],null)],null),new p(null,
5,[S,Vj,Z,!1,ci,"yyyy MMM dd",U,"string",R,"[datepicker-dropdown only] a representation of a date format. See cljs_time.format"],null),L([new p(null,5,[S,no,Z,!1,ci,!0,U,"boolean",R,"[datepicker-dropdown only] when an anchor is in a scrolling region (e.g. scroller component), the popover can sometimes be clipped. When this parameter is true (which is the default), re-com will use a different CSS method to show the popover. This method is slightly inferior because the popover can't track the anchor if it is repositioned"],
null),new p(null,4,[S,rm,Z,!1,U,"string",R,"[datepicker-dropdown only] placeholder text for when a date is not selected."],null)]));Id(function(a,b,c,d,e){return new O(null,2,5,P,[rw,new O(null,2,5,P,[Nz,new p(null,7,[U,"text",Ti,"off",jt,t(a)?null:new p(null,4,[Ky,"absolute",Lp,"0px",Ww,"0px",NA,"none"],null),So,w(b),EA,function(a){a=a.target.value;e.h?e.h(a):e.call(null,a);return null},UA,function(a){t(c.h?c.h(a):c.call(null,a))||a.preventDefault();return null},Yp,function(){of(d,!1);return null}],null)],null)],null)},new p(null,2,[jp,function(a){return rG(a).firstChild.focus()},mq,function(a){return rG(a).firstChild.focus()}],
null));function yL(a,b){a=H.c(a,zq);b=["solid 1px ",t(b)?"#999":"#ccc"].join("");return new O(null,4,5,P,[Et,new p(null,2,[xw,"display-flex",jt,ah.l(L([EK([a?"row":"column"," nowrap"].join("")),new p(null,3,[Lp,a?"8px":"20px",bD,a?"20px":"8px",JD,"auto"],null)]))],null),new O(null,2,5,P,[Et,new p(null,1,[jt,a?new p(null,3,[Lp,"3px",bD,"20px",dl,b],null):new p(null,3,[Lp,"20px",bD,"3px",dD,b],null)],null)],null),new O(null,2,5,P,[Et,new p(null,1,[jt,a?new p(null,3,[Lp,"3px",bD,"20px",dl,b],null):new p(null,
3,[Lp,"20px",bD,"3px",dD,b],null)],null)],null)],null)}
var zL=new O(null,12,5,P,[new p(null,5,[S,yA,Z,!0,U,"hiccup",V,wK,R,"markup to go in the left (or top) panel"],null),new p(null,5,[S,RA,Z,!0,U,"hiccup",V,wK,R,"markup to go in the right (or bottom) panel"],null),new p(null,6,[S,ws,Z,!1,ci,"auto",U,"string",V,fb,R,new O(null,17,5,P,[AD,"applied to the outer container of the two panels. Equivalent to CSS style ",new O(null,2,5,P,[ou,"flex"],null),".",new O(null,1,5,P,[fz],null),"Examples: ",new O(null,2,5,P,[Jx,"initial"],null),", ",new O(null,2,5,
P,[Jx,"auto"],null),", ",new O(null,2,5,P,[Jx,"none"],null),", ",new O(null,2,5,P,[Jx,"100px"],null),", ",new O(null,2,5,P,[Jx,"2"],null)," or a generic triple of ",new O(null,2,5,P,[Jx,"grow shrink basis"],null)],null)],null),new p(null,5,[S,Lp,Z,!1,U,"string",V,fb,R,"width of the outer container of the two panels. A CSS width style"],null),new p(null,5,[S,bD,Z,!1,U,"string",V,fb,R,"height of the outer container of the two panels. A CSS height style"],null),new p(null,5,[S,uk,Z,!1,U,"double -\x3e nil",
V,Gd,R,new O(null,4,5,P,[AD,"called when the user moves the splitter bar (on mouse up, not on each mouse move). Given the new ",new O(null,2,5,P,[Jx,":panel-1"],null)," percentage split"],null)],null),new p(null,6,[S,hD,Z,!1,ci,50,U,"double | string",V,CK,R,new O(null,4,5,P,[AD,"initial split percentage for ",new O(null,2,5,P,[Jx,":panel-1"],null),". Can be double value or string (with/without percentage sign)"],null)],null),new p(null,6,[S,Ri,Z,!1,ci,"8px",U,"string",V,fb,R,"thickness of the splitter"],
null),new p(null,6,[S,JD,Z,!1,ci,"8px",U,"string",V,fb,R,"thickness of the margin around the panels"],null),new p(null,5,[S,xw,Z,!1,U,"string",V,fb,R,"CSS class names, space separated (applies to the outer container)"],null),new p(null,5,[S,jt,Z,!1,U,"CSS style map",V,xK,R,"CSS styles to add or override (applies to the outer container)"],null),new p(null,5,[S,QD,Z,!1,U,"HTML attr map",V,AK,R,new O(null,9,5,P,[AD,"HTML attributes, like ",new O(null,2,5,P,[Jx,":on-mouse-move"],null),new O(null,1,5,
P,[fz],null),"No ",new O(null,2,5,P,[Jx,":class"],null)," or ",new O(null,2,5,P,[Jx,":style"],null),"allowed (applies to the outer container)"],null)],null)],null),AL=function AL(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return AL.l(0<c.length?new D(c.slice(0),0,null):null)};
AL.l=function(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.j(b,ws,"auto"),d=A.c(b,Lp),e=A.c(b,bD),g=A.c(b,uk),h=A.j(b,hD,50),l=A.j(b,Ri,"8px"),m=A.j(b,JD,"8px");if(!$J(YJ(zL),b,L(["v-split"])))throw Error('Assert failed: (validate-args-macro hv-split-args-desc args "v-split")');var n=Jh("v-split-"),r=tG(parseInt(h)),v=tG(!1),x=tG(!1),y=function(a,b,c,d,e,g,h,l,m,n,r){return function(){if(t(r)){var a=w(b);r.h?r.h(a):r.call(null,a)}return of(c,!1)}}(n,r,v,x,a,b,b,c,d,e,g,h,l,m),z=function(a){return function(b){var c=
document.getElementById(a);a:{var d=c.parentNode;for(var e=0,g=0;;)if(Ue.c(d.tagName,"BODY"))e+=d.scrollLeft,g+=d.scrollTop,d=d.parentNode;else{d=new p(null,2,[nD,e,fn,g],null);break a}}e=c.clientHeight;return 100*((b-c.offsetTop+fn.h(d))/e)}}(n,r,v,x,y,a,b,b,c,d,e,g,h,l,m),C=function(){return function(a){return H.c(a,document.documentElement)}}(n,r,v,x,y,z,a,b,b,c,d,e,g,h,l,m),F=function(a,b,c,d,e,g,h){return function(a){return h(a.relatedTarget)?e():null}}(n,r,v,x,y,z,C,a,b,b,c,d,e,g,h,l,m),I=function(a,
b,c,d,e,g){return function(a){return of(b,g(a.clientY))}}(n,r,v,x,y,z,C,F,a,b,b,c,d,e,g,h,l,m),T=function(a,b,c){return function(a){a.preventDefault();return of(c,!0)}}(n,r,v,x,y,z,C,F,I,a,b,b,c,d,e,g,h,l,m),W=function(a,b,c,d){return function(){return of(d,!0)}}(n,r,v,x,y,z,C,F,I,T,a,b,b,c,d,e,g,h,l,m),ea=function(a,b,c,d){return function(){return of(d,!1)}}(n,r,v,x,y,z,C,F,I,T,W,a,b,b,c,d,e,g,h,l,m),Ha=function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,Q,T,W,ea){return function(X,Y,qa,Aa){return ah.l(L([new p(null,
3,[xw,["rc-v-split display-flex ",u.h(X)].join(""),qw,a,jt,ah.l(L([DK(C),EK("column nowrap"),new p(null,3,[JD,ea,Lp,F,bD,I],null),Y]))],null),t(Aa)?new p(null,3,[Wy,function(a,b,c,d,e){return function(){e();return null}}(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,Q,T,W,ea),yx,function(a,b,c,d,e,g,h,l,m){return function(a){m(a);return null}}(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,Q,T,W,ea),Bn,function(a,b,c,d,e,g,h,l){return function(a){l(a);return null}}(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,Q,T,W,ea)],null):
null,qa]))}}(n,r,v,x,y,z,C,F,I,T,W,ea,a,b,b,c,d,e,g,h,l,m),Q=function(){return function(a,b,c){return new p(null,2,[xw,["display-flex ",u.h(a)].join(""),jt,ah.l(L([DK([u.h(c)," 1 0px"].join("")),new p(null,1,[Wn,"hidden"],null),t(b)?new p(null,1,[kB,"none"],null):null]))],null)}}(n,r,v,x,y,z,C,F,I,T,W,ea,Ha,a,b,b,c,d,e,g,h,l,m);return function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z){return function(){function a(a){var b=null;if(0<arguments.length){b=0;for(var c=Array(arguments.length-0);b<c.length;)c[b]=arguments[b+
0],++b;b=new D(c,0,null)}return e.call(this,b)}function e(a){var e=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a;A.c(e,Wz);a=A.c(e,RA);var g=A.c(e,yA),h=A.c(e,QD);A.c(e,il);A.c(e,Sm);A.c(e,ym);A.c(e,Mq);A.c(e,wt);var l=A.c(e,jt);A.c(e,Pt);e=A.c(e,xw);return new O(null,5,5,P,[Et,x(e,l,h,w(c)),new O(null,3,5,P,[Et,y("re-v-split-top",w(c),w(b)),g],null),new O(null,3,5,P,[Et,z("re-v-split-splitter"),new O(null,3,5,P,[yL,Ok,w(d)],null)],null),new O(null,3,5,P,[Et,y("re-v-split-bottom",w(c),100-w(b)),a],null)],
null)}a.D=0;a.C=function(a){a=B(a);return e(a)};a.l=e;return a}()}(n,r,v,x,y,z,C,F,I,T,W,ea,Ha,Q,function(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,Q,T,W,ea,Ha,kl){return function(X){return new p(null,5,[xw,["display-flex ",u.h(X)].join(""),hs,function(a,b,c,d,e,g,h,l,m,n){return function(a){n(a);return null}}(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,Q,T,W,ea,Ha,kl),mz,function(a,b,c,d,e,g,h,l,m,n,r){return function(){r();return null}}(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,Q,T,W,ea,Ha,kl),Bn,function(a,b,c,d,
e,g,h,l,m,n,r,v){return function(){v();return null}}(a,b,c,d,e,g,h,l,m,n,r,v,x,y,z,C,F,I,Q,T,W,ea,Ha,kl),jt,ah.l(L([DK(["0 0 ",u.h(Ha)].join("")),new p(null,1,[vq,"row-resize"],null),t(w(d))?new p(null,1,[mp,"#f8f8f8"],null):null]))],null)}}(n,r,v,x,y,z,C,F,I,T,W,ea,Ha,Q,a,b,b,c,d,e,g,h,l,m),a,b,b,c,d,e,g,h,l,m)};AL.D=0;AL.C=function(a){return this.l(B(a))};function BL(a,b){var c=null!=b&&(b.o&64||k===b.M)?N.c(Yg,b):b;b=A.c(c,Np);var d=A.c(c,iA);c=A.c(c,Lp);return a.markText({line:b,ch:0},{line:d,ch:c},{css:"color: #282828"})}
function CL(a,b){var c=a.getValue(),d=a.lastLine();var e=Fz.h(E(b));a:{b=N.c(u,qf.c(uq,b));for(var g=b.length;;){if(0===g){b="";break a}var h=A.c(b,g-1);if("\n"===h||"\r"===h)--g;else{b=b.substring(0,g);break a}}}e=new p(null,4,[Fz,e,Yy,"\n",rr,b,Cn,"\n\n"],null);h=null!=e&&(e.o&64||k===e.M)?N.c(Yg,e):e;g=A.c(h,Fz);e=A.c(h,Yy);b=A.c(h,rr);h=A.c(h,Cn);a.setValue([u.h(c),u.h(g)].join(""));c=a.lastLine();g=CJ(g);e=[u.h(e),u.h(b),u.h(h)].join("");a.setValue([u.h(a.getValue()),e].join(""));return new p(null,
3,[Np,d,iA,c,Lp,g],null)}function DL(a,b,c,d){d=Ly.h(sG(d));return t(d)?(pf.j(b,yd,CL(w(a),d)),d=new O(null,2,5,P,[Ow,w(b)],null),OI.h?OI.h(d):OI.call(null,d),BL(w(a),c),c=w(a),b=w(b),uh(qf.c(gf.c(BL,c),b)),w(a).scrollIntoView({line:w(a).lastLine()})):null}
function EL(a){var b=nf(null),c=nf(zd),d=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,e=A.c(d,Yv),g=A.c(d,vD),h=A.c(d,Ar),l=A.c(d,li),m=gf.G(DL,b,c,g);return xF(new p(null,5,[kv,function(a,b,c,d,e){return function(){return new O(null,2,5,P,[lt,new p(null,2,[qw,e,Ti,Yw],null)],null)}}(b,c,a,d,e,g,h,l,m),jp,function(a,b,c,d,e,g,h,l,m){return function(b){var c=rG(b);c=yJ(c,l);c.setValue(h);BL(c,g);of(a,c);c=new O(null,2,5,P,[Qm,c],null);OI.h?OI.h(c):OI.call(null,c);return m.h?m.h(b):m.call(null,b)}}(b,c,a,
d,e,g,h,l,m),zx,function(a){return function(){w(a).toTextArea();return of(a,null)}}(b,c,a,d,e,g,h,l,m),mq,m,py,e],null))};function FL(a){return Zi.h(a)}kJ.c?kJ.c(nA,FL):kJ.call(null,nA,FL);function GL(a){return $u.h(a)}kJ.c?kJ.c(nz,GL):kJ.call(null,nz,GL);function HL(a){return Km.h(a)}kJ.c?kJ.c(Dt,HL):kJ.call(null,Dt,HL);function IL(a){return Ni.h(a)}kJ.c?kJ.c(Qu,IL):kJ.call(null,Qu,IL);function JL(a){return Yt.h(a)}kJ.c?kJ.c(wl,JL):kJ.call(null,wl,JL);function KL(a){return Hz.h(a)}kJ.c?kJ.c(zD,KL):kJ.call(null,zD,KL);function LL(a){return dk.h(a)}kJ.c?kJ.c(Hq,LL):kJ.call(null,Hq,LL);function ML(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,Pw),d=A.c(b,$k),e=A.c(b,jt);return function(a,b,c,d,e,r){return function(){var b=ah.l(L([new p(null,1,[Bv,!0],null),e])),c=ah.l(L([new p(null,2,[Yv,"output",Ly,w(a)],null),d]));b=Dd.j(c,li,b);return new O(null,5,5,P,[PK,jt,r,zz,new O(null,2,5,P,[EL,b],null)],null)}}(function(){var a=new O(null,1,5,P,[Dt],null);return hJ.h?hJ.h(a):hJ.call(null,a)}(),a,b,c,d,e)}
function NL(a,b,c){var d=function(){var a=new O(null,1,5,P,[wl],null);return hJ.h?hJ.h(a):hJ.call(null,a)}(),e=function(){var a=new O(null,1,5,P,[nA],null);return hJ.h?hJ.h(a):hJ.call(null,a)}();return function(d,e){return function(){var g=ah.l(L([new p(null,2,[Yv,"input",Ly,function(){var a=w(e);return t(a)?a:w(d)}()],null),a]));g=Dd.j(g,li,b);return new O(null,5,5,P,[PK,jt,c,zz,new O(null,2,5,P,[BJ,g],null)],null)}}(d,e)}
function OL(a){var b=null!=a&&(a.o&64||k===a.M)?N.c(Yg,a):a,c=A.c(b,Pw),d=A.c(b,$k),e=A.c(b,dk),g=A.c(b,jt),h=ah.l(L([new p(null,1,[Yv,"input"],null),c])),l=ah.l(L([new p(null,1,[Ew,!0],null),d]));return new O(null,7,5,P,[NK,ws,"100%",Ex,"5px",Xj,new O(null,2,5,P,[new O(null,4,5,P,[NL,h,l,g],null),new O(null,9,5,P,[pL,xw,"btn-primary",pw,"Eval",FC,["Shortcut: ",function(){var a=Ys.h(e);return null==a?null:Ae(a)}()].join(""),ns,function(){return function(){var a=new O(null,1,5,P,[CD],null);return OI.h?
OI.h(a):OI.call(null,a)}}(h,l,a,b,c,d,e,g)],null)],null)],null)}var PL,QL=$D('ClojureScript 1.10.520\n    Docs : (doc function-name)\n           (find-doc "part-of-name")\n  Source : (source function-name)\n Results : Stored in *1, *2, *3,\n           an exception in *e\n\n',/\n|\r\n/);PL=null==QL?null:K(QL);
var RL=new p(null,3,[Np,0,iA,t(PL)?PL:0,Lp,CJ('ClojureScript 1.10.520\n    Docs : (doc function-name)\n           (find-doc "part-of-name")\n  Source : (source function-name)\n Results : Stored in *1, *2, *3,\n           an exception in *e\n\n')],null),SL=new p(null,5,[Ky,"absolute",Ww,"5px",fn,"0px",tm,"0px",Lp,"100%"],null),TL=ah.l(L([DK.h?DK.h("1"):DK.call(null,"1"),new p(null,2,[NA,"1px solid lightgrey",dB,"4px"],null)]));
function UL(a,b){var c=M(b,0,null),d=M(b,1,null);return Dd.j(Xe,A.c(a,c),function(a,b,c){return function(){var a=new O(null,1,5,P,[c],null);return OI.h?OI.h(a):OI.call(null,a)}}(b,c,d))}var VL=new p(null,5,[Ys,CD,sy,vm,Mj,vm,nD,Ro,rs,Ro],null);
function qG(){return function(a){return function(){var b=new p(null,3,[Pw,new p(null,3,[Yv,"replete-output",Ar,'ClojureScript 1.10.520\n    Docs : (doc function-name)\n           (find-doc "part-of-name")\n  Source : (source function-name)\n Results : Stored in *1, *2, *3,\n           an exception in *e\n\n',vD,RL],null),$k,new p(null,1,[kt,"replete-eval-light"],null),jt,TL],null);var c=w(a);c=N.c(ah,qf.c(gf.c(UL,c),VL));c=new p(null,4,[Pw,new p(null,1,[Yv,"replete-input"],null),$k,new p(null,2,[kt,
"replete-edit-light",Nr,c],null),dk,w(a),jt,TL],null);return new O(null,5,5,P,[PK,jt,SL,zz,new O(null,7,5,P,[AL,hD,70,yA,new O(null,2,5,P,[ML,b],null),RA,new O(null,2,5,P,[OL,c],null)],null)],null)}}(function(){var a=new O(null,1,5,P,[Hq],null);return hJ.h?hJ.h(a):hJ.call(null,a)}())};ca("replete.system.init",function(){var a=w(qJ);t(a)&&(a.terminate(),of(qJ,null));of(qJ,new Worker("js/bootstrap_worker.js"));w(qJ).addEventListener("message",pJ);a=new O(null,1,5,P,[ui],null);PI.h?PI.h(a):PI.call(null,a);$a();eJ.B?eJ.B():eJ.call(null);return pG()});